import {
  __commonJS
} from "./chunk-J43GMYXM.js";

// node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js
var require_AgoraRTC_N_production = __commonJS({
  "node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).AgoraRTC = t();
    }(exports, function() {
      "use strict";
      var e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, t = function(e3) {
        return e3 && e3.Math == Math && e3;
      }, i = t("object" == typeof globalThis && globalThis) || t("object" == typeof window && window) || t("object" == typeof self && self) || t("object" == typeof e && e) || function() {
        return this;
      }() || Function("return this")(), r = {}, n = function(e3) {
        try {
          return !!e3();
        } catch (e4) {
          return true;
        }
      }, o = !n(function() {
        return 7 != Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1];
      }), s = !n(function() {
        var e3 = function() {
        }.bind();
        return "function" != typeof e3 || e3.hasOwnProperty("prototype");
      }), a = s, c = Function.prototype.call, d = a ? c.bind(c) : function() {
        return c.apply(c, arguments);
      }, u = {}, h = {}.propertyIsEnumerable, A = Object.getOwnPropertyDescriptor, l = A && !h.call({ 1: 2 }, 1);
      u.f = l ? function(e3) {
        var t3 = A(this, e3);
        return !!t3 && t3.enumerable;
      } : h;
      var p, g, E = function(e3, t3) {
        return { enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t3 };
      }, f = s, m = Function.prototype, I = m.bind, _ = m.call, C = f && I.bind(_, _), S = f ? function(e3) {
        return e3 && C(e3);
      } : function(e3) {
        return e3 && function() {
          return _.apply(e3, arguments);
        };
      }, v = S, T = v({}.toString), R = v("".slice), y = function(e3) {
        return R(T(e3), 8, -1);
      }, w = S, b = n, N = y, O = i.Object, D = w("".split), P = b(function() {
        return !O("z").propertyIsEnumerable(0);
      }) ? function(e3) {
        return "String" == N(e3) ? D(e3, "") : O(e3);
      } : O, L = i.TypeError, k = function(e3) {
        if (null == e3)
          throw L("Can't call method on " + e3);
        return e3;
      }, B = P, M = k, U = function(e3) {
        return B(M(e3));
      }, x = function(e3) {
        return "function" == typeof e3;
      }, Q = x, F = function(e3) {
        return "object" == typeof e3 ? null !== e3 : Q(e3);
      }, V = i, j = x, G = function(e3) {
        return j(e3) ? e3 : void 0;
      }, K = function(e3, t3) {
        return arguments.length < 2 ? G(V[e3]) : V[e3] && V[e3][t3];
      }, H = S({}.isPrototypeOf), W = K("navigator", "userAgent") || "", Y = i, J = W, q = Y.process, X = Y.Deno, z = q && q.versions || X && X.version, Z = z && z.v8;
      Z && (g = (p = Z.split("."))[0] > 0 && p[0] < 4 ? 1 : +(p[0] + p[1])), !g && J && (!(p = J.match(/Edge\/(\d+)/)) || p[1] >= 74) && (p = J.match(/Chrome\/(\d+)/)) && (g = +p[1]);
      var $ = g, ee = $, te = n, ie = !!Object.getOwnPropertySymbols && !te(function() {
        var e3 = Symbol();
        return !String(e3) || !(Object(e3) instanceof Symbol) || !Symbol.sham && ee && ee < 41;
      }), re = ie && !Symbol.sham && "symbol" == typeof Symbol.iterator, ne = K, oe = x, se = H, ae = re, ce = i.Object, de = ae ? function(e3) {
        return "symbol" == typeof e3;
      } : function(e3) {
        var t3 = ne("Symbol");
        return oe(t3) && se(t3.prototype, ce(e3));
      }, ue = i.String, he = function(e3) {
        try {
          return ue(e3);
        } catch (e4) {
          return "Object";
        }
      }, Ae = x, le = he, pe = i.TypeError, ge = function(e3) {
        if (Ae(e3))
          return e3;
        throw pe(le(e3) + " is not a function");
      }, Ee = ge, fe = function(e3, t3) {
        var i3 = e3[t3];
        return null == i3 ? void 0 : Ee(i3);
      }, me = d, Ie = x, _e = F, Ce = i.TypeError, Se = { exports: {} }, ve = i, Te = Object.defineProperty, Re = function(e3, t3) {
        try {
          Te(ve, e3, { value: t3, configurable: true, writable: true });
        } catch (i3) {
          ve[e3] = t3;
        }
        return t3;
      }, ye = Re, we = "__core-js_shared__", be = i[we] || ye(we, {}), Ne = be;
      (Se.exports = function(e3, t3) {
        return Ne[e3] || (Ne[e3] = void 0 !== t3 ? t3 : {});
      })("versions", []).push({ version: "3.20.3", mode: "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE", source: "https://github.com/zloirock/core-js" });
      var Oe = k, De = i.Object, Pe = function(e3) {
        return De(Oe(e3));
      }, Le = Pe, ke = S({}.hasOwnProperty), Be = Object.hasOwn || function(e3, t3) {
        return ke(Le(e3), t3);
      }, Me = S, Ue = 0, xe = Math.random(), Qe = Me(1 .toString), Fe = function(e3) {
        return "Symbol(" + (void 0 === e3 ? "" : e3) + ")_" + Qe(++Ue + xe, 36);
      }, Ve = i, je = Se.exports, Ge = Be, Ke = Fe, He = ie, We = re, Ye = je("wks"), Je = Ve.Symbol, qe = Je && Je.for, Xe = We ? Je : Je && Je.withoutSetter || Ke, ze = function(e3) {
        if (!Ge(Ye, e3) || !He && "string" != typeof Ye[e3]) {
          var t3 = "Symbol." + e3;
          He && Ge(Je, e3) ? Ye[e3] = Je[e3] : Ye[e3] = We && qe ? qe(t3) : Xe(t3);
        }
        return Ye[e3];
      }, Ze = d, $e = F, et = de, tt = fe, it = function(e3, t3) {
        var i3, r3;
        if ("string" === t3 && Ie(i3 = e3.toString) && !_e(r3 = me(i3, e3)))
          return r3;
        if (Ie(i3 = e3.valueOf) && !_e(r3 = me(i3, e3)))
          return r3;
        if ("string" !== t3 && Ie(i3 = e3.toString) && !_e(r3 = me(i3, e3)))
          return r3;
        throw Ce("Can't convert object to primitive value");
      }, rt = ze, nt = i.TypeError, ot = rt("toPrimitive"), st = function(e3, t3) {
        if (!$e(e3) || et(e3))
          return e3;
        var i3, r3 = tt(e3, ot);
        if (r3) {
          if (void 0 === t3 && (t3 = "default"), i3 = Ze(r3, e3, t3), !$e(i3) || et(i3))
            return i3;
          throw nt("Can't convert object to primitive value");
        }
        return void 0 === t3 && (t3 = "number"), it(e3, t3);
      }, at = de, ct = function(e3) {
        var t3 = st(e3, "string");
        return at(t3) ? t3 : t3 + "";
      }, dt = F, ut = i.document, ht = dt(ut) && dt(ut.createElement), At = function(e3) {
        return ht ? ut.createElement(e3) : {};
      }, lt = At, pt = !o && !n(function() {
        return 7 != Object.defineProperty(lt("div"), "a", { get: function() {
          return 7;
        } }).a;
      }), gt = o, Et = d, ft = u, mt = E, It = U, _t = ct, Ct = Be, St = pt, vt = Object.getOwnPropertyDescriptor;
      r.f = gt ? vt : function(e3, t3) {
        if (e3 = It(e3), t3 = _t(t3), St)
          try {
            return vt(e3, t3);
          } catch (e4) {
          }
        if (Ct(e3, t3))
          return mt(!Et(ft.f, e3, t3), e3[t3]);
      };
      var Tt = {}, Rt = o && n(function() {
        return 42 != Object.defineProperty(function() {
        }, "prototype", { value: 42, writable: false }).prototype;
      }), yt = i, wt = F, bt = yt.String, Nt = yt.TypeError, Ot = function(e3) {
        if (wt(e3))
          return e3;
        throw Nt(bt(e3) + " is not an object");
      }, Dt = o, Pt = pt, Lt = Rt, kt = Ot, Bt = ct, Mt = i.TypeError, Ut = Object.defineProperty, xt = Object.getOwnPropertyDescriptor, Qt = "enumerable", Ft = "configurable", Vt = "writable";
      Tt.f = Dt ? Lt ? function(e3, t3, i3) {
        if (kt(e3), t3 = Bt(t3), kt(i3), "function" == typeof e3 && "prototype" === t3 && "value" in i3 && Vt in i3 && !i3.writable) {
          var r3 = xt(e3, t3);
          r3 && r3.writable && (e3[t3] = i3.value, i3 = { configurable: Ft in i3 ? i3.configurable : r3.configurable, enumerable: Qt in i3 ? i3.enumerable : r3.enumerable, writable: false });
        }
        return Ut(e3, t3, i3);
      } : Ut : function(e3, t3, i3) {
        if (kt(e3), t3 = Bt(t3), kt(i3), Pt)
          try {
            return Ut(e3, t3, i3);
          } catch (e4) {
          }
        if ("get" in i3 || "set" in i3)
          throw Mt("Accessors not supported");
        return "value" in i3 && (e3[t3] = i3.value), e3;
      };
      var jt = Tt, Gt = E, Kt = o ? function(e3, t3, i3) {
        return jt.f(e3, t3, Gt(1, i3));
      } : function(e3, t3, i3) {
        return e3[t3] = i3, e3;
      }, Ht = { exports: {} }, Wt = x, Yt = be, Jt = S(Function.toString);
      Wt(Yt.inspectSource) || (Yt.inspectSource = function(e3) {
        return Jt(e3);
      });
      var qt, Xt, zt, Zt = Yt.inspectSource, $t = x, ei = Zt, ti = i.WeakMap, ii = $t(ti) && /native code/.test(ei(ti)), ri = Se.exports, ni = Fe, oi = ri("keys"), si = function(e3) {
        return oi[e3] || (oi[e3] = ni(e3));
      }, ai = {}, ci = ii, di = i, ui = S, hi = F, Ai = Kt, li = Be, pi = be, gi = si, Ei = ai, fi = "Object already initialized", mi = di.TypeError, Ii = di.WeakMap;
      if (ci || pi.state) {
        var _i = pi.state || (pi.state = new Ii()), Ci = ui(_i.get), Si = ui(_i.has), vi = ui(_i.set);
        qt = function(e3, t3) {
          if (Si(_i, e3))
            throw new mi(fi);
          return t3.facade = e3, vi(_i, e3, t3), t3;
        }, Xt = function(e3) {
          return Ci(_i, e3) || {};
        }, zt = function(e3) {
          return Si(_i, e3);
        };
      } else {
        var Ti = gi("state");
        Ei[Ti] = true, qt = function(e3, t3) {
          if (li(e3, Ti))
            throw new mi(fi);
          return t3.facade = e3, Ai(e3, Ti, t3), t3;
        }, Xt = function(e3) {
          return li(e3, Ti) ? e3[Ti] : {};
        }, zt = function(e3) {
          return li(e3, Ti);
        };
      }
      var Ri = { set: qt, get: Xt, has: zt, enforce: function(e3) {
        return zt(e3) ? Xt(e3) : qt(e3, {});
      }, getterFor: function(e3) {
        return function(t3) {
          var i3;
          if (!hi(t3) || (i3 = Xt(t3)).type !== e3)
            throw mi("Incompatible receiver, " + e3 + " required");
          return i3;
        };
      } }, yi = o, wi = Be, bi = Function.prototype, Ni = yi && Object.getOwnPropertyDescriptor, Oi = wi(bi, "name"), Di = { EXISTS: Oi, PROPER: Oi && "something" === function() {
      }.name, CONFIGURABLE: Oi && (!yi || yi && Ni(bi, "name").configurable) }, Pi = i, Li = x, ki = Be, Bi = Kt, Mi = Re, Ui = Zt, xi = Di.CONFIGURABLE, Qi = Ri.get, Fi = Ri.enforce, Vi = String(String).split("String");
      (Ht.exports = function(e3, t3, i3, r3) {
        var n3, o3 = !!r3 && !!r3.unsafe, s3 = !!r3 && !!r3.enumerable, a3 = !!r3 && !!r3.noTargetGet, c3 = r3 && void 0 !== r3.name ? r3.name : t3;
        Li(i3) && ("Symbol(" === String(c3).slice(0, 7) && (c3 = "[" + String(c3).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!ki(i3, "name") || xi && i3.name !== c3) && Bi(i3, "name", c3), (n3 = Fi(i3)).source || (n3.source = Vi.join("string" == typeof c3 ? c3 : ""))), e3 !== Pi ? (o3 ? !a3 && e3[t3] && (s3 = true) : delete e3[t3], s3 ? e3[t3] = i3 : Bi(e3, t3, i3)) : s3 ? e3[t3] = i3 : Mi(t3, i3);
      })(Function.prototype, "toString", function() {
        return Li(this) && Qi(this).source || Ui(this);
      });
      var ji = {}, Gi = Math.ceil, Ki = Math.floor, Hi = function(e3) {
        var t3 = +e3;
        return t3 != t3 || 0 === t3 ? 0 : (t3 > 0 ? Ki : Gi)(t3);
      }, Wi = Hi, Yi = Math.max, Ji = Math.min, qi = function(e3, t3) {
        var i3 = Wi(e3);
        return i3 < 0 ? Yi(i3 + t3, 0) : Ji(i3, t3);
      }, Xi = Hi, zi = Math.min, Zi = function(e3) {
        return e3 > 0 ? zi(Xi(e3), 9007199254740991) : 0;
      }, $i = Zi, er = function(e3) {
        return $i(e3.length);
      }, tr = U, ir = qi, rr = er, nr = function(e3) {
        return function(t3, i3, r3) {
          var n3, o3 = tr(t3), s3 = rr(o3), a3 = ir(r3, s3);
          if (e3 && i3 != i3) {
            for (; s3 > a3; )
              if ((n3 = o3[a3++]) != n3)
                return true;
          } else
            for (; s3 > a3; a3++)
              if ((e3 || a3 in o3) && o3[a3] === i3)
                return e3 || a3 || 0;
          return !e3 && -1;
        };
      }, or = { includes: nr(true), indexOf: nr(false) }, sr = Be, ar = U, cr = or.indexOf, dr = ai, ur = S([].push), hr = function(e3, t3) {
        var i3, r3 = ar(e3), n3 = 0, o3 = [];
        for (i3 in r3)
          !sr(dr, i3) && sr(r3, i3) && ur(o3, i3);
        for (; t3.length > n3; )
          sr(r3, i3 = t3[n3++]) && (~cr(o3, i3) || ur(o3, i3));
        return o3;
      }, Ar = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], lr = hr, pr = Ar.concat("length", "prototype");
      ji.f = Object.getOwnPropertyNames || function(e3) {
        return lr(e3, pr);
      };
      var gr = {};
      gr.f = Object.getOwnPropertySymbols;
      var Er = K, fr = ji, mr = gr, Ir = Ot, _r = S([].concat), Cr = Er("Reflect", "ownKeys") || function(e3) {
        var t3 = fr.f(Ir(e3)), i3 = mr.f;
        return i3 ? _r(t3, i3(e3)) : t3;
      }, Sr = Be, vr = Cr, Tr = r, Rr = Tt, yr = function(e3, t3, i3) {
        for (var r3 = vr(t3), n3 = Rr.f, o3 = Tr.f, s3 = 0; s3 < r3.length; s3++) {
          var a3 = r3[s3];
          Sr(e3, a3) || i3 && Sr(i3, a3) || n3(e3, a3, o3(t3, a3));
        }
      }, wr = n, br = x, Nr = /#|\.prototype\./, Or = function(e3, t3) {
        var i3 = Pr[Dr(e3)];
        return i3 == kr || i3 != Lr && (br(t3) ? wr(t3) : !!t3);
      }, Dr = Or.normalize = function(e3) {
        return String(e3).replace(Nr, ".").toLowerCase();
      }, Pr = Or.data = {}, Lr = Or.NATIVE = "N", kr = Or.POLYFILL = "P", Br = Or, Mr = i, Ur = r.f, xr = Kt, Qr = Ht.exports, Fr = Re, Vr = yr, jr = Br, Gr = function(e3, t3) {
        var i3, r3, n3, o3, s3, a3 = e3.target, c3 = e3.global, d3 = e3.stat;
        if (i3 = c3 ? Mr : d3 ? Mr[a3] || Fr(a3, {}) : (Mr[a3] || {}).prototype)
          for (r3 in t3) {
            if (o3 = t3[r3], n3 = e3.noTargetGet ? (s3 = Ur(i3, r3)) && s3.value : i3[r3], !jr(c3 ? r3 : a3 + (d3 ? "." : "#") + r3, e3.forced) && void 0 !== n3) {
              if (typeof o3 == typeof n3)
                continue;
              Vr(o3, n3);
            }
            (e3.sham || n3 && n3.sham) && xr(o3, "sham", true), Qr(i3, r3, o3, e3);
          }
      }, Kr = s, Hr = Function.prototype, Wr = Hr.apply, Yr = Hr.call, Jr = "object" == typeof Reflect && Reflect.apply || (Kr ? Yr.bind(Wr) : function() {
        return Yr.apply(Wr, arguments);
      }), qr = Gr, Xr = K, zr = Jr, Zr = S, $r = n, en = i.Array, tn = Xr("JSON", "stringify"), rn = Zr(/./.exec), nn = Zr("".charAt), on = Zr("".charCodeAt), sn = Zr("".replace), an = Zr(1 .toString), cn = /[\uD800-\uDFFF]/g, dn = /^[\uD800-\uDBFF]$/, un = /^[\uDC00-\uDFFF]$/, hn = function(e3, t3, i3) {
        var r3 = nn(i3, t3 - 1), n3 = nn(i3, t3 + 1);
        return rn(dn, e3) && !rn(un, n3) || rn(un, e3) && !rn(dn, r3) ? "\\u" + an(on(e3, 0), 16) : e3;
      }, An = $r(function() {
        return '"\\udf06\\ud834"' !== tn("\uDF06\uD834") || '"\\udead"' !== tn("\uDEAD");
      });
      tn && qr({ target: "JSON", stat: true, forced: An }, { stringify: function(e3, t3, i3) {
        for (var r3 = 0, n3 = arguments.length, o3 = en(n3); r3 < n3; r3++)
          o3[r3] = arguments[r3];
        var s3 = zr(tn, null, o3);
        return "string" == typeof s3 ? sn(s3, cn, hn) : s3;
      } });
      var ln = function(e3) {
        try {
          return !!e3();
        } catch (e4) {
          return true;
        }
      }, pn = !ln(function() {
        var e3 = function() {
        }.bind();
        return "function" != typeof e3 || e3.hasOwnProperty("prototype");
      }), gn = pn, En = Function.prototype, fn = En.bind, mn = En.call, In = gn && fn.bind(mn, mn), _n = gn ? function(e3) {
        return e3 && In(e3);
      } : function(e3) {
        return e3 && function() {
          return mn.apply(e3, arguments);
        };
      }, Cn = _n({}.isPrototypeOf), Sn = function(e3) {
        return e3 && e3.Math == Math && e3;
      }, vn = Sn("object" == typeof globalThis && globalThis) || Sn("object" == typeof window && window) || Sn("object" == typeof self && self) || Sn("object" == typeof e && e) || function() {
        return this;
      }() || Function("return this")(), Tn = pn, Rn = Function.prototype, yn = Rn.apply, wn = Rn.call, bn = "object" == typeof Reflect && Reflect.apply || (Tn ? wn.bind(yn) : function() {
        return wn.apply(yn, arguments);
      }), Nn = function(e3) {
        return "function" == typeof e3;
      }, On = {}, Dn = !ln(function() {
        return 7 != Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1];
      }), Pn = pn, Ln = Function.prototype.call, kn = Pn ? Ln.bind(Ln) : function() {
        return Ln.apply(Ln, arguments);
      }, Bn = {}, Mn = {}.propertyIsEnumerable, Un = Object.getOwnPropertyDescriptor, xn = Un && !Mn.call({ 1: 2 }, 1);
      Bn.f = xn ? function(e3) {
        var t3 = Un(this, e3);
        return !!t3 && t3.enumerable;
      } : Mn;
      var Qn, Fn, Vn = function(e3, t3) {
        return { enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t3 };
      }, jn = _n, Gn = jn({}.toString), Kn = jn("".slice), Hn = function(e3) {
        return Kn(Gn(e3), 8, -1);
      }, Wn = _n, Yn = ln, Jn = Hn, qn = vn.Object, Xn = Wn("".split), zn = Yn(function() {
        return !qn("z").propertyIsEnumerable(0);
      }) ? function(e3) {
        return "String" == Jn(e3) ? Xn(e3, "") : qn(e3);
      } : qn, Zn = vn.TypeError, $n = function(e3) {
        if (null == e3)
          throw Zn("Can't call method on " + e3);
        return e3;
      }, eo = zn, to = $n, io = function(e3) {
        return eo(to(e3));
      }, ro = Nn, no = function(e3) {
        return "object" == typeof e3 ? null !== e3 : ro(e3);
      }, oo = {}, so = oo, ao = vn, co = Nn, uo = function(e3) {
        return co(e3) ? e3 : void 0;
      }, ho = function(e3, t3) {
        return arguments.length < 2 ? uo(so[e3]) || uo(ao[e3]) : so[e3] && so[e3][t3] || ao[e3] && ao[e3][t3];
      }, Ao = ho("navigator", "userAgent") || "", lo = vn, po = Ao, go = lo.process, Eo = lo.Deno, fo = go && go.versions || Eo && Eo.version, mo = fo && fo.v8;
      mo && (Fn = (Qn = mo.split("."))[0] > 0 && Qn[0] < 4 ? 1 : +(Qn[0] + Qn[1])), !Fn && po && (!(Qn = po.match(/Edge\/(\d+)/)) || Qn[1] >= 74) && (Qn = po.match(/Chrome\/(\d+)/)) && (Fn = +Qn[1]);
      var Io = Fn, _o = Io, Co = ln, So = !!Object.getOwnPropertySymbols && !Co(function() {
        var e3 = Symbol();
        return !String(e3) || !(Object(e3) instanceof Symbol) || !Symbol.sham && _o && _o < 41;
      }), vo = So && !Symbol.sham && "symbol" == typeof Symbol.iterator, To = ho, Ro = Nn, yo = Cn, wo = vo, bo = vn.Object, No = wo ? function(e3) {
        return "symbol" == typeof e3;
      } : function(e3) {
        var t3 = To("Symbol");
        return Ro(t3) && yo(t3.prototype, bo(e3));
      }, Oo = vn.String, Do = function(e3) {
        try {
          return Oo(e3);
        } catch (e4) {
          return "Object";
        }
      }, Po = Nn, Lo = Do, ko = vn.TypeError, Bo = function(e3) {
        if (Po(e3))
          return e3;
        throw ko(Lo(e3) + " is not a function");
      }, Mo = Bo, Uo = function(e3, t3) {
        var i3 = e3[t3];
        return null == i3 ? void 0 : Mo(i3);
      }, xo = kn, Qo = Nn, Fo = no, Vo = vn.TypeError, jo = { exports: {} }, Go = vn, Ko = Object.defineProperty, Ho = function(e3, t3) {
        try {
          Ko(Go, e3, { value: t3, configurable: true, writable: true });
        } catch (i3) {
          Go[e3] = t3;
        }
        return t3;
      }, Wo = "__core-js_shared__", Yo = vn[Wo] || Ho(Wo, {}), Jo = Yo;
      (jo.exports = function(e3, t3) {
        return Jo[e3] || (Jo[e3] = void 0 !== t3 ? t3 : {});
      })("versions", []).push({ version: "3.20.3", mode: "pure", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE", source: "https://github.com/zloirock/core-js" });
      var qo = $n, Xo = vn.Object, zo = function(e3) {
        return Xo(qo(e3));
      }, Zo = zo, $o = _n({}.hasOwnProperty), es = Object.hasOwn || function(e3, t3) {
        return $o(Zo(e3), t3);
      }, ts = _n, is = 0, rs = Math.random(), ns = ts(1 .toString), os = function(e3) {
        return "Symbol(" + (void 0 === e3 ? "" : e3) + ")_" + ns(++is + rs, 36);
      }, ss = vn, as = jo.exports, cs = es, ds = os, us = So, hs = vo, As = as("wks"), ls = ss.Symbol, ps = ls && ls.for, gs = hs ? ls : ls && ls.withoutSetter || ds, Es = function(e3) {
        if (!cs(As, e3) || !us && "string" != typeof As[e3]) {
          var t3 = "Symbol." + e3;
          us && cs(ls, e3) ? As[e3] = ls[e3] : As[e3] = hs && ps ? ps(t3) : gs(t3);
        }
        return As[e3];
      }, fs = kn, ms = no, Is = No, _s = Uo, Cs = function(e3, t3) {
        var i3, r3;
        if ("string" === t3 && Qo(i3 = e3.toString) && !Fo(r3 = xo(i3, e3)))
          return r3;
        if (Qo(i3 = e3.valueOf) && !Fo(r3 = xo(i3, e3)))
          return r3;
        if ("string" !== t3 && Qo(i3 = e3.toString) && !Fo(r3 = xo(i3, e3)))
          return r3;
        throw Vo("Can't convert object to primitive value");
      }, Ss = Es, vs = vn.TypeError, Ts = Ss("toPrimitive"), Rs = function(e3, t3) {
        if (!ms(e3) || Is(e3))
          return e3;
        var i3, r3 = _s(e3, Ts);
        if (r3) {
          if (void 0 === t3 && (t3 = "default"), i3 = fs(r3, e3, t3), !ms(i3) || Is(i3))
            return i3;
          throw vs("Can't convert object to primitive value");
        }
        return void 0 === t3 && (t3 = "number"), Cs(e3, t3);
      }, ys = No, ws = function(e3) {
        var t3 = Rs(e3, "string");
        return ys(t3) ? t3 : t3 + "";
      }, bs = no, Ns = vn.document, Os = bs(Ns) && bs(Ns.createElement), Ds = function(e3) {
        return Os ? Ns.createElement(e3) : {};
      }, Ps = Ds, Ls = !Dn && !ln(function() {
        return 7 != Object.defineProperty(Ps("div"), "a", { get: function() {
          return 7;
        } }).a;
      }), ks = Dn, Bs = kn, Ms = Bn, Us = Vn, xs = io, Qs = ws, Fs = es, Vs = Ls, js = Object.getOwnPropertyDescriptor;
      On.f = ks ? js : function(e3, t3) {
        if (e3 = xs(e3), t3 = Qs(t3), Vs)
          try {
            return js(e3, t3);
          } catch (e4) {
          }
        if (Fs(e3, t3))
          return Us(!Bs(Ms.f, e3, t3), e3[t3]);
      };
      var Gs = ln, Ks = Nn, Hs = /#|\.prototype\./, Ws = function(e3, t3) {
        var i3 = Js[Ys(e3)];
        return i3 == Xs || i3 != qs && (Ks(t3) ? Gs(t3) : !!t3);
      }, Ys = Ws.normalize = function(e3) {
        return String(e3).replace(Hs, ".").toLowerCase();
      }, Js = Ws.data = {}, qs = Ws.NATIVE = "N", Xs = Ws.POLYFILL = "P", zs = Ws, Zs = Bo, $s = pn, ea = _n(_n.bind), ta = function(e3, t3) {
        return Zs(e3), void 0 === t3 ? e3 : $s ? ea(e3, t3) : function() {
          return e3.apply(t3, arguments);
        };
      }, ia = {}, ra = Dn && ln(function() {
        return 42 != Object.defineProperty(function() {
        }, "prototype", { value: 42, writable: false }).prototype;
      }), na = vn, oa = no, sa = na.String, aa = na.TypeError, ca = function(e3) {
        if (oa(e3))
          return e3;
        throw aa(sa(e3) + " is not an object");
      }, da = Dn, ua = Ls, ha = ra, Aa = ca, la = ws, pa = vn.TypeError, ga = Object.defineProperty, Ea = Object.getOwnPropertyDescriptor, fa = "enumerable", ma = "configurable", Ia = "writable";
      ia.f = da ? ha ? function(e3, t3, i3) {
        if (Aa(e3), t3 = la(t3), Aa(i3), "function" == typeof e3 && "prototype" === t3 && "value" in i3 && Ia in i3 && !i3.writable) {
          var r3 = Ea(e3, t3);
          r3 && r3.writable && (e3[t3] = i3.value, i3 = { configurable: ma in i3 ? i3.configurable : r3.configurable, enumerable: fa in i3 ? i3.enumerable : r3.enumerable, writable: false });
        }
        return ga(e3, t3, i3);
      } : ga : function(e3, t3, i3) {
        if (Aa(e3), t3 = la(t3), Aa(i3), ua)
          try {
            return ga(e3, t3, i3);
          } catch (e4) {
          }
        if ("get" in i3 || "set" in i3)
          throw pa("Accessors not supported");
        return "value" in i3 && (e3[t3] = i3.value), e3;
      };
      var _a = ia, Ca = Vn, Sa = Dn ? function(e3, t3, i3) {
        return _a.f(e3, t3, Ca(1, i3));
      } : function(e3, t3, i3) {
        return e3[t3] = i3, e3;
      }, va = vn, Ta = bn, Ra = _n, ya = Nn, wa = On.f, ba = zs, Na = oo, Oa = ta, Da = Sa, Pa = es, La = function(e3) {
        var t3 = function(i3, r3, n3) {
          if (this instanceof t3) {
            switch (arguments.length) {
              case 0:
                return new e3();
              case 1:
                return new e3(i3);
              case 2:
                return new e3(i3, r3);
            }
            return new e3(i3, r3, n3);
          }
          return Ta(e3, this, arguments);
        };
        return t3.prototype = e3.prototype, t3;
      }, ka = function(e3, t3) {
        var i3, r3, n3, o3, s3, a3, c3, d3, u3 = e3.target, h3 = e3.global, A3 = e3.stat, l3 = e3.proto, p3 = h3 ? va : A3 ? va[u3] : (va[u3] || {}).prototype, g3 = h3 ? Na : Na[u3] || Da(Na, u3, {})[u3], E3 = g3.prototype;
        for (n3 in t3)
          i3 = !ba(h3 ? n3 : u3 + (A3 ? "." : "#") + n3, e3.forced) && p3 && Pa(p3, n3), s3 = g3[n3], i3 && (a3 = e3.noTargetGet ? (d3 = wa(p3, n3)) && d3.value : p3[n3]), o3 = i3 && a3 ? a3 : t3[n3], i3 && typeof s3 == typeof o3 || (c3 = e3.bind && i3 ? Oa(o3, va) : e3.wrap && i3 ? La(o3) : l3 && ya(o3) ? Ra(o3) : o3, (e3.sham || o3 && o3.sham || s3 && s3.sham) && Da(c3, "sham", true), Da(g3, n3, c3), l3 && (Pa(Na, r3 = u3 + "Prototype") || Da(Na, r3, {}), Da(Na[r3], n3, o3), e3.real && E3 && !E3[n3] && Da(E3, n3, o3)));
      }, Ba = Math.ceil, Ma = Math.floor, Ua = function(e3) {
        var t3 = +e3;
        return t3 != t3 || 0 === t3 ? 0 : (t3 > 0 ? Ma : Ba)(t3);
      }, xa = Ua, Qa = Math.min, Fa = function(e3) {
        return e3 > 0 ? Qa(xa(e3), 9007199254740991) : 0;
      }, Va = function(e3) {
        return Fa(e3.length);
      }, ja = Bo, Ga = zo, Ka = zn, Ha = Va, Wa = vn.TypeError, Ya = function(e3) {
        return function(t3, i3, r3, n3) {
          ja(i3);
          var o3 = Ga(t3), s3 = Ka(o3), a3 = Ha(o3), c3 = e3 ? a3 - 1 : 0, d3 = e3 ? -1 : 1;
          if (r3 < 2)
            for (; ; ) {
              if (c3 in s3) {
                n3 = s3[c3], c3 += d3;
                break;
              }
              if (c3 += d3, e3 ? c3 < 0 : a3 <= c3)
                throw Wa("Reduce of empty array with no initial value");
            }
          for (; e3 ? c3 >= 0 : a3 > c3; c3 += d3)
            c3 in s3 && (n3 = i3(n3, s3[c3], c3, o3));
          return n3;
        };
      }, Ja = { left: Ya(false), right: Ya(true) }, qa = ln, Xa = function(e3, t3) {
        var i3 = [][e3];
        return !!i3 && qa(function() {
          i3.call(null, t3 || function() {
            throw 1;
          }, 1);
        });
      }, za = "process" == Hn(vn.process), Za = Ja.left, $a = Io, ec = za;
      ka({ target: "Array", proto: true, forced: !Xa("reduce") || !ec && $a > 79 && $a < 83 }, { reduce: function(e3) {
        var t3 = arguments.length;
        return Za(this, e3, t3, t3 > 1 ? arguments[1] : void 0);
      } });
      var tc = oo, ic = function(e3) {
        return tc[e3 + "Prototype"];
      }, rc = ic("Array").reduce, nc = Cn, oc = rc, sc = Array.prototype, ac = function(e3) {
        var t3 = e3.reduce;
        return e3 === sc || nc(sc, e3) && t3 === sc.reduce ? oc : t3;
      }, cc = ac, dc = {};
      dc[ze("toStringTag")] = "z";
      var uc = i, hc = "[object z]" === String(dc), Ac = x, lc = y, pc = ze("toStringTag"), gc = uc.Object, Ec = "Arguments" == lc(function() {
        return arguments;
      }()), fc = hc ? lc : function(e3) {
        var t3, i3, r3;
        return void 0 === e3 ? "Undefined" : null === e3 ? "Null" : "string" == typeof (i3 = function(e4, t4) {
          try {
            return e4[t4];
          } catch (e5) {
          }
        }(t3 = gc(e3), pc)) ? i3 : Ec ? lc(t3) : "Object" == (r3 = lc(t3)) && Ac(t3.callee) ? "Arguments" : r3;
      }, mc = fc, Ic = i.String, _c = function(e3) {
        if ("Symbol" === mc(e3))
          throw TypeError("Cannot convert a Symbol value to a string");
        return Ic(e3);
      }, Cc = Ot, Sc = function() {
        var e3 = Cc(this), t3 = "";
        return e3.global && (t3 += "g"), e3.ignoreCase && (t3 += "i"), e3.multiline && (t3 += "m"), e3.dotAll && (t3 += "s"), e3.unicode && (t3 += "u"), e3.sticky && (t3 += "y"), t3;
      }, vc = n, Tc = i.RegExp, Rc = vc(function() {
        var e3 = Tc("a", "y");
        return e3.lastIndex = 2, null != e3.exec("abcd");
      }), yc = Rc || vc(function() {
        return !Tc("a", "y").sticky;
      }), wc = { BROKEN_CARET: Rc || vc(function() {
        var e3 = Tc("^r", "gy");
        return e3.lastIndex = 2, null != e3.exec("str");
      }), MISSED_STICKY: yc, UNSUPPORTED_Y: Rc }, bc = {}, Nc = hr, Oc = Ar, Dc = Object.keys || function(e3) {
        return Nc(e3, Oc);
      }, Pc = o, Lc = Rt, kc = Tt, Bc = Ot, Mc = U, Uc = Dc;
      bc.f = Pc && !Lc ? Object.defineProperties : function(e3, t3) {
        Bc(e3);
        for (var i3, r3 = Mc(t3), n3 = Uc(t3), o3 = n3.length, s3 = 0; o3 > s3; )
          kc.f(e3, i3 = n3[s3++], r3[i3]);
        return e3;
      };
      var xc, Qc = K("document", "documentElement"), Fc = Ot, Vc = bc, jc = Ar, Gc = ai, Kc = Qc, Hc = At, Wc = si("IE_PROTO"), Yc = function() {
      }, Jc = function(e3) {
        return "<script>" + e3 + "<\/script>";
      }, qc = function(e3) {
        e3.write(Jc("")), e3.close();
        var t3 = e3.parentWindow.Object;
        return e3 = null, t3;
      }, Xc = function() {
        try {
          xc = new ActiveXObject("htmlfile");
        } catch (e4) {
        }
        var e3, t3;
        Xc = "undefined" != typeof document ? document.domain && xc ? qc(xc) : ((t3 = Hc("iframe")).style.display = "none", Kc.appendChild(t3), t3.src = String("javascript:"), (e3 = t3.contentWindow.document).open(), e3.write(Jc("document.F=Object")), e3.close(), e3.F) : qc(xc);
        for (var i3 = jc.length; i3--; )
          delete Xc.prototype[jc[i3]];
        return Xc();
      };
      Gc[Wc] = true;
      var zc = Object.create || function(e3, t3) {
        var i3;
        return null !== e3 ? (Yc.prototype = Fc(e3), i3 = new Yc(), Yc.prototype = null, i3[Wc] = e3) : i3 = Xc(), void 0 === t3 ? i3 : Vc.f(i3, t3);
      }, Zc = n, $c = i.RegExp, ed = Zc(function() {
        var e3 = $c(".", "s");
        return !(e3.dotAll && e3.exec("\n") && "s" === e3.flags);
      }), td = n, id = i.RegExp, rd = td(function() {
        var e3 = id("(?<a>b)", "g");
        return "b" !== e3.exec("b").groups.a || "bc" !== "b".replace(e3, "$<a>c");
      }), nd = d, od = S, sd = _c, ad = Sc, cd = wc, dd = Se.exports, ud = zc, hd = Ri.get, Ad = ed, ld = rd, pd = dd("native-string-replace", String.prototype.replace), gd = RegExp.prototype.exec, Ed = gd, fd = od("".charAt), md = od("".indexOf), Id = od("".replace), _d = od("".slice), Cd = function() {
        var e3 = /a/, t3 = /b*/g;
        return nd(gd, e3, "a"), nd(gd, t3, "a"), 0 !== e3.lastIndex || 0 !== t3.lastIndex;
      }(), Sd = cd.BROKEN_CARET, vd = void 0 !== /()??/.exec("")[1];
      (Cd || vd || Sd || Ad || ld) && (Ed = function(e3) {
        var t3, i3, r3, n3, o3, s3, a3, c3 = this, d3 = hd(c3), u3 = sd(e3), h3 = d3.raw;
        if (h3)
          return h3.lastIndex = c3.lastIndex, t3 = nd(Ed, h3, u3), c3.lastIndex = h3.lastIndex, t3;
        var A3 = d3.groups, l3 = Sd && c3.sticky, p3 = nd(ad, c3), g3 = c3.source, E3 = 0, f3 = u3;
        if (l3 && (p3 = Id(p3, "y", ""), -1 === md(p3, "g") && (p3 += "g"), f3 = _d(u3, c3.lastIndex), c3.lastIndex > 0 && (!c3.multiline || c3.multiline && "\n" !== fd(u3, c3.lastIndex - 1)) && (g3 = "(?: " + g3 + ")", f3 = " " + f3, E3++), i3 = new RegExp("^(?:" + g3 + ")", p3)), vd && (i3 = new RegExp("^" + g3 + "$(?!\\s)", p3)), Cd && (r3 = c3.lastIndex), n3 = nd(gd, l3 ? i3 : c3, f3), l3 ? n3 ? (n3.input = _d(n3.input, E3), n3[0] = _d(n3[0], E3), n3.index = c3.lastIndex, c3.lastIndex += n3[0].length) : c3.lastIndex = 0 : Cd && n3 && (c3.lastIndex = c3.global ? n3.index + n3[0].length : r3), vd && n3 && n3.length > 1 && nd(pd, n3[0], i3, function() {
          for (o3 = 1; o3 < arguments.length - 2; o3++)
            void 0 === arguments[o3] && (n3[o3] = void 0);
        }), n3 && A3)
          for (n3.groups = s3 = ud(null), o3 = 0; o3 < A3.length; o3++)
            s3[(a3 = A3[o3])[0]] = n3[a3[1]];
        return n3;
      });
      var Td = Ed;
      Gr({ target: "RegExp", proto: true, forced: /./.exec !== Td }, { exec: Td });
      var Rd = zc, yd = Tt, wd = ze("unscopables"), bd = Array.prototype;
      null == bd[wd] && yd.f(bd, wd, { configurable: true, value: Rd(null) });
      var Nd, Od, Dd, Pd = {}, Ld = !n(function() {
        function e3() {
        }
        return e3.prototype.constructor = null, Object.getPrototypeOf(new e3()) !== e3.prototype;
      }), kd = i, Bd = Be, Md = x, Ud = Pe, xd = Ld, Qd = si("IE_PROTO"), Fd = kd.Object, Vd = Fd.prototype, jd = xd ? Fd.getPrototypeOf : function(e3) {
        var t3 = Ud(e3);
        if (Bd(t3, Qd))
          return t3[Qd];
        var i3 = t3.constructor;
        return Md(i3) && t3 instanceof i3 ? i3.prototype : t3 instanceof Fd ? Vd : null;
      }, Gd = n, Kd = x, Hd = jd, Wd = Ht.exports, Yd = ze("iterator"), Jd = false;
      [].keys && ("next" in (Dd = [].keys()) ? (Od = Hd(Hd(Dd))) !== Object.prototype && (Nd = Od) : Jd = true), (null == Nd || Gd(function() {
        var e3 = {};
        return Nd[Yd].call(e3) !== e3;
      })) && (Nd = {}), Kd(Nd[Yd]) || Wd(Nd, Yd, function() {
        return this;
      });
      var qd = { IteratorPrototype: Nd, BUGGY_SAFARI_ITERATORS: Jd }, Xd = Tt.f, zd = Be, Zd = ze("toStringTag"), $d = function(e3, t3, i3) {
        e3 && !i3 && (e3 = e3.prototype), e3 && !zd(e3, Zd) && Xd(e3, Zd, { configurable: true, value: t3 });
      }, eu = qd.IteratorPrototype, tu = zc, iu = E, ru = $d, nu = Pd, ou = function() {
        return this;
      }, su = i, au = x, cu = su.String, du = su.TypeError, uu = S, hu = Ot, Au = function(e3) {
        if ("object" == typeof e3 || au(e3))
          return e3;
        throw du("Can't set " + cu(e3) + " as a prototype");
      }, lu = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e3, t3 = false, i3 = {};
        try {
          (e3 = uu(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(i3, []), t3 = i3 instanceof Array;
        } catch (e4) {
        }
        return function(i4, r3) {
          return hu(i4), Au(r3), t3 ? e3(i4, r3) : i4.__proto__ = r3, i4;
        };
      }() : void 0), pu = Gr, gu = d, Eu = Di, fu = x, mu = function(e3, t3, i3, r3) {
        var n3 = t3 + " Iterator";
        return e3.prototype = tu(eu, { next: iu(+!r3, i3) }), ru(e3, n3, false), nu[n3] = ou, e3;
      }, Iu = jd, _u = lu, Cu = $d, Su = Kt, vu = Ht.exports, Tu = Pd, Ru = Eu.PROPER, yu = Eu.CONFIGURABLE, wu = qd.IteratorPrototype, bu = qd.BUGGY_SAFARI_ITERATORS, Nu = ze("iterator"), Ou = "keys", Du = "values", Pu = "entries", Lu = function() {
        return this;
      }, ku = U, Bu = function(e3) {
        bd[wd][e3] = true;
      }, Mu = Pd, Uu = Ri, xu = Tt.f, Qu = function(e3, t3, i3, r3, n3, o3, s3) {
        mu(i3, t3, r3);
        var a3, c3, d3, u3 = function(e4) {
          if (e4 === n3 && g3)
            return g3;
          if (!bu && e4 in l3)
            return l3[e4];
          switch (e4) {
            case Ou:
            case Du:
            case Pu:
              return function() {
                return new i3(this, e4);
              };
          }
          return function() {
            return new i3(this);
          };
        }, h3 = t3 + " Iterator", A3 = false, l3 = e3.prototype, p3 = l3[Nu] || l3["@@iterator"] || n3 && l3[n3], g3 = !bu && p3 || u3(n3), E3 = "Array" == t3 && l3.entries || p3;
        if (E3 && (a3 = Iu(E3.call(new e3()))) !== Object.prototype && a3.next && (Iu(a3) !== wu && (_u ? _u(a3, wu) : fu(a3[Nu]) || vu(a3, Nu, Lu)), Cu(a3, h3, true)), Ru && n3 == Du && p3 && p3.name !== Du && (yu ? Su(l3, "name", Du) : (A3 = true, g3 = function() {
          return gu(p3, this);
        })), n3)
          if (c3 = { values: u3(Du), keys: o3 ? g3 : u3(Ou), entries: u3(Pu) }, s3)
            for (d3 in c3)
              (bu || A3 || !(d3 in l3)) && vu(l3, d3, c3[d3]);
          else
            pu({ target: t3, proto: true, forced: bu || A3 }, c3);
        return l3[Nu] !== g3 && vu(l3, Nu, g3, { name: n3 }), Tu[t3] = g3, c3;
      }, Fu = o, Vu = "Array Iterator", ju = Uu.set, Gu = Uu.getterFor(Vu), Ku = Qu(Array, "Array", function(e3, t3) {
        ju(this, { type: Vu, target: ku(e3), index: 0, kind: t3 });
      }, function() {
        var e3 = Gu(this), t3 = e3.target, i3 = e3.kind, r3 = e3.index++;
        return !t3 || r3 >= t3.length ? (e3.target = void 0, { value: void 0, done: true }) : "keys" == i3 ? { value: r3, done: false } : "values" == i3 ? { value: t3[r3], done: false } : { value: [r3, t3[r3]], done: false };
      }, "values"), Hu = Mu.Arguments = Mu.Array;
      if (Bu("keys"), Bu("values"), Bu("entries"), Fu && "values" !== Hu.name)
        try {
          xu(Hu, "name", { value: "values" });
        } catch (e3) {
        }
      var Wu = At("span").classList, Yu = Wu && Wu.constructor && Wu.constructor.prototype, Ju = Yu === Object.prototype ? void 0 : Yu, qu = i, Xu = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, zu = Ju, Zu = Ku, $u = Kt, eh = ze, th = eh("iterator"), ih = eh("toStringTag"), rh = Zu.values, nh = function(e3, t3) {
        if (e3) {
          if (e3[th] !== rh)
            try {
              $u(e3, th, rh);
            } catch (t4) {
              e3[th] = rh;
            }
          if (e3[ih] || $u(e3, ih, t3), Xu[t3]) {
            for (var i3 in Zu)
              if (e3[i3] !== Zu[i3])
                try {
                  $u(e3, i3, Zu[i3]);
                } catch (t4) {
                  e3[i3] = Zu[i3];
                }
          }
        }
      };
      for (var oh in Xu)
        nh(qu[oh] && qu[oh].prototype, oh);
      nh(zu, "DOMTokenList");
      var sh = x, ah = F, ch = lu, dh = function(e3, t3, i3) {
        var r3, n3;
        return ch && sh(r3 = t3.constructor) && r3 !== i3 && ah(n3 = r3.prototype) && n3 !== i3.prototype && ch(e3, n3), e3;
      }, uh = _c, hh = function(e3, t3) {
        return void 0 === e3 ? arguments.length < 2 ? "" : t3 : uh(e3);
      }, Ah = F, lh = Kt, ph = S("".replace), gh = String(Error("zxcasd").stack), Eh = /\n\s*at [^:]*:[^\n]*/, fh = Eh.test(gh), mh = function(e3, t3) {
        if (fh && "string" == typeof e3)
          for (; t3--; )
            e3 = ph(e3, Eh, "");
        return e3;
      }, Ih = E, _h = !n(function() {
        var e3 = Error("a");
        return !("stack" in e3) || (Object.defineProperty(e3, "stack", Ih(1, 7)), 7 !== e3.stack);
      }), Ch = K, Sh = Be, vh = Kt, Th = H, Rh = lu, yh = yr, wh = dh, bh = hh, Nh = function(e3, t3) {
        Ah(t3) && "cause" in t3 && lh(e3, "cause", t3.cause);
      }, Oh = mh, Dh = _h, Ph = Gr, Lh = Jr, kh = function(e3, t3, i3, r3) {
        var n3 = r3 ? 2 : 1, o3 = e3.split("."), s3 = o3[o3.length - 1], a3 = Ch.apply(null, o3);
        if (a3) {
          var c3 = a3.prototype;
          if (Sh(c3, "cause") && delete c3.cause, !i3)
            return a3;
          var d3 = Ch("Error"), u3 = t3(function(e4, t4) {
            var i4 = bh(r3 ? t4 : e4, void 0), o4 = r3 ? new a3(e4) : new a3();
            return void 0 !== i4 && vh(o4, "message", i4), Dh && vh(o4, "stack", Oh(o4.stack, 2)), this && Th(c3, this) && wh(o4, this, u3), arguments.length > n3 && Nh(o4, arguments[n3]), o4;
          });
          u3.prototype = c3, "Error" !== s3 && (Rh ? Rh(u3, d3) : yh(u3, d3, { name: true })), yh(u3, a3);
          try {
            c3.name !== s3 && vh(c3, "name", s3), c3.constructor = u3;
          } catch (e4) {
          }
          return u3;
        }
      }, Bh = "WebAssembly", Mh = i.WebAssembly, Uh = 7 !== Error("e", { cause: 7 }).cause, xh = function(e3, t3) {
        var i3 = {};
        i3[e3] = kh(e3, t3, Uh), Ph({ global: true, forced: Uh }, i3);
      }, Qh = function(e3, t3) {
        if (Mh && Mh[e3]) {
          var i3 = {};
          i3[e3] = kh("WebAssembly." + e3, t3, Uh), Ph({ target: Bh, stat: true, forced: Uh }, i3);
        }
      };
      xh("Error", function(e3) {
        return function(t3) {
          return Lh(e3, this, arguments);
        };
      }), xh("EvalError", function(e3) {
        return function(t3) {
          return Lh(e3, this, arguments);
        };
      }), xh("RangeError", function(e3) {
        return function(t3) {
          return Lh(e3, this, arguments);
        };
      }), xh("ReferenceError", function(e3) {
        return function(t3) {
          return Lh(e3, this, arguments);
        };
      }), xh("SyntaxError", function(e3) {
        return function(t3) {
          return Lh(e3, this, arguments);
        };
      }), xh("TypeError", function(e3) {
        return function(t3) {
          return Lh(e3, this, arguments);
        };
      }), xh("URIError", function(e3) {
        return function(t3) {
          return Lh(e3, this, arguments);
        };
      }), Qh("CompileError", function(e3) {
        return function(t3) {
          return Lh(e3, this, arguments);
        };
      }), Qh("LinkError", function(e3) {
        return function(t3) {
          return Lh(e3, this, arguments);
        };
      }), Qh("RuntimeError", function(e3) {
        return function(t3) {
          return Lh(e3, this, arguments);
        };
      });
      let Fh = true, Vh = true;
      function jh(e3, t3, i3) {
        const r3 = e3.match(t3);
        return r3 && r3.length >= i3 && parseInt(r3[i3], 10);
      }
      function Gh(e3, t3, i3) {
        if (!e3.RTCPeerConnection)
          return;
        const r3 = e3.RTCPeerConnection.prototype, n3 = r3.addEventListener;
        r3.addEventListener = function(e4, r4) {
          if (e4 !== t3)
            return n3.apply(this, arguments);
          const o4 = (e5) => {
            const t4 = i3(e5);
            t4 && (r4.handleEvent ? r4.handleEvent(t4) : r4(t4));
          };
          return this._eventMap = this._eventMap || {}, this._eventMap[t3] || (this._eventMap[t3] = /* @__PURE__ */ new Map()), this._eventMap[t3].set(r4, o4), n3.apply(this, [e4, o4]);
        };
        const o3 = r3.removeEventListener;
        r3.removeEventListener = function(e4, i4) {
          if (e4 !== t3 || !this._eventMap || !this._eventMap[t3])
            return o3.apply(this, arguments);
          if (!this._eventMap[t3].has(i4))
            return o3.apply(this, arguments);
          const r4 = this._eventMap[t3].get(i4);
          return this._eventMap[t3].delete(i4), 0 === this._eventMap[t3].size && delete this._eventMap[t3], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o3.apply(this, [e4, r4]);
        }, Object.defineProperty(r3, "on" + t3, { get() {
          return this["_on" + t3];
        }, set(e4) {
          this["_on" + t3] && (this.removeEventListener(t3, this["_on" + t3]), delete this["_on" + t3]), e4 && this.addEventListener(t3, this["_on" + t3] = e4);
        }, enumerable: true, configurable: true });
      }
      function Kh(e3) {
        return "boolean" != typeof e3 ? new Error("Argument type: " + typeof e3 + ". Please use a boolean.") : (Fh = e3, e3 ? "adapter.js logging disabled" : "adapter.js logging enabled");
      }
      function Hh(e3) {
        return "boolean" != typeof e3 ? new Error("Argument type: " + typeof e3 + ". Please use a boolean.") : (Vh = !e3, "adapter.js deprecation warnings " + (e3 ? "disabled" : "enabled"));
      }
      function Wh() {
        if ("object" == typeof window) {
          if (Fh)
            return;
          "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments);
        }
      }
      function Yh(e3, t3) {
        Vh && console.warn(e3 + " is deprecated, please use " + t3 + " instead.");
      }
      function Jh(e3) {
        const t3 = { browser: null, version: null };
        if (void 0 === e3 || !e3.navigator)
          return t3.browser = "Not a browser.", t3;
        const { navigator: i3 } = e3;
        if (i3.mozGetUserMedia)
          t3.browser = "firefox", t3.version = jh(i3.userAgent, /Firefox\/(\d+)\./, 1);
        else if (i3.webkitGetUserMedia || false === e3.isSecureContext && e3.webkitRTCPeerConnection && !e3.RTCIceGatherer)
          t3.browser = "chrome", t3.version = jh(i3.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
        else if (i3.mediaDevices && i3.userAgent.match(/Edge\/(\d+).(\d+)$/))
          t3.browser = "edge", t3.version = jh(i3.userAgent, /Edge\/(\d+).(\d+)$/, 2);
        else {
          if (!e3.RTCPeerConnection || !i3.userAgent.match(/AppleWebKit\/(\d+)\./))
            return t3.browser = "Not a supported browser.", t3;
          t3.browser = "safari", t3.version = jh(i3.userAgent, /AppleWebKit\/(\d+)\./, 1), t3.supportsUnifiedPlan = e3.RTCRtpTransceiver && "currentDirection" in e3.RTCRtpTransceiver.prototype;
        }
        return t3;
      }
      function qh(e3) {
        return "[object Object]" === Object.prototype.toString.call(e3);
      }
      function Xh(e3) {
        var t3;
        return qh(e3) ? cc(t3 = Object.keys(e3)).call(t3, function(t4, i3) {
          const r3 = qh(e3[i3]), n3 = r3 ? Xh(e3[i3]) : e3[i3], o3 = r3 && !Object.keys(n3).length;
          return void 0 === n3 || o3 ? t4 : Object.assign(t4, { [i3]: n3 });
        }, {}) : e3;
      }
      function zh(e3, t3, i3) {
        const r3 = i3 ? "outbound-rtp" : "inbound-rtp", n3 = /* @__PURE__ */ new Map();
        if (null === t3)
          return n3;
        const o3 = [];
        return e3.forEach((e4) => {
          "track" === e4.type && e4.trackIdentifier === t3.id && o3.push(e4);
        }), o3.forEach((t4) => {
          e3.forEach((i4) => {
            i4.type === r3 && i4.trackId === t4.id && function e4(t5, i5, r4) {
              i5 && !r4.has(i5.id) && (r4.set(i5.id, i5), Object.keys(i5).forEach((n4) => {
                n4.endsWith("Id") ? e4(t5, t5.get(i5[n4]), r4) : n4.endsWith("Ids") && i5[n4].forEach((i6) => {
                  e4(t5, t5.get(i6), r4);
                });
              }));
            }(e3, i4, n3);
          });
        }), n3;
      }
      var Zh = jo.exports, $h = os, eA = Zh("keys"), tA = function(e3) {
        return eA[e3] || (eA[e3] = $h(e3));
      }, iA = !ln(function() {
        function e3() {
        }
        return e3.prototype.constructor = null, Object.getPrototypeOf(new e3()) !== e3.prototype;
      }), rA = vn, nA = es, oA = Nn, sA = zo, aA = iA, cA = tA("IE_PROTO"), dA = rA.Object, uA = dA.prototype, hA = aA ? dA.getPrototypeOf : function(e3) {
        var t3 = sA(e3);
        if (nA(t3, cA))
          return t3[cA];
        var i3 = t3.constructor;
        return oA(i3) && t3 instanceof i3 ? i3.prototype : t3 instanceof dA ? uA : null;
      }, AA = vn, lA = Nn, pA = AA.String, gA = AA.TypeError, EA = _n, fA = ca, mA = function(e3) {
        if ("object" == typeof e3 || lA(e3))
          return e3;
        throw gA("Can't set " + pA(e3) + " as a prototype");
      }, IA = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e3, t3 = false, i3 = {};
        try {
          (e3 = EA(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(i3, []), t3 = i3 instanceof Array;
        } catch (e4) {
        }
        return function(i4, r3) {
          return fA(i4), mA(r3), t3 ? e3(i4, r3) : i4.__proto__ = r3, i4;
        };
      }() : void 0), _A = {}, CA = Ua, SA = Math.max, vA = Math.min, TA = function(e3, t3) {
        var i3 = CA(e3);
        return i3 < 0 ? SA(i3 + t3, 0) : vA(i3, t3);
      }, RA = io, yA = TA, wA = Va, bA = function(e3) {
        return function(t3, i3, r3) {
          var n3, o3 = RA(t3), s3 = wA(o3), a3 = yA(r3, s3);
          if (e3 && i3 != i3) {
            for (; s3 > a3; )
              if ((n3 = o3[a3++]) != n3)
                return true;
          } else
            for (; s3 > a3; a3++)
              if ((e3 || a3 in o3) && o3[a3] === i3)
                return e3 || a3 || 0;
          return !e3 && -1;
        };
      }, NA = { includes: bA(true), indexOf: bA(false) }, OA = {}, DA = es, PA = io, LA = NA.indexOf, kA = OA, BA = _n([].push), MA = function(e3, t3) {
        var i3, r3 = PA(e3), n3 = 0, o3 = [];
        for (i3 in r3)
          !DA(kA, i3) && DA(r3, i3) && BA(o3, i3);
        for (; t3.length > n3; )
          DA(r3, i3 = t3[n3++]) && (~LA(o3, i3) || BA(o3, i3));
        return o3;
      }, UA = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], xA = MA, QA = UA.concat("length", "prototype");
      _A.f = Object.getOwnPropertyNames || function(e3) {
        return xA(e3, QA);
      };
      var FA = {};
      FA.f = Object.getOwnPropertySymbols;
      var VA = ho, jA = _A, GA = FA, KA = ca, HA = _n([].concat), WA = VA("Reflect", "ownKeys") || function(e3) {
        var t3 = jA.f(KA(e3)), i3 = GA.f;
        return i3 ? HA(t3, i3(e3)) : t3;
      }, YA = es, JA = WA, qA = On, XA = ia, zA = {}, ZA = MA, $A = UA, el = Object.keys || function(e3) {
        return ZA(e3, $A);
      }, tl = Dn, il = ra, rl = ia, nl = ca, ol = io, sl = el;
      zA.f = tl && !il ? Object.defineProperties : function(e3, t3) {
        nl(e3);
        for (var i3, r3 = ol(t3), n3 = sl(t3), o3 = n3.length, s3 = 0; o3 > s3; )
          rl.f(e3, i3 = n3[s3++], r3[i3]);
        return e3;
      };
      var al, cl = ho("document", "documentElement"), dl = ca, ul = zA, hl = UA, Al = OA, ll = cl, pl = Ds, gl = tA("IE_PROTO"), El = function() {
      }, fl = function(e3) {
        return "<script>" + e3 + "<\/script>";
      }, ml = function(e3) {
        e3.write(fl("")), e3.close();
        var t3 = e3.parentWindow.Object;
        return e3 = null, t3;
      }, Il = function() {
        try {
          al = new ActiveXObject("htmlfile");
        } catch (e4) {
        }
        var e3, t3;
        Il = "undefined" != typeof document ? document.domain && al ? ml(al) : ((t3 = pl("iframe")).style.display = "none", ll.appendChild(t3), t3.src = String("javascript:"), (e3 = t3.contentWindow.document).open(), e3.write(fl("document.F=Object")), e3.close(), e3.F) : ml(al);
        for (var i3 = hl.length; i3--; )
          delete Il.prototype[hl[i3]];
        return Il();
      };
      Al[gl] = true;
      var _l = Object.create || function(e3, t3) {
        var i3;
        return null !== e3 ? (El.prototype = dl(e3), i3 = new El(), El.prototype = null, i3[gl] = e3) : i3 = Il(), void 0 === t3 ? i3 : ul.f(i3, t3);
      }, Cl = _n("".replace), Sl = String(Error("zxcasd").stack), vl = /\n\s*at [^:]*:[^\n]*/, Tl = vl.test(Sl), Rl = no, yl = Sa, wl = {}, bl = wl, Nl = Es("iterator"), Ol = Array.prototype, Dl = function(e3) {
        return void 0 !== e3 && (bl.Array === e3 || Ol[Nl] === e3);
      }, Pl = {};
      Pl[Es("toStringTag")] = "z";
      var Ll = "[object z]" === String(Pl), kl = vn, Bl = Ll, Ml = Nn, Ul = Hn, xl = Es("toStringTag"), Ql = kl.Object, Fl = "Arguments" == Ul(function() {
        return arguments;
      }()), Vl = Bl ? Ul : function(e3) {
        var t3, i3, r3;
        return void 0 === e3 ? "Undefined" : null === e3 ? "Null" : "string" == typeof (i3 = function(e4, t4) {
          try {
            return e4[t4];
          } catch (e5) {
          }
        }(t3 = Ql(e3), xl)) ? i3 : Fl ? Ul(t3) : "Object" == (r3 = Ul(t3)) && Ml(t3.callee) ? "Arguments" : r3;
      }, jl = Vl, Gl = Uo, Kl = wl, Hl = Es("iterator"), Wl = function(e3) {
        if (null != e3)
          return Gl(e3, Hl) || Gl(e3, "@@iterator") || Kl[jl(e3)];
      }, Yl = kn, Jl = Bo, ql = ca, Xl = Do, zl = Wl, Zl = vn.TypeError, $l = function(e3, t3) {
        var i3 = arguments.length < 2 ? zl(e3) : t3;
        if (Jl(i3))
          return ql(Yl(i3, e3));
        throw Zl(Xl(e3) + " is not iterable");
      }, ep = kn, tp = ca, ip = Uo, rp = function(e3, t3, i3) {
        var r3, n3;
        tp(e3);
        try {
          if (!(r3 = ip(e3, "return"))) {
            if ("throw" === t3)
              throw i3;
            return i3;
          }
          r3 = ep(r3, e3);
        } catch (e4) {
          n3 = true, r3 = e4;
        }
        if ("throw" === t3)
          throw i3;
        if (n3)
          throw r3;
        return tp(r3), i3;
      }, np = ta, op = kn, sp = ca, ap = Do, cp = Dl, dp = Va, up = Cn, hp = $l, Ap = Wl, lp = rp, pp = vn.TypeError, gp = function(e3, t3) {
        this.stopped = e3, this.result = t3;
      }, Ep = gp.prototype, fp = function(e3, t3, i3) {
        var r3, n3, o3, s3, a3, c3, d3, u3 = i3 && i3.that, h3 = !(!i3 || !i3.AS_ENTRIES), A3 = !(!i3 || !i3.IS_ITERATOR), l3 = !(!i3 || !i3.INTERRUPTED), p3 = np(t3, u3), g3 = function(e4) {
          return r3 && lp(r3, "normal", e4), new gp(true, e4);
        }, E3 = function(e4) {
          return h3 ? (sp(e4), l3 ? p3(e4[0], e4[1], g3) : p3(e4[0], e4[1])) : l3 ? p3(e4, g3) : p3(e4);
        };
        if (A3)
          r3 = e3;
        else {
          if (!(n3 = Ap(e3)))
            throw pp(ap(e3) + " is not iterable");
          if (cp(n3)) {
            for (o3 = 0, s3 = dp(e3); s3 > o3; o3++)
              if ((a3 = E3(e3[o3])) && up(Ep, a3))
                return a3;
            return new gp(false);
          }
          r3 = hp(e3, n3);
        }
        for (c3 = r3.next; !(d3 = op(c3, r3)).done; ) {
          try {
            a3 = E3(d3.value);
          } catch (e4) {
            lp(r3, "throw", e4);
          }
          if ("object" == typeof a3 && a3 && up(Ep, a3))
            return a3;
        }
        return new gp(false);
      }, mp = Vl, Ip = vn.String, _p = function(e3) {
        if ("Symbol" === mp(e3))
          throw TypeError("Cannot convert a Symbol value to a string");
        return Ip(e3);
      }, Cp = _p, Sp = Vn, vp = !ln(function() {
        var e3 = Error("a");
        return !("stack" in e3) || (Object.defineProperty(e3, "stack", Sp(1, 7)), 7 !== e3.stack);
      }), Tp = ka, Rp = vn, yp = Cn, wp = hA, bp = IA, Np = function(e3, t3, i3) {
        for (var r3 = JA(t3), n3 = XA.f, o3 = qA.f, s3 = 0; s3 < r3.length; s3++) {
          var a3 = r3[s3];
          YA(e3, a3) || i3 && YA(i3, a3) || n3(e3, a3, o3(t3, a3));
        }
      }, Op = _l, Dp = Sa, Pp = Vn, Lp = function(e3, t3) {
        if (Tl && "string" == typeof e3)
          for (; t3--; )
            e3 = Cl(e3, vl, "");
        return e3;
      }, kp = function(e3, t3) {
        Rl(t3) && "cause" in t3 && yl(e3, "cause", t3.cause);
      }, Bp = fp, Mp = function(e3, t3) {
        return void 0 === e3 ? arguments.length < 2 ? "" : t3 : Cp(e3);
      }, Up = vp, xp = Es("toStringTag"), Qp = Rp.Error, Fp = [].push, Vp = function(e3, t3) {
        var i3, r3 = arguments.length > 2 ? arguments[2] : void 0, n3 = yp(jp, this);
        bp ? i3 = bp(new Qp(), n3 ? wp(this) : jp) : (i3 = n3 ? this : Op(jp), Dp(i3, xp, "Error")), void 0 !== t3 && Dp(i3, "message", Mp(t3)), Up && Dp(i3, "stack", Lp(i3.stack, 1)), kp(i3, r3);
        var o3 = [];
        return Bp(e3, Fp, { that: o3 }), Dp(i3, "errors", o3), i3;
      };
      bp ? bp(Vp, Qp) : Np(Vp, Qp, { name: true });
      var jp = Vp.prototype = Op(Qp.prototype, { constructor: Pp(1, Vp), message: Pp(1, ""), name: Pp(1, "AggregateError") });
      Tp({ global: true }, { AggregateError: Vp });
      var Gp = Nn, Kp = Yo, Hp = _n(Function.toString);
      Gp(Kp.inspectSource) || (Kp.inspectSource = function(e3) {
        return Hp(e3);
      });
      var Wp, Yp, Jp, qp = Kp.inspectSource, Xp = Nn, zp = qp, Zp = vn.WeakMap, $p = Xp(Zp) && /native code/.test(zp(Zp)), eg = vn, tg = _n, ig = no, rg = Sa, ng = es, og = Yo, sg = tA, ag = OA, cg = "Object already initialized", dg = eg.TypeError, ug = eg.WeakMap;
      if ($p || og.state) {
        var hg = og.state || (og.state = new ug()), Ag = tg(hg.get), lg = tg(hg.has), pg = tg(hg.set);
        Wp = function(e3, t3) {
          if (lg(hg, e3))
            throw new dg(cg);
          return t3.facade = e3, pg(hg, e3, t3), t3;
        }, Yp = function(e3) {
          return Ag(hg, e3) || {};
        }, Jp = function(e3) {
          return lg(hg, e3);
        };
      } else {
        var gg = sg("state");
        ag[gg] = true, Wp = function(e3, t3) {
          if (ng(e3, gg))
            throw new dg(cg);
          return t3.facade = e3, rg(e3, gg, t3), t3;
        }, Yp = function(e3) {
          return ng(e3, gg) ? e3[gg] : {};
        }, Jp = function(e3) {
          return ng(e3, gg);
        };
      }
      var Eg, fg, mg, Ig = { set: Wp, get: Yp, has: Jp, enforce: function(e3) {
        return Jp(e3) ? Yp(e3) : Wp(e3, {});
      }, getterFor: function(e3) {
        return function(t3) {
          var i3;
          if (!ig(t3) || (i3 = Yp(t3)).type !== e3)
            throw dg("Incompatible receiver, " + e3 + " required");
          return i3;
        };
      } }, _g = Dn, Cg = es, Sg = Function.prototype, vg = _g && Object.getOwnPropertyDescriptor, Tg = Cg(Sg, "name"), Rg = { EXISTS: Tg, PROPER: Tg && "something" === function() {
      }.name, CONFIGURABLE: Tg && (!_g || _g && vg(Sg, "name").configurable) }, yg = Sa, wg = function(e3, t3, i3, r3) {
        r3 && r3.enumerable ? e3[t3] = i3 : yg(e3, t3, i3);
      }, bg = ln, Ng = Nn, Og = _l, Dg = hA, Pg = wg, Lg = Es("iterator"), kg = false;
      [].keys && ("next" in (mg = [].keys()) ? (fg = Dg(Dg(mg))) !== Object.prototype && (Eg = fg) : kg = true);
      var Bg = null == Eg || bg(function() {
        var e3 = {};
        return Eg[Lg].call(e3) !== e3;
      });
      Ng((Eg = Bg ? {} : Og(Eg))[Lg]) || Pg(Eg, Lg, function() {
        return this;
      });
      var Mg = { IteratorPrototype: Eg, BUGGY_SAFARI_ITERATORS: kg }, Ug = Vl, xg = Ll ? {}.toString : function() {
        return "[object " + Ug(this) + "]";
      }, Qg = Ll, Fg = ia.f, Vg = Sa, jg = es, Gg = xg, Kg = Es("toStringTag"), Hg = function(e3, t3, i3, r3) {
        if (e3) {
          var n3 = i3 ? e3 : e3.prototype;
          jg(n3, Kg) || Fg(n3, Kg, { configurable: true, value: t3 }), r3 && !Qg && Vg(n3, "toString", Gg);
        }
      }, Wg = Mg.IteratorPrototype, Yg = _l, Jg = Vn, qg = Hg, Xg = wl, zg = function() {
        return this;
      }, Zg = function(e3, t3, i3, r3) {
        var n3 = t3 + " Iterator";
        return e3.prototype = Yg(Wg, { next: Jg(+!r3, i3) }), qg(e3, n3, false, true), Xg[n3] = zg, e3;
      }, $g = ka, eE = kn, tE = Zg, iE = hA, rE = Hg, nE = wg, oE = wl, sE = Rg.PROPER, aE = Mg.BUGGY_SAFARI_ITERATORS, cE = Es("iterator"), dE = "keys", uE = "values", hE = "entries", AE = function() {
        return this;
      }, lE = function(e3, t3, i3, r3, n3, o3, s3) {
        tE(i3, t3, r3);
        var a3, c3, d3, u3 = function(e4) {
          if (e4 === n3 && g3)
            return g3;
          if (!aE && e4 in l3)
            return l3[e4];
          switch (e4) {
            case dE:
            case uE:
            case hE:
              return function() {
                return new i3(this, e4);
              };
          }
          return function() {
            return new i3(this);
          };
        }, h3 = t3 + " Iterator", A3 = false, l3 = e3.prototype, p3 = l3[cE] || l3["@@iterator"] || n3 && l3[n3], g3 = !aE && p3 || u3(n3), E3 = "Array" == t3 && l3.entries || p3;
        if (E3 && (a3 = iE(E3.call(new e3()))) !== Object.prototype && a3.next && (rE(a3, h3, true, true), oE[h3] = AE), sE && n3 == uE && p3 && p3.name !== uE && (A3 = true, g3 = function() {
          return eE(p3, this);
        }), n3)
          if (c3 = { values: u3(uE), keys: o3 ? g3 : u3(dE), entries: u3(hE) }, s3)
            for (d3 in c3)
              (aE || A3 || !(d3 in l3)) && nE(l3, d3, c3[d3]);
          else
            $g({ target: t3, proto: true, forced: aE || A3 }, c3);
        return s3 && l3[cE] !== g3 && nE(l3, cE, g3, { name: n3 }), oE[t3] = g3, c3;
      }, pE = io, gE = wl, EE = Ig;
      ia.f;
      var fE = lE, mE = "Array Iterator", IE = EE.set, _E = EE.getterFor(mE);
      fE(Array, "Array", function(e3, t3) {
        IE(this, { type: mE, target: pE(e3), index: 0, kind: t3 });
      }, function() {
        var e3 = _E(this), t3 = e3.target, i3 = e3.kind, r3 = e3.index++;
        return !t3 || r3 >= t3.length ? (e3.target = void 0, { value: void 0, done: true }) : "keys" == i3 ? { value: r3, done: false } : "values" == i3 ? { value: t3[r3], done: false } : { value: [r3, t3[r3]], done: false };
      }, "values"), gE.Arguments = gE.Array;
      var CE = vn.Promise, SE = wg, vE = function(e3, t3, i3) {
        for (var r3 in t3)
          i3 && i3.unsafe && e3[r3] ? e3[r3] = t3[r3] : SE(e3, r3, t3[r3], i3);
        return e3;
      }, TE = ho, RE = ia, yE = Dn, wE = Es("species"), bE = Cn, NE = vn.TypeError, OE = function(e3, t3) {
        if (bE(t3, e3))
          return e3;
        throw NE("Incorrect invocation");
      }, DE = Es("iterator"), PE = false;
      try {
        var LE = 0, kE = { next: function() {
          return { done: !!LE++ };
        }, return: function() {
          PE = true;
        } };
        kE[DE] = function() {
          return this;
        }, Array.from(kE, function() {
          throw 2;
        });
      } catch (e3) {
      }
      var BE = _n, ME = ln, UE = Nn, xE = Vl, QE = qp, FE = function() {
      }, VE = [], jE = ho("Reflect", "construct"), GE = /^\s*(?:class|function)\b/, KE = BE(GE.exec), HE = !GE.exec(FE), WE = function(e3) {
        if (!UE(e3))
          return false;
        try {
          return jE(FE, VE, e3), true;
        } catch (e4) {
          return false;
        }
      }, YE = function(e3) {
        if (!UE(e3))
          return false;
        switch (xE(e3)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return HE || !!KE(GE, QE(e3));
        } catch (e4) {
          return true;
        }
      };
      YE.sham = true;
      var JE, qE, XE, zE, ZE = !jE || ME(function() {
        var e3;
        return WE(WE.call) || !WE(Object) || !WE(function() {
          e3 = true;
        }) || e3;
      }) ? YE : WE, $E = ZE, ef = Do, tf = vn.TypeError, rf = ca, nf = function(e3) {
        if ($E(e3))
          return e3;
        throw tf(ef(e3) + " is not a constructor");
      }, of = Es("species"), sf = function(e3, t3) {
        var i3, r3 = rf(e3).constructor;
        return void 0 === r3 || null == (i3 = rf(r3)[of]) ? t3 : nf(i3);
      }, af = _n([].slice), cf = /(?:ipad|iphone|ipod).*applewebkit/i.test(Ao), df = vn, uf = bn, hf = ta, Af = Nn, lf = es, pf = ln, gf = cl, Ef = af, ff = Ds, mf = cf, If = za, _f = df.setImmediate, Cf = df.clearImmediate, Sf = df.process, vf = df.Dispatch, Tf = df.Function, Rf = df.MessageChannel, yf = df.String, wf = 0, bf = {}, Nf = "onreadystatechange";
      try {
        JE = df.location;
      } catch (e3) {
      }
      var Of = function(e3) {
        if (lf(bf, e3)) {
          var t3 = bf[e3];
          delete bf[e3], t3();
        }
      }, Df = function(e3) {
        return function() {
          Of(e3);
        };
      }, Pf = function(e3) {
        Of(e3.data);
      }, Lf = function(e3) {
        df.postMessage(yf(e3), JE.protocol + "//" + JE.host);
      };
      _f && Cf || (_f = function(e3) {
        var t3 = Ef(arguments, 1);
        return bf[++wf] = function() {
          uf(Af(e3) ? e3 : Tf(e3), void 0, t3);
        }, qE(wf), wf;
      }, Cf = function(e3) {
        delete bf[e3];
      }, If ? qE = function(e3) {
        Sf.nextTick(Df(e3));
      } : vf && vf.now ? qE = function(e3) {
        vf.now(Df(e3));
      } : Rf && !mf ? (zE = (XE = new Rf()).port2, XE.port1.onmessage = Pf, qE = hf(zE.postMessage, zE)) : df.addEventListener && Af(df.postMessage) && !df.importScripts && JE && "file:" !== JE.protocol && !pf(Lf) ? (qE = Lf, df.addEventListener("message", Pf, false)) : qE = Nf in ff("script") ? function(e3) {
        gf.appendChild(ff("script")).onreadystatechange = function() {
          gf.removeChild(this), Of(e3);
        };
      } : function(e3) {
        setTimeout(Df(e3), 0);
      });
      var kf, Bf, Mf, Uf, xf, Qf, Ff, Vf, jf = { set: _f, clear: Cf }, Gf = vn, Kf = /ipad|iphone|ipod/i.test(Ao) && void 0 !== Gf.Pebble, Hf = /web0s(?!.*chrome)/i.test(Ao), Wf = vn, Yf = ta, Jf = On.f, qf = jf.set, Xf = cf, zf = Kf, Zf = Hf, $f = za, em = Wf.MutationObserver || Wf.WebKitMutationObserver, tm = Wf.document, im = Wf.process, rm = Wf.Promise, nm = Jf(Wf, "queueMicrotask"), om = nm && nm.value;
      om || (kf = function() {
        var e3, t3;
        for ($f && (e3 = im.domain) && e3.exit(); Bf; ) {
          t3 = Bf.fn, Bf = Bf.next;
          try {
            t3();
          } catch (e4) {
            throw Bf ? Uf() : Mf = void 0, e4;
          }
        }
        Mf = void 0, e3 && e3.enter();
      }, Xf || $f || Zf || !em || !tm ? !zf && rm && rm.resolve ? ((Ff = rm.resolve(void 0)).constructor = rm, Vf = Yf(Ff.then, Ff), Uf = function() {
        Vf(kf);
      }) : $f ? Uf = function() {
        im.nextTick(kf);
      } : (qf = Yf(qf, Wf), Uf = function() {
        qf(kf);
      }) : (xf = true, Qf = tm.createTextNode(""), new em(kf).observe(Qf, { characterData: true }), Uf = function() {
        Qf.data = xf = !xf;
      }));
      var sm = om || function(e3) {
        var t3 = { fn: e3, next: void 0 };
        Mf && (Mf.next = t3), Bf || (Bf = t3, Uf()), Mf = t3;
      }, am = {}, cm = Bo, dm = function(e3) {
        var t3, i3;
        this.promise = new e3(function(e4, r3) {
          if (void 0 !== t3 || void 0 !== i3)
            throw TypeError("Bad Promise constructor");
          t3 = e4, i3 = r3;
        }), this.resolve = cm(t3), this.reject = cm(i3);
      };
      am.f = function(e3) {
        return new dm(e3);
      };
      var um = ca, hm = no, Am = am, lm = function(e3, t3) {
        if (um(e3), hm(t3) && t3.constructor === e3)
          return t3;
        var i3 = Am.f(e3);
        return (0, i3.resolve)(t3), i3.promise;
      }, pm = vn, gm = function(e3) {
        try {
          return { error: false, value: e3() };
        } catch (e4) {
          return { error: true, value: e4 };
        }
      }, Em = function() {
        this.head = null, this.tail = null;
      };
      Em.prototype = { add: function(e3) {
        var t3 = { item: e3, next: null };
        this.head ? this.tail.next = t3 : this.head = t3, this.tail = t3;
      }, get: function() {
        var e3 = this.head;
        if (e3)
          return this.head = e3.next, this.tail === e3 && (this.tail = null), e3.item;
      } };
      var fm, mm, Im, _m = "object" == typeof window, Cm = ka, Sm = vn, vm = ho, Tm = kn, Rm = CE, ym = vE, wm = Hg, bm = function(e3) {
        var t3 = TE(e3), i3 = RE.f;
        yE && t3 && !t3[wE] && i3(t3, wE, { configurable: true, get: function() {
          return this;
        } });
      }, Nm = Bo, Om = Nn, Dm = no, Pm = OE, Lm = qp, km = fp, Bm = function(e3, t3) {
        if (!t3 && !PE)
          return false;
        var i3 = false;
        try {
          var r3 = {};
          r3[DE] = function() {
            return { next: function() {
              return { done: i3 = true };
            } };
          }, e3(r3);
        } catch (e4) {
        }
        return i3;
      }, Mm = sf, Um = jf.set, xm = sm, Qm = lm, Fm = function(e3, t3) {
        var i3 = pm.console;
        i3 && i3.error && (1 == arguments.length ? i3.error(e3) : i3.error(e3, t3));
      }, Vm = am, jm = gm, Gm = Em, Km = Ig, Hm = zs, Wm = _m, Ym = za, Jm = Io, qm = Es("species"), Xm = "Promise", zm = Km.getterFor(Xm), Zm = Km.set, $m = Km.getterFor(Xm), eI = Rm && Rm.prototype, tI = Rm, iI = eI, rI = Sm.TypeError, nI = Sm.document, oI = Sm.process, sI = Vm.f, aI = sI, cI = !!(nI && nI.createEvent && Sm.dispatchEvent), dI = Om(Sm.PromiseRejectionEvent), uI = "unhandledrejection", hI = Hm(Xm, function() {
        var e3 = Lm(tI), t3 = e3 !== String(tI);
        if (!t3 && 66 === Jm)
          return true;
        if (!iI.finally)
          return true;
        if (Jm >= 51 && /native code/.test(e3))
          return false;
        var i3 = new tI(function(e4) {
          e4(1);
        }), r3 = function(e4) {
          e4(function() {
          }, function() {
          });
        };
        return (i3.constructor = {})[qm] = r3, !(i3.then(function() {
        }) instanceof r3) || !t3 && Wm && !dI;
      }), AI = hI || !Bm(function(e3) {
        tI.all(e3).catch(function() {
        });
      }), lI = function(e3) {
        var t3;
        return !(!Dm(e3) || !Om(t3 = e3.then)) && t3;
      }, pI = function(e3, t3) {
        var i3, r3, n3, o3 = t3.value, s3 = 1 == t3.state, a3 = s3 ? e3.ok : e3.fail, c3 = e3.resolve, d3 = e3.reject, u3 = e3.domain;
        try {
          a3 ? (s3 || (2 === t3.rejection && II(t3), t3.rejection = 1), true === a3 ? i3 = o3 : (u3 && u3.enter(), i3 = a3(o3), u3 && (u3.exit(), n3 = true)), i3 === e3.promise ? d3(rI("Promise-chain cycle")) : (r3 = lI(i3)) ? Tm(r3, i3, c3, d3) : c3(i3)) : d3(o3);
        } catch (e4) {
          u3 && !n3 && u3.exit(), d3(e4);
        }
      }, gI = function(e3, t3) {
        e3.notified || (e3.notified = true, xm(function() {
          for (var i3, r3 = e3.reactions; i3 = r3.get(); )
            pI(i3, e3);
          e3.notified = false, t3 && !e3.rejection && fI(e3);
        }));
      }, EI = function(e3, t3, i3) {
        var r3, n3;
        cI ? ((r3 = nI.createEvent("Event")).promise = t3, r3.reason = i3, r3.initEvent(e3, false, true), Sm.dispatchEvent(r3)) : r3 = { promise: t3, reason: i3 }, !dI && (n3 = Sm["on" + e3]) ? n3(r3) : e3 === uI && Fm("Unhandled promise rejection", i3);
      }, fI = function(e3) {
        Tm(Um, Sm, function() {
          var t3, i3 = e3.facade, r3 = e3.value;
          if (mI(e3) && (t3 = jm(function() {
            Ym ? oI.emit("unhandledRejection", r3, i3) : EI(uI, i3, r3);
          }), e3.rejection = Ym || mI(e3) ? 2 : 1, t3.error))
            throw t3.value;
        });
      }, mI = function(e3) {
        return 1 !== e3.rejection && !e3.parent;
      }, II = function(e3) {
        Tm(Um, Sm, function() {
          var t3 = e3.facade;
          Ym ? oI.emit("rejectionHandled", t3) : EI("rejectionhandled", t3, e3.value);
        });
      }, _I = function(e3, t3, i3) {
        return function(r3) {
          e3(t3, r3, i3);
        };
      }, CI = function(e3, t3, i3) {
        e3.done || (e3.done = true, i3 && (e3 = i3), e3.value = t3, e3.state = 2, gI(e3, true));
      }, SI = function(e3, t3, i3) {
        if (!e3.done) {
          e3.done = true, i3 && (e3 = i3);
          try {
            if (e3.facade === t3)
              throw rI("Promise can't be resolved itself");
            var r3 = lI(t3);
            r3 ? xm(function() {
              var i4 = { done: false };
              try {
                Tm(r3, t3, _I(SI, i4, e3), _I(CI, i4, e3));
              } catch (t4) {
                CI(i4, t4, e3);
              }
            }) : (e3.value = t3, e3.state = 1, gI(e3, false));
          } catch (t4) {
            CI({ done: false }, t4, e3);
          }
        }
      };
      hI && (iI = (tI = function(e3) {
        Pm(this, iI), Nm(e3), Tm(fm, this);
        var t3 = zm(this);
        try {
          e3(_I(SI, t3), _I(CI, t3));
        } catch (e4) {
          CI(t3, e4);
        }
      }).prototype, (fm = function(e3) {
        Zm(this, { type: Xm, done: false, notified: false, parent: false, reactions: new Gm(), rejection: false, state: 0, value: void 0 });
      }).prototype = ym(iI, { then: function(e3, t3) {
        var i3 = $m(this), r3 = sI(Mm(this, tI));
        return i3.parent = true, r3.ok = !Om(e3) || e3, r3.fail = Om(t3) && t3, r3.domain = Ym ? oI.domain : void 0, 0 == i3.state ? i3.reactions.add(r3) : xm(function() {
          pI(r3, i3);
        }), r3.promise;
      }, catch: function(e3) {
        return this.then(void 0, e3);
      } }), mm = function() {
        var e3 = new fm(), t3 = zm(e3);
        this.promise = e3, this.resolve = _I(SI, t3), this.reject = _I(CI, t3);
      }, Vm.f = sI = function(e3) {
        return e3 === tI || e3 === Im ? new mm(e3) : aI(e3);
      }), Cm({ global: true, wrap: true, forced: hI }, { Promise: tI }), wm(tI, Xm, false, true), bm(Xm), Im = vm(Xm), Cm({ target: Xm, stat: true, forced: hI }, { reject: function(e3) {
        var t3 = sI(this);
        return Tm(t3.reject, void 0, e3), t3.promise;
      } }), Cm({ target: Xm, stat: true, forced: true }, { resolve: function(e3) {
        return Qm(this === Im ? tI : this, e3);
      } }), Cm({ target: Xm, stat: true, forced: AI }, { all: function(e3) {
        var t3 = this, i3 = sI(t3), r3 = i3.resolve, n3 = i3.reject, o3 = jm(function() {
          var i4 = Nm(t3.resolve), o4 = [], s3 = 0, a3 = 1;
          km(e3, function(e4) {
            var c3 = s3++, d3 = false;
            a3++, Tm(i4, t3, e4).then(function(e5) {
              d3 || (d3 = true, o4[c3] = e5, --a3 || r3(o4));
            }, n3);
          }), --a3 || r3(o4);
        });
        return o3.error && n3(o3.value), i3.promise;
      }, race: function(e3) {
        var t3 = this, i3 = sI(t3), r3 = i3.reject, n3 = jm(function() {
          var n4 = Nm(t3.resolve);
          km(e3, function(e4) {
            Tm(n4, t3, e4).then(i3.resolve, r3);
          });
        });
        return n3.error && r3(n3.value), i3.promise;
      } });
      var vI = kn, TI = Bo, RI = am, yI = gm, wI = fp;
      ka({ target: "Promise", stat: true }, { allSettled: function(e3) {
        var t3 = this, i3 = RI.f(t3), r3 = i3.resolve, n3 = i3.reject, o3 = yI(function() {
          var i4 = TI(t3.resolve), n4 = [], o4 = 0, s3 = 1;
          wI(e3, function(e4) {
            var a3 = o4++, c3 = false;
            s3++, vI(i4, t3, e4).then(function(e5) {
              c3 || (c3 = true, n4[a3] = { status: "fulfilled", value: e5 }, --s3 || r3(n4));
            }, function(e5) {
              c3 || (c3 = true, n4[a3] = { status: "rejected", reason: e5 }, --s3 || r3(n4));
            });
          }), --s3 || r3(n4);
        });
        return o3.error && n3(o3.value), i3.promise;
      } });
      var bI = Bo, NI = ho, OI = kn, DI = am, PI = gm, LI = fp, kI = "No one promise resolved";
      ka({ target: "Promise", stat: true }, { any: function(e3) {
        var t3 = this, i3 = NI("AggregateError"), r3 = DI.f(t3), n3 = r3.resolve, o3 = r3.reject, s3 = PI(function() {
          var r4 = bI(t3.resolve), s4 = [], a3 = 0, c3 = 1, d3 = false;
          LI(e3, function(e4) {
            var u3 = a3++, h3 = false;
            c3++, OI(r4, t3, e4).then(function(e5) {
              h3 || d3 || (d3 = true, n3(e5));
            }, function(e5) {
              h3 || d3 || (h3 = true, s4[u3] = e5, --c3 || o3(new i3(s4, kI)));
            });
          }), --c3 || o3(new i3(s4, kI));
        });
        return s3.error && o3(s3.value), r3.promise;
      } });
      var BI = CE, MI = ho, UI = Nn, xI = sf, QI = lm;
      ka({ target: "Promise", proto: true, real: true, forced: !!BI && ln(function() {
        BI.prototype.finally.call({ then: function() {
        } }, function() {
        });
      }) }, { finally: function(e3) {
        var t3 = xI(this, MI("Promise")), i3 = UI(e3);
        return this.then(i3 ? function(i4) {
          return QI(t3, e3()).then(function() {
            return i4;
          });
        } : e3, i3 ? function(i4) {
          return QI(t3, e3()).then(function() {
            throw i4;
          });
        } : e3);
      } });
      var FI = _n, VI = Ua, jI = _p, GI = $n, KI = FI("".charAt), HI = FI("".charCodeAt), WI = FI("".slice), YI = function(e3) {
        return function(t3, i3) {
          var r3, n3, o3 = jI(GI(t3)), s3 = VI(i3), a3 = o3.length;
          return s3 < 0 || s3 >= a3 ? e3 ? "" : void 0 : (r3 = HI(o3, s3)) < 55296 || r3 > 56319 || s3 + 1 === a3 || (n3 = HI(o3, s3 + 1)) < 56320 || n3 > 57343 ? e3 ? KI(o3, s3) : r3 : e3 ? WI(o3, s3, s3 + 2) : n3 - 56320 + (r3 - 55296 << 10) + 65536;
        };
      }, JI = { codeAt: YI(false), charAt: YI(true) }, qI = JI.charAt, XI = _p, zI = Ig, ZI = lE, $I = "String Iterator", e_ = zI.set, t_ = zI.getterFor($I);
      ZI(String, "String", function(e3) {
        e_(this, { type: $I, string: XI(e3), index: 0 });
      }, function() {
        var e3, t3 = t_(this), i3 = t3.string, r3 = t3.index;
        return r3 >= i3.length ? { value: void 0, done: true } : (e3 = qI(i3, r3), t3.index += e3.length, { value: e3, done: false });
      });
      var i_ = oo.Promise, r_ = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, n_ = vn, o_ = Vl, s_ = Sa, a_ = wl, c_ = Es("toStringTag");
      for (var d_ in r_) {
        var u_ = n_[d_], h_ = u_ && u_.prototype;
        h_ && o_(h_) !== c_ && s_(h_, c_, d_), a_[d_] = a_.Array;
      }
      var A_ = i_, l_ = A_, p_ = "process" == y(i.process), g_ = p_, E_ = H, f_ = i.TypeError, m_ = function(e3, t3) {
        if (E_(t3, e3))
          return e3;
        throw f_("Incorrect invocation");
      }, I_ = o, __ = n, C_ = Ot, S_ = zc, v_ = hh, T_ = Error.prototype.toString, R_ = __(function() {
        if (I_) {
          var e3 = S_(Object.defineProperty({}, "name", { get: function() {
            return this === e3;
          } }));
          if ("true" !== T_.call(e3))
            return true;
        }
        return "2: 1" !== T_.call({ message: 1, name: 2 }) || "Error" !== T_.call({});
      }) ? function() {
        var e3 = C_(this), t3 = v_(e3.name, "Error"), i3 = v_(e3.message);
        return t3 ? i3 ? t3 + ": " + i3 : t3 : i3;
      } : T_, y_ = { IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 }, DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 }, HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 }, WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 }, InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 }, NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 }, NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 }, NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 }, NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 }, InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 }, InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 }, SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 }, InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 }, NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 }, InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 }, ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 }, TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 }, SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 }, NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 }, AbortError: { s: "ABORT_ERR", c: 20, m: 1 }, URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 }, QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 }, TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 }, InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 }, DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 } }, w_ = Gr, b_ = function(e3) {
        try {
          if (g_)
            return Function('return require("' + e3 + '")')();
        } catch (e4) {
        }
      }, N_ = K, O_ = n, D_ = zc, P_ = E, L_ = Tt.f, k_ = bc.f, B_ = Ht.exports, M_ = Be, U_ = m_, x_ = Ot, Q_ = R_, F_ = hh, V_ = y_, j_ = mh, G_ = Ri, K_ = o, H_ = "DOMException", W_ = "DATA_CLONE_ERR", Y_ = N_("Error"), J_ = N_(H_) || function() {
        try {
          new (N_("MessageChannel") || b_("worker_threads").MessageChannel)().port1.postMessage(/* @__PURE__ */ new WeakMap());
        } catch (e3) {
          if (e3.name == W_ && 25 == e3.code)
            return e3.constructor;
        }
      }(), q_ = J_ && J_.prototype, X_ = Y_.prototype, z_ = G_.set, Z_ = G_.getterFor(H_), $_ = "stack" in Y_(H_), eC = function(e3) {
        return M_(V_, e3) && V_[e3].m ? V_[e3].c : 0;
      }, tC = function() {
        U_(this, iC);
        var e3 = arguments.length, t3 = F_(e3 < 1 ? void 0 : arguments[0]), i3 = F_(e3 < 2 ? void 0 : arguments[1], "Error"), r3 = eC(i3);
        if (z_(this, { type: H_, name: i3, message: t3, code: r3 }), K_ || (this.name = i3, this.message = t3, this.code = r3), $_) {
          var n3 = Y_(t3);
          n3.name = H_, L_(this, "stack", P_(1, j_(n3.stack, 1)));
        }
      }, iC = tC.prototype = D_(X_), rC = function(e3) {
        return { enumerable: true, configurable: true, get: e3 };
      }, nC = function(e3) {
        return rC(function() {
          return Z_(this)[e3];
        });
      };
      K_ && k_(iC, { name: nC("name"), message: nC("message"), code: nC("code") }), L_(iC, "constructor", P_(1, tC));
      var oC = O_(function() {
        return !(new J_() instanceof Y_);
      }), sC = oC || O_(function() {
        return X_.toString !== Q_ || "2: 1" !== String(new J_(1, 2));
      }), aC = oC || O_(function() {
        return 25 !== new J_(1, "DataCloneError").code;
      });
      oC || 25 !== J_.DATA_CLONE_ERR || q_.DATA_CLONE_ERR;
      w_({ global: true, forced: oC }, { DOMException: oC ? tC : J_ });
      var cC = N_(H_), dC = cC.prototype;
      for (var uC in sC && J_ === cC && B_(dC, "toString", Q_), aC && K_ && J_ === cC && L_(dC, "code", rC(function() {
        return eC(x_(this).name);
      })), V_)
        if (M_(V_, uC)) {
          var hC = V_[uC], AC = hC.s, lC = P_(6, hC.c);
          M_(cC, AC) || L_(cC, AC, lC), M_(dC, AC) || L_(dC, AC, lC);
        }
      var pC = Gr, gC = K, EC = E, fC = Tt.f, mC = Be, IC = m_, _C = dh, CC = hh, SC = y_, vC = mh, TC = "DOMException", RC = gC("Error"), yC = gC(TC), wC = function() {
        IC(this, bC);
        var e3 = arguments.length, t3 = CC(e3 < 1 ? void 0 : arguments[0]), i3 = CC(e3 < 2 ? void 0 : arguments[1], "Error"), r3 = new yC(t3, i3), n3 = RC(t3);
        return n3.name = TC, fC(r3, "stack", EC(1, vC(n3.stack, 1))), _C(r3, this, wC), r3;
      }, bC = wC.prototype = yC.prototype, NC = "stack" in RC(TC), OC = "stack" in new yC(1, 2), DC = NC && !OC;
      pC({ global: true, forced: DC }, { DOMException: DC ? wC : yC });
      var PC = gC(TC), LC = PC.prototype;
      if (LC.constructor !== PC) {
        for (var kC in fC(LC, "constructor", EC(1, PC)), SC)
          if (mC(SC, kC)) {
            var BC = SC[kC], MC = BC.s;
            mC(PC, MC) || fC(PC, MC, EC(6, BC.c));
          }
      }
      var UC = "DOMException";
      $d(K(UC), UC);
      var xC = S, QC = Ht.exports, FC = Td, VC = n, jC = ze, GC = Kt, KC = jC("species"), HC = RegExp.prototype, WC = S, YC = Hi, JC = _c, qC = k, XC = WC("".charAt), zC = WC("".charCodeAt), ZC = WC("".slice), $C = function(e3) {
        return function(t3, i3) {
          var r3, n3, o3 = JC(qC(t3)), s3 = YC(i3), a3 = o3.length;
          return s3 < 0 || s3 >= a3 ? e3 ? "" : void 0 : (r3 = zC(o3, s3)) < 55296 || r3 > 56319 || s3 + 1 === a3 || (n3 = zC(o3, s3 + 1)) < 56320 || n3 > 57343 ? e3 ? XC(o3, s3) : r3 : e3 ? ZC(o3, s3, s3 + 2) : n3 - 56320 + (r3 - 55296 << 10) + 65536;
        };
      }, eS = { codeAt: $C(false), charAt: $C(true) }.charAt, tS = S, iS = Pe, rS = Math.floor, nS = tS("".charAt), oS = tS("".replace), sS = tS("".slice), aS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, cS = /\$([$&'`]|\d{1,2})/g, dS = d, uS = Ot, hS = x, AS = y, lS = Td, pS = i.TypeError, gS = Jr, ES = d, fS = S, mS = function(e3, t3, i3, r3) {
        var n3 = jC(e3), o3 = !VC(function() {
          var t4 = {};
          return t4[n3] = function() {
            return 7;
          }, 7 != ""[e3](t4);
        }), s3 = o3 && !VC(function() {
          var t4 = false, i4 = /a/;
          return "split" === e3 && ((i4 = {}).constructor = {}, i4.constructor[KC] = function() {
            return i4;
          }, i4.flags = "", i4[n3] = /./[n3]), i4.exec = function() {
            return t4 = true, null;
          }, i4[n3](""), !t4;
        });
        if (!o3 || !s3 || i3) {
          var a3 = xC(/./[n3]), c3 = t3(n3, ""[e3], function(e4, t4, i4, r4, n4) {
            var s4 = xC(e4), c4 = t4.exec;
            return c4 === FC || c4 === HC.exec ? o3 && !n4 ? { done: true, value: a3(t4, i4, r4) } : { done: true, value: s4(i4, t4, r4) } : { done: false };
          });
          QC(String.prototype, e3, c3[0]), QC(HC, n3, c3[1]);
        }
        r3 && GC(HC[n3], "sham", true);
      }, IS = n, _S = Ot, CS = x, SS = Hi, vS = Zi, TS = _c, RS = k, yS = function(e3, t3, i3) {
        return t3 + (i3 ? eS(e3, t3).length : 1);
      }, wS = fe, bS = function(e3, t3, i3, r3, n3, o3) {
        var s3 = i3 + e3.length, a3 = r3.length, c3 = cS;
        return void 0 !== n3 && (n3 = iS(n3), c3 = aS), oS(o3, c3, function(o4, c4) {
          var d3;
          switch (nS(c4, 0)) {
            case "$":
              return "$";
            case "&":
              return e3;
            case "`":
              return sS(t3, 0, i3);
            case "'":
              return sS(t3, s3);
            case "<":
              d3 = n3[sS(c4, 1, -1)];
              break;
            default:
              var u3 = +c4;
              if (0 === u3)
                return o4;
              if (u3 > a3) {
                var h3 = rS(u3 / 10);
                return 0 === h3 ? o4 : h3 <= a3 ? void 0 === r3[h3 - 1] ? nS(c4, 1) : r3[h3 - 1] + nS(c4, 1) : o4;
              }
              d3 = r3[u3 - 1];
          }
          return void 0 === d3 ? "" : d3;
        });
      }, NS = function(e3, t3) {
        var i3 = e3.exec;
        if (hS(i3)) {
          var r3 = dS(i3, e3, t3);
          return null !== r3 && uS(r3), r3;
        }
        if ("RegExp" === AS(e3))
          return dS(lS, e3, t3);
        throw pS("RegExp#exec called on incompatible receiver");
      }, OS = ze("replace"), DS = Math.max, PS = Math.min, LS = fS([].concat), kS = fS([].push), BS = fS("".indexOf), MS = fS("".slice), US = "$0" === "a".replace(/./, "$0"), xS = !!/./[OS] && "" === /./[OS]("a", "$0");
      mS("replace", function(e3, t3, i3) {
        var r3 = xS ? "$" : "$0";
        return [function(e4, i4) {
          var r4 = RS(this), n3 = null == e4 ? void 0 : wS(e4, OS);
          return n3 ? ES(n3, e4, r4, i4) : ES(t3, TS(r4), e4, i4);
        }, function(e4, n3) {
          var o3 = _S(this), s3 = TS(e4);
          if ("string" == typeof n3 && -1 === BS(n3, r3) && -1 === BS(n3, "$<")) {
            var a3 = i3(t3, o3, s3, n3);
            if (a3.done)
              return a3.value;
          }
          var c3 = CS(n3);
          c3 || (n3 = TS(n3));
          var d3 = o3.global;
          if (d3) {
            var u3 = o3.unicode;
            o3.lastIndex = 0;
          }
          for (var h3 = []; ; ) {
            var A3 = NS(o3, s3);
            if (null === A3)
              break;
            if (kS(h3, A3), !d3)
              break;
            "" === TS(A3[0]) && (o3.lastIndex = yS(s3, vS(o3.lastIndex), u3));
          }
          for (var l3, p3 = "", g3 = 0, E3 = 0; E3 < h3.length; E3++) {
            for (var f3 = TS((A3 = h3[E3])[0]), m3 = DS(PS(SS(A3.index), s3.length), 0), I3 = [], _3 = 1; _3 < A3.length; _3++)
              kS(I3, void 0 === (l3 = A3[_3]) ? l3 : String(l3));
            var C3 = A3.groups;
            if (c3) {
              var S3 = LS([f3], I3, m3, s3);
              void 0 !== C3 && kS(S3, C3);
              var v3 = TS(gS(n3, void 0, S3));
            } else
              v3 = bS(f3, s3, m3, I3, C3, n3);
            m3 >= g3 && (p3 += MS(s3, g3, m3) + v3, g3 = m3 + f3.length);
          }
          return p3 + MS(s3, g3);
        }];
      }, !!IS(function() {
        var e3 = /./;
        return e3.exec = function() {
          var e4 = [];
          return e4.groups = { a: "7" }, e4;
        }, "7" !== "".replace(e3, "$<a>");
      }) || !US || xS);
      var QS = F, FS = y, VS = ze("match"), jS = K, GS = Tt, KS = o, HS = ze("species"), WS = function(e3) {
        var t3 = jS(e3), i3 = GS.f;
        KS && t3 && !t3[HS] && i3(t3, HS, { configurable: true, get: function() {
          return this;
        } });
      }, YS = o, JS = i, qS = S, XS = Br, zS = dh, ZS = Kt, $S = Tt.f, ev = ji.f, tv = H, iv = function(e3) {
        var t3;
        return QS(e3) && (void 0 !== (t3 = e3[VS]) ? !!t3 : "RegExp" == FS(e3));
      }, rv = _c, nv = Sc, ov = wc, sv = Ht.exports, av = n, cv = Be, dv = Ri.enforce, uv = WS, hv = ed, Av = rd, lv = ze("match"), pv = JS.RegExp, gv = pv.prototype, Ev = JS.SyntaxError, fv = qS(nv), mv = qS(gv.exec), Iv = qS("".charAt), _v = qS("".replace), Cv = qS("".indexOf), Sv = qS("".slice), vv = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/, Tv = /a/g, Rv = /a/g, yv = new pv(Tv) !== Tv, wv = ov.MISSED_STICKY, bv = ov.UNSUPPORTED_Y, Nv = YS && (!yv || wv || hv || Av || av(function() {
        return Rv[lv] = false, pv(Tv) != Tv || pv(Rv) == Rv || "/a/i" != pv(Tv, "i");
      }));
      if (XS("RegExp", Nv)) {
        for (var Ov = function(e3, t3) {
          var i3, r3, n3, o3, s3, a3, c3 = tv(gv, this), d3 = iv(e3), u3 = void 0 === t3, h3 = [], A3 = e3;
          if (!c3 && d3 && u3 && e3.constructor === Ov)
            return e3;
          if ((d3 || tv(gv, e3)) && (e3 = e3.source, u3 && (t3 = "flags" in A3 ? A3.flags : fv(A3))), e3 = void 0 === e3 ? "" : rv(e3), t3 = void 0 === t3 ? "" : rv(t3), A3 = e3, hv && "dotAll" in Tv && (r3 = !!t3 && Cv(t3, "s") > -1) && (t3 = _v(t3, /s/g, "")), i3 = t3, wv && "sticky" in Tv && (n3 = !!t3 && Cv(t3, "y") > -1) && bv && (t3 = _v(t3, /y/g, "")), Av && (e3 = (o3 = function(e4) {
            for (var t4, i4 = e4.length, r4 = 0, n4 = "", o4 = [], s4 = {}, a4 = false, c4 = false, d4 = 0, u4 = ""; r4 <= i4; r4++) {
              if ("\\" === (t4 = Iv(e4, r4)))
                t4 += Iv(e4, ++r4);
              else if ("]" === t4)
                a4 = false;
              else if (!a4)
                switch (true) {
                  case "[" === t4:
                    a4 = true;
                    break;
                  case "(" === t4:
                    mv(vv, Sv(e4, r4 + 1)) && (r4 += 2, c4 = true), n4 += t4, d4++;
                    continue;
                  case (">" === t4 && c4):
                    if ("" === u4 || cv(s4, u4))
                      throw new Ev("Invalid capture group name");
                    s4[u4] = true, o4[o4.length] = [u4, d4], c4 = false, u4 = "";
                    continue;
                }
              c4 ? u4 += t4 : n4 += t4;
            }
            return [n4, o4];
          }(e3))[0], h3 = o3[1]), s3 = zS(pv(e3, t3), c3 ? this : gv, Ov), (r3 || n3 || h3.length) && (a3 = dv(s3), r3 && (a3.dotAll = true, a3.raw = Ov(function(e4) {
            for (var t4, i4 = e4.length, r4 = 0, n4 = "", o4 = false; r4 <= i4; r4++)
              "\\" !== (t4 = Iv(e4, r4)) ? o4 || "." !== t4 ? ("[" === t4 ? o4 = true : "]" === t4 && (o4 = false), n4 += t4) : n4 += "[\\s\\S]" : n4 += t4 + Iv(e4, ++r4);
            return n4;
          }(e3), i3)), n3 && (a3.sticky = true), h3.length && (a3.groups = h3)), e3 !== A3)
            try {
              ZS(s3, "source", "" === A3 ? "(?:)" : A3);
            } catch (e4) {
            }
          return s3;
        }, Dv = function(e3) {
          e3 in Ov || $S(Ov, e3, { configurable: true, get: function() {
            return pv[e3];
          }, set: function(t3) {
            pv[e3] = t3;
          } });
        }, Pv = ev(pv), Lv = 0; Pv.length > Lv; )
          Dv(Pv[Lv++]);
        gv.constructor = Ov, Ov.prototype = gv, sv(JS, "RegExp", Ov);
      }
      uv("RegExp");
      var kv = i, Bv = o, Mv = ed, Uv = y, xv = Tt.f, Qv = Ri.get, Fv = RegExp.prototype, Vv = kv.TypeError;
      Bv && Mv && xv(Fv, "dotAll", { configurable: true, get: function() {
        if (this !== Fv) {
          if ("RegExp" === Uv(this))
            return !!Qv(this).dotAll;
          throw Vv("Incompatible receiver, RegExp required");
        }
      } });
      const jv = Wh;
      function Gv(e3, t3) {
        const i3 = e3 && e3.navigator;
        if (!i3.mediaDevices)
          return;
        const r3 = function(e4) {
          if ("object" != typeof e4 || e4.mandatory || e4.optional)
            return e4;
          const t4 = {};
          return Object.keys(e4).forEach((i4) => {
            if ("require" === i4 || "advanced" === i4 || "mediaSource" === i4)
              return;
            const r4 = "object" == typeof e4[i4] ? e4[i4] : { ideal: e4[i4] };
            void 0 !== r4.exact && "number" == typeof r4.exact && (r4.min = r4.max = r4.exact);
            const n4 = function(e5, t5) {
              return e5 ? e5 + t5.charAt(0).toUpperCase() + t5.slice(1) : "deviceId" === t5 ? "sourceId" : t5;
            };
            if (void 0 !== r4.ideal) {
              t4.optional = t4.optional || [];
              let e5 = {};
              "number" == typeof r4.ideal ? (e5[n4("min", i4)] = r4.ideal, t4.optional.push(e5), e5 = {}, e5[n4("max", i4)] = r4.ideal, t4.optional.push(e5)) : (e5[n4("", i4)] = r4.ideal, t4.optional.push(e5));
            }
            void 0 !== r4.exact && "number" != typeof r4.exact ? (t4.mandatory = t4.mandatory || {}, t4.mandatory[n4("", i4)] = r4.exact) : ["min", "max"].forEach((e5) => {
              void 0 !== r4[e5] && (t4.mandatory = t4.mandatory || {}, t4.mandatory[n4(e5, i4)] = r4[e5]);
            });
          }), e4.advanced && (t4.optional = (t4.optional || []).concat(e4.advanced)), t4;
        }, n3 = function(e4, n4) {
          if (t3.version >= 61)
            return n4(e4);
          if ((e4 = JSON.parse(JSON.stringify(e4))) && "object" == typeof e4.audio) {
            const t4 = function(e5, t5, i4) {
              t5 in e5 && !(i4 in e5) && (e5[i4] = e5[t5], delete e5[t5]);
            };
            t4((e4 = JSON.parse(JSON.stringify(e4))).audio, "autoGainControl", "googAutoGainControl"), t4(e4.audio, "noiseSuppression", "googNoiseSuppression"), e4.audio = r3(e4.audio);
          }
          if (e4 && "object" == typeof e4.video) {
            let o4 = e4.video.facingMode;
            o4 = o4 && ("object" == typeof o4 ? o4 : { ideal: o4 });
            const s3 = t3.version < 66;
            if (o4 && ("user" === o4.exact || "environment" === o4.exact || "user" === o4.ideal || "environment" === o4.ideal) && (!i3.mediaDevices.getSupportedConstraints || !i3.mediaDevices.getSupportedConstraints().facingMode || s3)) {
              let t4;
              if (delete e4.video.facingMode, "environment" === o4.exact || "environment" === o4.ideal ? t4 = ["back", "rear"] : "user" !== o4.exact && "user" !== o4.ideal || (t4 = ["front"]), t4)
                return i3.mediaDevices.enumerateDevices().then((i4) => {
                  let s4 = (i4 = i4.filter((e5) => "videoinput" === e5.kind)).find((e5) => t4.some((t5) => e5.label.toLowerCase().includes(t5)));
                  return !s4 && i4.length && t4.includes("back") && (s4 = i4[i4.length - 1]), s4 && (e4.video.deviceId = o4.exact ? { exact: s4.deviceId } : { ideal: s4.deviceId }), e4.video = r3(e4.video), jv("chrome: " + JSON.stringify(e4)), n4(e4);
                });
            }
            e4.video = r3(e4.video);
          }
          return jv("chrome: " + JSON.stringify(e4)), n4(e4);
        }, o3 = function(e4) {
          return t3.version >= 64 ? e4 : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e4.name] || e4.name, message: e4.message, constraint: e4.constraint || e4.constraintName, toString() {
            return this.name + (this.message && ": ") + this.message;
          } };
        };
        if (i3.getUserMedia = function(e4, t4, r4) {
          n3(e4, (e5) => {
            i3.webkitGetUserMedia(e5, t4, (e6) => {
              r4 && r4(o3(e6));
            });
          });
        }.bind(i3), i3.mediaDevices.getUserMedia) {
          const e4 = i3.mediaDevices.getUserMedia.bind(i3.mediaDevices);
          i3.mediaDevices.getUserMedia = function(t4) {
            return n3(t4, (t5) => e4(t5).then((e5) => {
              if (t5.audio && !e5.getAudioTracks().length || t5.video && !e5.getVideoTracks().length)
                throw e5.getTracks().forEach((e6) => {
                  e6.stop();
                }), new DOMException("", "NotFoundError");
              return e5;
            }, (e5) => l_.reject(o3(e5))));
          };
        }
      }
      function Kv(e3) {
        e3.MediaStream = e3.MediaStream || e3.webkitMediaStream;
      }
      function Hv(e3) {
        if ("object" == typeof e3 && e3.RTCPeerConnection && !("ontrack" in e3.RTCPeerConnection.prototype)) {
          Object.defineProperty(e3.RTCPeerConnection.prototype, "ontrack", { get() {
            return this._ontrack;
          }, set(e4) {
            this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e4);
          }, enumerable: true, configurable: true });
          const t3 = e3.RTCPeerConnection.prototype.setRemoteDescription;
          e3.RTCPeerConnection.prototype.setRemoteDescription = function() {
            return this._ontrackpoly || (this._ontrackpoly = (t4) => {
              t4.stream.addEventListener("addtrack", (i3) => {
                let r3;
                r3 = e3.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e4) => e4.track && e4.track.id === i3.track.id) : { track: i3.track };
                const n3 = new Event("track");
                n3.track = i3.track, n3.receiver = r3, n3.transceiver = { receiver: r3 }, n3.streams = [t4.stream], this.dispatchEvent(n3);
              }), t4.stream.getTracks().forEach((i3) => {
                let r3;
                r3 = e3.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e4) => e4.track && e4.track.id === i3.id) : { track: i3 };
                const n3 = new Event("track");
                n3.track = i3, n3.receiver = r3, n3.transceiver = { receiver: r3 }, n3.streams = [t4.stream], this.dispatchEvent(n3);
              });
            }, this.addEventListener("addstream", this._ontrackpoly)), t3.apply(this, arguments);
          };
        } else
          Gh(e3, "track", (e4) => (e4.transceiver || Object.defineProperty(e4, "transceiver", { value: { receiver: e4.receiver } }), e4));
      }
      function Wv(e3) {
        if ("object" == typeof e3 && e3.RTCPeerConnection && !("getSenders" in e3.RTCPeerConnection.prototype) && "createDTMFSender" in e3.RTCPeerConnection.prototype) {
          const t3 = function(e4, t4) {
            return { track: t4, get dtmf() {
              return void 0 === this._dtmf && ("audio" === t4.kind ? this._dtmf = e4.createDTMFSender(t4) : this._dtmf = null), this._dtmf;
            }, _pc: e4 };
          };
          if (!e3.RTCPeerConnection.prototype.getSenders) {
            e3.RTCPeerConnection.prototype.getSenders = function() {
              return this._senders = this._senders || [], this._senders.slice();
            };
            const i4 = e3.RTCPeerConnection.prototype.addTrack;
            e3.RTCPeerConnection.prototype.addTrack = function(e4, r5) {
              let n3 = i4.apply(this, arguments);
              return n3 || (n3 = t3(this, e4), this._senders.push(n3)), n3;
            };
            const r4 = e3.RTCPeerConnection.prototype.removeTrack;
            e3.RTCPeerConnection.prototype.removeTrack = function(e4) {
              r4.apply(this, arguments);
              const t4 = this._senders.indexOf(e4);
              -1 !== t4 && this._senders.splice(t4, 1);
            };
          }
          const i3 = e3.RTCPeerConnection.prototype.addStream;
          e3.RTCPeerConnection.prototype.addStream = function(e4) {
            this._senders = this._senders || [], i3.apply(this, [e4]), e4.getTracks().forEach((e5) => {
              this._senders.push(t3(this, e5));
            });
          };
          const r3 = e3.RTCPeerConnection.prototype.removeStream;
          e3.RTCPeerConnection.prototype.removeStream = function(e4) {
            this._senders = this._senders || [], r3.apply(this, [e4]), e4.getTracks().forEach((e5) => {
              const t4 = this._senders.find((t5) => t5.track === e5);
              t4 && this._senders.splice(this._senders.indexOf(t4), 1);
            });
          };
        } else if ("object" == typeof e3 && e3.RTCPeerConnection && "getSenders" in e3.RTCPeerConnection.prototype && "createDTMFSender" in e3.RTCPeerConnection.prototype && e3.RTCRtpSender && !("dtmf" in e3.RTCRtpSender.prototype)) {
          const t3 = e3.RTCPeerConnection.prototype.getSenders;
          e3.RTCPeerConnection.prototype.getSenders = function() {
            const e4 = t3.apply(this, []);
            return e4.forEach((e5) => e5._pc = this), e4;
          }, Object.defineProperty(e3.RTCRtpSender.prototype, "dtmf", { get() {
            return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
          } });
        }
      }
      function Yv(e3) {
        if (!e3.RTCPeerConnection)
          return;
        const t3 = e3.RTCPeerConnection.prototype.getStats;
        e3.RTCPeerConnection.prototype.getStats = function() {
          const [e4, i3, r3] = arguments;
          if (arguments.length > 0 && "function" == typeof e4)
            return t3.apply(this, arguments);
          if (0 === t3.length && (0 === arguments.length || "function" != typeof e4))
            return t3.apply(this, []);
          const n3 = function(e5) {
            const t4 = {};
            return e5.result().forEach((e6) => {
              const i4 = { id: e6.id, timestamp: e6.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e6.type] || e6.type };
              e6.names().forEach((t5) => {
                i4[t5] = e6.stat(t5);
              }), t4[i4.id] = i4;
            }), t4;
          }, o3 = function(e5) {
            return new Map(Object.keys(e5).map((t4) => [t4, e5[t4]]));
          };
          if (arguments.length >= 2) {
            const r4 = function(e5) {
              i3(o3(n3(e5)));
            };
            return t3.apply(this, [r4, e4]);
          }
          return new l_((e5, i4) => {
            t3.apply(this, [function(t4) {
              e5(o3(n3(t4)));
            }, i4]);
          }).then(i3, r3);
        };
      }
      function Jv(e3) {
        if (!("object" == typeof e3 && e3.RTCPeerConnection && e3.RTCRtpSender && e3.RTCRtpReceiver))
          return;
        if (!("getStats" in e3.RTCRtpSender.prototype)) {
          const t4 = e3.RTCPeerConnection.prototype.getSenders;
          t4 && (e3.RTCPeerConnection.prototype.getSenders = function() {
            const e4 = t4.apply(this, []);
            return e4.forEach((e5) => e5._pc = this), e4;
          });
          const i3 = e3.RTCPeerConnection.prototype.addTrack;
          i3 && (e3.RTCPeerConnection.prototype.addTrack = function() {
            const e4 = i3.apply(this, arguments);
            return e4._pc = this, e4;
          }), e3.RTCRtpSender.prototype.getStats = function() {
            const e4 = this;
            return this._pc.getStats().then((t5) => zh(t5, e4.track, true));
          };
        }
        if (!("getStats" in e3.RTCRtpReceiver.prototype)) {
          const t4 = e3.RTCPeerConnection.prototype.getReceivers;
          t4 && (e3.RTCPeerConnection.prototype.getReceivers = function() {
            const e4 = t4.apply(this, []);
            return e4.forEach((e5) => e5._pc = this), e4;
          }), Gh(e3, "track", (e4) => (e4.receiver._pc = e4.srcElement, e4)), e3.RTCRtpReceiver.prototype.getStats = function() {
            const e4 = this;
            return this._pc.getStats().then((t5) => zh(t5, e4.track, false));
          };
        }
        if (!("getStats" in e3.RTCRtpSender.prototype) || !("getStats" in e3.RTCRtpReceiver.prototype))
          return;
        const t3 = e3.RTCPeerConnection.prototype.getStats;
        e3.RTCPeerConnection.prototype.getStats = function() {
          if (arguments.length > 0 && arguments[0] instanceof e3.MediaStreamTrack) {
            const e4 = arguments[0];
            let t4, i3, r3;
            return this.getSenders().forEach((i4) => {
              i4.track === e4 && (t4 ? r3 = true : t4 = i4);
            }), this.getReceivers().forEach((t5) => (t5.track === e4 && (i3 ? r3 = true : i3 = t5), t5.track === e4)), r3 || t4 && i3 ? l_.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t4 ? t4.getStats() : i3 ? i3.getStats() : l_.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
          }
          return t3.apply(this, arguments);
        };
      }
      function qv(e3) {
        e3.RTCPeerConnection.prototype.getLocalStreams = function() {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e4) => this._shimmedLocalStreams[e4][0]);
        };
        const t3 = e3.RTCPeerConnection.prototype.addTrack;
        e3.RTCPeerConnection.prototype.addTrack = function(e4, i4) {
          if (!i4)
            return t3.apply(this, arguments);
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          const r4 = t3.apply(this, arguments);
          return this._shimmedLocalStreams[i4.id] ? -1 === this._shimmedLocalStreams[i4.id].indexOf(r4) && this._shimmedLocalStreams[i4.id].push(r4) : this._shimmedLocalStreams[i4.id] = [i4, r4], r4;
        };
        const i3 = e3.RTCPeerConnection.prototype.addStream;
        e3.RTCPeerConnection.prototype.addStream = function(e4) {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e4.getTracks().forEach((e5) => {
            if (this.getSenders().find((t5) => t5.track === e5))
              throw new DOMException("Track already exists.", "InvalidAccessError");
          });
          const t4 = this.getSenders();
          i3.apply(this, arguments);
          const r4 = this.getSenders().filter((e5) => -1 === t4.indexOf(e5));
          this._shimmedLocalStreams[e4.id] = [e4].concat(r4);
        };
        const r3 = e3.RTCPeerConnection.prototype.removeStream;
        e3.RTCPeerConnection.prototype.removeStream = function(e4) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e4.id], r3.apply(this, arguments);
        };
        const n3 = e3.RTCPeerConnection.prototype.removeTrack;
        e3.RTCPeerConnection.prototype.removeTrack = function(e4) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e4 && Object.keys(this._shimmedLocalStreams).forEach((t4) => {
            const i4 = this._shimmedLocalStreams[t4].indexOf(e4);
            -1 !== i4 && this._shimmedLocalStreams[t4].splice(i4, 1), 1 === this._shimmedLocalStreams[t4].length && delete this._shimmedLocalStreams[t4];
          }), n3.apply(this, arguments);
        };
      }
      function Xv(e3, t3) {
        if (!e3.RTCPeerConnection)
          return;
        if (e3.RTCPeerConnection.prototype.addTrack && t3.version >= 65)
          return qv(e3);
        const i3 = e3.RTCPeerConnection.prototype.getLocalStreams;
        e3.RTCPeerConnection.prototype.getLocalStreams = function() {
          const e4 = i3.apply(this);
          return this._reverseStreams = this._reverseStreams || {}, e4.map((e5) => this._reverseStreams[e5.id]);
        };
        const r3 = e3.RTCPeerConnection.prototype.addStream;
        e3.RTCPeerConnection.prototype.addStream = function(t4) {
          if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t4.getTracks().forEach((e4) => {
            if (this.getSenders().find((t5) => t5.track === e4))
              throw new DOMException("Track already exists.", "InvalidAccessError");
          }), !this._reverseStreams[t4.id]) {
            const i4 = new e3.MediaStream(t4.getTracks());
            this._streams[t4.id] = i4, this._reverseStreams[i4.id] = t4, t4 = i4;
          }
          r3.apply(this, [t4]);
        };
        const n3 = e3.RTCPeerConnection.prototype.removeStream;
        function o3(e4, t4) {
          let i4 = t4.sdp;
          return Object.keys(e4._reverseStreams || []).forEach((t5) => {
            const r4 = e4._reverseStreams[t5], n4 = e4._streams[r4.id];
            i4 = i4.replace(new RegExp(n4.id, "g"), r4.id);
          }), new RTCSessionDescription({ type: t4.type, sdp: i4 });
        }
        function s3(e4, t4) {
          let i4 = t4.sdp;
          return Object.keys(e4._reverseStreams || []).forEach((t5) => {
            const r4 = e4._reverseStreams[t5], n4 = e4._streams[r4.id];
            i4 = i4.replace(new RegExp(r4.id, "g"), n4.id);
          }), new RTCSessionDescription({ type: t4.type, sdp: i4 });
        }
        e3.RTCPeerConnection.prototype.removeStream = function(e4) {
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, n3.apply(this, [this._streams[e4.id] || e4]), delete this._reverseStreams[this._streams[e4.id] ? this._streams[e4.id].id : e4.id], delete this._streams[e4.id];
        }, e3.RTCPeerConnection.prototype.addTrack = function(t4, i4) {
          if ("closed" === this.signalingState)
            throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          const r4 = [].slice.call(arguments, 1);
          if (1 !== r4.length || !r4[0].getTracks().find((e4) => e4 === t4))
            throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
          const n4 = this.getSenders().find((e4) => e4.track === t4);
          if (n4)
            throw new DOMException("Track already exists.", "InvalidAccessError");
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
          const o4 = this._streams[i4.id];
          if (o4)
            o4.addTrack(t4), l_.resolve().then(() => {
              this.dispatchEvent(new Event("negotiationneeded"));
            });
          else {
            const r5 = new e3.MediaStream([t4]);
            this._streams[i4.id] = r5, this._reverseStreams[r5.id] = i4, this.addStream(r5);
          }
          return this.getSenders().find((e4) => e4.track === t4);
        }, ["createOffer", "createAnswer"].forEach(function(t4) {
          const i4 = e3.RTCPeerConnection.prototype[t4], r4 = { [t4]() {
            const e4 = arguments;
            return arguments.length && "function" == typeof arguments[0] ? i4.apply(this, [(t5) => {
              const i5 = o3(this, t5);
              e4[0].apply(null, [i5]);
            }, (t5) => {
              e4[1] && e4[1].apply(null, t5);
            }, arguments[2]]) : i4.apply(this, arguments).then((e5) => o3(this, e5));
          } };
          e3.RTCPeerConnection.prototype[t4] = r4[t4];
        });
        const a3 = e3.RTCPeerConnection.prototype.setLocalDescription;
        e3.RTCPeerConnection.prototype.setLocalDescription = function() {
          return arguments.length && arguments[0].type ? (arguments[0] = s3(this, arguments[0]), a3.apply(this, arguments)) : a3.apply(this, arguments);
        };
        const c3 = Object.getOwnPropertyDescriptor(e3.RTCPeerConnection.prototype, "localDescription");
        Object.defineProperty(e3.RTCPeerConnection.prototype, "localDescription", { get() {
          const e4 = c3.get.apply(this);
          return "" === e4.type ? e4 : o3(this, e4);
        } }), e3.RTCPeerConnection.prototype.removeTrack = function(e4) {
          if ("closed" === this.signalingState)
            throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          if (!e4._pc)
            throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
          if (!(e4._pc === this))
            throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
          let t4;
          this._streams = this._streams || {}, Object.keys(this._streams).forEach((i4) => {
            this._streams[i4].getTracks().find((t5) => e4.track === t5) && (t4 = this._streams[i4]);
          }), t4 && (1 === t4.getTracks().length ? this.removeStream(this._reverseStreams[t4.id]) : t4.removeTrack(e4.track), this.dispatchEvent(new Event("negotiationneeded")));
        };
      }
      function zv(e3, t3) {
        !e3.RTCPeerConnection && e3.webkitRTCPeerConnection && (e3.RTCPeerConnection = e3.webkitRTCPeerConnection), e3.RTCPeerConnection && t3.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t4) {
          const i3 = e3.RTCPeerConnection.prototype[t4], r3 = { [t4]() {
            return arguments[0] = new ("addIceCandidate" === t4 ? e3.RTCIceCandidate : e3.RTCSessionDescription)(arguments[0]), i3.apply(this, arguments);
          } };
          e3.RTCPeerConnection.prototype[t4] = r3[t4];
        });
      }
      function Zv(e3, t3) {
        Gh(e3, "negotiationneeded", (e4) => {
          const i3 = e4.target;
          if (!(t3.version < 72 || i3.getConfiguration && "plan-b" === i3.getConfiguration().sdpSemantics) || "stable" === i3.signalingState)
            return e4;
        });
      }
      var $v = Object.freeze({ __proto__: null, shimMediaStream: Kv, shimOnTrack: Hv, shimGetSendersWithDtmf: Wv, shimGetStats: Yv, shimSenderReceiverGetStats: Jv, shimAddTrackRemoveTrackWithNative: qv, shimAddTrackRemoveTrack: Xv, shimPeerConnection: zv, fixNegotiationNeeded: Zv, shimGetUserMedia: Gv, shimGetDisplayMedia: function(e3, t3) {
        e3.navigator.mediaDevices && "getDisplayMedia" in e3.navigator.mediaDevices || e3.navigator.mediaDevices && ("function" == typeof t3 ? e3.navigator.mediaDevices.getDisplayMedia = function(i3) {
          return t3(i3).then((t4) => {
            const r3 = i3.video && i3.video.width, n3 = i3.video && i3.video.height, o3 = i3.video && i3.video.frameRate;
            return i3.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t4, maxFrameRate: o3 || 3 } }, r3 && (i3.video.mandatory.maxWidth = r3), n3 && (i3.video.mandatory.maxHeight = n3), e3.navigator.mediaDevices.getUserMedia(i3);
          });
        } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
      } });
      var eT = { exports: {} };
      !function(e3) {
        var t3 = { generateIdentifier: function() {
          return Math.random().toString(36).substr(2, 10);
        } };
        t3.localCName = t3.generateIdentifier(), t3.splitLines = function(e4) {
          return e4.trim().split("\n").map(function(e5) {
            return e5.trim();
          });
        }, t3.splitSections = function(e4) {
          return e4.split("\nm=").map(function(e5, t4) {
            return (t4 > 0 ? "m=" + e5 : e5).trim() + "\r\n";
          });
        }, t3.getDescription = function(e4) {
          var i3 = t3.splitSections(e4);
          return i3 && i3[0];
        }, t3.getMediaSections = function(e4) {
          var i3 = t3.splitSections(e4);
          return i3.shift(), i3;
        }, t3.matchPrefix = function(e4, i3) {
          return t3.splitLines(e4).filter(function(e5) {
            return 0 === e5.indexOf(i3);
          });
        }, t3.parseCandidate = function(e4) {
          for (var t4, i3 = { foundation: (t4 = 0 === e4.indexOf("a=candidate:") ? e4.substring(12).split(" ") : e4.substring(10).split(" "))[0], component: parseInt(t4[1], 10), protocol: t4[2].toLowerCase(), priority: parseInt(t4[3], 10), ip: t4[4], address: t4[4], port: parseInt(t4[5], 10), type: t4[7] }, r3 = 8; r3 < t4.length; r3 += 2)
            switch (t4[r3]) {
              case "raddr":
                i3.relatedAddress = t4[r3 + 1];
                break;
              case "rport":
                i3.relatedPort = parseInt(t4[r3 + 1], 10);
                break;
              case "tcptype":
                i3.tcpType = t4[r3 + 1];
                break;
              case "ufrag":
                i3.ufrag = t4[r3 + 1], i3.usernameFragment = t4[r3 + 1];
                break;
              default:
                i3[t4[r3]] = t4[r3 + 1];
            }
          return i3;
        }, t3.writeCandidate = function(e4) {
          var t4 = [];
          t4.push(e4.foundation), t4.push(e4.component), t4.push(e4.protocol.toUpperCase()), t4.push(e4.priority), t4.push(e4.address || e4.ip), t4.push(e4.port);
          var i3 = e4.type;
          return t4.push("typ"), t4.push(i3), "host" !== i3 && e4.relatedAddress && e4.relatedPort && (t4.push("raddr"), t4.push(e4.relatedAddress), t4.push("rport"), t4.push(e4.relatedPort)), e4.tcpType && "tcp" === e4.protocol.toLowerCase() && (t4.push("tcptype"), t4.push(e4.tcpType)), (e4.usernameFragment || e4.ufrag) && (t4.push("ufrag"), t4.push(e4.usernameFragment || e4.ufrag)), "candidate:" + t4.join(" ");
        }, t3.parseIceOptions = function(e4) {
          return e4.substr(14).split(" ");
        }, t3.parseRtpMap = function(e4) {
          var t4 = e4.substr(9).split(" "), i3 = { payloadType: parseInt(t4.shift(), 10) };
          return t4 = t4[0].split("/"), i3.name = t4[0], i3.clockRate = parseInt(t4[1], 10), i3.channels = 3 === t4.length ? parseInt(t4[2], 10) : 1, i3.numChannels = i3.channels, i3;
        }, t3.writeRtpMap = function(e4) {
          var t4 = e4.payloadType;
          void 0 !== e4.preferredPayloadType && (t4 = e4.preferredPayloadType);
          var i3 = e4.channels || e4.numChannels || 1;
          return "a=rtpmap:" + t4 + " " + e4.name + "/" + e4.clockRate + (1 !== i3 ? "/" + i3 : "") + "\r\n";
        }, t3.parseExtmap = function(e4) {
          var t4 = e4.substr(9).split(" ");
          return { id: parseInt(t4[0], 10), direction: t4[0].indexOf("/") > 0 ? t4[0].split("/")[1] : "sendrecv", uri: t4[1] };
        }, t3.writeExtmap = function(e4) {
          return "a=extmap:" + (e4.id || e4.preferredId) + (e4.direction && "sendrecv" !== e4.direction ? "/" + e4.direction : "") + " " + e4.uri + "\r\n";
        }, t3.parseFmtp = function(e4) {
          for (var t4, i3 = {}, r3 = e4.substr(e4.indexOf(" ") + 1).split(";"), n3 = 0; n3 < r3.length; n3++)
            i3[(t4 = r3[n3].trim().split("="))[0].trim()] = t4[1];
          return i3;
        }, t3.writeFmtp = function(e4) {
          var t4 = "", i3 = e4.payloadType;
          if (void 0 !== e4.preferredPayloadType && (i3 = e4.preferredPayloadType), e4.parameters && Object.keys(e4.parameters).length) {
            var r3 = [];
            Object.keys(e4.parameters).forEach(function(t5) {
              e4.parameters[t5] ? r3.push(t5 + "=" + e4.parameters[t5]) : r3.push(t5);
            }), t4 += "a=fmtp:" + i3 + " " + r3.join(";") + "\r\n";
          }
          return t4;
        }, t3.parseRtcpFb = function(e4) {
          var t4 = e4.substr(e4.indexOf(" ") + 1).split(" ");
          return { type: t4.shift(), parameter: t4.join(" ") };
        }, t3.writeRtcpFb = function(e4) {
          var t4 = "", i3 = e4.payloadType;
          return void 0 !== e4.preferredPayloadType && (i3 = e4.preferredPayloadType), e4.rtcpFeedback && e4.rtcpFeedback.length && e4.rtcpFeedback.forEach(function(e5) {
            t4 += "a=rtcp-fb:" + i3 + " " + e5.type + (e5.parameter && e5.parameter.length ? " " + e5.parameter : "") + "\r\n";
          }), t4;
        }, t3.parseSsrcMedia = function(e4) {
          var t4 = e4.indexOf(" "), i3 = { ssrc: parseInt(e4.substr(7, t4 - 7), 10) }, r3 = e4.indexOf(":", t4);
          return r3 > -1 ? (i3.attribute = e4.substr(t4 + 1, r3 - t4 - 1), i3.value = e4.substr(r3 + 1)) : i3.attribute = e4.substr(t4 + 1), i3;
        }, t3.parseSsrcGroup = function(e4) {
          var t4 = e4.substr(13).split(" ");
          return { semantics: t4.shift(), ssrcs: t4.map(function(e5) {
            return parseInt(e5, 10);
          }) };
        }, t3.getMid = function(e4) {
          var i3 = t3.matchPrefix(e4, "a=mid:")[0];
          if (i3)
            return i3.substr(6);
        }, t3.parseFingerprint = function(e4) {
          var t4 = e4.substr(14).split(" ");
          return { algorithm: t4[0].toLowerCase(), value: t4[1] };
        }, t3.getDtlsParameters = function(e4, i3) {
          return { role: "auto", fingerprints: t3.matchPrefix(e4 + i3, "a=fingerprint:").map(t3.parseFingerprint) };
        }, t3.writeDtlsParameters = function(e4, t4) {
          var i3 = "a=setup:" + t4 + "\r\n";
          return e4.fingerprints.forEach(function(e5) {
            i3 += "a=fingerprint:" + e5.algorithm + " " + e5.value + "\r\n";
          }), i3;
        }, t3.getIceParameters = function(e4, i3) {
          var r3 = t3.splitLines(e4);
          return { usernameFragment: (r3 = r3.concat(t3.splitLines(i3))).filter(function(e5) {
            return 0 === e5.indexOf("a=ice-ufrag:");
          })[0].substr(12), password: r3.filter(function(e5) {
            return 0 === e5.indexOf("a=ice-pwd:");
          })[0].substr(10) };
        }, t3.writeIceParameters = function(e4) {
          return "a=ice-ufrag:" + e4.usernameFragment + "\r\na=ice-pwd:" + e4.password + "\r\n";
        }, t3.parseRtpParameters = function(e4) {
          for (var i3 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r3 = t3.splitLines(e4)[0].split(" "), n3 = 3; n3 < r3.length; n3++) {
            var o3 = r3[n3], s3 = t3.matchPrefix(e4, "a=rtpmap:" + o3 + " ")[0];
            if (s3) {
              var a3 = t3.parseRtpMap(s3), c3 = t3.matchPrefix(e4, "a=fmtp:" + o3 + " ");
              switch (a3.parameters = c3.length ? t3.parseFmtp(c3[0]) : {}, a3.rtcpFeedback = t3.matchPrefix(e4, "a=rtcp-fb:" + o3 + " ").map(t3.parseRtcpFb), i3.codecs.push(a3), a3.name.toUpperCase()) {
                case "RED":
                case "ULPFEC":
                  i3.fecMechanisms.push(a3.name.toUpperCase());
              }
            }
          }
          return t3.matchPrefix(e4, "a=extmap:").forEach(function(e5) {
            i3.headerExtensions.push(t3.parseExtmap(e5));
          }), i3;
        }, t3.writeRtpDescription = function(e4, i3) {
          var r3 = "";
          r3 += "m=" + e4 + " ", r3 += i3.codecs.length > 0 ? "9" : "0", r3 += " UDP/TLS/RTP/SAVPF ", r3 += i3.codecs.map(function(e5) {
            return void 0 !== e5.preferredPayloadType ? e5.preferredPayloadType : e5.payloadType;
          }).join(" ") + "\r\n", r3 += "c=IN IP4 0.0.0.0\r\n", r3 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", i3.codecs.forEach(function(e5) {
            r3 += t3.writeRtpMap(e5), r3 += t3.writeFmtp(e5), r3 += t3.writeRtcpFb(e5);
          });
          var n3 = 0;
          return i3.codecs.forEach(function(e5) {
            e5.maxptime > n3 && (n3 = e5.maxptime);
          }), n3 > 0 && (r3 += "a=maxptime:" + n3 + "\r\n"), r3 += "a=rtcp-mux\r\n", i3.headerExtensions && i3.headerExtensions.forEach(function(e5) {
            r3 += t3.writeExtmap(e5);
          }), r3;
        }, t3.parseRtpEncodingParameters = function(e4) {
          var i3, r3 = [], n3 = t3.parseRtpParameters(e4), o3 = -1 !== n3.fecMechanisms.indexOf("RED"), s3 = -1 !== n3.fecMechanisms.indexOf("ULPFEC"), a3 = t3.matchPrefix(e4, "a=ssrc:").map(function(e5) {
            return t3.parseSsrcMedia(e5);
          }).filter(function(e5) {
            return "cname" === e5.attribute;
          }), c3 = a3.length > 0 && a3[0].ssrc, d3 = t3.matchPrefix(e4, "a=ssrc-group:FID").map(function(e5) {
            return e5.substr(17).split(" ").map(function(e6) {
              return parseInt(e6, 10);
            });
          });
          d3.length > 0 && d3[0].length > 1 && d3[0][0] === c3 && (i3 = d3[0][1]), n3.codecs.forEach(function(e5) {
            if ("RTX" === e5.name.toUpperCase() && e5.parameters.apt) {
              var t4 = { ssrc: c3, codecPayloadType: parseInt(e5.parameters.apt, 10) };
              c3 && i3 && (t4.rtx = { ssrc: i3 }), r3.push(t4), o3 && ((t4 = JSON.parse(JSON.stringify(t4))).fec = { ssrc: c3, mechanism: s3 ? "red+ulpfec" : "red" }, r3.push(t4));
            }
          }), 0 === r3.length && c3 && r3.push({ ssrc: c3 });
          var u3 = t3.matchPrefix(e4, "b=");
          return u3.length && (u3 = 0 === u3[0].indexOf("b=TIAS:") ? parseInt(u3[0].substr(7), 10) : 0 === u3[0].indexOf("b=AS:") ? 1e3 * parseInt(u3[0].substr(5), 10) * 0.95 - 16e3 : void 0, r3.forEach(function(e5) {
            e5.maxBitrate = u3;
          })), r3;
        }, t3.parseRtcpParameters = function(e4) {
          var i3 = {}, r3 = t3.matchPrefix(e4, "a=ssrc:").map(function(e5) {
            return t3.parseSsrcMedia(e5);
          }).filter(function(e5) {
            return "cname" === e5.attribute;
          })[0];
          r3 && (i3.cname = r3.value, i3.ssrc = r3.ssrc);
          var n3 = t3.matchPrefix(e4, "a=rtcp-rsize");
          i3.reducedSize = n3.length > 0, i3.compound = 0 === n3.length;
          var o3 = t3.matchPrefix(e4, "a=rtcp-mux");
          return i3.mux = o3.length > 0, i3;
        }, t3.parseMsid = function(e4) {
          var i3, r3 = t3.matchPrefix(e4, "a=msid:");
          if (1 === r3.length)
            return { stream: (i3 = r3[0].substr(7).split(" "))[0], track: i3[1] };
          var n3 = t3.matchPrefix(e4, "a=ssrc:").map(function(e5) {
            return t3.parseSsrcMedia(e5);
          }).filter(function(e5) {
            return "msid" === e5.attribute;
          });
          return n3.length > 0 ? { stream: (i3 = n3[0].value.split(" "))[0], track: i3[1] } : void 0;
        }, t3.generateSessionId = function() {
          return Math.random().toString().substr(2, 21);
        }, t3.writeSessionBoilerplate = function(e4, i3, r3) {
          var n3 = void 0 !== i3 ? i3 : 2;
          return "v=0\r\no=" + (r3 || "thisisadapterortc") + " " + (e4 || t3.generateSessionId()) + " " + n3 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
        }, t3.writeMediaSection = function(e4, i3, r3, n3) {
          var o3 = t3.writeRtpDescription(e4.kind, i3);
          if (o3 += t3.writeIceParameters(e4.iceGatherer.getLocalParameters()), o3 += t3.writeDtlsParameters(e4.dtlsTransport.getLocalParameters(), "offer" === r3 ? "actpass" : "active"), o3 += "a=mid:" + e4.mid + "\r\n", e4.direction ? o3 += "a=" + e4.direction + "\r\n" : e4.rtpSender && e4.rtpReceiver ? o3 += "a=sendrecv\r\n" : e4.rtpSender ? o3 += "a=sendonly\r\n" : e4.rtpReceiver ? o3 += "a=recvonly\r\n" : o3 += "a=inactive\r\n", e4.rtpSender) {
            var s3 = "msid:" + n3.id + " " + e4.rtpSender.track.id + "\r\n";
            o3 += "a=" + s3, o3 += "a=ssrc:" + e4.sendEncodingParameters[0].ssrc + " " + s3, e4.sendEncodingParameters[0].rtx && (o3 += "a=ssrc:" + e4.sendEncodingParameters[0].rtx.ssrc + " " + s3, o3 += "a=ssrc-group:FID " + e4.sendEncodingParameters[0].ssrc + " " + e4.sendEncodingParameters[0].rtx.ssrc + "\r\n");
          }
          return o3 += "a=ssrc:" + e4.sendEncodingParameters[0].ssrc + " cname:" + t3.localCName + "\r\n", e4.rtpSender && e4.sendEncodingParameters[0].rtx && (o3 += "a=ssrc:" + e4.sendEncodingParameters[0].rtx.ssrc + " cname:" + t3.localCName + "\r\n"), o3;
        }, t3.getDirection = function(e4, i3) {
          for (var r3 = t3.splitLines(e4), n3 = 0; n3 < r3.length; n3++)
            switch (r3[n3]) {
              case "a=sendrecv":
              case "a=sendonly":
              case "a=recvonly":
              case "a=inactive":
                return r3[n3].substr(2);
            }
          return i3 ? t3.getDirection(i3) : "sendrecv";
        }, t3.getKind = function(e4) {
          return t3.splitLines(e4)[0].split(" ")[0].substr(2);
        }, t3.isRejected = function(e4) {
          return "0" === e4.split(" ", 2)[1];
        }, t3.parseMLine = function(e4) {
          var i3 = t3.splitLines(e4)[0].substr(2).split(" ");
          return { kind: i3[0], port: parseInt(i3[1], 10), protocol: i3[2], fmt: i3.slice(3).join(" ") };
        }, t3.parseOLine = function(e4) {
          var i3 = t3.matchPrefix(e4, "o=")[0].substr(2).split(" ");
          return { username: i3[0], sessionId: i3[1], sessionVersion: parseInt(i3[2], 10), netType: i3[3], addressType: i3[4], address: i3[5] };
        }, t3.isValidSDP = function(e4) {
          if ("string" != typeof e4 || 0 === e4.length)
            return false;
          for (var i3 = t3.splitLines(e4), r3 = 0; r3 < i3.length; r3++)
            if (i3[r3].length < 2 || "=" !== i3[r3].charAt(1))
              return false;
          return true;
        }, e3.exports = t3;
      }(eT);
      var tT = eT.exports;
      function iT(e3, t3, i3, r3, n3) {
        var o3 = tT.writeRtpDescription(e3.kind, t3);
        if (o3 += tT.writeIceParameters(e3.iceGatherer.getLocalParameters()), o3 += tT.writeDtlsParameters(e3.dtlsTransport.getLocalParameters(), "offer" === i3 ? "actpass" : n3 || "active"), o3 += "a=mid:" + e3.mid + "\r\n", e3.rtpSender && e3.rtpReceiver ? o3 += "a=sendrecv\r\n" : e3.rtpSender ? o3 += "a=sendonly\r\n" : e3.rtpReceiver ? o3 += "a=recvonly\r\n" : o3 += "a=inactive\r\n", e3.rtpSender) {
          var s3 = e3.rtpSender._initialTrackId || e3.rtpSender.track.id;
          e3.rtpSender._initialTrackId = s3;
          var a3 = "msid:" + (r3 ? r3.id : "-") + " " + s3 + "\r\n";
          o3 += "a=" + a3, o3 += "a=ssrc:" + e3.sendEncodingParameters[0].ssrc + " " + a3, e3.sendEncodingParameters[0].rtx && (o3 += "a=ssrc:" + e3.sendEncodingParameters[0].rtx.ssrc + " " + a3, o3 += "a=ssrc-group:FID " + e3.sendEncodingParameters[0].ssrc + " " + e3.sendEncodingParameters[0].rtx.ssrc + "\r\n");
        }
        return o3 += "a=ssrc:" + e3.sendEncodingParameters[0].ssrc + " cname:" + tT.localCName + "\r\n", e3.rtpSender && e3.sendEncodingParameters[0].rtx && (o3 += "a=ssrc:" + e3.sendEncodingParameters[0].rtx.ssrc + " cname:" + tT.localCName + "\r\n"), o3;
      }
      function rT(e3, t3) {
        var i3 = { codecs: [], headerExtensions: [], fecMechanisms: [] }, r3 = function(e4, t4) {
          e4 = parseInt(e4, 10);
          for (var i4 = 0; i4 < t4.length; i4++)
            if (t4[i4].payloadType === e4 || t4[i4].preferredPayloadType === e4)
              return t4[i4];
        }, n3 = function(e4, t4, i4, n4) {
          var o3 = r3(e4.parameters.apt, i4), s3 = r3(t4.parameters.apt, n4);
          return o3 && s3 && o3.name.toLowerCase() === s3.name.toLowerCase();
        };
        return e3.codecs.forEach(function(r4) {
          for (var o3 = 0; o3 < t3.codecs.length; o3++) {
            var s3 = t3.codecs[o3];
            if (r4.name.toLowerCase() === s3.name.toLowerCase() && r4.clockRate === s3.clockRate) {
              if ("rtx" === r4.name.toLowerCase() && r4.parameters && s3.parameters.apt && !n3(r4, s3, e3.codecs, t3.codecs))
                continue;
              (s3 = JSON.parse(JSON.stringify(s3))).numChannels = Math.min(r4.numChannels, s3.numChannels), i3.codecs.push(s3), s3.rtcpFeedback = s3.rtcpFeedback.filter(function(e4) {
                for (var t4 = 0; t4 < r4.rtcpFeedback.length; t4++)
                  if (r4.rtcpFeedback[t4].type === e4.type && r4.rtcpFeedback[t4].parameter === e4.parameter)
                    return true;
                return false;
              });
              break;
            }
          }
        }), e3.headerExtensions.forEach(function(e4) {
          for (var r4 = 0; r4 < t3.headerExtensions.length; r4++) {
            var n4 = t3.headerExtensions[r4];
            if (e4.uri === n4.uri) {
              i3.headerExtensions.push(n4);
              break;
            }
          }
        }), i3;
      }
      function nT(e3, t3, i3) {
        return -1 !== { offer: { setLocalDescription: ["stable", "have-local-offer"], setRemoteDescription: ["stable", "have-remote-offer"] }, answer: { setLocalDescription: ["have-remote-offer", "have-local-pranswer"], setRemoteDescription: ["have-local-offer", "have-remote-pranswer"] } }[t3][e3].indexOf(i3);
      }
      function oT(e3, t3) {
        var i3 = e3.getRemoteCandidates().find(function(e4) {
          return t3.foundation === e4.foundation && t3.ip === e4.ip && t3.port === e4.port && t3.priority === e4.priority && t3.protocol === e4.protocol && t3.type === e4.type;
        });
        return i3 || e3.addRemoteCandidate(t3), !i3;
      }
      function sT(e3, t3) {
        var i3 = new Error(t3);
        return i3.name = e3, i3.code = { NotSupportedError: 9, InvalidStateError: 11, InvalidAccessError: 15, TypeError: void 0, OperationError: void 0 }[e3], i3;
      }
      var aT = function(e3, t3) {
        function i3(t4, i4) {
          i4.addTrack(t4), i4.dispatchEvent(new e3.MediaStreamTrackEvent("addtrack", { track: t4 }));
        }
        function r3(t4, i4, r4, n4) {
          var o4 = new Event("track");
          o4.track = i4, o4.receiver = r4, o4.transceiver = { receiver: r4 }, o4.streams = n4, e3.setTimeout(function() {
            t4._dispatchEvent("track", o4);
          });
        }
        var n3 = function(i4) {
          var r4 = this, n4 = document.createDocumentFragment();
          if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function(e4) {
            r4[e4] = n4[e4].bind(n4);
          }), this.canTrickleIceCandidates = null, this.needNegotiation = false, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", i4 = JSON.parse(JSON.stringify(i4 || {})), this.usingBundle = "max-bundle" === i4.bundlePolicy, "negotiate" === i4.rtcpMuxPolicy)
            throw sT("NotSupportedError", "rtcpMuxPolicy 'negotiate' is not supported");
          switch (i4.rtcpMuxPolicy || (i4.rtcpMuxPolicy = "require"), i4.iceTransportPolicy) {
            case "all":
            case "relay":
              break;
            default:
              i4.iceTransportPolicy = "all";
          }
          switch (i4.bundlePolicy) {
            case "balanced":
            case "max-compat":
            case "max-bundle":
              break;
            default:
              i4.bundlePolicy = "balanced";
          }
          if (i4.iceServers = function(e4, t4) {
            var i5 = false;
            return (e4 = JSON.parse(JSON.stringify(e4))).filter(function(e5) {
              if (e5 && (e5.urls || e5.url)) {
                var r5 = e5.urls || e5.url;
                e5.url && !e5.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead.");
                var n5 = "string" == typeof r5;
                return n5 && (r5 = [r5]), r5 = r5.filter(function(e6) {
                  return 0 !== e6.indexOf("turn:") || -1 === e6.indexOf("transport=udp") || -1 !== e6.indexOf("turn:[") || i5 ? 0 === e6.indexOf("stun:") && t4 >= 14393 && -1 === e6.indexOf("?transport=udp") : (i5 = true, true);
                }), delete e5.url, e5.urls = n5 ? r5[0] : r5, !!r5.length;
              }
            });
          }(i4.iceServers || [], t3), this._iceGatherers = [], i4.iceCandidatePoolSize)
            for (var o4 = i4.iceCandidatePoolSize; o4 > 0; o4--)
              this._iceGatherers.push(new e3.RTCIceGatherer({ iceServers: i4.iceServers, gatherPolicy: i4.iceTransportPolicy }));
          else
            i4.iceCandidatePoolSize = 0;
          this._config = i4, this.transceivers = [], this._sdpSessionId = tT.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = false;
        };
        Object.defineProperty(n3.prototype, "localDescription", { configurable: true, get: function() {
          return this._localDescription;
        } }), Object.defineProperty(n3.prototype, "remoteDescription", { configurable: true, get: function() {
          return this._remoteDescription;
        } }), n3.prototype.onicecandidate = null, n3.prototype.onaddstream = null, n3.prototype.ontrack = null, n3.prototype.onremovestream = null, n3.prototype.onsignalingstatechange = null, n3.prototype.oniceconnectionstatechange = null, n3.prototype.onconnectionstatechange = null, n3.prototype.onicegatheringstatechange = null, n3.prototype.onnegotiationneeded = null, n3.prototype.ondatachannel = null, n3.prototype._dispatchEvent = function(e4, t4) {
          this._isClosed || (this.dispatchEvent(t4), "function" == typeof this["on" + e4] && this["on" + e4](t4));
        }, n3.prototype._emitGatheringStateChange = function() {
          var e4 = new Event("icegatheringstatechange");
          this._dispatchEvent("icegatheringstatechange", e4);
        }, n3.prototype.getConfiguration = function() {
          return this._config;
        }, n3.prototype.getLocalStreams = function() {
          return this.localStreams;
        }, n3.prototype.getRemoteStreams = function() {
          return this.remoteStreams;
        }, n3.prototype._createTransceiver = function(e4, t4) {
          var i4 = this.transceivers.length > 0, r4 = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: e4, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, associatedRemoteMediaStreams: [], wantReceive: true };
          if (this.usingBundle && i4)
            r4.iceTransport = this.transceivers[0].iceTransport, r4.dtlsTransport = this.transceivers[0].dtlsTransport;
          else {
            var n4 = this._createIceAndDtlsTransports();
            r4.iceTransport = n4.iceTransport, r4.dtlsTransport = n4.dtlsTransport;
          }
          return t4 || this.transceivers.push(r4), r4;
        }, n3.prototype.addTrack = function(t4, i4) {
          if (this._isClosed)
            throw sT("InvalidStateError", "Attempted to call addTrack on a closed peerconnection.");
          var r4;
          if (this.transceivers.find(function(e4) {
            return e4.track === t4;
          }))
            throw sT("InvalidAccessError", "Track already exists.");
          for (var n4 = 0; n4 < this.transceivers.length; n4++)
            this.transceivers[n4].track || this.transceivers[n4].kind !== t4.kind || (r4 = this.transceivers[n4]);
          return r4 || (r4 = this._createTransceiver(t4.kind)), this._maybeFireNegotiationNeeded(), -1 === this.localStreams.indexOf(i4) && this.localStreams.push(i4), r4.track = t4, r4.stream = i4, r4.rtpSender = new e3.RTCRtpSender(t4, r4.dtlsTransport), r4.rtpSender;
        }, n3.prototype.addStream = function(e4) {
          var i4 = this;
          if (t3 >= 15025)
            e4.getTracks().forEach(function(t4) {
              i4.addTrack(t4, e4);
            });
          else {
            var r4 = e4.clone();
            e4.getTracks().forEach(function(e5, t4) {
              var i5 = r4.getTracks()[t4];
              e5.addEventListener("enabled", function(e6) {
                i5.enabled = e6.enabled;
              });
            }), r4.getTracks().forEach(function(e5) {
              i4.addTrack(e5, r4);
            });
          }
        }, n3.prototype.removeTrack = function(t4) {
          if (this._isClosed)
            throw sT("InvalidStateError", "Attempted to call removeTrack on a closed peerconnection.");
          if (!(t4 instanceof e3.RTCRtpSender))
            throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.");
          var i4 = this.transceivers.find(function(e4) {
            return e4.rtpSender === t4;
          });
          if (!i4)
            throw sT("InvalidAccessError", "Sender was not created by this connection.");
          var r4 = i4.stream;
          i4.rtpSender.stop(), i4.rtpSender = null, i4.track = null, i4.stream = null, -1 === this.transceivers.map(function(e4) {
            return e4.stream;
          }).indexOf(r4) && this.localStreams.indexOf(r4) > -1 && this.localStreams.splice(this.localStreams.indexOf(r4), 1), this._maybeFireNegotiationNeeded();
        }, n3.prototype.removeStream = function(e4) {
          var t4 = this;
          e4.getTracks().forEach(function(e5) {
            var i4 = t4.getSenders().find(function(t5) {
              return t5.track === e5;
            });
            i4 && t4.removeTrack(i4);
          });
        }, n3.prototype.getSenders = function() {
          return this.transceivers.filter(function(e4) {
            return !!e4.rtpSender;
          }).map(function(e4) {
            return e4.rtpSender;
          });
        }, n3.prototype.getReceivers = function() {
          return this.transceivers.filter(function(e4) {
            return !!e4.rtpReceiver;
          }).map(function(e4) {
            return e4.rtpReceiver;
          });
        }, n3.prototype._createIceGatherer = function(t4, i4) {
          var r4 = this;
          if (i4 && t4 > 0)
            return this.transceivers[0].iceGatherer;
          if (this._iceGatherers.length)
            return this._iceGatherers.shift();
          var n4 = new e3.RTCIceGatherer({ iceServers: this._config.iceServers, gatherPolicy: this._config.iceTransportPolicy });
          return Object.defineProperty(n4, "state", { value: "new", writable: true }), this.transceivers[t4].bufferedCandidateEvents = [], this.transceivers[t4].bufferCandidates = function(e4) {
            var i5 = !e4.candidate || 0 === Object.keys(e4.candidate).length;
            n4.state = i5 ? "completed" : "gathering", null !== r4.transceivers[t4].bufferedCandidateEvents && r4.transceivers[t4].bufferedCandidateEvents.push(e4);
          }, n4.addEventListener("localcandidate", this.transceivers[t4].bufferCandidates), n4;
        }, n3.prototype._gather = function(t4, i4) {
          var r4 = this, n4 = this.transceivers[i4].iceGatherer;
          if (!n4.onlocalcandidate) {
            var o4 = this.transceivers[i4].bufferedCandidateEvents;
            this.transceivers[i4].bufferedCandidateEvents = null, n4.removeEventListener("localcandidate", this.transceivers[i4].bufferCandidates), n4.onlocalcandidate = function(e4) {
              if (!(r4.usingBundle && i4 > 0)) {
                var o5 = new Event("icecandidate");
                o5.candidate = { sdpMid: t4, sdpMLineIndex: i4 };
                var s3 = e4.candidate, a3 = !s3 || 0 === Object.keys(s3).length;
                if (a3)
                  "new" !== n4.state && "gathering" !== n4.state || (n4.state = "completed");
                else {
                  "new" === n4.state && (n4.state = "gathering"), s3.component = 1, s3.ufrag = n4.getLocalParameters().usernameFragment;
                  var c3 = tT.writeCandidate(s3);
                  o5.candidate = Object.assign(o5.candidate, tT.parseCandidate(c3)), o5.candidate.candidate = c3, o5.candidate.toJSON = function() {
                    return { candidate: o5.candidate.candidate, sdpMid: o5.candidate.sdpMid, sdpMLineIndex: o5.candidate.sdpMLineIndex, usernameFragment: o5.candidate.usernameFragment };
                  };
                }
                var d3 = tT.getMediaSections(r4._localDescription.sdp);
                d3[o5.candidate.sdpMLineIndex] += a3 ? "a=end-of-candidates\r\n" : "a=" + o5.candidate.candidate + "\r\n", r4._localDescription.sdp = tT.getDescription(r4._localDescription.sdp) + d3.join("");
                var u3 = r4.transceivers.every(function(e5) {
                  return e5.iceGatherer && "completed" === e5.iceGatherer.state;
                });
                "gathering" !== r4.iceGatheringState && (r4.iceGatheringState = "gathering", r4._emitGatheringStateChange()), a3 || r4._dispatchEvent("icecandidate", o5), u3 && (r4._dispatchEvent("icecandidate", new Event("icecandidate")), r4.iceGatheringState = "complete", r4._emitGatheringStateChange());
              }
            }, e3.setTimeout(function() {
              o4.forEach(function(e4) {
                n4.onlocalcandidate(e4);
              });
            }, 0);
          }
        }, n3.prototype._createIceAndDtlsTransports = function() {
          var t4 = this, i4 = new e3.RTCIceTransport(null);
          i4.onicestatechange = function() {
            t4._updateIceConnectionState(), t4._updateConnectionState();
          };
          var r4 = new e3.RTCDtlsTransport(i4);
          return r4.ondtlsstatechange = function() {
            t4._updateConnectionState();
          }, r4.onerror = function() {
            Object.defineProperty(r4, "state", { value: "failed", writable: true }), t4._updateConnectionState();
          }, { iceTransport: i4, dtlsTransport: r4 };
        }, n3.prototype._disposeIceAndDtlsTransports = function(e4) {
          var t4 = this.transceivers[e4].iceGatherer;
          t4 && (delete t4.onlocalcandidate, delete this.transceivers[e4].iceGatherer);
          var i4 = this.transceivers[e4].iceTransport;
          i4 && (delete i4.onicestatechange, delete this.transceivers[e4].iceTransport);
          var r4 = this.transceivers[e4].dtlsTransport;
          r4 && (delete r4.ondtlsstatechange, delete r4.onerror, delete this.transceivers[e4].dtlsTransport);
        }, n3.prototype._transceive = function(e4, i4, r4) {
          var n4 = rT(e4.localCapabilities, e4.remoteCapabilities);
          i4 && e4.rtpSender && (n4.encodings = e4.sendEncodingParameters, n4.rtcp = { cname: tT.localCName, compound: e4.rtcpParameters.compound }, e4.recvEncodingParameters.length && (n4.rtcp.ssrc = e4.recvEncodingParameters[0].ssrc), e4.rtpSender.send(n4)), r4 && e4.rtpReceiver && n4.codecs.length > 0 && ("video" === e4.kind && e4.recvEncodingParameters && t3 < 15019 && e4.recvEncodingParameters.forEach(function(e5) {
            delete e5.rtx;
          }), e4.recvEncodingParameters.length ? n4.encodings = e4.recvEncodingParameters : n4.encodings = [{}], n4.rtcp = { compound: e4.rtcpParameters.compound }, e4.rtcpParameters.cname && (n4.rtcp.cname = e4.rtcpParameters.cname), e4.sendEncodingParameters.length && (n4.rtcp.ssrc = e4.sendEncodingParameters[0].ssrc), e4.rtpReceiver.receive(n4));
        }, n3.prototype.setLocalDescription = function(e4) {
          var t4, i4, r4 = this;
          if (-1 === ["offer", "answer"].indexOf(e4.type))
            return Promise.reject(sT("TypeError", 'Unsupported type "' + e4.type + '"'));
          if (!nT("setLocalDescription", e4.type, r4.signalingState) || r4._isClosed)
            return Promise.reject(sT("InvalidStateError", "Can not set local " + e4.type + " in state " + r4.signalingState));
          if ("offer" === e4.type)
            t4 = tT.splitSections(e4.sdp), i4 = t4.shift(), t4.forEach(function(e5, t5) {
              var i5 = tT.parseRtpParameters(e5);
              r4.transceivers[t5].localCapabilities = i5;
            }), r4.transceivers.forEach(function(e5, t5) {
              r4._gather(e5.mid, t5);
            });
          else if ("answer" === e4.type) {
            t4 = tT.splitSections(r4._remoteDescription.sdp), i4 = t4.shift();
            var n4 = tT.matchPrefix(i4, "a=ice-lite").length > 0;
            t4.forEach(function(e5, t5) {
              var o4 = r4.transceivers[t5], s3 = o4.iceGatherer, a3 = o4.iceTransport, c3 = o4.dtlsTransport, d3 = o4.localCapabilities, u3 = o4.remoteCapabilities;
              if (!(tT.isRejected(e5) && 0 === tT.matchPrefix(e5, "a=bundle-only").length) && !o4.rejected) {
                var h3 = tT.getIceParameters(e5, i4), A3 = tT.getDtlsParameters(e5, i4);
                n4 && (A3.role = "server"), r4.usingBundle && 0 !== t5 || (r4._gather(o4.mid, t5), "new" === a3.state && a3.start(s3, h3, n4 ? "controlling" : "controlled"), "new" === c3.state && c3.start(A3));
                var l3 = rT(d3, u3);
                r4._transceive(o4, l3.codecs.length > 0, false);
              }
            });
          }
          return r4._localDescription = { type: e4.type, sdp: e4.sdp }, "offer" === e4.type ? r4._updateSignalingState("have-local-offer") : r4._updateSignalingState("stable"), Promise.resolve();
        }, n3.prototype.setRemoteDescription = function(n4) {
          var o4 = this;
          if (-1 === ["offer", "answer"].indexOf(n4.type))
            return Promise.reject(sT("TypeError", 'Unsupported type "' + n4.type + '"'));
          if (!nT("setRemoteDescription", n4.type, o4.signalingState) || o4._isClosed)
            return Promise.reject(sT("InvalidStateError", "Can not set remote " + n4.type + " in state " + o4.signalingState));
          var s3 = {};
          o4.remoteStreams.forEach(function(e4) {
            s3[e4.id] = e4;
          });
          var a3 = [], c3 = tT.splitSections(n4.sdp), d3 = c3.shift(), u3 = tT.matchPrefix(d3, "a=ice-lite").length > 0, h3 = tT.matchPrefix(d3, "a=group:BUNDLE ").length > 0;
          o4.usingBundle = h3;
          var A3 = tT.matchPrefix(d3, "a=ice-options:")[0];
          return o4.canTrickleIceCandidates = !!A3 && A3.substr(14).split(" ").indexOf("trickle") >= 0, c3.forEach(function(r4, c4) {
            var A4 = tT.splitLines(r4), l3 = tT.getKind(r4), p3 = tT.isRejected(r4) && 0 === tT.matchPrefix(r4, "a=bundle-only").length, g3 = A4[0].substr(2).split(" ")[2], E3 = tT.getDirection(r4, d3), f3 = tT.parseMsid(r4), m3 = tT.getMid(r4) || tT.generateIdentifier();
            if (p3 || "application" === l3 && ("DTLS/SCTP" === g3 || "UDP/DTLS/SCTP" === g3))
              o4.transceivers[c4] = { mid: m3, kind: l3, protocol: g3, rejected: true };
            else {
              var I3, _3, C3, S3, v3, T3, R3, y3, w3;
              !p3 && o4.transceivers[c4] && o4.transceivers[c4].rejected && (o4.transceivers[c4] = o4._createTransceiver(l3, true));
              var b3, N3, O3 = tT.parseRtpParameters(r4);
              p3 || (b3 = tT.getIceParameters(r4, d3), (N3 = tT.getDtlsParameters(r4, d3)).role = "client"), R3 = tT.parseRtpEncodingParameters(r4);
              var D3 = tT.parseRtcpParameters(r4), P3 = tT.matchPrefix(r4, "a=end-of-candidates", d3).length > 0, L3 = tT.matchPrefix(r4, "a=candidate:").map(function(e4) {
                return tT.parseCandidate(e4);
              }).filter(function(e4) {
                return 1 === e4.component;
              });
              if (("offer" === n4.type || "answer" === n4.type) && !p3 && h3 && c4 > 0 && o4.transceivers[c4] && (o4._disposeIceAndDtlsTransports(c4), o4.transceivers[c4].iceGatherer = o4.transceivers[0].iceGatherer, o4.transceivers[c4].iceTransport = o4.transceivers[0].iceTransport, o4.transceivers[c4].dtlsTransport = o4.transceivers[0].dtlsTransport, o4.transceivers[c4].rtpSender && o4.transceivers[c4].rtpSender.setTransport(o4.transceivers[0].dtlsTransport), o4.transceivers[c4].rtpReceiver && o4.transceivers[c4].rtpReceiver.setTransport(o4.transceivers[0].dtlsTransport)), "offer" !== n4.type || p3) {
                if ("answer" === n4.type && !p3) {
                  _3 = (I3 = o4.transceivers[c4]).iceGatherer, C3 = I3.iceTransport, S3 = I3.dtlsTransport, v3 = I3.rtpReceiver, T3 = I3.sendEncodingParameters, y3 = I3.localCapabilities, o4.transceivers[c4].recvEncodingParameters = R3, o4.transceivers[c4].remoteCapabilities = O3, o4.transceivers[c4].rtcpParameters = D3, L3.length && "new" === C3.state && (!u3 && !P3 || h3 && 0 !== c4 ? L3.forEach(function(e4) {
                    oT(I3.iceTransport, e4);
                  }) : C3.setRemoteCandidates(L3)), h3 && 0 !== c4 || ("new" === C3.state && C3.start(_3, b3, "controlling"), "new" === S3.state && S3.start(N3)), !rT(I3.localCapabilities, I3.remoteCapabilities).codecs.filter(function(e4) {
                    return "rtx" === e4.name.toLowerCase();
                  }).length && I3.sendEncodingParameters[0].rtx && delete I3.sendEncodingParameters[0].rtx, o4._transceive(I3, "sendrecv" === E3 || "recvonly" === E3, "sendrecv" === E3 || "sendonly" === E3), !v3 || "sendrecv" !== E3 && "sendonly" !== E3 ? delete I3.rtpReceiver : (w3 = v3.track, f3 ? (s3[f3.stream] || (s3[f3.stream] = new e3.MediaStream()), i3(w3, s3[f3.stream]), a3.push([w3, v3, s3[f3.stream]])) : (s3.default || (s3.default = new e3.MediaStream()), i3(w3, s3.default), a3.push([w3, v3, s3.default])));
                }
              } else {
                (I3 = o4.transceivers[c4] || o4._createTransceiver(l3)).mid = m3, I3.iceGatherer || (I3.iceGatherer = o4._createIceGatherer(c4, h3)), L3.length && "new" === I3.iceTransport.state && (!P3 || h3 && 0 !== c4 ? L3.forEach(function(e4) {
                  oT(I3.iceTransport, e4);
                }) : I3.iceTransport.setRemoteCandidates(L3)), y3 = e3.RTCRtpReceiver.getCapabilities(l3), t3 < 15019 && (y3.codecs = y3.codecs.filter(function(e4) {
                  return "rtx" !== e4.name;
                })), T3 = I3.sendEncodingParameters || [{ ssrc: 1001 * (2 * c4 + 2) }];
                var k3, B3 = false;
                if ("sendrecv" === E3 || "sendonly" === E3) {
                  if (B3 = !I3.rtpReceiver, v3 = I3.rtpReceiver || new e3.RTCRtpReceiver(I3.dtlsTransport, l3), B3)
                    w3 = v3.track, f3 && "-" === f3.stream || (f3 ? (s3[f3.stream] || (s3[f3.stream] = new e3.MediaStream(), Object.defineProperty(s3[f3.stream], "id", { get: function() {
                      return f3.stream;
                    } })), Object.defineProperty(w3, "id", { get: function() {
                      return f3.track;
                    } }), k3 = s3[f3.stream]) : (s3.default || (s3.default = new e3.MediaStream()), k3 = s3.default)), k3 && (i3(w3, k3), I3.associatedRemoteMediaStreams.push(k3)), a3.push([w3, v3, k3]);
                } else
                  I3.rtpReceiver && I3.rtpReceiver.track && (I3.associatedRemoteMediaStreams.forEach(function(t4) {
                    var i4 = t4.getTracks().find(function(e4) {
                      return e4.id === I3.rtpReceiver.track.id;
                    });
                    i4 && function(t5, i5) {
                      i5.removeTrack(t5), i5.dispatchEvent(new e3.MediaStreamTrackEvent("removetrack", { track: t5 }));
                    }(i4, t4);
                  }), I3.associatedRemoteMediaStreams = []);
                I3.localCapabilities = y3, I3.remoteCapabilities = O3, I3.rtpReceiver = v3, I3.rtcpParameters = D3, I3.sendEncodingParameters = T3, I3.recvEncodingParameters = R3, o4._transceive(o4.transceivers[c4], false, B3);
              }
            }
          }), void 0 === o4._dtlsRole && (o4._dtlsRole = "offer" === n4.type ? "active" : "passive"), o4._remoteDescription = { type: n4.type, sdp: n4.sdp }, "offer" === n4.type ? o4._updateSignalingState("have-remote-offer") : o4._updateSignalingState("stable"), Object.keys(s3).forEach(function(t4) {
            var i4 = s3[t4];
            if (i4.getTracks().length) {
              if (-1 === o4.remoteStreams.indexOf(i4)) {
                o4.remoteStreams.push(i4);
                var n5 = new Event("addstream");
                n5.stream = i4, e3.setTimeout(function() {
                  o4._dispatchEvent("addstream", n5);
                });
              }
              a3.forEach(function(e4) {
                var t5 = e4[0], n6 = e4[1];
                i4.id === e4[2].id && r3(o4, t5, n6, [i4]);
              });
            }
          }), a3.forEach(function(e4) {
            e4[2] || r3(o4, e4[0], e4[1], []);
          }), e3.setTimeout(function() {
            o4 && o4.transceivers && o4.transceivers.forEach(function(e4) {
              e4.iceTransport && "new" === e4.iceTransport.state && e4.iceTransport.getRemoteCandidates().length > 0 && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), e4.iceTransport.addRemoteCandidate({}));
            });
          }, 4e3), Promise.resolve();
        }, n3.prototype.close = function() {
          this.transceivers.forEach(function(e4) {
            e4.iceTransport && e4.iceTransport.stop(), e4.dtlsTransport && e4.dtlsTransport.stop(), e4.rtpSender && e4.rtpSender.stop(), e4.rtpReceiver && e4.rtpReceiver.stop();
          }), this._isClosed = true, this._updateSignalingState("closed");
        }, n3.prototype._updateSignalingState = function(e4) {
          this.signalingState = e4;
          var t4 = new Event("signalingstatechange");
          this._dispatchEvent("signalingstatechange", t4);
        }, n3.prototype._maybeFireNegotiationNeeded = function() {
          var t4 = this;
          "stable" === this.signalingState && true !== this.needNegotiation && (this.needNegotiation = true, e3.setTimeout(function() {
            if (t4.needNegotiation) {
              t4.needNegotiation = false;
              var e4 = new Event("negotiationneeded");
              t4._dispatchEvent("negotiationneeded", e4);
            }
          }, 0));
        }, n3.prototype._updateIceConnectionState = function() {
          var e4, t4 = { new: 0, closed: 0, checking: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 };
          if (this.transceivers.forEach(function(e5) {
            e5.iceTransport && !e5.rejected && t4[e5.iceTransport.state]++;
          }), e4 = "new", t4.failed > 0 ? e4 = "failed" : t4.checking > 0 ? e4 = "checking" : t4.disconnected > 0 ? e4 = "disconnected" : t4.new > 0 ? e4 = "new" : t4.connected > 0 ? e4 = "connected" : t4.completed > 0 && (e4 = "completed"), e4 !== this.iceConnectionState) {
            this.iceConnectionState = e4;
            var i4 = new Event("iceconnectionstatechange");
            this._dispatchEvent("iceconnectionstatechange", i4);
          }
        }, n3.prototype._updateConnectionState = function() {
          var e4, t4 = { new: 0, closed: 0, connecting: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 };
          if (this.transceivers.forEach(function(e5) {
            e5.iceTransport && e5.dtlsTransport && !e5.rejected && (t4[e5.iceTransport.state]++, t4[e5.dtlsTransport.state]++);
          }), t4.connected += t4.completed, e4 = "new", t4.failed > 0 ? e4 = "failed" : t4.connecting > 0 ? e4 = "connecting" : t4.disconnected > 0 ? e4 = "disconnected" : t4.new > 0 ? e4 = "new" : t4.connected > 0 && (e4 = "connected"), e4 !== this.connectionState) {
            this.connectionState = e4;
            var i4 = new Event("connectionstatechange");
            this._dispatchEvent("connectionstatechange", i4);
          }
        }, n3.prototype.createOffer = function() {
          var i4 = this;
          if (i4._isClosed)
            return Promise.reject(sT("InvalidStateError", "Can not call createOffer after close"));
          var r4 = i4.transceivers.filter(function(e4) {
            return "audio" === e4.kind;
          }).length, n4 = i4.transceivers.filter(function(e4) {
            return "video" === e4.kind;
          }).length, o4 = arguments[0];
          if (o4) {
            if (o4.mandatory || o4.optional)
              throw new TypeError("Legacy mandatory/optional constraints not supported.");
            void 0 !== o4.offerToReceiveAudio && (r4 = true === o4.offerToReceiveAudio ? 1 : false === o4.offerToReceiveAudio ? 0 : o4.offerToReceiveAudio), void 0 !== o4.offerToReceiveVideo && (n4 = true === o4.offerToReceiveVideo ? 1 : false === o4.offerToReceiveVideo ? 0 : o4.offerToReceiveVideo);
          }
          for (i4.transceivers.forEach(function(e4) {
            "audio" === e4.kind ? --r4 < 0 && (e4.wantReceive = false) : "video" === e4.kind && --n4 < 0 && (e4.wantReceive = false);
          }); r4 > 0 || n4 > 0; )
            r4 > 0 && (i4._createTransceiver("audio"), r4--), n4 > 0 && (i4._createTransceiver("video"), n4--);
          var s3 = tT.writeSessionBoilerplate(i4._sdpSessionId, i4._sdpSessionVersion++);
          i4.transceivers.forEach(function(r5, n5) {
            var o5 = r5.track, s4 = r5.kind, a4 = r5.mid || tT.generateIdentifier();
            r5.mid = a4, r5.iceGatherer || (r5.iceGatherer = i4._createIceGatherer(n5, i4.usingBundle));
            var c3 = e3.RTCRtpSender.getCapabilities(s4);
            t3 < 15019 && (c3.codecs = c3.codecs.filter(function(e4) {
              return "rtx" !== e4.name;
            })), c3.codecs.forEach(function(e4) {
              "H264" === e4.name && void 0 === e4.parameters["level-asymmetry-allowed"] && (e4.parameters["level-asymmetry-allowed"] = "1"), r5.remoteCapabilities && r5.remoteCapabilities.codecs && r5.remoteCapabilities.codecs.forEach(function(t4) {
                e4.name.toLowerCase() === t4.name.toLowerCase() && e4.clockRate === t4.clockRate && (e4.preferredPayloadType = t4.payloadType);
              });
            }), c3.headerExtensions.forEach(function(e4) {
              (r5.remoteCapabilities && r5.remoteCapabilities.headerExtensions || []).forEach(function(t4) {
                e4.uri === t4.uri && (e4.id = t4.id);
              });
            });
            var d3 = r5.sendEncodingParameters || [{ ssrc: 1001 * (2 * n5 + 1) }];
            o5 && t3 >= 15019 && "video" === s4 && !d3[0].rtx && (d3[0].rtx = { ssrc: d3[0].ssrc + 1 }), r5.wantReceive && (r5.rtpReceiver = new e3.RTCRtpReceiver(r5.dtlsTransport, s4)), r5.localCapabilities = c3, r5.sendEncodingParameters = d3;
          }), "max-compat" !== i4._config.bundlePolicy && (s3 += "a=group:BUNDLE " + i4.transceivers.map(function(e4) {
            return e4.mid;
          }).join(" ") + "\r\n"), s3 += "a=ice-options:trickle\r\n", i4.transceivers.forEach(function(e4, t4) {
            s3 += iT(e4, e4.localCapabilities, "offer", e4.stream, i4._dtlsRole), s3 += "a=rtcp-rsize\r\n", !e4.iceGatherer || "new" === i4.iceGatheringState || 0 !== t4 && i4.usingBundle || (e4.iceGatherer.getLocalCandidates().forEach(function(e5) {
              e5.component = 1, s3 += "a=" + tT.writeCandidate(e5) + "\r\n";
            }), "completed" === e4.iceGatherer.state && (s3 += "a=end-of-candidates\r\n"));
          });
          var a3 = new e3.RTCSessionDescription({ type: "offer", sdp: s3 });
          return Promise.resolve(a3);
        }, n3.prototype.createAnswer = function() {
          var i4 = this;
          if (i4._isClosed)
            return Promise.reject(sT("InvalidStateError", "Can not call createAnswer after close"));
          if ("have-remote-offer" !== i4.signalingState && "have-local-pranswer" !== i4.signalingState)
            return Promise.reject(sT("InvalidStateError", "Can not call createAnswer in signalingState " + i4.signalingState));
          var r4 = tT.writeSessionBoilerplate(i4._sdpSessionId, i4._sdpSessionVersion++);
          i4.usingBundle && (r4 += "a=group:BUNDLE " + i4.transceivers.map(function(e4) {
            return e4.mid;
          }).join(" ") + "\r\n"), r4 += "a=ice-options:trickle\r\n";
          var n4 = tT.getMediaSections(i4._remoteDescription.sdp).length;
          i4.transceivers.forEach(function(e4, o5) {
            if (!(o5 + 1 > n4)) {
              if (e4.rejected)
                return "application" === e4.kind ? "DTLS/SCTP" === e4.protocol ? r4 += "m=application 0 DTLS/SCTP 5000\r\n" : r4 += "m=application 0 " + e4.protocol + " webrtc-datachannel\r\n" : "audio" === e4.kind ? r4 += "m=audio 0 UDP/TLS/RTP/SAVPF 0\r\na=rtpmap:0 PCMU/8000\r\n" : "video" === e4.kind && (r4 += "m=video 0 UDP/TLS/RTP/SAVPF 120\r\na=rtpmap:120 VP8/90000\r\n"), void (r4 += "c=IN IP4 0.0.0.0\r\na=inactive\r\na=mid:" + e4.mid + "\r\n");
              var s3;
              if (e4.stream)
                "audio" === e4.kind ? s3 = e4.stream.getAudioTracks()[0] : "video" === e4.kind && (s3 = e4.stream.getVideoTracks()[0]), s3 && t3 >= 15019 && "video" === e4.kind && !e4.sendEncodingParameters[0].rtx && (e4.sendEncodingParameters[0].rtx = { ssrc: e4.sendEncodingParameters[0].ssrc + 1 });
              var a3 = rT(e4.localCapabilities, e4.remoteCapabilities);
              !a3.codecs.filter(function(e5) {
                return "rtx" === e5.name.toLowerCase();
              }).length && e4.sendEncodingParameters[0].rtx && delete e4.sendEncodingParameters[0].rtx, r4 += iT(e4, a3, "answer", e4.stream, i4._dtlsRole), e4.rtcpParameters && e4.rtcpParameters.reducedSize && (r4 += "a=rtcp-rsize\r\n");
            }
          });
          var o4 = new e3.RTCSessionDescription({ type: "answer", sdp: r4 });
          return Promise.resolve(o4);
        }, n3.prototype.addIceCandidate = function(e4) {
          var t4, i4 = this;
          return e4 && void 0 === e4.sdpMLineIndex && !e4.sdpMid ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise(function(r4, n4) {
            if (!i4._remoteDescription)
              return n4(sT("InvalidStateError", "Can not add ICE candidate without a remote description"));
            if (e4 && "" !== e4.candidate) {
              var o4 = e4.sdpMLineIndex;
              if (e4.sdpMid) {
                for (var s3 = 0; s3 < i4.transceivers.length; s3++)
                  if (i4.transceivers[s3].mid === e4.sdpMid) {
                    o4 = s3;
                    break;
                  }
              }
              var a3 = i4.transceivers[o4];
              if (!a3)
                return n4(sT("OperationError", "Can not add ICE candidate"));
              if (a3.rejected)
                return r4();
              var c3 = Object.keys(e4.candidate).length > 0 ? tT.parseCandidate(e4.candidate) : {};
              if ("tcp" === c3.protocol && (0 === c3.port || 9 === c3.port))
                return r4();
              if (c3.component && 1 !== c3.component)
                return r4();
              if ((0 === o4 || o4 > 0 && a3.iceTransport !== i4.transceivers[0].iceTransport) && !oT(a3.iceTransport, c3))
                return n4(sT("OperationError", "Can not add ICE candidate"));
              var d3 = e4.candidate.trim();
              0 === d3.indexOf("a=") && (d3 = d3.substr(2)), (t4 = tT.getMediaSections(i4._remoteDescription.sdp))[o4] += "a=" + (c3.type ? d3 : "end-of-candidates") + "\r\n", i4._remoteDescription.sdp = tT.getDescription(i4._remoteDescription.sdp) + t4.join("");
            } else
              for (var u3 = 0; u3 < i4.transceivers.length && (i4.transceivers[u3].rejected || (i4.transceivers[u3].iceTransport.addRemoteCandidate({}), (t4 = tT.getMediaSections(i4._remoteDescription.sdp))[u3] += "a=end-of-candidates\r\n", i4._remoteDescription.sdp = tT.getDescription(i4._remoteDescription.sdp) + t4.join(""), !i4.usingBundle)); u3++)
                ;
            r4();
          });
        }, n3.prototype.getStats = function(t4) {
          if (t4 && t4 instanceof e3.MediaStreamTrack) {
            var i4 = null;
            if (this.transceivers.forEach(function(e4) {
              e4.rtpSender && e4.rtpSender.track === t4 ? i4 = e4.rtpSender : e4.rtpReceiver && e4.rtpReceiver.track === t4 && (i4 = e4.rtpReceiver);
            }), !i4)
              throw sT("InvalidAccessError", "Invalid selector.");
            return i4.getStats();
          }
          var r4 = [];
          return this.transceivers.forEach(function(e4) {
            ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach(function(t5) {
              e4[t5] && r4.push(e4[t5].getStats());
            });
          }), Promise.all(r4).then(function(e4) {
            var t5 = /* @__PURE__ */ new Map();
            return e4.forEach(function(e5) {
              e5.forEach(function(e6) {
                t5.set(e6.id, e6);
              });
            }), t5;
          });
        };
        ["RTCRtpSender", "RTCRtpReceiver", "RTCIceGatherer", "RTCIceTransport", "RTCDtlsTransport"].forEach(function(t4) {
          var i4 = e3[t4];
          if (i4 && i4.prototype && i4.prototype.getStats) {
            var r4 = i4.prototype.getStats;
            i4.prototype.getStats = function() {
              return r4.apply(this).then(function(e4) {
                var t5 = /* @__PURE__ */ new Map();
                return Object.keys(e4).forEach(function(i5) {
                  var r5;
                  e4[i5].type = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[(r5 = e4[i5]).type] || r5.type, t5.set(i5, e4[i5]);
                }), t5;
              });
            };
          }
        });
        var o3 = ["createOffer", "createAnswer"];
        return o3.forEach(function(e4) {
          var t4 = n3.prototype[e4];
          n3.prototype[e4] = function() {
            var e5 = arguments;
            return "function" == typeof e5[0] || "function" == typeof e5[1] ? t4.apply(this, [arguments[2]]).then(function(t5) {
              "function" == typeof e5[0] && e5[0].apply(null, [t5]);
            }, function(t5) {
              "function" == typeof e5[1] && e5[1].apply(null, [t5]);
            }) : t4.apply(this, arguments);
          };
        }), (o3 = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"]).forEach(function(e4) {
          var t4 = n3.prototype[e4];
          n3.prototype[e4] = function() {
            var e5 = arguments;
            return "function" == typeof e5[1] || "function" == typeof e5[2] ? t4.apply(this, arguments).then(function() {
              "function" == typeof e5[1] && e5[1].apply(null);
            }, function(t5) {
              "function" == typeof e5[2] && e5[2].apply(null, [t5]);
            }) : t4.apply(this, arguments);
          };
        }), ["getStats"].forEach(function(e4) {
          var t4 = n3.prototype[e4];
          n3.prototype[e4] = function() {
            var e5 = arguments;
            return "function" == typeof e5[1] ? t4.apply(this, arguments).then(function() {
              "function" == typeof e5[1] && e5[1].apply(null);
            }) : t4.apply(this, arguments);
          };
        }), n3;
      };
      function cT(e3) {
        const t3 = e3 && e3.navigator, i3 = t3.mediaDevices.getUserMedia.bind(t3.mediaDevices);
        t3.mediaDevices.getUserMedia = function(e4) {
          return i3(e4).catch((e5) => l_.reject(function(e6) {
            return { name: { PermissionDeniedError: "NotAllowedError" }[e6.name] || e6.name, message: e6.message, constraint: e6.constraint, toString() {
              return this.name;
            } };
          }(e5)));
        };
      }
      function dT(e3) {
        "getDisplayMedia" in e3.navigator && e3.navigator.mediaDevices && (e3.navigator.mediaDevices && "getDisplayMedia" in e3.navigator.mediaDevices || (e3.navigator.mediaDevices.getDisplayMedia = e3.navigator.getDisplayMedia.bind(e3.navigator)));
      }
      function uT(e3, t3) {
        if (e3.RTCIceGatherer && (e3.RTCIceCandidate || (e3.RTCIceCandidate = function(e4) {
          return e4;
        }), e3.RTCSessionDescription || (e3.RTCSessionDescription = function(e4) {
          return e4;
        }), t3.version < 15025)) {
          const t4 = Object.getOwnPropertyDescriptor(e3.MediaStreamTrack.prototype, "enabled");
          Object.defineProperty(e3.MediaStreamTrack.prototype, "enabled", { set(e4) {
            t4.set.call(this, e4);
            const i4 = new Event("enabled");
            i4.enabled = e4, this.dispatchEvent(i4);
          } });
        }
        e3.RTCRtpSender && !("dtmf" in e3.RTCRtpSender.prototype) && Object.defineProperty(e3.RTCRtpSender.prototype, "dtmf", { get() {
          return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = new e3.RTCDtmfSender(this) : "video" === this.track.kind && (this._dtmf = null)), this._dtmf;
        } }), e3.RTCDtmfSender && !e3.RTCDTMFSender && (e3.RTCDTMFSender = e3.RTCDtmfSender);
        const i3 = aT(e3, t3.version);
        e3.RTCPeerConnection = function(e4) {
          return e4 && e4.iceServers && (e4.iceServers = function(e5, t4) {
            let i4 = false;
            return (e5 = JSON.parse(JSON.stringify(e5))).filter((e6) => {
              if (e6 && (e6.urls || e6.url)) {
                let t5 = e6.urls || e6.url;
                e6.url && !e6.urls && Yh("RTCIceServer.url", "RTCIceServer.urls");
                const r3 = "string" == typeof t5;
                return r3 && (t5 = [t5]), t5 = t5.filter((e7) => {
                  if (0 === e7.indexOf("stun:"))
                    return false;
                  const t6 = e7.startsWith("turn") && !e7.startsWith("turn:[") && e7.includes("transport=udp");
                  return t6 && !i4 ? (i4 = true, true) : t6 && !i4;
                }), delete e6.url, e6.urls = r3 ? t5[0] : t5, !!t5.length;
              }
            });
          }(e4.iceServers, t3.version), Wh("ICE servers after filtering:", e4.iceServers)), new i3(e4);
        }, e3.RTCPeerConnection.prototype = i3.prototype;
      }
      function hT(e3) {
        e3.RTCRtpSender && !("replaceTrack" in e3.RTCRtpSender.prototype) && (e3.RTCRtpSender.prototype.replaceTrack = e3.RTCRtpSender.prototype.setTrack);
      }
      var AT = Object.freeze({ __proto__: null, shimPeerConnection: uT, shimReplaceTrack: hT, shimGetUserMedia: cT, shimGetDisplayMedia: dT }), lT = i.Promise, pT = Ht.exports, gT = function(e3, t3, i3) {
        for (var r3 in t3)
          pT(e3, r3, t3[r3], i3);
        return e3;
      }, ET = ge, fT = s, mT = S(S.bind), IT = function(e3, t3) {
        return ET(e3), void 0 === t3 ? e3 : fT ? mT(e3, t3) : function() {
          return e3.apply(t3, arguments);
        };
      }, _T = Pd, CT = ze("iterator"), ST = Array.prototype, vT = function(e3) {
        return void 0 !== e3 && (_T.Array === e3 || ST[CT] === e3);
      }, TT = fc, RT = fe, yT = Pd, wT = ze("iterator"), bT = function(e3) {
        if (null != e3)
          return RT(e3, wT) || RT(e3, "@@iterator") || yT[TT(e3)];
      }, NT = d, OT = ge, DT = Ot, PT = he, LT = bT, kT = i.TypeError, BT = function(e3, t3) {
        var i3 = arguments.length < 2 ? LT(e3) : t3;
        if (OT(i3))
          return DT(NT(i3, e3));
        throw kT(PT(e3) + " is not iterable");
      }, MT = d, UT = Ot, xT = fe, QT = IT, FT = d, VT = Ot, jT = he, GT = vT, KT = er, HT = H, WT = BT, YT = bT, JT = function(e3, t3, i3) {
        var r3, n3;
        UT(e3);
        try {
          if (!(r3 = xT(e3, "return"))) {
            if ("throw" === t3)
              throw i3;
            return i3;
          }
          r3 = MT(r3, e3);
        } catch (e4) {
          n3 = true, r3 = e4;
        }
        if ("throw" === t3)
          throw i3;
        if (n3)
          throw r3;
        return UT(r3), i3;
      }, qT = i.TypeError, XT = function(e3, t3) {
        this.stopped = e3, this.result = t3;
      }, zT = XT.prototype, ZT = ze("iterator"), $T = false;
      try {
        var eR = 0, tR = { next: function() {
          return { done: !!eR++ };
        }, return: function() {
          $T = true;
        } };
        tR[ZT] = function() {
          return this;
        }, Array.from(tR, function() {
          throw 2;
        });
      } catch (e3) {
      }
      var iR = function(e3, t3) {
        if (!t3 && !$T)
          return false;
        var i3 = false;
        try {
          var r3 = {};
          r3[ZT] = function() {
            return { next: function() {
              return { done: i3 = true };
            } };
          }, e3(r3);
        } catch (e4) {
        }
        return i3;
      }, rR = S, nR = n, oR = x, sR = fc, aR = Zt, cR = function() {
      }, dR = [], uR = K("Reflect", "construct"), hR = /^\s*(?:class|function)\b/, AR = rR(hR.exec), lR = !hR.exec(cR), pR = function(e3) {
        if (!oR(e3))
          return false;
        try {
          return uR(cR, dR, e3), true;
        } catch (e4) {
          return false;
        }
      }, gR = function(e3) {
        if (!oR(e3))
          return false;
        switch (sR(e3)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return lR || !!AR(hR, aR(e3));
        } catch (e4) {
          return true;
        }
      };
      gR.sham = true;
      var ER, fR, mR, IR, _R = !uR || nR(function() {
        var e3;
        return pR(pR.call) || !pR(Object) || !pR(function() {
          e3 = true;
        }) || e3;
      }) ? gR : pR, CR = _R, SR = he, vR = i.TypeError, TR = function(e3) {
        if (CR(e3))
          return e3;
        throw vR(SR(e3) + " is not a constructor");
      }, RR = Ot, yR = TR, wR = ze("species"), bR = function(e3, t3) {
        var i3, r3 = RR(e3).constructor;
        return void 0 === r3 || null == (i3 = RR(r3)[wR]) ? t3 : yR(i3);
      }, NR = S([].slice), OR = /(?:ipad|iphone|ipod).*applewebkit/i.test(W), DR = i, PR = Jr, LR = IT, kR = x, BR = Be, MR = n, UR = Qc, xR = NR, QR = At, FR = OR, VR = p_, jR = DR.setImmediate, GR = DR.clearImmediate, KR = DR.process, HR = DR.Dispatch, WR = DR.Function, YR = DR.MessageChannel, JR = DR.String, qR = 0, XR = {}, zR = "onreadystatechange";
      try {
        ER = DR.location;
      } catch (e3) {
      }
      var ZR = function(e3) {
        if (BR(XR, e3)) {
          var t3 = XR[e3];
          delete XR[e3], t3();
        }
      }, $R = function(e3) {
        return function() {
          ZR(e3);
        };
      }, ey = function(e3) {
        ZR(e3.data);
      }, ty = function(e3) {
        DR.postMessage(JR(e3), ER.protocol + "//" + ER.host);
      };
      jR && GR || (jR = function(e3) {
        var t3 = xR(arguments, 1);
        return XR[++qR] = function() {
          PR(kR(e3) ? e3 : WR(e3), void 0, t3);
        }, fR(qR), qR;
      }, GR = function(e3) {
        delete XR[e3];
      }, VR ? fR = function(e3) {
        KR.nextTick($R(e3));
      } : HR && HR.now ? fR = function(e3) {
        HR.now($R(e3));
      } : YR && !FR ? (IR = (mR = new YR()).port2, mR.port1.onmessage = ey, fR = LR(IR.postMessage, IR)) : DR.addEventListener && kR(DR.postMessage) && !DR.importScripts && ER && "file:" !== ER.protocol && !MR(ty) ? (fR = ty, DR.addEventListener("message", ey, false)) : fR = zR in QR("script") ? function(e3) {
        UR.appendChild(QR("script")).onreadystatechange = function() {
          UR.removeChild(this), ZR(e3);
        };
      } : function(e3) {
        setTimeout($R(e3), 0);
      });
      var iy, ry, ny, oy, sy, ay, cy, dy, uy = { set: jR, clear: GR }, hy = i, Ay = /ipad|iphone|ipod/i.test(W) && void 0 !== hy.Pebble, ly = /web0s(?!.*chrome)/i.test(W), py = i, gy = IT, Ey = r.f, fy = uy.set, my = OR, Iy = Ay, _y = ly, Cy = p_, Sy = py.MutationObserver || py.WebKitMutationObserver, vy = py.document, Ty = py.process, Ry = py.Promise, yy = Ey(py, "queueMicrotask"), wy = yy && yy.value;
      wy || (iy = function() {
        var e3, t3;
        for (Cy && (e3 = Ty.domain) && e3.exit(); ry; ) {
          t3 = ry.fn, ry = ry.next;
          try {
            t3();
          } catch (e4) {
            throw ry ? oy() : ny = void 0, e4;
          }
        }
        ny = void 0, e3 && e3.enter();
      }, my || Cy || _y || !Sy || !vy ? !Iy && Ry && Ry.resolve ? ((cy = Ry.resolve(void 0)).constructor = Ry, dy = gy(cy.then, cy), oy = function() {
        dy(iy);
      }) : Cy ? oy = function() {
        Ty.nextTick(iy);
      } : (fy = gy(fy, py), oy = function() {
        fy(iy);
      }) : (sy = true, ay = vy.createTextNode(""), new Sy(iy).observe(ay, { characterData: true }), oy = function() {
        ay.data = sy = !sy;
      }));
      var by = wy || function(e3) {
        var t3 = { fn: e3, next: void 0 };
        ny && (ny.next = t3), ry || (ry = t3, oy()), ny = t3;
      }, Ny = {}, Oy = ge, Dy = function(e3) {
        var t3, i3;
        this.promise = new e3(function(e4, r3) {
          if (void 0 !== t3 || void 0 !== i3)
            throw TypeError("Bad Promise constructor");
          t3 = e4, i3 = r3;
        }), this.resolve = Oy(t3), this.reject = Oy(i3);
      };
      Ny.f = function(e3) {
        return new Dy(e3);
      };
      var Py = Ot, Ly = F, ky = Ny, By = function(e3, t3) {
        if (Py(e3), Ly(t3) && t3.constructor === e3)
          return t3;
        var i3 = ky.f(e3);
        return (0, i3.resolve)(t3), i3.promise;
      }, My = i, Uy = function() {
        this.head = null, this.tail = null;
      };
      Uy.prototype = { add: function(e3) {
        var t3 = { item: e3, next: null };
        this.head ? this.tail.next = t3 : this.head = t3, this.tail = t3;
      }, get: function() {
        var e3 = this.head;
        if (e3)
          return this.head = e3.next, this.tail === e3 && (this.tail = null), e3.item;
      } };
      var xy, Qy, Fy, Vy, jy = Uy, Gy = "object" == typeof window, Ky = Gr, Hy = i, Wy = K, Yy = d, Jy = lT, qy = Ht.exports, Xy = gT, zy = lu, Zy = $d, $y = WS, ew = ge, tw = x, iw = F, rw = m_, nw = Zt, ow = function(e3, t3, i3) {
        var r3, n3, o3, s3, a3, c3, d3, u3 = i3 && i3.that, h3 = !(!i3 || !i3.AS_ENTRIES), A3 = !(!i3 || !i3.IS_ITERATOR), l3 = !(!i3 || !i3.INTERRUPTED), p3 = QT(t3, u3), g3 = function(e4) {
          return r3 && JT(r3, "normal", e4), new XT(true, e4);
        }, E3 = function(e4) {
          return h3 ? (VT(e4), l3 ? p3(e4[0], e4[1], g3) : p3(e4[0], e4[1])) : l3 ? p3(e4, g3) : p3(e4);
        };
        if (A3)
          r3 = e3;
        else {
          if (!(n3 = YT(e3)))
            throw qT(jT(e3) + " is not iterable");
          if (GT(n3)) {
            for (o3 = 0, s3 = KT(e3); s3 > o3; o3++)
              if ((a3 = E3(e3[o3])) && HT(zT, a3))
                return a3;
            return new XT(false);
          }
          r3 = WT(e3, n3);
        }
        for (c3 = r3.next; !(d3 = FT(c3, r3)).done; ) {
          try {
            a3 = E3(d3.value);
          } catch (e4) {
            JT(r3, "throw", e4);
          }
          if ("object" == typeof a3 && a3 && HT(zT, a3))
            return a3;
        }
        return new XT(false);
      }, sw = iR, aw = bR, cw = uy.set, dw = by, uw = By, hw = function(e3, t3) {
        var i3 = My.console;
        i3 && i3.error && (1 == arguments.length ? i3.error(e3) : i3.error(e3, t3));
      }, Aw = Ny, lw = function(e3) {
        try {
          return { error: false, value: e3() };
        } catch (e4) {
          return { error: true, value: e4 };
        }
      }, pw = jy, gw = Ri, Ew = Br, fw = Gy, mw = p_, Iw = $, _w = ze("species"), Cw = "Promise", Sw = gw.getterFor(Cw), vw = gw.set, Tw = gw.getterFor(Cw), Rw = Jy && Jy.prototype, yw = Jy, ww = Rw, bw = Hy.TypeError, Nw = Hy.document, Ow = Hy.process, Dw = Aw.f, Pw = Dw, Lw = !!(Nw && Nw.createEvent && Hy.dispatchEvent), kw = tw(Hy.PromiseRejectionEvent), Bw = "unhandledrejection", Mw = false, Uw = Ew(Cw, function() {
        var e3 = nw(yw), t3 = e3 !== String(yw);
        if (!t3 && 66 === Iw)
          return true;
        if (Iw >= 51 && /native code/.test(e3))
          return false;
        var i3 = new yw(function(e4) {
          e4(1);
        }), r3 = function(e4) {
          e4(function() {
          }, function() {
          });
        };
        return (i3.constructor = {})[_w] = r3, !(Mw = i3.then(function() {
        }) instanceof r3) || !t3 && fw && !kw;
      }), xw = Uw || !sw(function(e3) {
        yw.all(e3).catch(function() {
        });
      }), Qw = function(e3) {
        var t3;
        return !(!iw(e3) || !tw(t3 = e3.then)) && t3;
      }, Fw = function(e3, t3) {
        var i3, r3, n3, o3 = t3.value, s3 = 1 == t3.state, a3 = s3 ? e3.ok : e3.fail, c3 = e3.resolve, d3 = e3.reject, u3 = e3.domain;
        try {
          a3 ? (s3 || (2 === t3.rejection && Hw(t3), t3.rejection = 1), true === a3 ? i3 = o3 : (u3 && u3.enter(), i3 = a3(o3), u3 && (u3.exit(), n3 = true)), i3 === e3.promise ? d3(bw("Promise-chain cycle")) : (r3 = Qw(i3)) ? Yy(r3, i3, c3, d3) : c3(i3)) : d3(o3);
        } catch (e4) {
          u3 && !n3 && u3.exit(), d3(e4);
        }
      }, Vw = function(e3, t3) {
        e3.notified || (e3.notified = true, dw(function() {
          for (var i3, r3 = e3.reactions; i3 = r3.get(); )
            Fw(i3, e3);
          e3.notified = false, t3 && !e3.rejection && Gw(e3);
        }));
      }, jw = function(e3, t3, i3) {
        var r3, n3;
        Lw ? ((r3 = Nw.createEvent("Event")).promise = t3, r3.reason = i3, r3.initEvent(e3, false, true), Hy.dispatchEvent(r3)) : r3 = { promise: t3, reason: i3 }, !kw && (n3 = Hy["on" + e3]) ? n3(r3) : e3 === Bw && hw("Unhandled promise rejection", i3);
      }, Gw = function(e3) {
        Yy(cw, Hy, function() {
          var t3, i3 = e3.facade, r3 = e3.value;
          if (Kw(e3) && (t3 = lw(function() {
            mw ? Ow.emit("unhandledRejection", r3, i3) : jw(Bw, i3, r3);
          }), e3.rejection = mw || Kw(e3) ? 2 : 1, t3.error))
            throw t3.value;
        });
      }, Kw = function(e3) {
        return 1 !== e3.rejection && !e3.parent;
      }, Hw = function(e3) {
        Yy(cw, Hy, function() {
          var t3 = e3.facade;
          mw ? Ow.emit("rejectionHandled", t3) : jw("rejectionhandled", t3, e3.value);
        });
      }, Ww = function(e3, t3, i3) {
        return function(r3) {
          e3(t3, r3, i3);
        };
      }, Yw = function(e3, t3, i3) {
        e3.done || (e3.done = true, i3 && (e3 = i3), e3.value = t3, e3.state = 2, Vw(e3, true));
      }, Jw = function(e3, t3, i3) {
        if (!e3.done) {
          e3.done = true, i3 && (e3 = i3);
          try {
            if (e3.facade === t3)
              throw bw("Promise can't be resolved itself");
            var r3 = Qw(t3);
            r3 ? dw(function() {
              var i4 = { done: false };
              try {
                Yy(r3, t3, Ww(Jw, i4, e3), Ww(Yw, i4, e3));
              } catch (t4) {
                Yw(i4, t4, e3);
              }
            }) : (e3.value = t3, e3.state = 1, Vw(e3, false));
          } catch (t4) {
            Yw({ done: false }, t4, e3);
          }
        }
      };
      if (Uw && (ww = (yw = function(e3) {
        rw(this, ww), ew(e3), Yy(xy, this);
        var t3 = Sw(this);
        try {
          e3(Ww(Jw, t3), Ww(Yw, t3));
        } catch (e4) {
          Yw(t3, e4);
        }
      }).prototype, (xy = function(e3) {
        vw(this, { type: Cw, done: false, notified: false, parent: false, reactions: new pw(), rejection: false, state: 0, value: void 0 });
      }).prototype = Xy(ww, { then: function(e3, t3) {
        var i3 = Tw(this), r3 = Dw(aw(this, yw));
        return i3.parent = true, r3.ok = !tw(e3) || e3, r3.fail = tw(t3) && t3, r3.domain = mw ? Ow.domain : void 0, 0 == i3.state ? i3.reactions.add(r3) : dw(function() {
          Fw(r3, i3);
        }), r3.promise;
      }, catch: function(e3) {
        return this.then(void 0, e3);
      } }), Qy = function() {
        var e3 = new xy(), t3 = Sw(e3);
        this.promise = e3, this.resolve = Ww(Jw, t3), this.reject = Ww(Yw, t3);
      }, Aw.f = Dw = function(e3) {
        return e3 === yw || e3 === Fy ? new Qy(e3) : Pw(e3);
      }, tw(Jy) && Rw !== Object.prototype)) {
        Vy = Rw.then, Mw || (qy(Rw, "then", function(e3, t3) {
          var i3 = this;
          return new yw(function(e4, t4) {
            Yy(Vy, i3, e4, t4);
          }).then(e3, t3);
        }, { unsafe: true }), qy(Rw, "catch", ww.catch, { unsafe: true }));
        try {
          delete Rw.constructor;
        } catch (e3) {
        }
        zy && zy(Rw, ww);
      }
      Ky({ global: true, wrap: true, forced: Uw }, { Promise: yw }), Zy(yw, Cw, false), $y(Cw), Fy = Wy(Cw), Ky({ target: Cw, stat: true, forced: Uw }, { reject: function(e3) {
        var t3 = Dw(this);
        return Yy(t3.reject, void 0, e3), t3.promise;
      } }), Ky({ target: Cw, stat: true, forced: Uw }, { resolve: function(e3) {
        return uw(this, e3);
      } }), Ky({ target: Cw, stat: true, forced: xw }, { all: function(e3) {
        var t3 = this, i3 = Dw(t3), r3 = i3.resolve, n3 = i3.reject, o3 = lw(function() {
          var i4 = ew(t3.resolve), o4 = [], s3 = 0, a3 = 1;
          ow(e3, function(e4) {
            var c3 = s3++, d3 = false;
            a3++, Yy(i4, t3, e4).then(function(e5) {
              d3 || (d3 = true, o4[c3] = e5, --a3 || r3(o4));
            }, n3);
          }), --a3 || r3(o4);
        });
        return o3.error && n3(o3.value), i3.promise;
      }, race: function(e3) {
        var t3 = this, i3 = Dw(t3), r3 = i3.reject, n3 = lw(function() {
          var n4 = ew(t3.resolve);
          ow(e3, function(e4) {
            Yy(n4, t3, e4).then(i3.resolve, r3);
          });
        });
        return n3.error && r3(n3.value), i3.promise;
      } });
      var qw = Gr, Xw = lT, zw = n, Zw = K, $w = x, eb = bR, tb = By, ib = Ht.exports;
      if (qw({ target: "Promise", proto: true, real: true, forced: !!Xw && zw(function() {
        Xw.prototype.finally.call({ then: function() {
        } }, function() {
        });
      }) }, { finally: function(e3) {
        var t3 = eb(this, Zw("Promise")), i3 = $w(e3);
        return this.then(i3 ? function(i4) {
          return tb(t3, e3()).then(function() {
            return i4;
          });
        } : e3, i3 ? function(i4) {
          return tb(t3, e3()).then(function() {
            throw i4;
          });
        } : e3);
      } }), $w(Xw)) {
        var rb = Zw("Promise").prototype.finally;
        Xw.prototype.finally !== rb && ib(Xw.prototype, "finally", rb, { unsafe: true });
      }
      function nb(e3, t3) {
        const i3 = e3 && e3.navigator, r3 = e3 && e3.MediaStreamTrack;
        if (i3.getUserMedia = function(e4, t4, r4) {
          Yh("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i3.mediaDevices.getUserMedia(e4).then(t4, r4);
        }, !(t3.version > 55 && "autoGainControl" in i3.mediaDevices.getSupportedConstraints())) {
          const e4 = function(e5, t5, i4) {
            t5 in e5 && !(i4 in e5) && (e5[i4] = e5[t5], delete e5[t5]);
          }, t4 = i3.mediaDevices.getUserMedia.bind(i3.mediaDevices);
          if (i3.mediaDevices.getUserMedia = function(i4) {
            return "object" == typeof i4 && "object" == typeof i4.audio && (i4 = JSON.parse(JSON.stringify(i4)), e4(i4.audio, "autoGainControl", "mozAutoGainControl"), e4(i4.audio, "noiseSuppression", "mozNoiseSuppression")), t4(i4);
          }, r3 && r3.prototype.getSettings) {
            const t5 = r3.prototype.getSettings;
            r3.prototype.getSettings = function() {
              const i4 = t5.apply(this, arguments);
              return e4(i4, "mozAutoGainControl", "autoGainControl"), e4(i4, "mozNoiseSuppression", "noiseSuppression"), i4;
            };
          }
          if (r3 && r3.prototype.applyConstraints) {
            const t5 = r3.prototype.applyConstraints;
            r3.prototype.applyConstraints = function(i4) {
              return "audio" === this.kind && "object" == typeof i4 && (i4 = JSON.parse(JSON.stringify(i4)), e4(i4, "autoGainControl", "mozAutoGainControl"), e4(i4, "noiseSuppression", "mozNoiseSuppression")), t5.apply(this, [i4]);
            };
          }
        }
      }
      function ob(e3) {
        "object" == typeof e3 && e3.RTCTrackEvent && "receiver" in e3.RTCTrackEvent.prototype && !("transceiver" in e3.RTCTrackEvent.prototype) && Object.defineProperty(e3.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function sb(e3, t3) {
        if ("object" != typeof e3 || !e3.RTCPeerConnection && !e3.mozRTCPeerConnection)
          return;
        !e3.RTCPeerConnection && e3.mozRTCPeerConnection && (e3.RTCPeerConnection = e3.mozRTCPeerConnection), t3.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t4) {
          const i4 = e3.RTCPeerConnection.prototype[t4], r4 = { [t4]() {
            return arguments[0] = new ("addIceCandidate" === t4 ? e3.RTCIceCandidate : e3.RTCSessionDescription)(arguments[0]), i4.apply(this, arguments);
          } };
          e3.RTCPeerConnection.prototype[t4] = r4[t4];
        });
        const i3 = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, r3 = e3.RTCPeerConnection.prototype.getStats;
        e3.RTCPeerConnection.prototype.getStats = function() {
          const [e4, n3, o3] = arguments;
          return r3.apply(this, [e4 || null]).then((e5) => {
            if (t3.version < 53 && !n3)
              try {
                e5.forEach((e6) => {
                  e6.type = i3[e6.type] || e6.type;
                });
              } catch (t4) {
                if ("TypeError" !== t4.name)
                  throw t4;
                e5.forEach((t5, r4) => {
                  e5.set(r4, Object.assign({}, t5, { type: i3[t5.type] || t5.type }));
                });
              }
            return e5;
          }).then(n3, o3);
        };
      }
      function ab(e3) {
        if ("object" != typeof e3 || !e3.RTCPeerConnection || !e3.RTCRtpSender)
          return;
        if (e3.RTCRtpSender && "getStats" in e3.RTCRtpSender.prototype)
          return;
        const t3 = e3.RTCPeerConnection.prototype.getSenders;
        t3 && (e3.RTCPeerConnection.prototype.getSenders = function() {
          const e4 = t3.apply(this, []);
          return e4.forEach((e5) => e5._pc = this), e4;
        });
        const i3 = e3.RTCPeerConnection.prototype.addTrack;
        i3 && (e3.RTCPeerConnection.prototype.addTrack = function() {
          const e4 = i3.apply(this, arguments);
          return e4._pc = this, e4;
        }), e3.RTCRtpSender.prototype.getStats = function() {
          return this.track ? this._pc.getStats(this.track) : l_.resolve(/* @__PURE__ */ new Map());
        };
      }
      function cb(e3) {
        if ("object" != typeof e3 || !e3.RTCPeerConnection || !e3.RTCRtpSender)
          return;
        if (e3.RTCRtpSender && "getStats" in e3.RTCRtpReceiver.prototype)
          return;
        const t3 = e3.RTCPeerConnection.prototype.getReceivers;
        t3 && (e3.RTCPeerConnection.prototype.getReceivers = function() {
          const e4 = t3.apply(this, []);
          return e4.forEach((e5) => e5._pc = this), e4;
        }), Gh(e3, "track", (e4) => (e4.receiver._pc = e4.srcElement, e4)), e3.RTCRtpReceiver.prototype.getStats = function() {
          return this._pc.getStats(this.track);
        };
      }
      function db(e3) {
        e3.RTCPeerConnection && !("removeStream" in e3.RTCPeerConnection.prototype) && (e3.RTCPeerConnection.prototype.removeStream = function(e4) {
          Yh("removeStream", "removeTrack"), this.getSenders().forEach((t3) => {
            t3.track && e4.getTracks().includes(t3.track) && this.removeTrack(t3);
          });
        });
      }
      function ub(e3) {
        e3.DataChannel && !e3.RTCDataChannel && (e3.RTCDataChannel = e3.DataChannel);
      }
      function hb(e3) {
        if ("object" != typeof e3 || !e3.RTCPeerConnection)
          return;
        const t3 = e3.RTCPeerConnection.prototype.addTransceiver;
        t3 && (e3.RTCPeerConnection.prototype.addTransceiver = function() {
          this.setParametersPromises = [];
          const e4 = arguments[1], i3 = e4 && "sendEncodings" in e4;
          i3 && e4.sendEncodings.forEach((e5) => {
            if ("rid" in e5) {
              if (!/^[a-z0-9]{0,16}$/i.test(e5.rid))
                throw new TypeError("Invalid RID value provided.");
            }
            if ("scaleResolutionDownBy" in e5 && !(parseFloat(e5.scaleResolutionDownBy) >= 1))
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            if ("maxFramerate" in e5 && !(parseFloat(e5.maxFramerate) >= 0))
              throw new RangeError("max_framerate must be >= 0.0");
          });
          const r3 = t3.apply(this, arguments);
          if (i3) {
            const { sender: t4 } = r3, i4 = t4.getParameters();
            (!("encodings" in i4) || 1 === i4.encodings.length && 0 === Object.keys(i4.encodings[0]).length) && (i4.encodings = e4.sendEncodings, t4.sendEncodings = e4.sendEncodings, this.setParametersPromises.push(t4.setParameters(i4).then(() => {
              delete t4.sendEncodings;
            }).catch(() => {
              delete t4.sendEncodings;
            })));
          }
          return r3;
        });
      }
      function Ab(e3) {
        if ("object" != typeof e3 || !e3.RTCRtpSender)
          return;
        const t3 = e3.RTCRtpSender.prototype.getParameters;
        t3 && (e3.RTCRtpSender.prototype.getParameters = function() {
          const e4 = t3.apply(this, arguments);
          return "encodings" in e4 || (e4.encodings = [].concat(this.sendEncodings || [{}])), e4;
        });
      }
      function lb(e3) {
        if ("object" != typeof e3 || !e3.RTCPeerConnection)
          return;
        const t3 = e3.RTCPeerConnection.prototype.createOffer;
        e3.RTCPeerConnection.prototype.createOffer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? l_.all(this.setParametersPromises).then(() => t3.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t3.apply(this, arguments);
        };
      }
      function pb(e3) {
        if ("object" != typeof e3 || !e3.RTCPeerConnection)
          return;
        const t3 = e3.RTCPeerConnection.prototype.createAnswer;
        e3.RTCPeerConnection.prototype.createAnswer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? l_.all(this.setParametersPromises).then(() => t3.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t3.apply(this, arguments);
        };
      }
      var gb = Object.freeze({ __proto__: null, shimOnTrack: ob, shimPeerConnection: sb, shimSenderGetStats: ab, shimReceiverGetStats: cb, shimRemoveStream: db, shimRTCDataChannel: ub, shimAddTransceiver: hb, shimGetParameters: Ab, shimCreateOffer: lb, shimCreateAnswer: pb, shimGetUserMedia: nb, shimGetDisplayMedia: function(e3, t3) {
        e3.navigator.mediaDevices && "getDisplayMedia" in e3.navigator.mediaDevices || e3.navigator.mediaDevices && (e3.navigator.mediaDevices.getDisplayMedia = function(i3) {
          if (!i3 || !i3.video) {
            const e4 = new DOMException("getDisplayMedia without video constraints is undefined");
            return e4.name = "NotFoundError", e4.code = 8, l_.reject(e4);
          }
          return true === i3.video ? i3.video = { mediaSource: t3 } : i3.video.mediaSource = t3, e3.navigator.mediaDevices.getUserMedia(i3);
        });
      } });
      function Eb(e3) {
        if ("object" == typeof e3 && e3.RTCPeerConnection) {
          if ("getLocalStreams" in e3.RTCPeerConnection.prototype || (e3.RTCPeerConnection.prototype.getLocalStreams = function() {
            return this._localStreams || (this._localStreams = []), this._localStreams;
          }), !("addStream" in e3.RTCPeerConnection.prototype)) {
            const t3 = e3.RTCPeerConnection.prototype.addTrack;
            e3.RTCPeerConnection.prototype.addStream = function(e4) {
              this._localStreams || (this._localStreams = []), this._localStreams.includes(e4) || this._localStreams.push(e4), e4.getAudioTracks().forEach((i3) => t3.call(this, i3, e4)), e4.getVideoTracks().forEach((i3) => t3.call(this, i3, e4));
            }, e3.RTCPeerConnection.prototype.addTrack = function(e4) {
              for (var i3 = arguments.length, r3 = new Array(i3 > 1 ? i3 - 1 : 0), n3 = 1; n3 < i3; n3++)
                r3[n3 - 1] = arguments[n3];
              return r3 && r3.forEach((e5) => {
                this._localStreams ? this._localStreams.includes(e5) || this._localStreams.push(e5) : this._localStreams = [e5];
              }), t3.apply(this, arguments);
            };
          }
          "removeStream" in e3.RTCPeerConnection.prototype || (e3.RTCPeerConnection.prototype.removeStream = function(e4) {
            this._localStreams || (this._localStreams = []);
            const t3 = this._localStreams.indexOf(e4);
            if (-1 === t3)
              return;
            this._localStreams.splice(t3, 1);
            const i3 = e4.getTracks();
            this.getSenders().forEach((e5) => {
              i3.includes(e5.track) && this.removeTrack(e5);
            });
          });
        }
      }
      function fb(e3) {
        if ("object" == typeof e3 && e3.RTCPeerConnection && ("getRemoteStreams" in e3.RTCPeerConnection.prototype || (e3.RTCPeerConnection.prototype.getRemoteStreams = function() {
          return this._remoteStreams ? this._remoteStreams : [];
        }), !("onaddstream" in e3.RTCPeerConnection.prototype))) {
          Object.defineProperty(e3.RTCPeerConnection.prototype, "onaddstream", { get() {
            return this._onaddstream;
          }, set(e4) {
            this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e4), this.addEventListener("track", this._onaddstreampoly = (e5) => {
              e5.streams.forEach((e6) => {
                if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e6))
                  return;
                this._remoteStreams.push(e6);
                const t4 = new Event("addstream");
                t4.stream = e6, this.dispatchEvent(t4);
              });
            });
          } });
          const t3 = e3.RTCPeerConnection.prototype.setRemoteDescription;
          e3.RTCPeerConnection.prototype.setRemoteDescription = function() {
            const e4 = this;
            return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t4) {
              t4.streams.forEach((t5) => {
                if (e4._remoteStreams || (e4._remoteStreams = []), e4._remoteStreams.indexOf(t5) >= 0)
                  return;
                e4._remoteStreams.push(t5);
                const i3 = new Event("addstream");
                i3.stream = t5, e4.dispatchEvent(i3);
              });
            }), t3.apply(e4, arguments);
          };
        }
      }
      function mb(e3) {
        if ("object" != typeof e3 || !e3.RTCPeerConnection)
          return;
        const t3 = e3.RTCPeerConnection.prototype, i3 = t3.createOffer, r3 = t3.createAnswer, n3 = t3.setLocalDescription, o3 = t3.setRemoteDescription, s3 = t3.addIceCandidate;
        t3.createOffer = function(e4, t4) {
          const r4 = arguments.length >= 2 ? arguments[2] : arguments[0], n4 = i3.apply(this, [r4]);
          return t4 ? (n4.then(e4, t4), l_.resolve()) : n4;
        }, t3.createAnswer = function(e4, t4) {
          const i4 = arguments.length >= 2 ? arguments[2] : arguments[0], n4 = r3.apply(this, [i4]);
          return t4 ? (n4.then(e4, t4), l_.resolve()) : n4;
        };
        let a3 = function(e4, t4, i4) {
          const r4 = n3.apply(this, [e4]);
          return i4 ? (r4.then(t4, i4), l_.resolve()) : r4;
        };
        t3.setLocalDescription = a3, a3 = function(e4, t4, i4) {
          const r4 = o3.apply(this, [e4]);
          return i4 ? (r4.then(t4, i4), l_.resolve()) : r4;
        }, t3.setRemoteDescription = a3, a3 = function(e4, t4, i4) {
          const r4 = s3.apply(this, [e4]);
          return i4 ? (r4.then(t4, i4), l_.resolve()) : r4;
        }, t3.addIceCandidate = a3;
      }
      function Ib(e3) {
        const t3 = e3 && e3.navigator;
        if (t3.mediaDevices && t3.mediaDevices.getUserMedia) {
          const e4 = t3.mediaDevices, i3 = e4.getUserMedia.bind(e4);
          t3.mediaDevices.getUserMedia = (e5) => i3(_b(e5));
        }
        !t3.getUserMedia && t3.mediaDevices && t3.mediaDevices.getUserMedia && (t3.getUserMedia = function(e4, i3, r3) {
          t3.mediaDevices.getUserMedia(e4).then(i3, r3);
        }.bind(t3));
      }
      function _b(e3) {
        return e3 && void 0 !== e3.video ? Object.assign({}, e3, { video: Xh(e3.video) }) : e3;
      }
      function Cb(e3) {
        if (!e3.RTCPeerConnection)
          return;
        const t3 = e3.RTCPeerConnection;
        e3.RTCPeerConnection = function(e4, i3) {
          if (e4 && e4.iceServers) {
            const t4 = [];
            for (let i4 = 0; i4 < e4.iceServers.length; i4++) {
              let r3 = e4.iceServers[i4];
              !r3.hasOwnProperty("urls") && r3.hasOwnProperty("url") ? (Yh("RTCIceServer.url", "RTCIceServer.urls"), r3 = JSON.parse(JSON.stringify(r3)), r3.urls = r3.url, delete r3.url, t4.push(r3)) : t4.push(e4.iceServers[i4]);
            }
            e4.iceServers = t4;
          }
          return new t3(e4, i3);
        }, e3.RTCPeerConnection.prototype = t3.prototype, "generateCertificate" in t3 && Object.defineProperty(e3.RTCPeerConnection, "generateCertificate", { get: () => t3.generateCertificate });
      }
      function Sb(e3) {
        "object" == typeof e3 && e3.RTCTrackEvent && "receiver" in e3.RTCTrackEvent.prototype && !("transceiver" in e3.RTCTrackEvent.prototype) && Object.defineProperty(e3.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function vb(e3) {
        const t3 = e3.RTCPeerConnection.prototype.createOffer;
        e3.RTCPeerConnection.prototype.createOffer = function(e4) {
          if (e4) {
            void 0 !== e4.offerToReceiveAudio && (e4.offerToReceiveAudio = !!e4.offerToReceiveAudio);
            const t4 = this.getTransceivers().find((e5) => "audio" === e5.receiver.track.kind);
            false === e4.offerToReceiveAudio && t4 ? "sendrecv" === t4.direction ? t4.setDirection ? t4.setDirection("sendonly") : t4.direction = "sendonly" : "recvonly" === t4.direction && (t4.setDirection ? t4.setDirection("inactive") : t4.direction = "inactive") : true !== e4.offerToReceiveAudio || t4 || this.addTransceiver("audio"), void 0 !== e4.offerToReceiveVideo && (e4.offerToReceiveVideo = !!e4.offerToReceiveVideo);
            const i3 = this.getTransceivers().find((e5) => "video" === e5.receiver.track.kind);
            false === e4.offerToReceiveVideo && i3 ? "sendrecv" === i3.direction ? i3.setDirection ? i3.setDirection("sendonly") : i3.direction = "sendonly" : "recvonly" === i3.direction && (i3.setDirection ? i3.setDirection("inactive") : i3.direction = "inactive") : true !== e4.offerToReceiveVideo || i3 || this.addTransceiver("video");
          }
          return t3.apply(this, arguments);
        };
      }
      function Tb(e3) {
        "object" != typeof e3 || e3.AudioContext || (e3.AudioContext = e3.webkitAudioContext);
      }
      var Rb = Object.freeze({ __proto__: null, shimLocalStreamsAPI: Eb, shimRemoteStreamsAPI: fb, shimCallbacksAPI: mb, shimGetUserMedia: Ib, shimConstraints: _b, shimRTCIceServerUrls: Cb, shimTrackEventTransceiver: Sb, shimCreateOfferLegacy: vb, shimAudioContext: Tb }), yb = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF", wb = $n, bb = _p, Nb = _n("".replace), Ob = "[	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]", Db = RegExp("^" + Ob + Ob + "*"), Pb = RegExp(Ob + Ob + "*$"), Lb = function(e3) {
        return function(t3) {
          var i3 = bb(wb(t3));
          return 1 & e3 && (i3 = Nb(i3, Db, "")), 2 & e3 && (i3 = Nb(i3, Pb, "")), i3;
        };
      }, kb = { start: Lb(1), end: Lb(2), trim: Lb(3) }, Bb = Rg.PROPER, Mb = ln, Ub = yb, xb = kb.trim;
      ka({ target: "String", proto: true, forced: function(e3) {
        return Mb(function() {
          return !!Ub[e3]() || "\u200B\x85\u180E" !== "\u200B\x85\u180E"[e3]() || Bb && Ub[e3].name !== e3;
        });
      }("trim") }, { trim: function() {
        return xb(this);
      } });
      var Qb = ic("String").trim, Fb = Cn, Vb = Qb, jb = String.prototype, Gb = function(e3) {
        var t3 = e3.trim;
        return "string" == typeof e3 || e3 === jb || Fb(jb, e3) && t3 === jb.trim ? Vb : t3;
      }, Kb = d;
      Gr({ target: "URL", proto: true, enumerable: true }, { toJSON: function() {
        return Kb(URL.prototype.toString, this);
      } });
      var Hb = { exports: {} };
      !function(e3) {
        var t3 = { generateIdentifier: function() {
          return Math.random().toString(36).substr(2, 10);
        } };
        t3.localCName = t3.generateIdentifier(), t3.splitLines = function(e4) {
          return Gb(e4).call(e4).split("\n").map(function(e5) {
            return Gb(e5).call(e5);
          });
        }, t3.splitSections = function(e4) {
          return e4.split("\nm=").map(function(e5, t4) {
            var i3;
            return Gb(i3 = t4 > 0 ? "m=" + e5 : e5).call(i3) + "\r\n";
          });
        }, t3.getDescription = function(e4) {
          var i3 = t3.splitSections(e4);
          return i3 && i3[0];
        }, t3.getMediaSections = function(e4) {
          var i3 = t3.splitSections(e4);
          return i3.shift(), i3;
        }, t3.matchPrefix = function(e4, i3) {
          return t3.splitLines(e4).filter(function(e5) {
            return 0 === e5.indexOf(i3);
          });
        }, t3.parseCandidate = function(e4) {
          for (var t4, i3 = { foundation: (t4 = 0 === e4.indexOf("a=candidate:") ? e4.substring(12).split(" ") : e4.substring(10).split(" "))[0], component: parseInt(t4[1], 10), protocol: t4[2].toLowerCase(), priority: parseInt(t4[3], 10), ip: t4[4], address: t4[4], port: parseInt(t4[5], 10), type: t4[7] }, r3 = 8; r3 < t4.length; r3 += 2)
            switch (t4[r3]) {
              case "raddr":
                i3.relatedAddress = t4[r3 + 1];
                break;
              case "rport":
                i3.relatedPort = parseInt(t4[r3 + 1], 10);
                break;
              case "tcptype":
                i3.tcpType = t4[r3 + 1];
                break;
              case "ufrag":
                i3.ufrag = t4[r3 + 1], i3.usernameFragment = t4[r3 + 1];
                break;
              default:
                i3[t4[r3]] = t4[r3 + 1];
            }
          return i3;
        }, t3.writeCandidate = function(e4) {
          var t4 = [];
          t4.push(e4.foundation), t4.push(e4.component), t4.push(e4.protocol.toUpperCase()), t4.push(e4.priority), t4.push(e4.address || e4.ip), t4.push(e4.port);
          var i3 = e4.type;
          return t4.push("typ"), t4.push(i3), "host" !== i3 && e4.relatedAddress && e4.relatedPort && (t4.push("raddr"), t4.push(e4.relatedAddress), t4.push("rport"), t4.push(e4.relatedPort)), e4.tcpType && "tcp" === e4.protocol.toLowerCase() && (t4.push("tcptype"), t4.push(e4.tcpType)), (e4.usernameFragment || e4.ufrag) && (t4.push("ufrag"), t4.push(e4.usernameFragment || e4.ufrag)), "candidate:" + t4.join(" ");
        }, t3.parseIceOptions = function(e4) {
          return e4.substr(14).split(" ");
        }, t3.parseRtpMap = function(e4) {
          var t4 = e4.substr(9).split(" "), i3 = { payloadType: parseInt(t4.shift(), 10) };
          return t4 = t4[0].split("/"), i3.name = t4[0], i3.clockRate = parseInt(t4[1], 10), i3.channels = 3 === t4.length ? parseInt(t4[2], 10) : 1, i3.numChannels = i3.channels, i3;
        }, t3.writeRtpMap = function(e4) {
          var t4 = e4.payloadType;
          void 0 !== e4.preferredPayloadType && (t4 = e4.preferredPayloadType);
          var i3 = e4.channels || e4.numChannels || 1;
          return "a=rtpmap:" + t4 + " " + e4.name + "/" + e4.clockRate + (1 !== i3 ? "/" + i3 : "") + "\r\n";
        }, t3.parseExtmap = function(e4) {
          var t4 = e4.substr(9).split(" ");
          return { id: parseInt(t4[0], 10), direction: t4[0].indexOf("/") > 0 ? t4[0].split("/")[1] : "sendrecv", uri: t4[1] };
        }, t3.writeExtmap = function(e4) {
          return "a=extmap:" + (e4.id || e4.preferredId) + (e4.direction && "sendrecv" !== e4.direction ? "/" + e4.direction : "") + " " + e4.uri + "\r\n";
        }, t3.parseFmtp = function(e4) {
          for (var t4, i3 = {}, r3 = e4.substr(e4.indexOf(" ") + 1).split(";"), n3 = 0; n3 < r3.length; n3++) {
            var o3, s3;
            t4 = Gb(o3 = r3[n3]).call(o3).split("="), i3[Gb(s3 = t4[0]).call(s3)] = t4[1];
          }
          return i3;
        }, t3.writeFmtp = function(e4) {
          var t4 = "", i3 = e4.payloadType;
          if (void 0 !== e4.preferredPayloadType && (i3 = e4.preferredPayloadType), e4.parameters && Object.keys(e4.parameters).length) {
            var r3 = [];
            Object.keys(e4.parameters).forEach(function(t5) {
              e4.parameters[t5] ? r3.push(t5 + "=" + e4.parameters[t5]) : r3.push(t5);
            }), t4 += "a=fmtp:" + i3 + " " + r3.join(";") + "\r\n";
          }
          return t4;
        }, t3.parseRtcpFb = function(e4) {
          var t4 = e4.substr(e4.indexOf(" ") + 1).split(" ");
          return { type: t4.shift(), parameter: t4.join(" ") };
        }, t3.writeRtcpFb = function(e4) {
          var t4 = "", i3 = e4.payloadType;
          return void 0 !== e4.preferredPayloadType && (i3 = e4.preferredPayloadType), e4.rtcpFeedback && e4.rtcpFeedback.length && e4.rtcpFeedback.forEach(function(e5) {
            t4 += "a=rtcp-fb:" + i3 + " " + e5.type + (e5.parameter && e5.parameter.length ? " " + e5.parameter : "") + "\r\n";
          }), t4;
        }, t3.parseSsrcMedia = function(e4) {
          var t4 = e4.indexOf(" "), i3 = { ssrc: parseInt(e4.substr(7, t4 - 7), 10) }, r3 = e4.indexOf(":", t4);
          return r3 > -1 ? (i3.attribute = e4.substr(t4 + 1, r3 - t4 - 1), i3.value = e4.substr(r3 + 1)) : i3.attribute = e4.substr(t4 + 1), i3;
        }, t3.parseSsrcGroup = function(e4) {
          var t4 = e4.substr(13).split(" ");
          return { semantics: t4.shift(), ssrcs: t4.map(function(e5) {
            return parseInt(e5, 10);
          }) };
        }, t3.getMid = function(e4) {
          var i3 = t3.matchPrefix(e4, "a=mid:")[0];
          if (i3)
            return i3.substr(6);
        }, t3.parseFingerprint = function(e4) {
          var t4 = e4.substr(14).split(" ");
          return { algorithm: t4[0].toLowerCase(), value: t4[1] };
        }, t3.getDtlsParameters = function(e4, i3) {
          return { role: "auto", fingerprints: t3.matchPrefix(e4 + i3, "a=fingerprint:").map(t3.parseFingerprint) };
        }, t3.writeDtlsParameters = function(e4, t4) {
          var i3 = "a=setup:" + t4 + "\r\n";
          return e4.fingerprints.forEach(function(e5) {
            i3 += "a=fingerprint:" + e5.algorithm + " " + e5.value + "\r\n";
          }), i3;
        }, t3.parseCryptoLine = function(e4) {
          var t4 = e4.substr(9).split(" ");
          return { tag: parseInt(t4[0], 10), cryptoSuite: t4[1], keyParams: t4[2], sessionParams: t4.slice(3) };
        }, t3.writeCryptoLine = function(e4) {
          return "a=crypto:" + e4.tag + " " + e4.cryptoSuite + " " + ("object" == typeof e4.keyParams ? t3.writeCryptoKeyParams(e4.keyParams) : e4.keyParams) + (e4.sessionParams ? " " + e4.sessionParams.join(" ") : "") + "\r\n";
        }, t3.parseCryptoKeyParams = function(e4) {
          if (0 !== e4.indexOf("inline:"))
            return null;
          var t4 = e4.substr(7).split("|");
          return { keyMethod: "inline", keySalt: t4[0], lifeTime: t4[1], mkiValue: t4[2] ? t4[2].split(":")[0] : void 0, mkiLength: t4[2] ? t4[2].split(":")[1] : void 0 };
        }, t3.writeCryptoKeyParams = function(e4) {
          return e4.keyMethod + ":" + e4.keySalt + (e4.lifeTime ? "|" + e4.lifeTime : "") + (e4.mkiValue && e4.mkiLength ? "|" + e4.mkiValue + ":" + e4.mkiLength : "");
        }, t3.getCryptoParameters = function(e4, i3) {
          return t3.matchPrefix(e4 + i3, "a=crypto:").map(t3.parseCryptoLine);
        }, t3.getIceParameters = function(e4, i3) {
          var r3 = t3.matchPrefix(e4 + i3, "a=ice-ufrag:")[0], n3 = t3.matchPrefix(e4 + i3, "a=ice-pwd:")[0];
          return r3 && n3 ? { usernameFragment: r3.substr(12), password: n3.substr(10) } : null;
        }, t3.writeIceParameters = function(e4) {
          return "a=ice-ufrag:" + e4.usernameFragment + "\r\na=ice-pwd:" + e4.password + "\r\n";
        }, t3.parseRtpParameters = function(e4) {
          for (var i3 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r3 = t3.splitLines(e4)[0].split(" "), n3 = 3; n3 < r3.length; n3++) {
            var o3 = r3[n3], s3 = t3.matchPrefix(e4, "a=rtpmap:" + o3 + " ")[0];
            if (s3) {
              var a3 = t3.parseRtpMap(s3), c3 = t3.matchPrefix(e4, "a=fmtp:" + o3 + " ");
              switch (a3.parameters = c3.length ? t3.parseFmtp(c3[0]) : {}, a3.rtcpFeedback = t3.matchPrefix(e4, "a=rtcp-fb:" + o3 + " ").map(t3.parseRtcpFb), i3.codecs.push(a3), a3.name.toUpperCase()) {
                case "RED":
                case "ULPFEC":
                  i3.fecMechanisms.push(a3.name.toUpperCase());
              }
            }
          }
          return t3.matchPrefix(e4, "a=extmap:").forEach(function(e5) {
            i3.headerExtensions.push(t3.parseExtmap(e5));
          }), i3;
        }, t3.writeRtpDescription = function(e4, i3) {
          var r3 = "";
          r3 += "m=" + e4 + " ", r3 += i3.codecs.length > 0 ? "9" : "0", r3 += " UDP/TLS/RTP/SAVPF ", r3 += i3.codecs.map(function(e5) {
            return void 0 !== e5.preferredPayloadType ? e5.preferredPayloadType : e5.payloadType;
          }).join(" ") + "\r\n", r3 += "c=IN IP4 0.0.0.0\r\n", r3 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", i3.codecs.forEach(function(e5) {
            r3 += t3.writeRtpMap(e5), r3 += t3.writeFmtp(e5), r3 += t3.writeRtcpFb(e5);
          });
          var n3 = 0;
          return i3.codecs.forEach(function(e5) {
            e5.maxptime > n3 && (n3 = e5.maxptime);
          }), n3 > 0 && (r3 += "a=maxptime:" + n3 + "\r\n"), r3 += "a=rtcp-mux\r\n", i3.headerExtensions && i3.headerExtensions.forEach(function(e5) {
            r3 += t3.writeExtmap(e5);
          }), r3;
        }, t3.parseRtpEncodingParameters = function(e4) {
          var i3, r3 = [], n3 = t3.parseRtpParameters(e4), o3 = -1 !== n3.fecMechanisms.indexOf("RED"), s3 = -1 !== n3.fecMechanisms.indexOf("ULPFEC"), a3 = t3.matchPrefix(e4, "a=ssrc:").map(function(e5) {
            return t3.parseSsrcMedia(e5);
          }).filter(function(e5) {
            return "cname" === e5.attribute;
          }), c3 = a3.length > 0 && a3[0].ssrc, d3 = t3.matchPrefix(e4, "a=ssrc-group:FID").map(function(e5) {
            return e5.substr(17).split(" ").map(function(e6) {
              return parseInt(e6, 10);
            });
          });
          d3.length > 0 && d3[0].length > 1 && d3[0][0] === c3 && (i3 = d3[0][1]), n3.codecs.forEach(function(e5) {
            if ("RTX" === e5.name.toUpperCase() && e5.parameters.apt) {
              var t4 = { ssrc: c3, codecPayloadType: parseInt(e5.parameters.apt, 10) };
              c3 && i3 && (t4.rtx = { ssrc: i3 }), r3.push(t4), o3 && ((t4 = JSON.parse(JSON.stringify(t4))).fec = { ssrc: c3, mechanism: s3 ? "red+ulpfec" : "red" }, r3.push(t4));
            }
          }), 0 === r3.length && c3 && r3.push({ ssrc: c3 });
          var u3 = t3.matchPrefix(e4, "b=");
          return u3.length && (u3 = 0 === u3[0].indexOf("b=TIAS:") ? parseInt(u3[0].substr(7), 10) : 0 === u3[0].indexOf("b=AS:") ? 1e3 * parseInt(u3[0].substr(5), 10) * 0.95 - 16e3 : void 0, r3.forEach(function(e5) {
            e5.maxBitrate = u3;
          })), r3;
        }, t3.parseRtcpParameters = function(e4) {
          var i3 = {}, r3 = t3.matchPrefix(e4, "a=ssrc:").map(function(e5) {
            return t3.parseSsrcMedia(e5);
          }).filter(function(e5) {
            return "cname" === e5.attribute;
          })[0];
          r3 && (i3.cname = r3.value, i3.ssrc = r3.ssrc);
          var n3 = t3.matchPrefix(e4, "a=rtcp-rsize");
          i3.reducedSize = n3.length > 0, i3.compound = 0 === n3.length;
          var o3 = t3.matchPrefix(e4, "a=rtcp-mux");
          return i3.mux = o3.length > 0, i3;
        }, t3.parseMsid = function(e4) {
          var i3, r3 = t3.matchPrefix(e4, "a=msid:");
          if (1 === r3.length)
            return { stream: (i3 = r3[0].substr(7).split(" "))[0], track: i3[1] };
          var n3 = t3.matchPrefix(e4, "a=ssrc:").map(function(e5) {
            return t3.parseSsrcMedia(e5);
          }).filter(function(e5) {
            return "msid" === e5.attribute;
          });
          return n3.length > 0 ? { stream: (i3 = n3[0].value.split(" "))[0], track: i3[1] } : void 0;
        }, t3.parseSctpDescription = function(e4) {
          var i3, r3 = t3.parseMLine(e4), n3 = t3.matchPrefix(e4, "a=max-message-size:");
          n3.length > 0 && (i3 = parseInt(n3[0].substr(19), 10)), isNaN(i3) && (i3 = 65536);
          var o3 = t3.matchPrefix(e4, "a=sctp-port:");
          if (o3.length > 0)
            return { port: parseInt(o3[0].substr(12), 10), protocol: r3.fmt, maxMessageSize: i3 };
          if (t3.matchPrefix(e4, "a=sctpmap:").length > 0) {
            var s3 = t3.matchPrefix(e4, "a=sctpmap:")[0].substr(10).split(" ");
            return { port: parseInt(s3[0], 10), protocol: s3[1], maxMessageSize: i3 };
          }
        }, t3.writeSctpDescription = function(e4, t4) {
          var i3 = [];
          return i3 = "DTLS/SCTP" !== e4.protocol ? ["m=" + e4.kind + " 9 " + e4.protocol + " " + t4.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t4.port + "\r\n"] : ["m=" + e4.kind + " 9 " + e4.protocol + " " + t4.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t4.port + " " + t4.protocol + " 65535\r\n"], void 0 !== t4.maxMessageSize && i3.push("a=max-message-size:" + t4.maxMessageSize + "\r\n"), i3.join("");
        }, t3.generateSessionId = function() {
          return Math.random().toString().substr(2, 21);
        }, t3.writeSessionBoilerplate = function(e4, i3, r3) {
          var n3 = void 0 !== i3 ? i3 : 2;
          return "v=0\r\no=" + (r3 || "thisisadapterortc") + " " + (e4 || t3.generateSessionId()) + " " + n3 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
        }, t3.writeMediaSection = function(e4, i3, r3, n3) {
          var o3 = t3.writeRtpDescription(e4.kind, i3);
          if (o3 += t3.writeIceParameters(e4.iceGatherer.getLocalParameters()), o3 += t3.writeDtlsParameters(e4.dtlsTransport.getLocalParameters(), "offer" === r3 ? "actpass" : "active"), o3 += "a=mid:" + e4.mid + "\r\n", e4.direction ? o3 += "a=" + e4.direction + "\r\n" : e4.rtpSender && e4.rtpReceiver ? o3 += "a=sendrecv\r\n" : e4.rtpSender ? o3 += "a=sendonly\r\n" : e4.rtpReceiver ? o3 += "a=recvonly\r\n" : o3 += "a=inactive\r\n", e4.rtpSender) {
            var s3 = "msid:" + n3.id + " " + e4.rtpSender.track.id + "\r\n";
            o3 += "a=" + s3, o3 += "a=ssrc:" + e4.sendEncodingParameters[0].ssrc + " " + s3, e4.sendEncodingParameters[0].rtx && (o3 += "a=ssrc:" + e4.sendEncodingParameters[0].rtx.ssrc + " " + s3, o3 += "a=ssrc-group:FID " + e4.sendEncodingParameters[0].ssrc + " " + e4.sendEncodingParameters[0].rtx.ssrc + "\r\n");
          }
          return o3 += "a=ssrc:" + e4.sendEncodingParameters[0].ssrc + " cname:" + t3.localCName + "\r\n", e4.rtpSender && e4.sendEncodingParameters[0].rtx && (o3 += "a=ssrc:" + e4.sendEncodingParameters[0].rtx.ssrc + " cname:" + t3.localCName + "\r\n"), o3;
        }, t3.getDirection = function(e4, i3) {
          for (var r3 = t3.splitLines(e4), n3 = 0; n3 < r3.length; n3++)
            switch (r3[n3]) {
              case "a=sendrecv":
              case "a=sendonly":
              case "a=recvonly":
              case "a=inactive":
                return r3[n3].substr(2);
            }
          return i3 ? t3.getDirection(i3) : "sendrecv";
        }, t3.getKind = function(e4) {
          return t3.splitLines(e4)[0].split(" ")[0].substr(2);
        }, t3.isRejected = function(e4) {
          return "0" === e4.split(" ", 2)[1];
        }, t3.parseMLine = function(e4) {
          var i3 = t3.splitLines(e4)[0].substr(2).split(" ");
          return { kind: i3[0], port: parseInt(i3[1], 10), protocol: i3[2], fmt: i3.slice(3).join(" ") };
        }, t3.parseOLine = function(e4) {
          var i3 = t3.matchPrefix(e4, "o=")[0].substr(2).split(" ");
          return { username: i3[0], sessionId: i3[1], sessionVersion: parseInt(i3[2], 10), netType: i3[3], addressType: i3[4], address: i3[5] };
        }, t3.isValidSDP = function(e4) {
          if ("string" != typeof e4 || 0 === e4.length)
            return false;
          for (var i3 = t3.splitLines(e4), r3 = 0; r3 < i3.length; r3++)
            if (i3[r3].length < 2 || "=" !== i3[r3].charAt(1))
              return false;
          return true;
        }, e3.exports = t3;
      }(Hb);
      var Wb = Hb.exports;
      function Yb(e3) {
        if (!e3.RTCIceCandidate || e3.RTCIceCandidate && "foundation" in e3.RTCIceCandidate.prototype)
          return;
        const t3 = e3.RTCIceCandidate;
        e3.RTCIceCandidate = function(e4) {
          if ("object" == typeof e4 && e4.candidate && 0 === e4.candidate.indexOf("a=") && ((e4 = JSON.parse(JSON.stringify(e4))).candidate = e4.candidate.substr(2)), e4.candidate && e4.candidate.length) {
            const i3 = new t3(e4), r3 = Wb.parseCandidate(e4.candidate), n3 = Object.assign(i3, r3);
            return n3.toJSON = function() {
              return { candidate: n3.candidate, sdpMid: n3.sdpMid, sdpMLineIndex: n3.sdpMLineIndex, usernameFragment: n3.usernameFragment };
            }, n3;
          }
          return new t3(e4);
        }, e3.RTCIceCandidate.prototype = t3.prototype, Gh(e3, "icecandidate", (t4) => (t4.candidate && Object.defineProperty(t4, "candidate", { value: new e3.RTCIceCandidate(t4.candidate), writable: "false" }), t4));
      }
      function Jb(e3, t3) {
        if (!e3.RTCPeerConnection)
          return;
        "sctp" in e3.RTCPeerConnection.prototype || Object.defineProperty(e3.RTCPeerConnection.prototype, "sctp", { get() {
          return void 0 === this._sctp ? null : this._sctp;
        } });
        const i3 = function(e4) {
          if (!e4 || !e4.sdp)
            return false;
          const t4 = Wb.splitSections(e4.sdp);
          return t4.shift(), t4.some((e5) => {
            const t5 = Wb.parseMLine(e5);
            return t5 && "application" === t5.kind && -1 !== t5.protocol.indexOf("SCTP");
          });
        }, r3 = function(e4) {
          const t4 = e4.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
          if (null === t4 || t4.length < 2)
            return -1;
          const i4 = parseInt(t4[1], 10);
          return i4 != i4 ? -1 : i4;
        }, n3 = function(e4) {
          let i4 = 65536;
          return "firefox" === t3.browser && (i4 = t3.version < 57 ? -1 === e4 ? 16384 : 2147483637 : t3.version < 60 ? 57 === t3.version ? 65535 : 65536 : 2147483637), i4;
        }, o3 = function(e4, i4) {
          let r4 = 65536;
          "firefox" === t3.browser && 57 === t3.version && (r4 = 65535);
          const n4 = Wb.matchPrefix(e4.sdp, "a=max-message-size:");
          return n4.length > 0 ? r4 = parseInt(n4[0].substr(19), 10) : "firefox" === t3.browser && -1 !== i4 && (r4 = 2147483637), r4;
        }, s3 = e3.RTCPeerConnection.prototype.setRemoteDescription;
        e3.RTCPeerConnection.prototype.setRemoteDescription = function() {
          if (this._sctp = null, "chrome" === t3.browser && t3.version >= 76) {
            const { sdpSemantics: e4 } = this.getConfiguration();
            "plan-b" === e4 && Object.defineProperty(this, "sctp", { get() {
              return void 0 === this._sctp ? null : this._sctp;
            }, enumerable: true, configurable: true });
          }
          if (i3(arguments[0])) {
            const e4 = r3(arguments[0]), t4 = n3(e4), i4 = o3(arguments[0], e4);
            let s4;
            s4 = 0 === t4 && 0 === i4 ? Number.POSITIVE_INFINITY : 0 === t4 || 0 === i4 ? Math.max(t4, i4) : Math.min(t4, i4);
            const a3 = {};
            Object.defineProperty(a3, "maxMessageSize", { get: () => s4 }), this._sctp = a3;
          }
          return s3.apply(this, arguments);
        };
      }
      function qb(e3) {
        if (!e3.RTCPeerConnection || !("createDataChannel" in e3.RTCPeerConnection.prototype))
          return;
        function t3(e4, t4) {
          const i4 = e4.send;
          e4.send = function() {
            const r3 = arguments[0], n3 = r3.length || r3.size || r3.byteLength;
            if ("open" === e4.readyState && t4.sctp && n3 > t4.sctp.maxMessageSize)
              throw new TypeError("Message too large (can send a maximum of " + t4.sctp.maxMessageSize + " bytes)");
            return i4.apply(e4, arguments);
          };
        }
        const i3 = e3.RTCPeerConnection.prototype.createDataChannel;
        e3.RTCPeerConnection.prototype.createDataChannel = function() {
          const e4 = i3.apply(this, arguments);
          return t3(e4, this), e4;
        }, Gh(e3, "datachannel", (e4) => (t3(e4.channel, e4.target), e4));
      }
      function Xb(e3) {
        if (!e3.RTCPeerConnection || "connectionState" in e3.RTCPeerConnection.prototype)
          return;
        const t3 = e3.RTCPeerConnection.prototype;
        Object.defineProperty(t3, "connectionState", { get() {
          return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
        }, enumerable: true, configurable: true }), Object.defineProperty(t3, "onconnectionstatechange", { get() {
          return this._onconnectionstatechange || null;
        }, set(e4) {
          this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e4 && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e4);
        }, enumerable: true, configurable: true }), ["setLocalDescription", "setRemoteDescription"].forEach((e4) => {
          const i3 = t3[e4];
          t3[e4] = function() {
            return this._connectionstatechangepoly || (this._connectionstatechangepoly = (e5) => {
              const t4 = e5.target;
              if (t4._lastConnectionState !== t4.connectionState) {
                t4._lastConnectionState = t4.connectionState;
                const i4 = new Event("connectionstatechange", e5);
                t4.dispatchEvent(i4);
              }
              return e5;
            }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i3.apply(this, arguments);
          };
        });
      }
      function zb(e3, t3) {
        if (!e3.RTCPeerConnection)
          return;
        if ("chrome" === t3.browser && t3.version >= 71)
          return;
        if ("safari" === t3.browser && t3.version >= 605)
          return;
        const i3 = e3.RTCPeerConnection.prototype.setRemoteDescription;
        e3.RTCPeerConnection.prototype.setRemoteDescription = function(t4) {
          if (t4 && t4.sdp && -1 !== t4.sdp.indexOf("\na=extmap-allow-mixed")) {
            const i4 = t4.sdp.split("\n").filter((e4) => "a=extmap-allow-mixed" !== Gb(e4).call(e4)).join("\n");
            e3.RTCSessionDescription && t4 instanceof e3.RTCSessionDescription ? arguments[0] = new e3.RTCSessionDescription({ type: t4.type, sdp: i4 }) : t4.sdp = i4;
          }
          return i3.apply(this, arguments);
        };
      }
      function Zb(e3, t3) {
        if (!e3.RTCPeerConnection || !e3.RTCPeerConnection.prototype)
          return;
        const i3 = e3.RTCPeerConnection.prototype.addIceCandidate;
        i3 && 0 !== i3.length && (e3.RTCPeerConnection.prototype.addIceCandidate = function() {
          return arguments[0] ? ("chrome" === t3.browser && t3.version < 78 || "firefox" === t3.browser && t3.version < 68 || "safari" === t3.browser) && arguments[0] && "" === arguments[0].candidate ? l_.resolve() : i3.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), l_.resolve());
        });
      }
      var $b = Object.freeze({ __proto__: null, shimRTCIceCandidate: Yb, shimMaxMessageSize: Jb, shimSendThrowTypeError: qb, shimConnectionState: Xb, removeExtmapAllowMixed: zb, shimAddIceCandidateNullOrEmpty: Zb });
      let eN, tN;
      !function() {
        let { window: e3 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: true, shimFirefox: true, shimEdge: true, shimSafari: true };
        const i3 = Wh, r3 = Jh(e3), n3 = { browserDetails: r3, commonShim: $b, extractVersion: jh, disableLog: Kh, disableWarnings: Hh };
        switch (r3.browser) {
          case "chrome":
            if (!$v || !zv || !t3.shimChrome)
              return i3("Chrome shim is not included in this adapter release."), n3;
            if (null === r3.version)
              return i3("Chrome shim can not determine version, not shimming."), n3;
            i3("adapter.js shimming chrome."), n3.browserShim = $v, Zb(e3, r3), Gv(e3, r3), Kv(e3), zv(e3, r3), Hv(e3), Xv(e3, r3), Wv(e3), Yv(e3), Jv(e3), Zv(e3, r3), Yb(e3), Xb(e3), Jb(e3, r3), qb(e3), zb(e3, r3);
            break;
          case "firefox":
            if (!gb || !sb || !t3.shimFirefox)
              return i3("Firefox shim is not included in this adapter release."), n3;
            i3("adapter.js shimming firefox."), n3.browserShim = gb, Zb(e3, r3), nb(e3, r3), sb(e3, r3), ob(e3), db(e3), ab(e3), cb(e3), ub(e3), hb(e3), Ab(e3), lb(e3), pb(e3), Yb(e3), Xb(e3), Jb(e3, r3), qb(e3);
            break;
          case "edge":
            if (!AT || !uT || !t3.shimEdge)
              return i3("MS edge shim is not included in this adapter release."), n3;
            i3("adapter.js shimming edge."), n3.browserShim = AT, cT(e3), dT(e3), uT(e3, r3), hT(e3), Jb(e3, r3), qb(e3);
            break;
          case "safari":
            if (!Rb || !t3.shimSafari)
              return i3("Safari shim is not included in this adapter release."), n3;
            i3("adapter.js shimming safari."), n3.browserShim = Rb, Zb(e3, r3), Cb(e3), vb(e3), mb(e3), Eb(e3), fb(e3), Sb(e3), Ib(e3), Tb(e3), Yb(e3), Jb(e3, r3), qb(e3), zb(e3, r3);
            break;
          default:
            i3("Unsupported browser!");
        }
      }({ window: "undefined" == typeof window ? void 0 : window }), function(e3) {
        e3.WIN_10 = "Windows 10", e3.WIN_81 = "Windows 8.1", e3.WIN_8 = "Windows 8", e3.WIN_7 = "Windows 7", e3.WIN_VISTA = "Windows Vista", e3.WIN_SERVER_2003 = "Windows Server 2003", e3.WIN_XP = "Windows XP", e3.WIN_2000 = "Windows 2000", e3.ANDROID = "Android", e3.OPEN_BSD = "Open BSD", e3.SUN_OS = "Sun OS", e3.LINUX = "Linux", e3.IOS = "iOS", e3.MAC_OS = "Mac OS", e3.QNX = "QNX", e3.UNIX = "UNIX", e3.BEOS = "BeOS", e3.OS_2 = "OS/2", e3.SEARCH_BOT = "Search Bot";
      }(eN || (eN = {})), function(e3) {
        e3.CHROME = "Chrome", e3.SAFARI = "Safari", e3.EDGE = "Edge", e3.FIREFOX = "Firefox", e3.OPERA = "OPR", e3.QQ = "QQBrowser", e3.WECHAT = "MicroMessenger";
      }(tN || (tN = {}));
      var iN = { exports: {} };
      !function(t3, i3) {
        !function(e3, r3) {
          var n3 = "function", o3 = "undefined", s3 = "object", a3 = "string", c3 = "model", d3 = "name", u3 = "type", h3 = "vendor", A3 = "version", l3 = "architecture", p3 = "console", g3 = "mobile", E3 = "tablet", f3 = "smarttv", m3 = "wearable", I3 = "embedded", _3 = "Amazon", C3 = "Apple", S3 = "ASUS", v3 = "BlackBerry", T3 = "Firefox", R3 = "Google", y3 = "Huawei", w3 = "LG", b3 = "Microsoft", N3 = "Motorola", O3 = "Opera", D3 = "Samsung", P3 = "Sharp", L3 = "Sony", k3 = "Xiaomi", B3 = "Zebra", M3 = "Facebook", U3 = function(e4) {
            for (var t4 = {}, i4 = 0; i4 < e4.length; i4++)
              t4[e4[i4].toUpperCase()] = e4[i4];
            return t4;
          }, x3 = function(e4, t4) {
            return typeof e4 === a3 && -1 !== Q3(t4).indexOf(Q3(e4));
          }, Q3 = function(e4) {
            return e4.toLowerCase();
          }, F3 = function(e4, t4) {
            if (typeof e4 === a3)
              return e4 = e4.replace(/^\s\s*/, "").replace(/\s\s*$/, ""), typeof t4 === o3 ? e4 : e4.substring(0, 350);
          }, V3 = function(e4, t4) {
            for (var i4, o4, a4, c4, d4, u4, h4 = 0; h4 < t4.length && !d4; ) {
              var A4 = t4[h4], l4 = t4[h4 + 1];
              for (i4 = o4 = 0; i4 < A4.length && !d4; )
                if (d4 = A4[i4++].exec(e4))
                  for (a4 = 0; a4 < l4.length; a4++)
                    u4 = d4[++o4], typeof (c4 = l4[a4]) === s3 && c4.length > 0 ? 2 === c4.length ? typeof c4[1] == n3 ? this[c4[0]] = c4[1].call(this, u4) : this[c4[0]] = c4[1] : 3 === c4.length ? typeof c4[1] !== n3 || c4[1].exec && c4[1].test ? this[c4[0]] = u4 ? u4.replace(c4[1], c4[2]) : r3 : this[c4[0]] = u4 ? c4[1].call(this, u4, c4[2]) : r3 : 4 === c4.length && (this[c4[0]] = u4 ? c4[3].call(this, u4.replace(c4[1], c4[2])) : r3) : this[c4] = u4 || r3;
              h4 += 2;
            }
          }, j3 = function(e4, t4) {
            for (var i4 in t4)
              if (typeof t4[i4] === s3 && t4[i4].length > 0) {
                for (var n4 = 0; n4 < t4[i4].length; n4++)
                  if (x3(t4[i4][n4], e4))
                    return "?" === i4 ? r3 : i4;
              } else if (x3(t4[i4], e4))
                return "?" === i4 ? r3 : i4;
            return e4;
          }, G3 = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, K3 = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [A3, [d3, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [A3, [d3, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [d3, A3], [/opios[\/ ]+([\w\.]+)/i], [A3, [d3, "Opera Mini"]], [/\bopr\/([\w\.]+)/i], [A3, [d3, O3]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [d3, A3], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [A3, [d3, "UCBrowser"]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [A3, [d3, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [A3, [d3, "WeChat"]], [/konqueror\/([\w\.]+)/i], [A3, [d3, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [A3, [d3, "IE"]], [/yabrowser\/([\w\.]+)/i], [A3, [d3, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[d3, /(.+)/, "$1 Secure Browser"], A3], [/\bfocus\/([\w\.]+)/i], [A3, [d3, "Firefox Focus"]], [/\bopt\/([\w\.]+)/i], [A3, [d3, "Opera Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [A3, [d3, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [A3, [d3, "Dolphin"]], [/coast\/([\w\.]+)/i], [A3, [d3, "Opera Coast"]], [/miuibrowser\/([\w\.]+)/i], [A3, [d3, "MIUI Browser"]], [/fxios\/([-\w\.]+)/i], [A3, [d3, T3]], [/\bqihu|(qi?ho?o?|360)browser/i], [[d3, "360 Browser"]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[d3, /(.+)/, "$1 Browser"], A3], [/(comodo_dragon)\/([\w\.]+)/i], [[d3, /_/g, " "], A3], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [d3, A3], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [d3], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[d3, M3], A3], [/safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [d3, A3], [/\bgsa\/([\w\.]+) .*safari\//i], [A3, [d3, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [A3, [d3, "Chrome Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[d3, "Chrome WebView"], A3], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [A3, [d3, "Android Browser"]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [d3, A3], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [A3, [d3, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [A3, d3], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [d3, [A3, j3, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [d3, A3], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[d3, "Netscape"], A3], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [A3, [d3, "Firefox Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i], [d3, A3]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[l3, "amd64"]], [/(ia32(?=;))/i], [[l3, Q3]], [/((?:i[346]|x)86)[;\)]/i], [[l3, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[l3, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[l3, "armhf"]], [/windows (ce|mobile); ppc;/i], [[l3, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[l3, /ower/, "", Q3]], [/(sun4\w)[;\)]/i], [[l3, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[l3, Q3]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [c3, [h3, D3], [u3, E3]], [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [c3, [h3, D3], [u3, g3]], [/\((ip(?:hone|od)[\w ]*);/i], [c3, [h3, C3], [u3, g3]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [c3, [h3, C3], [u3, E3]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [c3, [h3, y3], [u3, E3]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [c3, [h3, y3], [u3, g3]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[c3, /_/g, " "], [h3, k3], [u3, g3]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[c3, /_/g, " "], [h3, k3], [u3, E3]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [c3, [h3, "OPPO"], [u3, g3]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [c3, [h3, "Vivo"], [u3, g3]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [c3, [h3, "Realme"], [u3, g3]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [c3, [h3, N3], [u3, g3]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [c3, [h3, N3], [u3, E3]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [c3, [h3, w3], [u3, E3]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [c3, [h3, w3], [u3, g3]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [c3, [h3, "Lenovo"], [u3, E3]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[c3, /_/g, " "], [h3, "Nokia"], [u3, g3]], [/(pixel c)\b/i], [c3, [h3, R3], [u3, E3]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [c3, [h3, R3], [u3, g3]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [c3, [h3, L3], [u3, g3]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[c3, "Xperia Tablet"], [h3, L3], [u3, E3]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [c3, [h3, "OnePlus"], [u3, g3]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [c3, [h3, _3], [u3, E3]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[c3, /(.+)/g, "Fire Phone $1"], [h3, _3], [u3, g3]], [/(playbook);[-\w\),; ]+(rim)/i], [c3, h3, [u3, E3]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [c3, [h3, v3], [u3, g3]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [c3, [h3, S3], [u3, E3]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [c3, [h3, S3], [u3, g3]], [/(nexus 9)/i], [c3, [h3, "HTC"], [u3, E3]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\w]*)/i], [h3, [c3, /_/g, " "], [u3, g3]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [c3, [h3, "Acer"], [u3, E3]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [c3, [h3, "Meizu"], [u3, g3]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [c3, [h3, P3], [u3, g3]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [h3, c3, [u3, g3]], [/(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [h3, c3, [u3, E3]], [/(surface duo)/i], [c3, [h3, b3], [u3, E3]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [c3, [h3, "Fairphone"], [u3, g3]], [/(u304aa)/i], [c3, [h3, "AT&T"], [u3, g3]], [/\bsie-(\w*)/i], [c3, [h3, "Siemens"], [u3, g3]], [/\b(rct\w+) b/i], [c3, [h3, "RCA"], [u3, E3]], [/\b(venue[\d ]{2,7}) b/i], [c3, [h3, "Dell"], [u3, E3]], [/\b(q(?:mv|ta)\w+) b/i], [c3, [h3, "Verizon"], [u3, E3]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [c3, [h3, "Barnes & Noble"], [u3, E3]], [/\b(tm\d{3}\w+) b/i], [c3, [h3, "NuVision"], [u3, E3]], [/\b(k88) b/i], [c3, [h3, "ZTE"], [u3, E3]], [/\b(nx\d{3}j) b/i], [c3, [h3, "ZTE"], [u3, g3]], [/\b(gen\d{3}) b.+49h/i], [c3, [h3, "Swiss"], [u3, g3]], [/\b(zur\d{3}) b/i], [c3, [h3, "Swiss"], [u3, E3]], [/\b((zeki)?tb.*\b) b/i], [c3, [h3, "Zeki"], [u3, E3]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[h3, "Dragon Touch"], c3, [u3, E3]], [/\b(ns-?\w{0,9}) b/i], [c3, [h3, "Insignia"], [u3, E3]], [/\b((nxa|next)-?\w{0,9}) b/i], [c3, [h3, "NextBook"], [u3, E3]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[h3, "Voice"], c3, [u3, g3]], [/\b(lvtel\-)?(v1[12]) b/i], [[h3, "LvTel"], c3, [u3, g3]], [/\b(ph-1) /i], [c3, [h3, "Essential"], [u3, g3]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [c3, [h3, "Envizen"], [u3, E3]], [/\b(trio[-\w\. ]+) b/i], [c3, [h3, "MachSpeed"], [u3, E3]], [/\btu_(1491) b/i], [c3, [h3, "Rotor"], [u3, E3]], [/(shield[\w ]+) b/i], [c3, [h3, "Nvidia"], [u3, E3]], [/(sprint) (\w+)/i], [h3, c3, [u3, g3]], [/(kin\.[onetw]{3})/i], [[c3, /\./g, " "], [h3, b3], [u3, g3]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [c3, [h3, B3], [u3, E3]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [c3, [h3, B3], [u3, g3]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [h3, c3, [u3, p3]], [/droid.+; (shield) bui/i], [c3, [h3, "Nvidia"], [u3, p3]], [/(playstation [345portablevi]+)/i], [c3, [h3, L3], [u3, p3]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [c3, [h3, b3], [u3, p3]], [/smart-tv.+(samsung)/i], [h3, [u3, f3]], [/hbbtv.+maple;(\d+)/i], [[c3, /^/, "SmartTV"], [h3, D3], [u3, f3]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[h3, w3], [u3, f3]], [/(apple) ?tv/i], [h3, [c3, "Apple TV"], [u3, f3]], [/crkey/i], [[c3, "Chromecast"], [h3, R3], [u3, f3]], [/droid.+aft(\w)( bui|\))/i], [c3, [h3, _3], [u3, f3]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [c3, [h3, P3], [u3, f3]], [/(bravia[\w ]+)( bui|\))/i], [c3, [h3, L3], [u3, f3]], [/(mitv-\w{5}) bui/i], [c3, [h3, k3], [u3, f3]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i], [[h3, F3], [c3, F3], [u3, f3]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[u3, f3]], [/((pebble))app/i], [h3, c3, [u3, m3]], [/droid.+; (glass) \d/i], [c3, [h3, R3], [u3, m3]], [/droid.+; (wt63?0{2,3})\)/i], [c3, [h3, B3], [u3, m3]], [/(quest( 2)?)/i], [c3, [h3, M3], [u3, m3]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [h3, [u3, I3]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [c3, [u3, g3]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [c3, [u3, E3]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[u3, E3]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[u3, g3]], [/(android[-\w\. ]{0,9});.+buil/i], [c3, [h3, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [A3, [d3, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [A3, [d3, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [d3, A3], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [A3, d3]], os: [[/microsoft (windows) (vista|xp)/i], [d3, A3], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [d3, [A3, j3, G3]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[d3, "Windows"], [A3, j3, G3]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[A3, /_/g, "."], [d3, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[d3, "Mac OS"], [A3, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [A3, d3], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [d3, A3], [/\(bb(10);/i], [A3, [d3, v3]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [A3, [d3, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [A3, [d3, "Firefox OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [A3, [d3, "webOS"]], [/crkey\/([\d\.]+)/i], [A3, [d3, "Chromecast"]], [/(cros) [\w]+ ([\w\.]+\w)/i], [[d3, "Chromium OS"], A3], [/(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [d3, A3], [/(sunos) ?([\w\.\d]*)/i], [[d3, "Solaris"], A3], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [d3, A3]] }, H3 = function(t4, i4) {
            if (typeof t4 === s3 && (i4 = t4, t4 = r3), !(this instanceof H3))
              return new H3(t4, i4).getResult();
            var n4 = t4 || (typeof e3 !== o3 && e3.navigator && e3.navigator.userAgent ? e3.navigator.userAgent : ""), c4 = i4 ? function(e4, t5) {
              var i5 = {};
              for (var r4 in e4)
                t5[r4] && t5[r4].length % 2 == 0 ? i5[r4] = t5[r4].concat(e4[r4]) : i5[r4] = e4[r4];
              return i5;
            }(K3, i4) : K3;
            return this.getBrowser = function() {
              var e4 = {};
              return e4.name = r3, e4.version = r3, V3.call(e4, n4, c4.browser), e4.major = function(e5) {
                return typeof e5 === a3 ? e5.replace(/[^\d\.]/g, "").split(".")[0] : r3;
              }(e4.version), e4;
            }, this.getCPU = function() {
              var e4 = {};
              return e4.architecture = r3, V3.call(e4, n4, c4.cpu), e4;
            }, this.getDevice = function() {
              var e4 = {};
              return e4.vendor = r3, e4.model = r3, e4.type = r3, V3.call(e4, n4, c4.device), e4;
            }, this.getEngine = function() {
              var e4 = {};
              return e4.name = r3, e4.version = r3, V3.call(e4, n4, c4.engine), e4;
            }, this.getOS = function() {
              var e4 = {};
              return e4.name = r3, e4.version = r3, V3.call(e4, n4, c4.os), e4;
            }, this.getResult = function() {
              return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
            }, this.getUA = function() {
              return n4;
            }, this.setUA = function(e4) {
              return n4 = typeof e4 === a3 && e4.length > 350 ? F3(e4, 350) : e4, this;
            }, this.setUA(n4), this;
          };
          H3.VERSION = "0.7.32", H3.BROWSER = U3([d3, A3, "major"]), H3.CPU = U3([l3]), H3.DEVICE = U3([c3, h3, u3, p3, g3, f3, E3, m3, I3]), H3.ENGINE = H3.OS = U3([d3, A3]), t3.exports && (i3 = t3.exports = H3), i3.UAParser = H3;
          var W3 = typeof e3 !== o3 && (e3.jQuery || e3.Zepto);
          if (W3 && !W3.ua) {
            var Y3 = new H3();
            W3.ua = Y3.getResult(), W3.ua.get = function() {
              return Y3.getUA();
            }, W3.ua.set = function(e4) {
              Y3.setUA(e4);
              var t4 = Y3.getResult();
              for (var i4 in t4)
                W3.ua[i4] = t4[i4];
            };
          }
        }("object" == typeof window ? window : e);
      }(iN, iN.exports);
      const rN = new (0, iN.exports)();
      let nN = rN.getResult();
      function oN(e3) {
        return e3 && rN.setUA(e3), nN = rN.getResult(), { name: sN(nN), version: aN(nN), os: cN(nN), osVersion: nN.os.version };
      }
      function sN(e3) {
        if ("Blink" === e3.engine.name && "WeChat" !== e3.browser.name)
          return tN.CHROME;
        switch (e3.browser.name) {
          case "Chrome Headless":
          case "Chrome":
          case "Chromium":
            return tN.CHROME;
          case "Safari":
          case "Mobile Safari":
            return tN.SAFARI;
          case "Edge":
            return tN.EDGE;
          case "Firefox":
            return tN.FIREFOX;
          case "QQBrowser":
            return tN.QQ;
          case "Opera":
            return tN.OPERA;
          case "WeChat":
            return tN.WECHAT;
          default:
            return e3.browser.name || "";
        }
      }
      function aN(e3) {
        let t3;
        return t3 = "Blink" === e3.engine.name ? e3.engine.version || "" : e3.browser.version || "", t3.split(".")[0];
      }
      function cN(e3) {
        switch (e3.os.name) {
          case "Windows":
            return e3.os.version ? e3.os.name + " " + e3.os.version : e3.os.name;
          default:
            return e3.os.name || "";
        }
      }
      function dN() {
        return oN().os;
      }
      function uN() {
        const e3 = oN();
        return !!("WebKit" === nN.engine.name && e3.os === eN.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e3.name !== tN.SAFARI || EN() && e3.name !== tN.SAFARI);
      }
      function hN() {
        const e3 = oN();
        if (uN()) {
          if (e3.os === eN.MAC_OS)
            return true;
          if (e3.os === eN.IOS) {
            const e4 = nN.os.version && nN.os.version.split(".");
            if (e4 && 14 === Number(e4[0]) && e4[1] && Number(e4[1]) >= 3)
              return true;
            if (e4 && Number(e4[0]) > 14)
              return true;
          }
        }
        return false;
      }
      function AN() {
        return "WebKit" === nN.engine.name;
      }
      function lN() {
        return oN().name === tN.CHROME;
      }
      function pN() {
        return oN().name === tN.SAFARI;
      }
      function gN() {
        return oN().name === tN.FIREFOX;
      }
      function EN() {
        return oN().os === eN.IOS;
      }
      function fN() {
        const e3 = oN();
        return !(e3.name !== tN.CHROME || !e3.osVersion) && Number(e3.version) <= 90;
      }
      function mN() {
        const e3 = oN();
        if (e3.os !== eN.IOS || !e3.osVersion)
          return false;
        const t3 = e3.osVersion.split(".");
        return Number(t3[0]) <= 14 && Number(t3[1]) <= 6;
      }
      function IN() {
        const e3 = oN();
        if (e3.os !== eN.IOS || !e3.osVersion)
          return false;
        const t3 = e3.osVersion.split(".");
        return 15 === Number(t3[0]);
      }
      function _N() {
        const e3 = oN();
        if (e3.os !== eN.IOS || !e3.osVersion)
          return false;
        const t3 = e3.osVersion.split(".");
        return 15 === Number(t3[0]) && 0 === Number(t3[1]);
      }
      function CN() {
        const e3 = oN();
        if (e3.os !== eN.IOS || !e3.osVersion)
          return false;
        const t3 = e3.osVersion.split(".");
        return 15 === Number(t3[0]) && Number(t3[1]) >= 1;
      }
      function SN() {
        const e3 = oN();
        if (e3.os !== eN.IOS || !e3.osVersion)
          return false;
        const t3 = e3.osVersion.split(".");
        return 15 === Number(t3[0]) && Number(t3[1]) >= 2;
      }
      function vN() {
        return pN() && navigator.maxTouchPoints > 0;
      }
      function TN() {
        return oN().name === tN.WECHAT;
      }
      function RN() {
        return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35;
      }
      function yN() {
        const e3 = oN();
        if (e3.name === tN.EDGE || e3.name === tN.SAFARI)
          return false;
        return !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i);
      }
      function wN() {
        return oN().os === eN.ANDROID;
      }
      function bN() {
        const e3 = oN();
        return "Android" === e3.os && ("Chrome" === e3.name || e3.name === tN.WECHAT || /chrome|chromium/i.test(navigator.userAgent));
      }
      var NN = { exports: {} }, ON = ka, DN = Dn, PN = ia.f;
      ON({ target: "Object", stat: true, forced: Object.defineProperty !== PN, sham: !DN }, { defineProperty: PN });
      var LN = oo.Object, kN = NN.exports = function(e3, t3, i3) {
        return LN.defineProperty(e3, t3, i3);
      };
      LN.defineProperty.sham && (kN.sham = true);
      var BN = NN.exports;
      function MN(e3, t3, i3) {
        return t3 in e3 ? BN(e3, t3, { value: i3, enumerable: true, configurable: true, writable: true }) : e3[t3] = i3, e3;
      }
      var UN, xN = { exports: {} }, QN = function(e3, t3) {
        return function() {
          for (var i3 = new Array(arguments.length), r3 = 0; r3 < i3.length; r3++)
            i3[r3] = arguments[r3];
          return e3.apply(t3, i3);
        };
      }, FN = QN, VN = Object.prototype.toString, jN = (UN = /* @__PURE__ */ Object.create(null), function(e3) {
        var t3 = VN.call(e3);
        return UN[t3] || (UN[t3] = t3.slice(8, -1).toLowerCase());
      });
      function GN(e3) {
        return e3 = e3.toLowerCase(), function(t3) {
          return jN(t3) === e3;
        };
      }
      function KN(e3) {
        return Array.isArray(e3);
      }
      function HN(e3) {
        return void 0 === e3;
      }
      var WN = GN("ArrayBuffer");
      function YN(e3) {
        return null !== e3 && "object" == typeof e3;
      }
      function JN(e3) {
        if ("object" !== jN(e3))
          return false;
        var t3 = Object.getPrototypeOf(e3);
        return null === t3 || t3 === Object.prototype;
      }
      var qN = GN("Date"), XN = GN("File"), zN = GN("Blob"), ZN = GN("FileList");
      function $N(e3) {
        return "[object Function]" === VN.call(e3);
      }
      var eO = GN("URLSearchParams");
      function tO(e3, t3) {
        if (null != e3)
          if ("object" != typeof e3 && (e3 = [e3]), KN(e3))
            for (var i3 = 0, r3 = e3.length; i3 < r3; i3++)
              t3.call(null, e3[i3], i3, e3);
          else
            for (var n3 in e3)
              Object.prototype.hasOwnProperty.call(e3, n3) && t3.call(null, e3[n3], n3, e3);
      }
      var iO = function(e3) {
        return function(t3) {
          return e3 && t3 instanceof e3;
        };
      }("undefined" != typeof Uint8Array && Object.getPrototypeOf(Uint8Array)), rO = { isArray: KN, isArrayBuffer: WN, isBuffer: function(e3) {
        return null !== e3 && !HN(e3) && null !== e3.constructor && !HN(e3.constructor) && "function" == typeof e3.constructor.isBuffer && e3.constructor.isBuffer(e3);
      }, isFormData: function(e3) {
        var t3 = "[object FormData]";
        return e3 && ("function" == typeof FormData && e3 instanceof FormData || VN.call(e3) === t3 || $N(e3.toString) && e3.toString() === t3);
      }, isArrayBufferView: function(e3) {
        return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e3) : e3 && e3.buffer && WN(e3.buffer);
      }, isString: function(e3) {
        return "string" == typeof e3;
      }, isNumber: function(e3) {
        return "number" == typeof e3;
      }, isObject: YN, isPlainObject: JN, isUndefined: HN, isDate: qN, isFile: XN, isBlob: zN, isFunction: $N, isStream: function(e3) {
        return YN(e3) && $N(e3.pipe);
      }, isURLSearchParams: eO, isStandardBrowserEnv: function() {
        return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && ("undefined" != typeof window && "undefined" != typeof document);
      }, forEach: tO, merge: function e3() {
        var t3 = {};
        function i3(i4, r4) {
          JN(t3[r4]) && JN(i4) ? t3[r4] = e3(t3[r4], i4) : JN(i4) ? t3[r4] = e3({}, i4) : KN(i4) ? t3[r4] = i4.slice() : t3[r4] = i4;
        }
        for (var r3 = 0, n3 = arguments.length; r3 < n3; r3++)
          tO(arguments[r3], i3);
        return t3;
      }, extend: function(e3, t3, i3) {
        return tO(t3, function(t4, r3) {
          e3[r3] = i3 && "function" == typeof t4 ? FN(t4, i3) : t4;
        }), e3;
      }, trim: function(e3) {
        return e3.trim ? e3.trim() : e3.replace(/^\s+|\s+$/g, "");
      }, stripBOM: function(e3) {
        return 65279 === e3.charCodeAt(0) && (e3 = e3.slice(1)), e3;
      }, inherits: function(e3, t3, i3, r3) {
        e3.prototype = Object.create(t3.prototype, r3), e3.prototype.constructor = e3, i3 && Object.assign(e3.prototype, i3);
      }, toFlatObject: function(e3, t3, i3) {
        var r3, n3, o3, s3 = {};
        t3 = t3 || {};
        do {
          for (n3 = (r3 = Object.getOwnPropertyNames(e3)).length; n3-- > 0; )
            s3[o3 = r3[n3]] || (t3[o3] = e3[o3], s3[o3] = true);
          e3 = Object.getPrototypeOf(e3);
        } while (e3 && (!i3 || i3(e3, t3)) && e3 !== Object.prototype);
        return t3;
      }, kindOf: jN, kindOfTest: GN, endsWith: function(e3, t3, i3) {
        e3 = String(e3), (void 0 === i3 || i3 > e3.length) && (i3 = e3.length), i3 -= t3.length;
        var r3 = e3.indexOf(t3, i3);
        return -1 !== r3 && r3 === i3;
      }, toArray: function(e3) {
        if (!e3)
          return null;
        var t3 = e3.length;
        if (HN(t3))
          return null;
        for (var i3 = new Array(t3); t3-- > 0; )
          i3[t3] = e3[t3];
        return i3;
      }, isTypedArray: iO, isFileList: ZN }, nO = rO;
      function oO(e3) {
        return encodeURIComponent(e3).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      var sO = function(e3, t3, i3) {
        if (!t3)
          return e3;
        var r3;
        if (i3)
          r3 = i3(t3);
        else if (nO.isURLSearchParams(t3))
          r3 = t3.toString();
        else {
          var n3 = [];
          nO.forEach(t3, function(e4, t4) {
            null != e4 && (nO.isArray(e4) ? t4 += "[]" : e4 = [e4], nO.forEach(e4, function(e5) {
              nO.isDate(e5) ? e5 = e5.toISOString() : nO.isObject(e5) && (e5 = JSON.stringify(e5)), n3.push(oO(t4) + "=" + oO(e5));
            }));
          }), r3 = n3.join("&");
        }
        if (r3) {
          var o3 = e3.indexOf("#");
          -1 !== o3 && (e3 = e3.slice(0, o3)), e3 += (-1 === e3.indexOf("?") ? "?" : "&") + r3;
        }
        return e3;
      }, aO = rO;
      function cO() {
        this.handlers = [];
      }
      cO.prototype.use = function(e3, t3, i3) {
        return this.handlers.push({ fulfilled: e3, rejected: t3, synchronous: !!i3 && i3.synchronous, runWhen: i3 ? i3.runWhen : null }), this.handlers.length - 1;
      }, cO.prototype.eject = function(e3) {
        this.handlers[e3] && (this.handlers[e3] = null);
      }, cO.prototype.forEach = function(e3) {
        aO.forEach(this.handlers, function(t3) {
          null !== t3 && e3(t3);
        });
      };
      var dO = cO, uO = rO, hO = rO;
      function AO(e3, t3, i3, r3, n3) {
        Error.call(this), this.message = e3, this.name = "AxiosError", t3 && (this.code = t3), i3 && (this.config = i3), r3 && (this.request = r3), n3 && (this.response = n3);
      }
      hO.inherits(AO, Error, { toJSON: function() {
        return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null };
      } });
      var lO = AO.prototype, pO = {};
      ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function(e3) {
        pO[e3] = { value: e3 };
      }), Object.defineProperties(AO, pO), Object.defineProperty(lO, "isAxiosError", { value: true }), AO.from = function(e3, t3, i3, r3, n3, o3) {
        var s3 = Object.create(lO);
        return hO.toFlatObject(e3, s3, function(e4) {
          return e4 !== Error.prototype;
        }), AO.call(s3, e3.message, t3, i3, r3, n3), s3.name = e3.name, o3 && Object.assign(s3, o3), s3;
      };
      var gO = AO, EO = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, fO = rO;
      var mO = function(e3, t3) {
        t3 = t3 || new FormData();
        var i3 = [];
        function r3(e4) {
          return null === e4 ? "" : fO.isDate(e4) ? e4.toISOString() : fO.isArrayBuffer(e4) || fO.isTypedArray(e4) ? "function" == typeof Blob ? new Blob([e4]) : Buffer.from(e4) : e4;
        }
        return function e4(n3, o3) {
          if (fO.isPlainObject(n3) || fO.isArray(n3)) {
            if (-1 !== i3.indexOf(n3))
              throw Error("Circular reference detected in " + o3);
            i3.push(n3), fO.forEach(n3, function(i4, n4) {
              if (!fO.isUndefined(i4)) {
                var s3, a3 = o3 ? o3 + "." + n4 : n4;
                if (i4 && !o3 && "object" == typeof i4) {
                  if (fO.endsWith(n4, "{}"))
                    i4 = JSON.stringify(i4);
                  else if (fO.endsWith(n4, "[]") && (s3 = fO.toArray(i4)))
                    return void s3.forEach(function(e5) {
                      !fO.isUndefined(e5) && t3.append(a3, r3(e5));
                    });
                }
                e4(i4, a3);
              }
            }), i3.pop();
          } else
            t3.append(o3, r3(n3));
        }(e3), t3;
      }, IO = gO, _O = rO, CO = _O.isStandardBrowserEnv() ? { write: function(e3, t3, i3, r3, n3, o3) {
        var s3 = [];
        s3.push(e3 + "=" + encodeURIComponent(t3)), _O.isNumber(i3) && s3.push("expires=" + new Date(i3).toGMTString()), _O.isString(r3) && s3.push("path=" + r3), _O.isString(n3) && s3.push("domain=" + n3), true === o3 && s3.push("secure"), document.cookie = s3.join("; ");
      }, read: function(e3) {
        var t3 = document.cookie.match(new RegExp("(^|;\\s*)(" + e3 + ")=([^;]*)"));
        return t3 ? decodeURIComponent(t3[3]) : null;
      }, remove: function(e3) {
        this.write(e3, "", Date.now() - 864e5);
      } } : { write: function() {
      }, read: function() {
        return null;
      }, remove: function() {
      } }, SO = function(e3) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e3);
      }, vO = function(e3, t3) {
        return t3 ? e3.replace(/\/+$/, "") + "/" + t3.replace(/^\/+/, "") : e3;
      }, TO = function(e3, t3) {
        return e3 && !SO(t3) ? vO(e3, t3) : t3;
      }, RO = rO, yO = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"], wO = rO, bO = wO.isStandardBrowserEnv() ? function() {
        var e3, t3 = /(msie|trident)/i.test(navigator.userAgent), i3 = document.createElement("a");
        function r3(e4) {
          var r4 = e4;
          return t3 && (i3.setAttribute("href", r4), r4 = i3.href), i3.setAttribute("href", r4), { href: i3.href, protocol: i3.protocol ? i3.protocol.replace(/:$/, "") : "", host: i3.host, search: i3.search ? i3.search.replace(/^\?/, "") : "", hash: i3.hash ? i3.hash.replace(/^#/, "") : "", hostname: i3.hostname, port: i3.port, pathname: "/" === i3.pathname.charAt(0) ? i3.pathname : "/" + i3.pathname };
        }
        return e3 = r3(window.location.href), function(t4) {
          var i4 = wO.isString(t4) ? r3(t4) : t4;
          return i4.protocol === e3.protocol && i4.host === e3.host;
        };
      }() : function() {
        return true;
      }, NO = gO;
      function OO(e3) {
        NO.call(this, null == e3 ? "canceled" : e3, NO.ERR_CANCELED), this.name = "CanceledError";
      }
      rO.inherits(OO, NO, { __CANCEL__: true });
      var DO = OO, PO = rO, LO = function(e3, t3, i3) {
        var r3 = i3.config.validateStatus;
        i3.status && r3 && !r3(i3.status) ? t3(new IO("Request failed with status code " + i3.status, [IO.ERR_BAD_REQUEST, IO.ERR_BAD_RESPONSE][Math.floor(i3.status / 100) - 4], i3.config, i3.request, i3)) : e3(i3);
      }, kO = CO, BO = sO, MO = TO, UO = function(e3) {
        var t3, i3, r3, n3 = {};
        return e3 ? (RO.forEach(e3.split("\n"), function(e4) {
          if (r3 = e4.indexOf(":"), t3 = RO.trim(e4.substr(0, r3)).toLowerCase(), i3 = RO.trim(e4.substr(r3 + 1)), t3) {
            if (n3[t3] && yO.indexOf(t3) >= 0)
              return;
            n3[t3] = "set-cookie" === t3 ? (n3[t3] ? n3[t3] : []).concat([i3]) : n3[t3] ? n3[t3] + ", " + i3 : i3;
          }
        }), n3) : n3;
      }, xO = bO, QO = EO, FO = gO, VO = DO, jO = function(e3) {
        var t3 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e3);
        return t3 && t3[1] || "";
      }, GO = function(e3) {
        return new Promise(function(t3, i3) {
          var r3, n3 = e3.data, o3 = e3.headers, s3 = e3.responseType;
          function a3() {
            e3.cancelToken && e3.cancelToken.unsubscribe(r3), e3.signal && e3.signal.removeEventListener("abort", r3);
          }
          PO.isFormData(n3) && PO.isStandardBrowserEnv() && delete o3["Content-Type"];
          var c3 = new XMLHttpRequest();
          if (e3.auth) {
            var d3 = e3.auth.username || "", u3 = e3.auth.password ? unescape(encodeURIComponent(e3.auth.password)) : "";
            o3.Authorization = "Basic " + btoa(d3 + ":" + u3);
          }
          var h3 = MO(e3.baseURL, e3.url);
          function A3() {
            if (c3) {
              var r4 = "getAllResponseHeaders" in c3 ? UO(c3.getAllResponseHeaders()) : null, n4 = { data: s3 && "text" !== s3 && "json" !== s3 ? c3.response : c3.responseText, status: c3.status, statusText: c3.statusText, headers: r4, config: e3, request: c3 };
              LO(function(e4) {
                t3(e4), a3();
              }, function(e4) {
                i3(e4), a3();
              }, n4), c3 = null;
            }
          }
          if (c3.open(e3.method.toUpperCase(), BO(h3, e3.params, e3.paramsSerializer), true), c3.timeout = e3.timeout, "onloadend" in c3 ? c3.onloadend = A3 : c3.onreadystatechange = function() {
            c3 && 4 === c3.readyState && (0 !== c3.status || c3.responseURL && 0 === c3.responseURL.indexOf("file:")) && setTimeout(A3);
          }, c3.onabort = function() {
            c3 && (i3(new FO("Request aborted", FO.ECONNABORTED, e3, c3)), c3 = null);
          }, c3.onerror = function() {
            i3(new FO("Network Error", FO.ERR_NETWORK, e3, c3, c3)), c3 = null;
          }, c3.ontimeout = function() {
            var t4 = e3.timeout ? "timeout of " + e3.timeout + "ms exceeded" : "timeout exceeded", r4 = e3.transitional || QO;
            e3.timeoutErrorMessage && (t4 = e3.timeoutErrorMessage), i3(new FO(t4, r4.clarifyTimeoutError ? FO.ETIMEDOUT : FO.ECONNABORTED, e3, c3)), c3 = null;
          }, PO.isStandardBrowserEnv()) {
            var l3 = (e3.withCredentials || xO(h3)) && e3.xsrfCookieName ? kO.read(e3.xsrfCookieName) : void 0;
            l3 && (o3[e3.xsrfHeaderName] = l3);
          }
          "setRequestHeader" in c3 && PO.forEach(o3, function(e4, t4) {
            void 0 === n3 && "content-type" === t4.toLowerCase() ? delete o3[t4] : c3.setRequestHeader(t4, e4);
          }), PO.isUndefined(e3.withCredentials) || (c3.withCredentials = !!e3.withCredentials), s3 && "json" !== s3 && (c3.responseType = e3.responseType), "function" == typeof e3.onDownloadProgress && c3.addEventListener("progress", e3.onDownloadProgress), "function" == typeof e3.onUploadProgress && c3.upload && c3.upload.addEventListener("progress", e3.onUploadProgress), (e3.cancelToken || e3.signal) && (r3 = function(e4) {
            c3 && (i3(!e4 || e4 && e4.type ? new VO() : e4), c3.abort(), c3 = null);
          }, e3.cancelToken && e3.cancelToken.subscribe(r3), e3.signal && (e3.signal.aborted ? r3() : e3.signal.addEventListener("abort", r3))), n3 || (n3 = null);
          var p3 = jO(h3);
          p3 && -1 === ["http", "https", "file"].indexOf(p3) ? i3(new FO("Unsupported protocol " + p3 + ":", FO.ERR_BAD_REQUEST, e3)) : c3.send(n3);
        });
      }, KO = rO, HO = function(e3, t3) {
        uO.forEach(e3, function(i3, r3) {
          r3 !== t3 && r3.toUpperCase() === t3.toUpperCase() && (e3[t3] = i3, delete e3[r3]);
        });
      }, WO = gO, YO = mO, JO = { "Content-Type": "application/x-www-form-urlencoded" };
      function qO(e3, t3) {
        !KO.isUndefined(e3) && KO.isUndefined(e3["Content-Type"]) && (e3["Content-Type"] = t3);
      }
      var XO, zO = { transitional: EO, adapter: (("undefined" != typeof XMLHttpRequest || "undefined" != typeof process && "[object process]" === Object.prototype.toString.call(process)) && (XO = GO), XO), transformRequest: [function(e3, t3) {
        if (HO(t3, "Accept"), HO(t3, "Content-Type"), KO.isFormData(e3) || KO.isArrayBuffer(e3) || KO.isBuffer(e3) || KO.isStream(e3) || KO.isFile(e3) || KO.isBlob(e3))
          return e3;
        if (KO.isArrayBufferView(e3))
          return e3.buffer;
        if (KO.isURLSearchParams(e3))
          return qO(t3, "application/x-www-form-urlencoded;charset=utf-8"), e3.toString();
        var i3, r3 = KO.isObject(e3), n3 = t3 && t3["Content-Type"];
        if ((i3 = KO.isFileList(e3)) || r3 && "multipart/form-data" === n3) {
          var o3 = this.env && this.env.FormData;
          return YO(i3 ? { "files[]": e3 } : e3, o3 && new o3());
        }
        return r3 || "application/json" === n3 ? (qO(t3, "application/json"), function(e4, t4, i4) {
          if (KO.isString(e4))
            try {
              return (t4 || JSON.parse)(e4), KO.trim(e4);
            } catch (e5) {
              if ("SyntaxError" !== e5.name)
                throw e5;
            }
          return (i4 || JSON.stringify)(e4);
        }(e3)) : e3;
      }], transformResponse: [function(e3) {
        var t3 = this.transitional || zO.transitional, i3 = t3 && t3.silentJSONParsing, r3 = t3 && t3.forcedJSONParsing, n3 = !i3 && "json" === this.responseType;
        if (n3 || r3 && KO.isString(e3) && e3.length)
          try {
            return JSON.parse(e3);
          } catch (e4) {
            if (n3) {
              if ("SyntaxError" === e4.name)
                throw WO.from(e4, WO.ERR_BAD_RESPONSE, this, null, this.response);
              throw e4;
            }
          }
        return e3;
      }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: null }, validateStatus: function(e3) {
        return e3 >= 200 && e3 < 300;
      }, headers: { common: { Accept: "application/json, text/plain, */*" } } };
      KO.forEach(["delete", "get", "head"], function(e3) {
        zO.headers[e3] = {};
      }), KO.forEach(["post", "put", "patch"], function(e3) {
        zO.headers[e3] = KO.merge(JO);
      });
      var ZO = zO, $O = rO, eD = ZO, tD = function(e3) {
        return !(!e3 || !e3.__CANCEL__);
      }, iD = rO, rD = function(e3, t3, i3) {
        var r3 = this || eD;
        return $O.forEach(i3, function(i4) {
          e3 = i4.call(r3, e3, t3);
        }), e3;
      }, nD = tD, oD = ZO, sD = DO;
      function aD(e3) {
        if (e3.cancelToken && e3.cancelToken.throwIfRequested(), e3.signal && e3.signal.aborted)
          throw new sD();
      }
      var cD = rO, dD = function(e3, t3) {
        t3 = t3 || {};
        var i3 = {};
        function r3(e4, t4) {
          return cD.isPlainObject(e4) && cD.isPlainObject(t4) ? cD.merge(e4, t4) : cD.isPlainObject(t4) ? cD.merge({}, t4) : cD.isArray(t4) ? t4.slice() : t4;
        }
        function n3(i4) {
          return cD.isUndefined(t3[i4]) ? cD.isUndefined(e3[i4]) ? void 0 : r3(void 0, e3[i4]) : r3(e3[i4], t3[i4]);
        }
        function o3(e4) {
          if (!cD.isUndefined(t3[e4]))
            return r3(void 0, t3[e4]);
        }
        function s3(i4) {
          return cD.isUndefined(t3[i4]) ? cD.isUndefined(e3[i4]) ? void 0 : r3(void 0, e3[i4]) : r3(void 0, t3[i4]);
        }
        function a3(i4) {
          return i4 in t3 ? r3(e3[i4], t3[i4]) : i4 in e3 ? r3(void 0, e3[i4]) : void 0;
        }
        var c3 = { url: o3, method: o3, data: o3, baseURL: s3, transformRequest: s3, transformResponse: s3, paramsSerializer: s3, timeout: s3, timeoutMessage: s3, withCredentials: s3, adapter: s3, responseType: s3, xsrfCookieName: s3, xsrfHeaderName: s3, onUploadProgress: s3, onDownloadProgress: s3, decompress: s3, maxContentLength: s3, maxBodyLength: s3, beforeRedirect: s3, transport: s3, httpAgent: s3, httpsAgent: s3, cancelToken: s3, socketPath: s3, responseEncoding: s3, validateStatus: a3 };
        return cD.forEach(Object.keys(e3).concat(Object.keys(t3)), function(e4) {
          var t4 = c3[e4] || n3, r4 = t4(e4);
          cD.isUndefined(r4) && t4 !== a3 || (i3[e4] = r4);
        }), i3;
      }, uD = "0.27.2", hD = uD, AD = gO, lD = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(e3, t3) {
        lD[e3] = function(i3) {
          return typeof i3 === e3 || "a" + (t3 < 1 ? "n " : " ") + e3;
        };
      });
      var pD = {};
      lD.transitional = function(e3, t3, i3) {
        function r3(e4, t4) {
          return "[Axios v" + hD + "] Transitional option '" + e4 + "'" + t4 + (i3 ? ". " + i3 : "");
        }
        return function(i4, n3, o3) {
          if (false === e3)
            throw new AD(r3(n3, " has been removed" + (t3 ? " in " + t3 : "")), AD.ERR_DEPRECATED);
          return t3 && !pD[n3] && (pD[n3] = true, console.warn(r3(n3, " has been deprecated since v" + t3 + " and will be removed in the near future"))), !e3 || e3(i4, n3, o3);
        };
      };
      var gD = rO, ED = sO, fD = dO, mD = function(e3) {
        return aD(e3), e3.headers = e3.headers || {}, e3.data = rD.call(e3, e3.data, e3.headers, e3.transformRequest), e3.headers = iD.merge(e3.headers.common || {}, e3.headers[e3.method] || {}, e3.headers), iD.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(t3) {
          delete e3.headers[t3];
        }), (e3.adapter || oD.adapter)(e3).then(function(t3) {
          return aD(e3), t3.data = rD.call(e3, t3.data, t3.headers, e3.transformResponse), t3;
        }, function(t3) {
          return nD(t3) || (aD(e3), t3 && t3.response && (t3.response.data = rD.call(e3, t3.response.data, t3.response.headers, e3.transformResponse))), Promise.reject(t3);
        });
      }, ID = dD, _D = TO, CD = { assertOptions: function(e3, t3, i3) {
        if ("object" != typeof e3)
          throw new AD("options must be an object", AD.ERR_BAD_OPTION_VALUE);
        for (var r3 = Object.keys(e3), n3 = r3.length; n3-- > 0; ) {
          var o3 = r3[n3], s3 = t3[o3];
          if (s3) {
            var a3 = e3[o3], c3 = void 0 === a3 || s3(a3, o3, e3);
            if (true !== c3)
              throw new AD("option " + o3 + " must be " + c3, AD.ERR_BAD_OPTION_VALUE);
          } else if (true !== i3)
            throw new AD("Unknown option " + o3, AD.ERR_BAD_OPTION);
        }
      }, validators: lD }, SD = CD.validators;
      function vD(e3) {
        this.defaults = e3, this.interceptors = { request: new fD(), response: new fD() };
      }
      vD.prototype.request = function(e3, t3) {
        "string" == typeof e3 ? (t3 = t3 || {}).url = e3 : t3 = e3 || {}, (t3 = ID(this.defaults, t3)).method ? t3.method = t3.method.toLowerCase() : this.defaults.method ? t3.method = this.defaults.method.toLowerCase() : t3.method = "get";
        var i3 = t3.transitional;
        void 0 !== i3 && CD.assertOptions(i3, { silentJSONParsing: SD.transitional(SD.boolean), forcedJSONParsing: SD.transitional(SD.boolean), clarifyTimeoutError: SD.transitional(SD.boolean) }, false);
        var r3 = [], n3 = true;
        this.interceptors.request.forEach(function(e4) {
          "function" == typeof e4.runWhen && false === e4.runWhen(t3) || (n3 = n3 && e4.synchronous, r3.unshift(e4.fulfilled, e4.rejected));
        });
        var o3, s3 = [];
        if (this.interceptors.response.forEach(function(e4) {
          s3.push(e4.fulfilled, e4.rejected);
        }), !n3) {
          var a3 = [mD, void 0];
          for (Array.prototype.unshift.apply(a3, r3), a3 = a3.concat(s3), o3 = Promise.resolve(t3); a3.length; )
            o3 = o3.then(a3.shift(), a3.shift());
          return o3;
        }
        for (var c3 = t3; r3.length; ) {
          var d3 = r3.shift(), u3 = r3.shift();
          try {
            c3 = d3(c3);
          } catch (e4) {
            u3(e4);
            break;
          }
        }
        try {
          o3 = mD(c3);
        } catch (e4) {
          return Promise.reject(e4);
        }
        for (; s3.length; )
          o3 = o3.then(s3.shift(), s3.shift());
        return o3;
      }, vD.prototype.getUri = function(e3) {
        e3 = ID(this.defaults, e3);
        var t3 = _D(e3.baseURL, e3.url);
        return ED(t3, e3.params, e3.paramsSerializer);
      }, gD.forEach(["delete", "get", "head", "options"], function(e3) {
        vD.prototype[e3] = function(t3, i3) {
          return this.request(ID(i3 || {}, { method: e3, url: t3, data: (i3 || {}).data }));
        };
      }), gD.forEach(["post", "put", "patch"], function(e3) {
        function t3(t4) {
          return function(i3, r3, n3) {
            return this.request(ID(n3 || {}, { method: e3, headers: t4 ? { "Content-Type": "multipart/form-data" } : {}, url: i3, data: r3 }));
          };
        }
        vD.prototype[e3] = t3(), vD.prototype[e3 + "Form"] = t3(true);
      });
      var TD = vD, RD = DO;
      function yD(e3) {
        if ("function" != typeof e3)
          throw new TypeError("executor must be a function.");
        var t3;
        this.promise = new Promise(function(e4) {
          t3 = e4;
        });
        var i3 = this;
        this.promise.then(function(e4) {
          if (i3._listeners) {
            var t4, r3 = i3._listeners.length;
            for (t4 = 0; t4 < r3; t4++)
              i3._listeners[t4](e4);
            i3._listeners = null;
          }
        }), this.promise.then = function(e4) {
          var t4, r3 = new Promise(function(e5) {
            i3.subscribe(e5), t4 = e5;
          }).then(e4);
          return r3.cancel = function() {
            i3.unsubscribe(t4);
          }, r3;
        }, e3(function(e4) {
          i3.reason || (i3.reason = new RD(e4), t3(i3.reason));
        });
      }
      yD.prototype.throwIfRequested = function() {
        if (this.reason)
          throw this.reason;
      }, yD.prototype.subscribe = function(e3) {
        this.reason ? e3(this.reason) : this._listeners ? this._listeners.push(e3) : this._listeners = [e3];
      }, yD.prototype.unsubscribe = function(e3) {
        if (this._listeners) {
          var t3 = this._listeners.indexOf(e3);
          -1 !== t3 && this._listeners.splice(t3, 1);
        }
      }, yD.source = function() {
        var e3;
        return { token: new yD(function(t3) {
          e3 = t3;
        }), cancel: e3 };
      };
      var wD = yD, bD = rO, ND = rO, OD = QN, DD = TD, PD = dD;
      var LD = function e3(t3) {
        var i3 = new DD(t3), r3 = OD(DD.prototype.request, i3);
        return ND.extend(r3, DD.prototype, i3), ND.extend(r3, i3), r3.create = function(i4) {
          return e3(PD(t3, i4));
        }, r3;
      }(ZO);
      LD.Axios = DD, LD.CanceledError = DO, LD.CancelToken = wD, LD.isCancel = tD, LD.VERSION = uD, LD.toFormData = mO, LD.AxiosError = gO, LD.Cancel = LD.CanceledError, LD.all = function(e3) {
        return Promise.all(e3);
      }, LD.spread = function(e3) {
        return function(t3) {
          return e3.apply(null, t3);
        };
      }, LD.isAxiosError = function(e3) {
        return bD.isObject(e3) && true === e3.isAxiosError;
      }, xN.exports = LD, xN.exports.default = LD;
      var kD = xN.exports;
      class BD {
        constructor(e3) {
          MN(this, "logger", void 0), MN(this, "prefixLists", []), this.logger = e3;
        }
        debug() {
          for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
            t3[i3] = arguments[i3];
          this.logger.debug(...this.prefixLists, ...t3);
        }
        info() {
          for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
            t3[i3] = arguments[i3];
          this.logger.info(...this.prefixLists, ...t3);
        }
        warning() {
          for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
            t3[i3] = arguments[i3];
          this.logger.warning(...this.prefixLists, ...t3);
        }
        error() {
          for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
            t3[i3] = arguments[i3];
          this.logger.error(...this.prefixLists, ...t3);
        }
        prefix(e3) {
          return this.prefixLists.push(e3), this;
        }
        popPrefix() {
          return this.prefixLists.pop(), this;
        }
      }
      class MD {
        constructor() {
          MN(this, "_events", {}), MN(this, "addListener", this.on);
        }
        getListeners(e3) {
          return this._events[e3] ? this._events[e3].map((e4) => e4.listener) : [];
        }
        on(e3, t3) {
          this._events[e3] || (this._events[e3] = []);
          const i3 = this._events[e3];
          -1 === this._indexOfListener(i3, t3) && i3.push({ listener: t3, once: false });
        }
        once(e3, t3) {
          this._events[e3] || (this._events[e3] = []);
          const i3 = this._events[e3];
          -1 === this._indexOfListener(i3, t3) && i3.push({ listener: t3, once: true });
        }
        off(e3, t3) {
          if (!this._events[e3])
            return;
          const i3 = this._events[e3], r3 = this._indexOfListener(i3, t3);
          -1 !== r3 && i3.splice(r3, 1), 0 === this._events[e3].length && delete this._events[e3];
        }
        removeAllListeners(e3) {
          e3 ? delete this._events[e3] : this._events = {};
        }
        emit(e3) {
          this._events[e3] || (this._events[e3] = []);
          const t3 = this._events[e3].map((e4) => e4);
          for (var i3 = arguments.length, r3 = new Array(i3 > 1 ? i3 - 1 : 0), n3 = 1; n3 < i3; n3++)
            r3[n3 - 1] = arguments[n3];
          for (let i4 = 0; i4 < t3.length; i4 += 1) {
            const n4 = t3[i4];
            n4.once && this.off(e3, n4.listener), n4.listener.apply(this, r3 || []);
          }
        }
        _indexOfListener(e3, t3) {
          let i3 = e3.length;
          for (; i3--; )
            if (e3[i3].listener === t3)
              return i3;
          return -1;
        }
      }
      const UD = new class extends MD {
        reportLogUploadError(e3) {
          this.emit("REPORT_LOG_UPLOAD", e3);
        }
      }();
      let xD;
      !function(e3) {
        e3.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", e3.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", e3.TIMEOUT = "TIMEOUT", e3.INVALID_PARAMS = "INVALID_PARAMS", e3.NOT_READABLE = "NOT_READABLE", e3.NOT_SUPPORTED = "NOT_SUPPORTED", e3.INVALID_OPERATION = "INVALID_OPERATION", e3.OPERATION_ABORTED = "OPERATION_ABORTED", e3.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", e3.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", e3.NETWORK_ERROR = "NETWORK_ERROR", e3.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", e3.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", e3.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", e3.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", e3.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", e3.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", e3.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", e3.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", e3.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", e3.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", e3.PERMISSION_DENIED = "PERMISSION_DENIED", e3.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", e3.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", e3.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", e3.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", e3.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", e3.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", e3.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", e3.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", e3.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", e3.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", e3.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", e3.UID_CONFLICT = "UID_CONFLICT", e3.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", e3.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", e3.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", e3.INVALID_TRACK = "INVALID_TRACK", e3.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", e3.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", e3.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", e3.ICE_FAILED = "ICE_FAILED", e3.PC_CLOSED = "PC_CLOSED", e3.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", e3.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", e3.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", e3.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", e3.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", e3.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e3.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", e3.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", e3.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", e3.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", e3.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", e3.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", e3.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", e3.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", e3.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", e3.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", e3.WS_ABORT = "WS_ABORT", e3.WS_DISCONNECT = "WS_DISCONNECT", e3.WS_ERR = "WS_ERR", e3.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", e3.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", e3.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", e3.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", e3.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", e3.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", e3.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", e3.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", e3.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", e3.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", e3.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", e3.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", e3.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", e3.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", e3.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", e3.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", e3.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", e3.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", e3.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", e3.INVALID_PLUGIN = "INVALID_PLUGIN", e3.DISCONNECT_P2P = "DISCONNECT_P2P", e3.INIT_WEBSOCKET_TIMEOUT = "INIT_WEBSOCKET_TIMEOUT", e3.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = "CONVERTING_IMAGEDATA_TO_BLOB_FAILED", e3.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED", e3.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT", e3.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT";
      }(xD || (xD = {}));
      class QD extends Error {
        constructor(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", i3 = arguments.length > 2 ? arguments[2] : void 0;
          super(t3), MN(this, "code", void 0), MN(this, "message", void 0), MN(this, "data", void 0), MN(this, "name", "AgoraRTCException"), this.code = e3, this.message = "AgoraRTCError ".concat(this.code, ": ").concat(t3), this.data = i3;
        }
        toString() {
          return this.data ? "data: ".concat(JSON.stringify(this.data), "\n").concat(this.stack) : "".concat(this.stack);
        }
        print() {
          let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error";
          return "error" === e3 && JD.error(this.toString()), "warning" === e3 && JD.warning(this.toString()), this;
        }
        throw() {
          throw this.print(), this;
        }
      }
      const FD = { timeout: 500, timeoutFactor: 1.5, maxRetryCount: 1 / 0, maxRetryTimeout: 1e4 };
      function VD(e3, t3) {
        const i3 = Math.floor(t3.timeout * Math.pow(t3.timeoutFactor, e3));
        return Math.min(t3.maxRetryTimeout, i3);
      }
      function jD(e3, t3, i3, r3) {
        const n3 = Object.assign({}, FD, r3);
        let o3 = n3.timeout;
        const s3 = async () => {
          await function(e4) {
            return new l_((t4) => {
              window.setTimeout(t4, e4);
            });
          }(o3), o3 *= n3.timeoutFactor, o3 = Math.min(n3.maxRetryTimeout, o3);
        };
        let a3 = false;
        const c3 = new l_(async (r4, o4) => {
          t3 = t3 || (() => false), i3 = i3 || (() => true);
          for (let c4 = 0; c4 < n3.maxRetryCount; c4 += 1) {
            if (a3)
              return o4(new QD(xD.OPERATION_ABORTED));
            try {
              const i4 = await e3();
              if (!t3(i4, c4))
                return r4(i4);
              if (c4 + 1 === n3.maxRetryCount)
                return r4(i4);
              await s3();
            } catch (e4) {
              if (!i3(e4, c4))
                return o4(e4);
              if (c4 + 1 === n3.maxRetryCount)
                return o4(e4);
              await s3();
            }
          }
        });
        return c3.cancel = () => a3 = true, c3;
      }
      function GD() {
        const e3 = new Date();
        return e3.toTimeString().split(" ")[0] + ":" + e3.getMilliseconds();
      }
      function KD() {
        const e3 = new Date(), t3 = /((\d+:){2}\d+)/.exec(new Date().toUTCString());
        return t3 ? (null == t3 ? void 0 : t3[0]) + ":" + e3.getUTCMilliseconds() : e3.toTimeString().split(" ")[0] + ":" + e3.getMilliseconds();
      }
      const HD = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 }, WD = Date.now(), YD = (e3) => {
        for (const t3 in HD)
          if (Object.prototype.hasOwnProperty.call(HD, t3) && HD[t3] === e3)
            return t3;
        return "DEFAULT";
      };
      const JD = new class {
        constructor() {
          MN(this, "proxyServerURL", void 0), MN(this, "logLevel", HD.DEBUG), MN(this, "uploadState", "collecting"), MN(this, "uploadLogWaitingList", []), MN(this, "uploadLogUploadingList", []), MN(this, "uploadErrorCount", 0), MN(this, "currentLogID", 0), MN(this, "url", void 0), MN(this, "extLog", (e3, t3) => {
            this.appendLogToWaitingList(e3, ...t3);
          });
        }
        debug() {
          for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
            t3[i3] = arguments[i3];
          const r3 = [HD.DEBUG].concat(t3);
          this.log.apply(this, r3);
        }
        info() {
          for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
            t3[i3] = arguments[i3];
          const r3 = [HD.INFO].concat(t3);
          this.log.apply(this, r3);
        }
        warning() {
          for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
            t3[i3] = arguments[i3];
          const r3 = [HD.WARNING].concat(t3);
          this.log.apply(this, r3);
        }
        error() {
          for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
            t3[i3] = arguments[i3];
          const r3 = [HD.ERROR].concat(t3);
          this.log.apply(this, r3);
        }
        upload() {
          for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
            t3[i3] = arguments[i3];
          const r3 = [HD.DEBUG].concat(t3);
          this.uploadLog.apply(this, r3);
        }
        setLogLevel(e3) {
          e3 = Math.min(Math.max(0, e3), 4), this.logLevel = e3;
        }
        enableLogUpload() {
          PP("UPLOAD_LOG", true);
        }
        disableLogUpload() {
          PP("UPLOAD_LOG", false), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];
        }
        setProxyServer(e3) {
          this.proxyServerURL = e3;
        }
        prefix(e3) {
          return new BD(this).prefix(e3);
        }
        log() {
          for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
            t3[i3] = arguments[i3];
          if (Date.now() - WD < 100)
            return void setTimeout(() => {
              this.log(...t3);
            }, Date.now() - WD);
          const r3 = Math.max(0, Math.min(4, t3[0]));
          if (t3[0] = GD() + " Agora-SDK [".concat(YD(r3), "]:"), this.appendLogToWaitingList(r3, ...t3), r3 < this.logLevel)
            return;
          const n3 = GD() + " %cAgora-SDK [".concat(YD(r3), "]:");
          let o3 = [];
          if (!LP("USE_NEW_LOG"))
            switch (r3) {
              case HD.DEBUG:
                o3 = [n3, "color: #64B5F6;"].concat(t3.slice(1)), console.log.apply(console, o3);
                break;
              case HD.INFO:
                o3 = [n3, "color: #1E88E5; font-weight: bold;"].concat(t3.slice(1)), console.log.apply(console, o3);
                break;
              case HD.WARNING:
                o3 = [n3, "color: #FB8C00; font-weight: bold;"].concat(t3.slice(1)), console.warn.apply(console, o3);
                break;
              case HD.ERROR:
                o3 = [n3, "color: #B00020; font-weight: bold;"].concat(t3.slice(1)), console.error.apply(console, o3);
            }
        }
        uploadLog() {
          for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
            t3[i3] = arguments[i3];
          if (Date.now() - WD < 100)
            return void setTimeout(() => {
              this.uploadLog(...t3);
            }, Date.now() - WD);
          const r3 = Math.max(0, Math.min(4, t3[0]));
          t3[0] = GD() + " Agora-SDK [".concat(YD(r3), "]:"), this.appendLogToWaitingList(r3, ...t3);
        }
        appendLogToWaitingList(e3) {
          if (!LP("UPLOAD_LOG"))
            return;
          for (var t3 = arguments.length, i3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
            i3[r3 - 1] = arguments[r3];
          Array.isArray(i3[0]) ? i3[0][0] = KD() + " Agora-SDK [".concat(YD(e3), "]:") : i3[0] = KD() + " Agora-SDK [".concat(YD(e3), "]:");
          let n3 = "";
          i3.forEach((e4) => {
            "object" == typeof e4 && (e4 = JSON.stringify(e4)), n3 += "".concat(e4, " ");
          }), this.uploadLogWaitingList.push({ payload_str: n3, log_level: e3, log_item_id: this.currentLogID++ }), "uploading" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
        }
        startUpload() {
          this.uploadState = "uploading", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
        }
        async uploadLogs() {
          const e3 = this.uploadLogUploadingList, t3 = { sdk_version: CP, process_id: LP("PROCESS_ID"), payload: JSON.stringify(e3) };
          return jD(async () => {
            const e4 = await kD.post(this.url || (this.proxyServerURL ? "https://".concat(this.proxyServerURL, "/ls/?h=").concat(LP("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(LP("LOG_UPLOAD_SERVER"), "/upload/v1")), t3, { responseType: "text" });
            if ("OK" !== e4.data) {
              const t4 = new Error("unexpected upload log response");
              throw t4.response = e4, t4;
            }
          }, () => (this.uploadLogUploadingList = [], false), (e4) => (e4.response ? UD.reportLogUploadError({ status: e4.response.status, data: e4.response.data, headers: e4.response.headers, message: e4.message }) : e4.request ? UD.reportLogUploadError({ status: e4.request.status, message: e4.message }) : UD.reportLogUploadError({ status: -1, message: e4.message }), true), { timeout: LP("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"), maxRetryTimeout: LP("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL") });
        }
        uploadLogInterval() {
          0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, LP("UPLOAD_LOG_LENGTH_EACH_TIME"))), this.uploadLogs().then(() => {
            this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), LP("UPLOAD_LOG_INTERVAL"));
          }).catch((e3) => {
            this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), LP("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")) : window.setTimeout(() => this.uploadLogInterval(), LP("UPLOAD_LOG_RETRY_INTERVAL_V1"));
          }));
        }
      }(), qD = { debug: console.log, info: console.log, warning: console.warn, error: console.error }, XD = { debug: "color: #64B5F6;", info: "color: #1E88E5; font-weight: bold;", warning: "color: #FB8C00; font-weight: bold;", error: "color: #B00020; font-weight: bold;" }, zD = { debug: 0, info: 1, warning: 2, error: 3 }, ZD = [];
      let $D, eP = 0, tP = 0, iP = false;
      function rP() {
        const e3 = new Date();
        return [e3.getTime(), e3.toTimeString().split(" ")[0] + ":" + e3.getMilliseconds()];
      }
      function nP(e3) {
        if (!LP("UPLOAD_LOG"))
          return;
        let t3;
        switch (e3.type) {
          case JL.MISC:
            t3 = [e3.timestamp, e3.level, e3.type, e3.module, e3.instanceId, [e3.msg]];
            break;
          case JL.INTERNAL_EVENT:
          case JL.PUBLIC_EVENT:
          case JL.WEB_EVENT:
            t3 = [e3.timestamp, e3.level, e3.type, e3.module, e3.instanceId, [e3.event, e3.msg]];
            break;
          case JL.INTERNAL_API:
          case JL.PUBLIC_API:
          case JL.WEB_API:
            t3 = [e3.timestamp, e3.level, e3.type, e3.module, e3.instanceId, [e3.api, e3.args, e3.result]];
        }
        ZD.push(t3);
      }
      function oP(e3, t3) {
        const [i3, r3] = rP(), n3 = "warning", o3 = "".concat(r3, " %cAgora-SDK [").concat(n3, "] [INTERNAL API]:"), s3 = { [JL.WEB_API]: "logWebAPI", [JL.PUBLIC_API]: "logPublicAPI", [JL.INTERNAL_API]: "logInternalAPI", [JL.WEB_EVENT]: "logWebEvent", [JL.PUBLIC_EVENT]: "logPublicEvent", [JL.INTERNAL_EVENT]: "logInternalEvent", [JL.MISC]: "logMisc" }[e3], a3 = [o3, XD.warning, "Log.".concat(s3), t3];
        LP("USE_NEW_LOG") && (aP(n3) && qD.warning.apply(console, a3), nP({ timestamp: i3, level: n3, module: "Log", instanceId: void 0, type: JL.INTERNAL_API, api: s3, args: void 0, result: t3.toString() }));
      }
      function sP(e3) {
        if (Array.isArray(e3)) {
          let [t4, i4] = e3;
          return t4 || (t4 = "Global"), { module: t4, instanceId: i4 };
        }
        let t3, i3;
        if ("string" != typeof e3.__moduleName)
          throw new Error("Cannot get __moduleName from log instance.");
        t3 = e3.__moduleName;
        try {
          i3 = e3.__instanceId;
        } catch (e4) {
          throw new Error("Cannot get __instanceId from log instance.");
        }
        return { module: t3, instanceId: i3 };
      }
      function aP(e3) {
        return zD[e3] >= tP;
      }
      function cP(e3, t3, i3, r3, n3, o3) {
        if (e3 === JL.PUBLIC_API || e3 === JL.WEB_API || e3 === JL.INTERNAL_API)
          try {
            const { module: s3, instanceId: a3 } = sP(i3);
            n3 = n3 && JSON.stringify(n3), o3 = o3 instanceof Error ? o3.toString() : o3 && JSON.stringify(o3);
            const [c3, d3] = rP(), u3 = ["".concat(d3, " %cAgora-SDK [").concat(t3, "] [").concat({ [JL.PUBLIC_API]: "PUBLIC API", [JL.WEB_API]: "WEB API", [JL.INTERNAL_API]: "INTERNAL API" }[e3], "]:"), XD[t3], "".concat(s3).concat(a3 ? "<".concat(a3, ">") : "", ".").concat(r3), n3, o3];
            LP("USE_NEW_LOG") && (aP(t3) && qD[t3].apply(console, u3), nP({ timestamp: c3, level: t3, module: s3, instanceId: a3, type: e3, api: r3, args: n3, result: o3 }));
          } catch (t4) {
            oP(e3, t4);
          }
      }
      function dP(e3, t3, i3, r3, n3) {
        if (e3 === JL.WEB_EVENT || e3 === JL.INTERNAL_EVENT || e3 === JL.PUBLIC_EVENT)
          try {
            const { module: o3, instanceId: s3 } = sP(i3);
            "string" != typeof n3 && (n3 = n3 instanceof Error ? n3.toString() : JSON.stringify(n3));
            const [a3, c3] = rP(), d3 = ["".concat(c3, " %cAgora-SDK [").concat(t3, "] [").concat({ [JL.WEB_EVENT]: "WEB EVENT", [JL.PUBLIC_EVENT]: "PUBLIC EVENT", [JL.INTERNAL_EVENT]: "INTERNAL EVENT" }[e3], "]:"), XD[t3], "".concat(o3).concat(s3 ? "<".concat(s3, ">") : "", ".on(").concat(r3, ")"), n3 || ""];
            LP("USE_NEW_LOG") && (aP(t3) && qD[t3].apply(console, d3), nP({ timestamp: a3, level: t3, module: o3, instanceId: s3, type: e3, event: r3, msg: n3 }));
          } catch (t4) {
            oP(e3, t4);
          }
      }
      function uP(e3) {
        $D = e3;
      }
      function hP(e3, t3, i3) {
        try {
          const { module: r3, instanceId: n3 } = sP(t3), [o3, s3] = rP(), a3 = ["".concat(s3, " %cAgora-SDK [").concat(e3, "] [MISC]:"), XD[e3], "".concat(r3).concat(n3 ? "<".concat(n3, ">") : ""), '"'.concat(i3, '"')];
          LP("USE_NEW_LOG") && (aP(e3) && qD[e3].apply(console, a3), nP({ timestamp: o3, level: e3, module: r3, instanceId: n3, type: JL.MISC, msg: i3 }));
        } catch (e4) {
          gP("warning", ["log"], "logMisc", void 0, e4);
        }
      }
      function AP(e3, t3, i3, r3) {
        dP(JL.INTERNAL_EVENT, e3, t3, i3, r3);
      }
      function lP(e3, t3, i3, r3) {
        dP(JL.PUBLIC_EVENT, e3, t3, i3, r3);
      }
      function pP(e3, t3, i3, r3) {
        dP(JL.WEB_EVENT, e3, t3, i3, r3);
      }
      function gP(e3, t3, i3, r3, n3) {
        cP(JL.INTERNAL_API, e3, t3, i3, r3, n3);
      }
      function EP(e3, t3, i3, r3, n3) {
        cP(JL.WEB_API, e3, t3, i3, r3, n3);
      }
      function fP(e3, t3, i3, r3, n3) {
        cP(JL.PUBLIC_API, e3, t3, i3, r3, n3);
      }
      function mP(e3, t3) {
        return function(i3) {
          return class extends i3 {
            get __moduleName() {
              return e3;
            }
            get __instanceId() {
              if (t3) {
                if ("function" == typeof this[t3])
                  return this[t3]();
                {
                  const e4 = t3.split(".");
                  return e4.length > 0 ? cc(e4).call(e4, (e5, t4) => {
                    try {
                      return e5 ? e5[t4] : e5;
                    } catch (e6) {
                      return;
                    }
                  }, this) : this[t3];
                }
              }
            }
          };
        };
      }
      async function IP(e3) {
        if (!e3 && iP)
          return;
        if (iP = true, !LP("UPLOAD_LOG"))
          return void setTimeout(() => IP(true), LP("UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF"));
        if (0 === ZD.length)
          return void setTimeout(() => IP(true), LP("UPLOAD_LOG_INTERVAL"));
        const t3 = ZD.slice(0, LP("UPLOAD_LOG_LENGTH_EACH_TIME")), i3 = { sdk_version: CP, log_version: LP("LOG_VERSION"), process_id: LP("PROCESS_ID"), index: eP, logs: JSON.stringify(t3) };
        await jD(async () => {
          const e4 = await kD.post($D ? "https://".concat($D, "/ls/?h=").concat(LP("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(LP("LOG_UPLOAD_SERVER"), "/upload/v1"), i3, { responseType: "text" });
          if ("OK" !== e4.data)
            throw new Error("Log service response error ".concat(e4.data));
          return e4;
        }, void 0, void 0, { timeout: LP("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"), maxRetryTimeout: LP("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL") }), ZD.splice(0, LP("UPLOAD_LOG_LENGTH_EACH_TIME")), eP += t3.length, setTimeout(() => IP(true), LP("UPLOAD_LOG_INTERVAL"));
      }
      const _P = "v4.15.0-0-g9051d3de-dirty(11/10/2022, 5:13:56 PM)", CP = function(e3) {
        if (e3.match(/[0-9]+\.[0-9]+\.[0-9]+$/))
          return e3;
        const t3 = e3.match(/([0-9]+\.[0-9]+\.[0-9]+)\-alpha\.([0-9]+)/);
        if (t3 && t3[1] && t3[2]) {
          const e4 = t3[1], i4 = t3[2];
          return "".concat(e4, ".").concat(i4);
        }
        const i3 = e3.match(/([0-9]+\.[0-9]+\.[0-9]+)\-special\.([0-9]+)/);
        if (i3 && i3[1] && i3[2]) {
          const e4 = i3[1], t4 = i3[2];
          return "".concat(e4, ".").concat(100 * (Number(t4) + 1));
        }
        return "4.0.0.999";
      }("4.15.0"), SP = function() {
        try {
          return true === JSON.parse("true");
        } catch (e3) {
          return true;
        }
      }(), vP = function() {
        const e3 = "us".concat("erna", "me"), t3 = "pa".concat("sswo", "rd"), i3 = ["t", "s", "t"];
        i3.splice(1, 0, "e");
        const r3 = i3.join(""), n3 = [];
        for (let e4 = 0; e4 < 6; e4++)
          n3.push("1");
        const o3 = n3.join(""), s3 = {};
        return s3[e3] = r3, s3[t3] = o3, Object.assign(s3, { turnServerURL: "", tcpport: 3433, udpport: 3478, forceturn: false });
      }();
      window.DEFAULT_TURN_CONFIG = vP;
      const TP = { "90p": UP(160, 90), "90p_1": UP(160, 90), "120p": UP(160, 120, 15, 30, 65), "120p_1": UP(160, 120, 15, 30, 65), "120p_3": UP(120, 120, 15, 30, 50), "120p_4": UP(212, 120), "180p": UP(320, 180, 15, 30, 140), "180p_1": UP(320, 180, 15, 30, 140), "180p_3": UP(180, 180, 15, 30, 100), "180p_4": UP(240, 180, 15, 30, 120), "240p": UP(320, 240, 15, 40, 200), "240p_1": UP(320, 240, 15, 40, 200), "240p_3": UP(240, 240, 15, 40, 140), "240p_4": UP(424, 240, 15, 40, 220), "360p": UP(640, 360, 15, 80, 400), "360p_1": UP(640, 360, 15, 80, 400), "360p_3": UP(360, 360, 15, 80, 260), "360p_4": UP(640, 360, 30, 80, 600), "360p_6": UP(360, 360, 30, 80, 400), "360p_7": UP(480, 360, 15, 80, 320), "360p_8": UP(480, 360, 30, 80, 490), "360p_9": UP(640, 360, 15, 80, 800), "360p_10": UP(640, 360, 24, 80, 800), "360p_11": UP(640, 360, 24, 80, 1e3), "480p": UP(640, 480, 15, 100, 500), "480p_1": UP(640, 480, 15, 100, 500), "480p_2": UP(640, 480, 30, 100, 1e3), "480p_3": UP(480, 480, 15, 100, 400), "480p_4": UP(640, 480, 30, 100, 750), "480p_6": UP(480, 480, 30, 100, 600), "480p_8": UP(848, 480, 15, 100, 610), "480p_9": UP(848, 480, 30, 100, 930), "480p_10": UP(640, 480, 10, 100, 400), "720p": UP(1280, 720, 15, 120, 1130), "720p_1": UP(1280, 720, 15, 120, 1130), "720p_2": UP(1280, 720, 30, 120, 2e3), "720p_3": UP(1280, 720, 30, 120, 1710), "720p_5": UP(960, 720, 15, 120, 910), "720p_6": UP(960, 720, 30, 120, 1380), "1080p": UP(1920, 1080, 15, 120, 2080), "1080p_1": UP(1920, 1080, 15, 120, 2080), "1080p_2": UP(1920, 1080, 30, 120, 3e3), "1080p_3": UP(1920, 1080, 30, 120, 3150), "1080p_5": UP(1920, 1080, 60, 120, 4780), "1440p": UP(2560, 1440, 30, 120, 4850), "1440p_1": UP(2560, 1440, 30, 120, 4850), "1440p_2": UP(2560, 1440, 60, 120, 7350), "4k": UP(3840, 2160, 30, 120, 8910), "4k_1": UP(3840, 2160, 30, 120, 8910), "4k_3": UP(3840, 2160, 60, 120, 13500) }, RP = { "480p": xP(640, 480, 5), "480p_1": xP(640, 480, 5), "480p_2": xP(640, 480, 30), "480p_3": xP(640, 480, 15), "720p": xP(1280, 720, 5), "720p_1": xP(1280, 720, 5), "720p_2": xP(1280, 720, 30), "720p_3": xP(1280, 720, 15), "1080p": xP(1920, 1080, 5), "1080p_1": xP(1920, 1080, 5), "1080p_2": xP(1920, 1080, 30), "1080p_3": xP(1920, 1080, 15) }, yP = { "1SL1TL": QP(1, 1), "3SL3TL": QP(3, 3), "2SL3TL": QP(2, 3) };
      function wP(e3) {
        return "string" == typeof e3 ? Object.assign({}, TP[e3]) : e3;
      }
      function bP(e3) {
        return "string" == typeof e3 ? Object.assign({}, RP[e3]) : e3;
      }
      function NP(e3) {
        return "string" == typeof e3 ? Object.assign({}, yP[e3]) : e3;
      }
      const OP = { speech_low_quality: MP(16e3, false), speech_standard: MP(32e3, false, 18), music_standard: MP(48e3, false), standard_stereo: MP(48e3, true, 56), high_quality: MP(48e3, false, 128), high_quality_stereo: MP(48e3, true, 192) };
      function DP(e3) {
        return "string" == typeof e3 ? Object.assign({}, OP[e3]) : e3;
      }
      function PP(e3, t3, i3) {
        Object.keys(kP).includes(e3) && (!i3 && Object.keys(BP).includes(e3) || (kP[e3] = t3));
      }
      function LP(e3) {
        return kP[e3];
      }
      const kP = { PROCESS_ID: "", ENCRYPT_AES: true, AREAS: ["CHINA", "GLOBAL"], WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-web-2.ap.sd-rtn.com", "cds-ap-web-3.agora.io", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-web-2.ap.sd-rtn.com", "sua-ap-web-3.agora.io", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-web-2.ap.sd-rtn.com", "uap-ap-web-3.agora.io", "uap-web-4.ap.sd-rtn.com"], LOG_UPLOAD_SERVER: "logservice.agora.io", EVENT_REPORT_DOMAIN: "statscollector-1.agora.io", EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com", ENABLE_EVENT_REPORT: true, GATEWAY_ADDRESS: [], GATEWAY_WSS_ADDRESS: "", LIVE_STREAMING_ADDRESS: "", HTTP_CONNECT_TIMEOUT: 5e3, SIGNAL_REQUEST_TIMEOUT: 1e4, REPORT_STATS: true, UPLOAD_LOG: false, NOT_REPORT_EVENT: [], SUBSCRIBE_TCC: true, PING_PONG_TIME_OUT: 10, WEBSOCKET_TIMEOUT_MIN: 1e4, EVENT_REPORT_SEND_INTERVAL: 3e3, CONFIG_DISTRIBUTE_INTERVAL: 3e5, ENABLE_CONFIG_DISTRIBUTE: true, CANDIDATE_TIMEOUT: 5e3, SHOW_REPORT_INVOKER_LOG: false, JOIN_EXTEND: "", PUB_EXTEND: "", SUB_EXTEND: "", FORCE_TURN: false, TURN_ENABLE_TCP: true, TURN_ENABLE_UDP: true, MAX_UPLOAD_CACHE: 50, UPLOAD_CACHE_INTERVAL: 2e3, AJAX_REQUEST_CONCURRENT: 3, REPORT_APP_SCENARIO: void 0, GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"], WORKER_DOMAIN: "edge.agora.io", TURN_DOMAIN: "edge.agora.io", EVENT_REPORT_RETRY: true, CHROME_FORCE_PLAN_B: false, AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400, AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3, AUDIO_VOLUME_INDICATION_INTERVAL: 2e3, VOLUME_VOICE_WEIGHT: 10, GET_VOLUME_OF_MUTED_AUDIO_TRACK: false, NORMAL_EVENT_QUEUE_CAPACITY: 100, CUSTOM_REPORT: true, CUSTOM_REPORT_LIMIT: 20, PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io", PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com", "webrtc-cloud-proxy.agora.io"], CUSTOM_PUB_ANSWER_MODIFIER: null, CUSTOM_SUB_ANSWER_MODIFIER: null, CUSTOM_PUB_OFFER_MODIFIER: null, CUSTOM_SUB_OFFER_MODIFIER: null, DSCP_TYPE: "high", REMOVE_NEW_CODECS: true, FRAGEMENT_LENGTH: 3, WEBSOCKET_COMPRESS: false, SIMULCAST: false, PRELOAD_MEDIA_COUNT: 0, USE_RTX: false, CHECK_VIDEO_VISIBLE_INTERVAL: 3e4, ENUMERATE_DEVICES_INTERVAL: false, ENUMERATE_DEVICES_INTERVAL_TIME: 1e4, USE_NEW_TOKEN: false, CLOSE_AFB_FOR_LOCAL_AP: true, JOIN_WITH_FALLBACK_SIGNAL_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: false, JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION: 2e3, USE_TURN_SERVER_OF_GATEWAY: false, H264_PROFILE_LEVEL_ID: "", USE_NEW_LOG: false, LOG_VERSION: 3, MEDIA_DEVICE_CONSTRAINTS: null, ENCRYPT_PROXY_USERNAME_AND_PSW: true, SDP_LOGGING: false, CSP_DETECTED_HOSTNAME_LIST: ["agora.io", "sd-rtn.com"], REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: false, LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: true, BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE", AI_DENOISER_PARAMETERS: {}, ADJUST_3A_FROM_PLUGINS: true, RAISE_H264_BASELINE_PRIORITY: true, FILTER_SEND_H264_BASELINE: false, ENABLE_PUBLISHED_USER_LIST: true, MAX_SUBSCRIPTION: 50, X_GOOGLE_START_BITRATE: void 0, NEW_REPORT_SERVER: false, NEW_REPORT_SERVER_DOMAINS: ["data-reporting.agora.io", "data-reporting.agora.io"], VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3, VIDEO_INSPECT_QUALITY_RATIO: 0.9, VIDEO_INSPECT_WORKER_MANAGER_HOST: "edge.agora.io", VIDEO_INSPECT_WORKER_MANAGER_PORT: "", VIDEO_INSPECT_WORKER_PORT: "", SHOW_VIDEO_INSPECT_WORKER_MESSAGE: false, STATS_COLLECTOR_PORT: 443, FORCE_TURN_TCP: false, SUBSCRIBE_AUDIO_FILTER_TOPN: void 0, ENABLE_PUBLISH_AUDIO_FILTER: void 0, WEBAUDIO_INIT_OPTIONS: void 0, FILTER_VIDEO_FEC: true, FILTER_AUDIO_FEC: false, CHROME_DUAL_STREAM_USE_ENCODING: true, EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4, ICE_RESTART: true, ENABLE_USER_LICENSE_CHECK: true, SIGNAL_CHANNEL: 0, TRANSMITTER_INITIAL_RTT: 30, TRANSMITTER_INITIAL_RTO: 30, TRANSMITTER_MAX_BATCH_ACK_COUNT: 2, TRANSMITTER_MAX_RTO: 500, DATACHANNEL_COMPRESS: true, FINGERPRINT: null, DC_JOIN_WITH_FAILBACK: 5e3, ACCOUNT_REGISTER_RETRY_TIMEOUT: 1, ACCOUNT_REGISTER_RETRY_RATIO: 2, ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4, ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5, AUDIO_CONTEXT: null, WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3, PLAYER_STATE_DEFER: 2e3, SIGNAL_REQUEST_WATCH_INTERVAL: 1e3, FILEPATH_LENMAX: 255, DUALSTREAM_OPERATION_CHECK: true, MEDIA_ELEMENT_EXISTS_DEPTH: 3, SHIM_CANDIDATE: false, LEAVE_MSG_TIMEOUT: 2e3, STATS_FILTER: { transportId: true, googTrackId: true }, UPLOAD_LOG_INTERVAL: 3e3, UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3, UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4, UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3, UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4, UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200, UPLOAD_LOG_LENGTH_EACH_TIME: 10, APP_TYPE: 0, SPATIALIZER_PARAMETERS: {} }, BP = {};
      function MP(e3, t3, i3) {
        return { sampleRate: e3, stereo: t3, bitrate: i3 };
      }
      function UP(e3, t3, i3, r3, n3) {
        return { width: e3, height: t3, frameRate: i3, bitrateMin: r3, bitrateMax: n3 };
      }
      function xP(e3, t3, i3, r3, n3) {
        return { width: { max: e3 }, height: { max: t3 }, frameRate: i3, bitrateMin: r3, bitrateMax: n3 };
      }
      function QP(e3, t3) {
        return { numSpatialLayers: e3, numTemporalLayers: t3 };
      }
      SP || (kP.WEBCS_DOMAIN = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"], kP.WEBCS_DOMAIN_BACKUP_LIST = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"], kP.PROXY_CS = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"], kP.CDS_AP = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], kP.ACCOUNT_REGISTER = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], kP.UAP_AP = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], kP.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io", kP.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io", kP.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io", kP.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io", kP.AREAS = ["NORTH_AMERICA", "OVERSEA"]);
      const FP = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]], VP = [], jP = [];
      var GP = ws, KP = ia, HP = Vn, WP = function(e3, t3, i3) {
        var r3 = GP(t3);
        r3 in e3 ? KP.f(e3, r3, HP(0, i3)) : e3[r3] = i3;
      }, YP = TA, JP = Va, qP = WP, XP = vn.Array, zP = Math.max, ZP = function(e3, t3, i3) {
        for (var r3 = JP(e3), n3 = YP(t3, r3), o3 = YP(void 0 === i3 ? r3 : i3, r3), s3 = XP(zP(o3 - n3, 0)), a3 = 0; n3 < o3; n3++, a3++)
          qP(s3, a3, e3[n3]);
        return s3.length = a3, s3;
      }, $P = ZP, eL = Math.floor, tL = function(e3, t3) {
        var i3 = e3.length, r3 = eL(i3 / 2);
        return i3 < 8 ? iL(e3, t3) : rL(e3, tL($P(e3, 0, r3), t3), tL($P(e3, r3), t3), t3);
      }, iL = function(e3, t3) {
        for (var i3, r3, n3 = e3.length, o3 = 1; o3 < n3; ) {
          for (r3 = o3, i3 = e3[o3]; r3 && t3(e3[r3 - 1], i3) > 0; )
            e3[r3] = e3[--r3];
          r3 !== o3++ && (e3[r3] = i3);
        }
        return e3;
      }, rL = function(e3, t3, i3, r3) {
        for (var n3 = t3.length, o3 = i3.length, s3 = 0, a3 = 0; s3 < n3 || a3 < o3; )
          e3[s3 + a3] = s3 < n3 && a3 < o3 ? r3(t3[s3], i3[a3]) <= 0 ? t3[s3++] : i3[a3++] : s3 < n3 ? t3[s3++] : i3[a3++];
        return e3;
      }, nL = tL, oL = Ao.match(/firefox\/(\d+)/i), sL = !!oL && +oL[1], aL = /MSIE|Trident/.test(Ao), cL = Ao.match(/AppleWebKit\/(\d+)\./), dL = !!cL && +cL[1], uL = ka, hL = _n, AL = Bo, lL = zo, pL = Va, gL = _p, EL = ln, fL = nL, mL = Xa, IL = sL, _L = aL, CL = Io, SL = dL, vL = [], TL = hL(vL.sort), RL = hL(vL.push), yL = EL(function() {
        vL.sort(void 0);
      }), wL = EL(function() {
        vL.sort(null);
      }), bL = mL("sort"), NL = !EL(function() {
        if (CL)
          return CL < 70;
        if (!(IL && IL > 3)) {
          if (_L)
            return true;
          if (SL)
            return SL < 603;
          var e3, t3, i3, r3, n3 = "";
          for (e3 = 65; e3 < 76; e3++) {
            switch (t3 = String.fromCharCode(e3), e3) {
              case 66:
              case 69:
              case 70:
              case 72:
                i3 = 3;
                break;
              case 68:
              case 71:
                i3 = 4;
                break;
              default:
                i3 = 2;
            }
            for (r3 = 0; r3 < 47; r3++)
              vL.push({ k: t3 + r3, v: i3 });
          }
          for (vL.sort(function(e4, t4) {
            return t4.v - e4.v;
          }), r3 = 0; r3 < vL.length; r3++)
            t3 = vL[r3].k.charAt(0), n3.charAt(n3.length - 1) !== t3 && (n3 += t3);
          return "DGBEFHACIJK" !== n3;
        }
      });
      uL({ target: "Array", proto: true, forced: yL || !wL || !bL || !NL }, { sort: function(e3) {
        void 0 !== e3 && AL(e3);
        var t3 = lL(this);
        if (NL)
          return void 0 === e3 ? TL(t3) : TL(t3, e3);
        var i3, r3, n3 = [], o3 = pL(t3);
        for (r3 = 0; r3 < o3; r3++)
          r3 in t3 && RL(n3, t3[r3]);
        for (fL(n3, function(e4) {
          return function(t4, i4) {
            return void 0 === i4 ? -1 : void 0 === t4 ? 1 : void 0 !== e4 ? +e4(t4, i4) || 0 : gL(t4) > gL(i4) ? 1 : -1;
          };
        }(e3)), i3 = n3.length, r3 = 0; r3 < i3; )
          t3[r3] = n3[r3++];
        for (; r3 < o3; )
          delete t3[r3++];
        return t3;
      } });
      var OL = ic("Array").sort, DL = Cn, PL = OL, LL = Array.prototype, kL = function(e3) {
        var t3 = e3.sort;
        return e3 === LL || DL(LL, e3) && t3 === LL.sort ? PL : t3;
      };
      function BL(e3, t3) {
        if ("boolean" != typeof e3)
          throw new QD(xD.INVALID_PARAMS, "Invalid ".concat(t3, ": The value is of the boolean type."));
      }
      function ML(e3, t3, i3) {
        if (i3.includes(e3))
          return;
        throw new QD(xD.INVALID_PARAMS, "".concat(t3, " can only be set as ").concat(JSON.stringify(i3)));
      }
      function UL(e3, t3) {
        let i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4, n3 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        if (e3 < i3 || e3 > r3 || n3 && !HL(e3)) {
          throw new QD(xD.INVALID_PARAMS, "invalid ".concat(t3, ": the value range is [").concat(i3, ", ").concat(r3, "]. integer only"));
        }
      }
      function xL(e3, t3) {
        if ("number" != typeof e3) {
          if (!(e3.min || e3.max || e3.ideal || e3.exact)) {
            throw new QD(xD.INVALID_PARAMS, "".concat(t3, " is not a valid ConstrainLong"));
          }
          void 0 !== e3.min && UL(e3.min, "".concat(t3, ".min"), 0, 1 / 0), void 0 !== e3.max && UL(e3.max, "".concat(t3, ".max"), 1, 1 / 0), void 0 !== e3.exact && UL(e3.exact, "".concat(t3, ".exact"), 1, 1 / 0), void 0 !== e3.ideal && UL(e3.ideal, "".concat(t3, ".ideal"), 1, 1 / 0);
        } else
          UL(e3, t3, 1, 1 / 0);
      }
      function QL(e3, t3) {
        let i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255, n3 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        if (null == e3)
          throw new QD(xD.INVALID_PARAMS, "".concat(t3 || "param", " cannot be empty"));
        if (!KL(e3, i3, r3, n3))
          throw new QD(xD.INVALID_PARAMS, "Invalid ".concat(t3 || "string param", ": Length of the string: [").concat(i3, ",").concat(r3, "].").concat(n3 ? " ASCII characters only." : ""));
      }
      function FL(e3, t3) {
        if (!Array.isArray(e3))
          throw new QD(xD.INVALID_PARAMS, "".concat(t3, " should be an array"));
      }
      function VL(e3) {
        if ("string" != typeof e3 || !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e3))
          throw JD.error("Invalid Channel Name ".concat(e3)), new QD(xD.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,");
      }
      function jL(e3) {
        if (!(t3 = e3, "number" == typeof t3 && Math.floor(t3) === t3 && 0 <= t3 && t3 <= 4294967295 || KL(e3, 1, 255)))
          throw JD.error("Invalid UID ".concat(e3, " ").concat(typeof e3)), new QD(xD.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
        var t3;
        "string" == typeof e3 && JD.warning("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.");
      }
      function GL(e3) {
        return null == e3;
      }
      function KL(e3) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255, r3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
        return "string" == typeof e3 && e3.length <= i3 && e3.length >= t3 && (!r3 || WL(e3));
      }
      function HL(e3) {
        return "number" == typeof e3 && e3 % 1 == 0;
      }
      function WL(e3) {
        if ("string" != typeof e3)
          return false;
        for (let t3 = 0; t3 < e3.length; t3 += 1) {
          const i3 = e3.charCodeAt(t3);
          if (i3 < 0 || i3 > 255)
            return false;
        }
        return true;
      }
      let YL, JL, qL;
      !function(e3) {
        e3.FREE = "free", e3.UPLOADING = "uploading";
      }(YL || (YL = {})), function(e3) {
        e3[e3.MISC = 0] = "MISC", e3[e3.INTERNAL_EVENT = 1] = "INTERNAL_EVENT", e3[e3.PUBLIC_EVENT = 2] = "PUBLIC_EVENT", e3[e3.WEB_EVENT = 3] = "WEB_EVENT", e3[e3.INTERNAL_API = 4] = "INTERNAL_API", e3[e3.WEB_API = 5] = "WEB_API", e3[e3.PUBLIC_API = 6] = "PUBLIC_API";
      }(JL || (JL = {})), function(e3) {
        e3.NONE = "none", e3.INIT = "init", e3.CANPLAY = "canplay", e3.PLAYING = "playing", e3.PAUSED = "paused", e3.SUSPEND = "suspend", e3.STALLED = "stalled", e3.WAITING = "waiting", e3.ERROR = "error", e3.DESTROYED = "destroyed", e3.ABORT = "abort", e3.ENDED = "ended", e3.EMPTIED = "emptied", e3.LOADEDDATA = "loadeddata";
      }(qL || (qL = {}));
      const XL = { uninit: 100, none: 110, init: 120, loadeddata: 130, canplay: 200, playing: 210, paused: 220, suspend: 300, stalled: 310, waiting: 320, error: 330, destroyed: 340, abort: 350, ended: 360, emptied: 370 };
      function zL(e3) {
        return QL(e3.reportId, "params.reportId", 0, 100, false), QL(e3.category, "params.category", 0, 100, false), QL(e3.event, "params.event", 0, 100, false), QL(e3.label, "params.label", 0, 100, false), UL(e3.value, "params.value", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, false), true;
      }
      const ZL = { sid: "", lts: 0, success: null, cname: null, uid: null, peer: null, cid: null, elapse: null, extend: null, vid: 0 };
      let $L, ek, tk, ik, rk, nk, ok, sk, ak, ck, dk, uk, hk, Ak, lk, pk, gk, Ek, fk, mk, Ik, _k, Ck, Sk;
      function vk(e3) {
        return UL(e3.timeout, "config.timeout", 0, 1e5), UL(e3.timeoutFactor, "config.timeoutFactor", 0, 100, false), UL(e3.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0), UL(e3.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0), true;
      }
      function Tk(e3) {
        return ML(e3.codec, "config.codec", ["vp8", "vp9", "av1", "h264"]), ML(e3.mode, "config.mode", ["rtc", "live"]), void 0 !== e3.audioCodec && ML(e3.audioCodec, "config.audioCodec", ["opus", "pcmu", "pcma", "g722"]), void 0 !== e3.proxyServer && QL(e3.proxyServer, "config.proxyServer", 1, 1e4), void 0 !== e3.turnServer && yk(e3.turnServer), void 0 !== e3.httpRetryConfig && vk(e3.httpRetryConfig), void 0 !== e3.websocketRetryConfig && vk(e3.websocketRetryConfig), true;
      }
      function Rk(e3) {
        if (!Array.isArray(e3) || e3.length < 1)
          return false;
        try {
          e3.forEach((e4) => {
            if (!e4.urls)
              throw Error();
          });
        } catch (e4) {
          return false;
        }
        return true;
      }
      function yk(e3) {
        return QL(e3.turnServerURL, "turnServerURL"), QL(e3.username, "username"), QL(e3.password, "password"), e3.udpport && UL(e3.udpport, "udpport", 1, 99999, true), e3.forceturn && BL(e3.forceturn, "forceturn"), e3.security && BL(e3.security, "security"), e3.tcpport && UL(e3.tcpport, "tcpport", 1, 99999, true), true;
      }
      function wk(e3) {
        return void 0 !== e3.level && ML(e3.level, "level", [1, 2, 3]), true;
      }
      !function(e3) {
        e3.PUBLISH = "publish", e3.SUBSCRIBE = "subscribe", e3.WS_COMPRESSOR_INIT = "ws_compressor_init", e3.SESSION_INIT = "session_init", e3.JOIN_CHOOSE_SERVER = "join_choose_server", e3.REQ_USER_ACCOUNT = "req_user_account", e3.JOIN_GATEWAY = "join_gateway", e3.REJOIN_GATEWAY = "rejoin_gateway", e3.STREAM_SWITCH = "stream_switch", e3.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager", e3.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter", e3.FIRST_VIDEO_RECEIVED = "first_video_received", e3.FIRST_AUDIO_RECEIVED = "first_audio_received", e3.FIRST_VIDEO_DECODE = "first_video_decode", e3.FIRST_AUDIO_DECODE = "first_audio_decode", e3.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e3.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e3.ON_UPDATE_STREAM = "on_update_stream", e3.ON_REMOVE_STREAM = "on_remove_stream", e3.USER_ANALYTICS = "req_user_analytics";
      }($L || ($L = {})), function(e3) {
        e3.SESSION = "io.agora.pb.Wrtc.Session", e3.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer", e3.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount", e3.JOIN_GATEWAY = "io.agora.pb.Wrtc.JoinGateway", e3.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway", e3.PUBLISH = "io.agora.pb.Wrtc.Publish", e3.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe", e3.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit", e3.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch", e3.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped", e3.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped", e3.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter", e3.REQUEST_PROXY_WORKER_MANAGER = "io.agora.pb.Wrtc.RequestProxyWorkerManager", e3.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke", e3.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived", e3.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived", e3.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode", e3.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode", e3.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream", e3.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream", e3.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream", e3.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream", e3.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout", e3.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus", e3.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent", e3.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent", e3.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP", e3.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit", e3.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics", e3.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed";
      }(ek || (ek = {})), function(e3) {
        e3[e3.WORKER_EVENT = 156] = "WORKER_EVENT", e3[e3.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT";
      }(tk || (tk = {})), function(e3) {
        e3[e3.SESSION = 26] = "SESSION", e3[e3.JOIN_CHOOSE_SERVER = 27] = "JOIN_CHOOSE_SERVER", e3[e3.REQ_USER_ACCOUNT = 196] = "REQ_USER_ACCOUNT", e3[e3.JOIN_GATEWAY = 28] = "JOIN_GATEWAY", e3[e3.PUBLISH = 30] = "PUBLISH", e3[e3.SUBSCRIBE = 29] = "SUBSCRIBE", e3[e3.WS_COMPRESSOR_INIT = 9430] = "WS_COMPRESSOR_INIT", e3[e3.STREAM_SWITCH = 32] = "STREAM_SWITCH", e3[e3.AUDIO_SENDING_STOPPED = 33] = "AUDIO_SENDING_STOPPED", e3[e3.VIDEO_SENDING_STOPPED = 34] = "VIDEO_SENDING_STOPPED", e3[e3.REQUEST_PROXY_APPCENTER = 35] = "REQUEST_PROXY_APPCENTER", e3[e3.REQUEST_PROXY_WORKER_MANAGER = 36] = "REQUEST_PROXY_WORKER_MANAGER", e3[e3.API_INVOKE = 41] = "API_INVOKE", e3[e3.FIRST_VIDEO_RECEIVED = 348] = "FIRST_VIDEO_RECEIVED", e3[e3.FIRST_AUDIO_RECEIVED = 349] = "FIRST_AUDIO_RECEIVED", e3[e3.FIRST_VIDEO_DECODE = 350] = "FIRST_VIDEO_DECODE", e3[e3.FIRST_AUDIO_DECODE = 351] = "FIRST_AUDIO_DECODE", e3[e3.ON_ADD_AUDIO_STREAM = 352] = "ON_ADD_AUDIO_STREAM", e3[e3.ON_ADD_VIDEO_STREAM = 353] = "ON_ADD_VIDEO_STREAM", e3[e3.ON_UPDATE_STREAM = 356] = "ON_UPDATE_STREAM", e3[e3.ON_REMOVE_STREAM = 355] = "ON_REMOVE_STREAM", e3[e3.JOIN_CHANNEL_TIMEOUT = 407] = "JOIN_CHANNEL_TIMEOUT", e3[e3.PEER_PUBLISH_STATUS = 408] = "PEER_PUBLISH_STATUS", e3[e3.WORKER_EVENT = 156] = "WORKER_EVENT", e3[e3.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT", e3[e3.JOIN_WEB_PROXY_AP = 700] = "JOIN_WEB_PROXY_AP", e3[e3.WEBSOCKET_QUIT = 671] = "WEBSOCKET_QUIT", e3[e3.USER_ANALYTICS = 1e4] = "USER_ANALYTICS", e3[e3.AUTOPLAY_FAILED = 9178] = "AUTOPLAY_FAILED";
      }(ik || (ik = {})), function(e3) {
        e3.CREATE_CLIENT = "createClient", e3.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements", e3.SET_AREA = "setArea", e3.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive", e3.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive", e3.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack", e3.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack", e3.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack", e3.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack", e3.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack", e3.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks", e3.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack", e3.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig", e3.START_PROXY_SERVER = "Client.startProxyServer", e3.STOP_PROXY_SERVER = "Client.stopProxyServer", e3.SET_PROXY_SERVER = "Client.setProxyServer", e3.SET_TURN_SERVER = "Client.setTurnServer", e3.SET_CLIENT_ROLE = "Client.setClientRole", e3.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter", e3.ENABLE_DUAL_STREAM = "Client.enableDualStream", e3.DISABLE_DUAL_STREAM = "Client.disableDualStream", e3.JOIN = "Client.join", e3.LEAVE = "Client.leave", e3.PUBLISH = "Client.publish", e3.UNPUBLISH = "Client.unpublish", e3.SUBSCRIBE = "Client.subscribe", e3.MASS_SUBSCRIBE = "Client.massSubscribe", e3.MASS_UNSUBSCRIBE = "Client.massUnsubscribe", e3.UNSUBSCRIBE = "Client.unsubscribe", e3.RENEW_TOKEN = "Client.renewToken", e3.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType", e3.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption", e3.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator", e3.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage", e3.INSPECT_VIDEO_CONTENT = "Client.inspectVideoContent", e3.STOP_INSPECT_VIDEO_CONTENT = "Client.stopInspectVideoContent", e3.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy", e3.DATACHANNEL_FAILBACK = "Client._datachannelFailback", e3.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning", e3.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError", e3.START_LIVE_STREAMING = "Client.startLiveStreaming", e3.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding", e3.STOP_LIVE_STREAMING = "Client.stopLiveStreaming", e3.ADD_INJECT_STREAM_URL = "Client.addInjectStreamUrl", e3.REMOVE_INJECT_STREAM_URL = "Client.removeInjectStreamUrl", e3.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay", e3.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay", e3.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay", e3.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request", e3.SET_CONFIG_DISTRIBUTE = "_configDistribute", e3.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute", e3.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play", e3.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement", e3.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop", e3.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume", e3.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice", e3.BUFFER_AUDIO_TRACK_START = "BufferSourceAudioTrack.startProcessAudioBuffer", e3.BUFFER_AUDIO_TRACK_STOP = "BufferSourceAudioTrack.stopProcessAudioBuffer", e3.BUFFER_AUDIO_TRACK_PAUSE = "BufferSourceAudioTrack.pauseProcessAudioBuffer", e3.BUFFER_AUDIO_TRACK_RESUME = "BufferSourceAudioTrack.resumeProcessAudioBuffer", e3.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer", e3.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play", e3.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop", e3.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = "LocalVideoTrack.getVideoElementVisibleStatus", e3.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect", e3.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice", e3.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = "CameraVideoTrack.setEncoderConfiguration", e3.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play", e3.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop", e3.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = "RemoteVideoTrack.getVideoElementVisibleStatus", e3.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play", e3.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop", e3.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume", e3.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice", e3.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack", e3.STREAM_TYPE_CHANGE = "streamTypeChange", e3.CONNECTION_STATE_CHANGE = "connectionStateChange", e3.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage";
      }(rk || (rk = {})), function(e3) {
        e3.TRACER = "tracer";
      }(nk || (nk = {})), function(e3) {
        e3.IDLE = "IDLE", e3.INITING = "INITING", e3.INITEND = "INITEND";
      }(ok || (ok = {})), function(e3) {
        e3.STATE_CHANGE = "state_change", e3.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged", e3.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged", e3.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged";
      }(sk || (sk = {})), function(e3) {
        e3[e3.ACCESS_POINT = 101] = "ACCESS_POINT", e3[e3.UNILBS = 201] = "UNILBS", e3[e3.STRING_UID_ALLOCATOR = 901] = "STRING_UID_ALLOCATOR";
      }(ak || (ak = {})), function(e3) {
        e3[e3.IIIEGAL_APPID = 1] = "IIIEGAL_APPID", e3[e3.IIIEGAL_UID = 2] = "IIIEGAL_UID", e3[e3.INTERNAL_ERROR = 3] = "INTERNAL_ERROR";
      }(ck || (ck = {})), function(e3) {
        e3[e3.INVALID_VENDOR_KEY = 5] = "INVALID_VENDOR_KEY", e3[e3.INVALID_CHANNEL_NAME = 7] = "INVALID_CHANNEL_NAME", e3[e3.INTERNAL_ERROR = 8] = "INTERNAL_ERROR", e3[e3.NO_AUTHORIZED = 9] = "NO_AUTHORIZED", e3[e3.DYNAMIC_KEY_TIMEOUT = 10] = "DYNAMIC_KEY_TIMEOUT", e3[e3.NO_ACTIVE_STATUS = 11] = "NO_ACTIVE_STATUS", e3[e3.DYNAMIC_KEY_EXPIRED = 13] = "DYNAMIC_KEY_EXPIRED", e3[e3.STATIC_USE_DYNAMIC_KEY = 14] = "STATIC_USE_DYNAMIC_KEY", e3[e3.DYNAMIC_USE_STATIC_KEY = 15] = "DYNAMIC_USE_STATIC_KEY", e3[e3.USER_OVERLOAD = 16] = "USER_OVERLOAD", e3[e3.FORBIDDEN_REGION = 18] = "FORBIDDEN_REGION", e3[e3.CANNOT_MEET_AREA_DEMAND = 19] = "CANNOT_MEET_AREA_DEMAND";
      }(dk || (dk = {})), function(e3) {
        e3[e3.NO_FLAG_SET = 100] = "NO_FLAG_SET", e3[e3.FLAG_SET_BUT_EMPTY = 101] = "FLAG_SET_BUT_EMPTY", e3[e3.INVALID_FALG_SET = 102] = "INVALID_FALG_SET", e3[e3.FLAG_SET_BUT_NO_RE = 103] = "FLAG_SET_BUT_NO_RE", e3[e3.INVALID_SERVICE_ID = 104] = "INVALID_SERVICE_ID", e3[e3.NO_SERVICE_AVAILABLE = 200] = "NO_SERVICE_AVAILABLE", e3[e3.NO_SERVICE_AVAILABLE_P2P = 201] = "NO_SERVICE_AVAILABLE_P2P", e3[e3.NO_SERVICE_AVAILABLE_VOICE = 202] = "NO_SERVICE_AVAILABLE_VOICE", e3[e3.NO_SERVICE_AVAILABLE_WEBRTC = 203] = "NO_SERVICE_AVAILABLE_WEBRTC", e3[e3.NO_SERVICE_AVAILABLE_CDS = 204] = "NO_SERVICE_AVAILABLE_CDS", e3[e3.NO_SERVICE_AVAILABLE_CDN = 205] = "NO_SERVICE_AVAILABLE_CDN", e3[e3.NO_SERVICE_AVAILABLE_TDS = 206] = "NO_SERVICE_AVAILABLE_TDS", e3[e3.NO_SERVICE_AVAILABLE_REPORT = 207] = "NO_SERVICE_AVAILABLE_REPORT", e3[e3.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER", e3[e3.NO_SERVICE_AVAILABLE_ENV0 = 209] = "NO_SERVICE_AVAILABLE_ENV0", e3[e3.NO_SERVICE_AVAILABLE_VOET = 210] = "NO_SERVICE_AVAILABLE_VOET", e3[e3.NO_SERVICE_AVAILABLE_STRING_UID = 211] = "NO_SERVICE_AVAILABLE_STRING_UID", e3[e3.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS", e3[e3.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV";
      }(uk || (uk = {})), function(e3) {
        e3[e3.K_TIMESTAMP_EXPIRED = 2] = "K_TIMESTAMP_EXPIRED", e3[e3.K_CHANNEL_PERMISSION_INVALID = 3] = "K_CHANNEL_PERMISSION_INVALID", e3[e3.K_CERTIFICATE_INVALID = 4] = "K_CERTIFICATE_INVALID", e3[e3.K_CHANNEL_NAME_EMPTY = 5] = "K_CHANNEL_NAME_EMPTY", e3[e3.K_CHANNEL_NOT_FOUND = 6] = "K_CHANNEL_NOT_FOUND", e3[e3.K_TICKET_INVALID = 7] = "K_TICKET_INVALID", e3[e3.K_CHANNEL_CONFLICTED = 8] = "K_CHANNEL_CONFLICTED", e3[e3.K_SERVICE_NOT_READY = 9] = "K_SERVICE_NOT_READY", e3[e3.K_SERVICE_TOO_HEAVY = 10] = "K_SERVICE_TOO_HEAVY", e3[e3.K_UID_BANNED = 14] = "K_UID_BANNED", e3[e3.K_IP_BANNED = 15] = "K_IP_BANNED", e3[e3.K_CHANNEL_BANNED = 16] = "K_CHANNEL_BANNED", e3[e3.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", e3[e3.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", e3[e3.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", e3[e3.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", e3[e3.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", e3[e3.WARN_REQUEST_DEFERRED = 108] = "WARN_REQUEST_DEFERRED", e3[e3.ERR_DYNAMIC_KEY_TIMEOUT = 109] = "ERR_DYNAMIC_KEY_TIMEOUT", e3[e3.ERR_NO_AUTHORIZED = 110] = "ERR_NO_AUTHORIZED", e3[e3.ERR_VOM_SERVICE_UNAVAILABLE = 111] = "ERR_VOM_SERVICE_UNAVAILABLE", e3[e3.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE", e3[e3.ERR_MASTER_VOCS_UNAVAILABLE = 114] = "ERR_MASTER_VOCS_UNAVAILABLE", e3[e3.ERR_INTERNAL_ERROR = 115] = "ERR_INTERNAL_ERROR", e3[e3.ERR_NO_ACTIVE_STATUS = 116] = "ERR_NO_ACTIVE_STATUS", e3[e3.ERR_INVALID_UID = 117] = "ERR_INVALID_UID", e3[e3.ERR_DYNAMIC_KEY_EXPIRED = 118] = "ERR_DYNAMIC_KEY_EXPIRED", e3[e3.ERR_STATIC_USE_DYANMIC_KE = 119] = "ERR_STATIC_USE_DYANMIC_KE", e3[e3.ERR_DYNAMIC_USE_STATIC_KE = 120] = "ERR_DYNAMIC_USE_STATIC_KE", e3[e3.ERR_NO_VOCS_AVAILABLE = 2e3] = "ERR_NO_VOCS_AVAILABLE", e3[e3.ERR_NO_VOS_AVAILABLE = 2001] = "ERR_NO_VOS_AVAILABLE", e3[e3.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT", e3[e3.ERR_REPEAT_JOIN_CHANNEL = 2003] = "ERR_REPEAT_JOIN_CHANNEL", e3[e3.ERR_JOIN_BY_MULTI_IP = 2004] = "ERR_JOIN_BY_MULTI_IP", e3[e3.ERR_NOT_JOINED = 2011] = "ERR_NOT_JOINED", e3[e3.ERR_REPEAT_JOIN_REQUEST = 2012] = "ERR_REPEAT_JOIN_REQUEST", e3[e3.ERR_INVALID_VENDOR_KEY = 2013] = "ERR_INVALID_VENDOR_KEY", e3[e3.ERR_INVALID_CHANNEL_NAME = 2014] = "ERR_INVALID_CHANNEL_NAME", e3[e3.ERR_INVALID_STRINGUID = 2015] = "ERR_INVALID_STRINGUID", e3[e3.ERR_TOO_MANY_USERS = 2016] = "ERR_TOO_MANY_USERS", e3[e3.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT", e3[e3.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION", e3[e3.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", e3[e3.ERR_PUBLISH_REQUEST_INVALID = 2020] = "ERR_PUBLISH_REQUEST_INVALID", e3[e3.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID", e3[e3.ERR_NOT_SUPPORTED_MESSAGE = 2022] = "ERR_NOT_SUPPORTED_MESSAGE", e3[e3.ERR_ILLEAGAL_PLUGIN = 2023] = "ERR_ILLEAGAL_PLUGIN", e3[e3.ERR_REJOIN_TOKEN_INVALID = 2024] = "ERR_REJOIN_TOKEN_INVALID", e3[e3.ERR_REJOIN_USER_NOT_JOINED = 2025] = "ERR_REJOIN_USER_NOT_JOINED", e3[e3.ERR_INVALID_OPTIONAL_INFO = 2027] = "ERR_INVALID_OPTIONAL_INFO", e3[e3.ILLEGAL_AES_PASSWORD = 2028] = "ILLEGAL_AES_PASSWORD", e3[e3.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = "ILLEGAL_CLIENT_ROLE_LEVEL", e3[e3.ERR_TOO_MANY_BROADCASTERS = 2031] = "ERR_TOO_MANY_BROADCASTERS", e3[e3.ERR_TOO_MANY_SUBSCRIBERS = 2032] = "ERR_TOO_MANY_SUBSCRIBERS", e3[e3.ERR_LICENSE_MISSING = 32769] = "ERR_LICENSE_MISSING", e3[e3.ERR_LICENSE_EXPIRED = 32771] = "ERR_LICENSE_EXPIRED", e3[e3.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = "ERR_LICENSE_MINUTES_EXCEEDED", e3[e3.ERR_LICENSE_PERIOD_INVALID = 32774] = "ERR_LICENSE_PERIOD_INVALID", e3[e3.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = "ERR_LICENSE_MULTIPLE_SDK_SERVICE", e3[e3.ERR_LICENSE_ILLEGAL = 32783] = "ERR_LICENSE_ILLEGAL", e3[e3.ERR_TEST_RECOVER = 9e3] = "ERR_TEST_RECOVER", e3[e3.ERR_TEST_TRYNEXT = 9001] = "ERR_TEST_TRYNEXT", e3[e3.ERR_TEST_RETRY = 9002] = "ERR_TEST_RETRY";
      }(hk || (hk = {})), function(e3) {
        e3[e3.AUDIENCE_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LEVEL_LOW_LATENCY", e3[e3.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY", e3[e3.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = "AUDIENCE_LEVEL_SYNC_LATENCY";
      }(Ak || (Ak = {})), function(e3) {
        e3.LEAVE = "LEAVE", e3.NETWORK_ERROR = "NETWORK_ERROR", e3.SERVER_ERROR = "SERVER_ERROR", e3.UID_BANNED = "UID_BANNED", e3.IP_BANNED = "IP_BANNED", e3.CHANNEL_BANNED = "CHANNEL_BANNED", e3.FALLBACK = "FALLBACK", e3.LICENSE_MISSING = "LICENSE_MISSING", e3.LICENSE_EXPIRED = "LICENSE_EXPIRED", e3.LICENSE_MINUTES_EXCEEDED = "LICENSE_MINUTES_EXCEEDED", e3.LICENSE_PERIOD_INVALID = "LICENSE_PERIOD_INVALID", e3.LICENSE_MULTIPLE_SDK_SERVICE = "LICENSE_MULTIPLE_SDK_SERVICE", e3.LICENSE_ILLEGAL = "LICENSE_ILLEGAL";
      }(lk || (lk = {})), function(e3) {
        e3.CONNECTION_STATE_CHANGE = "connection-state-change", e3.MEDIA_RECONNECT_START = "media-reconnect-start", e3.MEDIA_RECONNECT_END = "media-reconnect-end", e3.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy", e3.USER_JOINED = "user-joined", e3.USER_LEAVED = "user-left", e3.USER_PUBLISHED = "user-published", e3.USER_UNPUBLISHED = "user-unpublished", e3.USER_INFO_UPDATED = "user-info-updated", e3.CLIENT_BANNED = "client-banned", e3.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state", e3.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event", e3.VOLUME_INDICATOR = "volume-indicator", e3.CRYPT_ERROR = "crypt-error", e3.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire", e3.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire", e3.NETWORK_QUALITY = "network-quality", e3.STREAM_TYPE_CHANGED = "stream-type-changed", e3.STREAM_FALLBACK = "stream-fallback", e3.RECEIVE_METADATA = "receive-metadata", e3.STREAM_MESSAGE = "stream-message", e3.LIVE_STREAMING_ERROR = "live-streaming-error", e3.LIVE_STREAMING_WARNING = "live-streaming-warning", e3.INJECT_STREAM_STATUS = "stream-inject-status", e3.EXCEPTION = "exception", e3.ERROR = "error", e3.P2P_LOST = "p2p_lost", e3.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy", e3.CHANNEL_FALLBACK_TO_WEBSOCKET = "channel-fallback-to-websocket", e3.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change", e3.PUBLISHED_USER_LIST = "published-user-list", e3.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = "content-inspect-connection-state-change", e3.CONTENT_INSPECT_ERROR = "content-inspect-error", e3.CONTENT_INSPECT_RESULT = "content-inspect-result";
      }(pk || (pk = {})), function(e3) {
        e3.NETWORK_ERROR = "NETWORK_ERROR", e3.SERVER_ERROR = "SERVER_ERROR", e3.MULTI_IP = "MULTI_IP", e3.TIMEOUT = "TIMEOUT", e3.OFFLINE = "OFFLINE", e3.LEAVE = "LEAVE", e3.P2P_FAILED = "P2P_FAILED", e3.FALLBACK = "FALLBACK";
      }(gk || (gk = {})), function(e3) {
        e3.CONNECTING = "connecting", e3.CONNECTED = "connected", e3.RECONNECTING = "reconnecting", e3.CLOSED = "closed";
      }(Ek || (Ek = {})), function(e3) {
        e3.WS_CONNECTED = "ws_connected", e3.WS_RECONNECTING = "ws_reconnecting", e3.WS_CLOSED = "ws_closed", e3.WS_RECONNECT_WAITTING_FINISH = "ws_reconnect_waitting_finish", e3.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection", e3.ON_BINARY_DATA = "on_binary_data", e3.REQUEST_RECOVER = "request_recover", e3.REQUEST_JOIN_INFO = "request_join_info", e3.REQUEST_REJOIN_INFO = "req_rejoin_info", e3.IS_P2P_DISCONNECTED = "is_p2p_dis", e3.DISCONNECT_P2P = "dis_p2p", e3.ABORT_P2P_EXECUTION = "abort_p2p_execution", e3.NEED_RENEW_SESSION = "need-sid", e3.REPORT_JOIN_GATEWAY = "report_join_gateway", e3.REQUEST_TIMEOUT = "request_timeout", e3.REQUEST_SUCCESS = "request_success", e3.JOIN_RESPONSE = "join_response", e3.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e3.DATACHANNEL_CONNECTING = "datachannel_connecting", e3.DATACHANNEL_FAILBACK = "datachannel_failback";
      }(fk || (fk = {})), function(e3) {
        e3.PING = "ping", e3.PING_BACK = "ping_back", e3.JOIN = "join_v3", e3.REJOIN = "rejoin_v3", e3.LEAVE = "leave", e3.SET_CLIENT_ROLE = "set_client_role", e3.PUBLISH = "publish", e3.UNPUBLISH = "unpublish", e3.SUBSCRIBE = "subscribe", e3.SUBSCRIBE_STREAMS = "subscribe_streams", e3.UNSUBSCRIBE = "unsubscribe", e3.UNSUBSCRIBE_STREAMS = "unsubscribe_streams", e3.SUBSCRIBE_CHANGE = "subscribe_change", e3.TRAFFIC_STATS = "traffic_stats", e3.RENEW_TOKEN = "renew_token", e3.SWITCH_VIDEO_STREAM = "switch_video_stream", e3.DEFAULT_VIDEO_STREAM = "default_video_stream", e3.SET_FALLBACK_OPTION = "set_fallback_option", e3.GATEWAY_INFO = "gateway_info", e3.CONTROL = "control", e3.SEND_METADATA = "send_metadata", e3.DATA_STREAM = "data_stream", e3.PICK_SVC_LAYER = "pick_svc_layer", e3.RESTART_ICE = "restart_ice", e3.CONNECT_PC = "connect_pc", e3.SET_VIDEO_PROFILE = "set_video_profile", e3.SET_PARAMETER = "set_parameter";
      }(mk || (mk = {})), function(e3) {
        e3.PUBLISH_STATS = "publish_stats", e3.PUBLISH_RELATED_STATS = "publish_related_stats", e3.SUBSCRIBE_STATS = "subscribe_stats", e3.SUBSCRIBE_RELATED_STATS = "subscribe_related_stats", e3.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length", e3.DENOISER_STATS = "denoiser_stats", e3.TRANSPORT_STATS = "transport_stats", e3.EXTENSION_USAGE_STATS = "extension_usage_stats";
      }(Ik || (Ik = {})), function(e3) {
        e3.ON_USER_ONLINE = "on_user_online", e3.ON_USER_OFFLINE = "on_user_offline", e3.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update", e3.ON_PUBLISH_STREAM = "on_publish_stream", e3.ON_UPLINK_STATS = "on_uplink_stats", e3.ON_P2P_LOST = "on_p2p_lost", e3.ON_REMOVE_STREAM = "on_remove_stream", e3.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e3.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e3.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire", e3.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire", e3.ON_USER_BANNED = "on_user_banned", e3.ON_USER_LICENSE_BANNED = "on_user_license_banned", e3.ON_NOTIFICATION = "on_notification", e3.ON_CRYPT_ERROR = "on_crypt_error", e3.MUTE_AUDIO = "mute_audio", e3.MUTE_VIDEO = "mute_video", e3.UNMUTE_AUDIO = "unmute_audio", e3.UNMUTE_VIDEO = "unmute_video", e3.ON_P2P_OK = "on_p2p_ok", e3.RECEIVE_METADATA = "receive_metadata", e3.ON_DATA_STREAM = "on_data_stream", e3.ENABLE_LOCAL_VIDEO = "enable_local_video", e3.DISABLE_LOCAL_VIDEO = "disable_local_video", e3.ENABLE_LOCAL_AUDIO = "enable_local_audio", e3.DISABLE_LOCAL_AUDIO = "disable_local_audio", e3.ON_PUBLISHED_USER_LIST = "on_published_user_list";
      }(_k || (_k = {})), function(e3) {
        e3.CONNECTION_STATE_CHANGE = "CONNECTION_STATE_CHANGE", e3.NEED_ANSWER = "NEED_ANSWER", e3.NEED_RENEGOTIATE = "NEED_RENEGOTIATE", e3.P2P_LOST = "P2P_LOST", e3.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e3.NEED_UNPUB = "NEED_UNPUB", e3.NEED_UNSUB = "NEED_UNSUB", e3.NEED_UPLOAD = "NEED_UPLOAD", e3.NEED_CONTROL = "NEED_CONTROL", e3.START_RECONNECT = "START_RECONNECT", e3.END_RECONNECT = "END_RECONNECT", e3.NEED_SIGNAL_RTT = "NEED_SIGNAL_RTT";
      }(Ck || (Ck = {})), function(e3) {
        e3.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change", e3.RECEIVE_TRACK_BUFFER = "receive_track_buffer", e3.ON_AUDIO_BUFFER = "on_audio_buffer", e3.UPDATE_SOURCE = "update_source";
      }(Sk || (Sk = {}));
      const bk = { sendVolumeLevel: 0, sendBitrate: 0, sendBytes: 0, sendPackets: 0, sendPacketsLost: 0, currentPacketLossRate: 0 }, Nk = { sendBytes: 0, sendBitrate: 0, sendPackets: 0, sendPacketsLost: 0, sendResolutionHeight: 0, sendResolutionWidth: 0, captureResolutionHeight: 0, captureResolutionWidth: 0, targetSendBitrate: 0, totalDuration: 0, totalFreezeTime: 0, currentPacketLossRate: 0 }, Ok = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveLevel: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 }, Dk = { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 }, Pk = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receiveResolutionHeight: 0, receiveResolutionWidth: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 };
      let Lk, kk, Bk;
      !function(e3) {
        e3.CONNECTED = "websocket:connected", e3.RECONNECTING = "websocket:reconnecting", e3.WILL_RECONNECT = "websocket:will_reconnect", e3.CLOSED = "websocket:closed", e3.FAILED = "websocket:failed", e3.ON_MESSAGE = "websocket:on_message", e3.REQUEST_NEW_URLS = "websocket:request_new_urls", e3.RECONNECT_WAITTING_FINISH = "websocket:reconnect_waitting_finish", e3.RECONNECT_CREATE_CONNECTION = "websocket:reconnect_create_connection", e3.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "websocket:on_token_privilege_did_expire";
      }(Lk || (Lk = {})), function(e3) {
        e3.TRANSCODE = "mix_streaming", e3.RAW = "raw_streaming", e3.INJECT = "inject_streaming";
      }(kk || (kk = {})), function(e3) {
        e3[e3.INJECT_STREAM_STATUS_START_SUCCESS = 0] = "INJECT_STREAM_STATUS_START_SUCCESS", e3[e3.INJECT_STREAM_STATUS_START_ALREADY_EXISTS = 1] = "INJECT_STREAM_STATUS_START_ALREADY_EXISTS", e3[e3.INJECT_STREAM_STATUS_START_UNAUTHORIZED = 2] = "INJECT_STREAM_STATUS_START_UNAUTHORIZED", e3[e3.INJECT_STREAM_STATUS_START_TIMEOUT = 3] = "INJECT_STREAM_STATUS_START_TIMEOUT", e3[e3.INJECT_STREAM_STATUS_START_FAILED = 4] = "INJECT_STREAM_STATUS_START_FAILED", e3[e3.INJECT_STREAM_STATUS_STOP_SUCCESS = 5] = "INJECT_STREAM_STATUS_STOP_SUCCESS", e3[e3.INJECT_STREAM_STATUS_STOP_NOT_FOUND = 6] = "INJECT_STREAM_STATUS_STOP_NOT_FOUND", e3[e3.INJECT_STREAM_STATUS_STOP_UNAUTHORIZED = 7] = "INJECT_STREAM_STATUS_STOP_UNAUTHORIZED", e3[e3.INJECT_STREAM_STATUS_STOP_TIMEOUT = 8] = "INJECT_STREAM_STATUS_STOP_TIMEOUT", e3[e3.INJECT_STREAM_STATUS_STOP_FAILED = 9] = "INJECT_STREAM_STATUS_STOP_FAILED", e3[e3.INJECT_STREAM_STATUS_BROKEN = 10] = "INJECT_STREAM_STATUS_BROKEN";
      }(Bk || (Bk = {}));
      const Mk = { alpha: 1, height: 640, width: 360, x: 0, y: 0, zOrder: 0, audioChannel: 0 }, Uk = { x: 0, y: 0, width: 160, height: 160, zOrder: 255, alpha: 1 };
      function xk(e3, t3) {
        QL(e3.url, "".concat(t3, ".url"), 1, 1e3, false), GL(e3.x) || UL(e3.x, "".concat(t3, ".x"), 0, 1e4), GL(e3.y) || UL(e3.y, "".concat(t3, ".y"), 0, 1e4), GL(e3.width) || UL(e3.width, "".concat(t3, ".width"), 0, 1e4), GL(e3.height) || UL(e3.height, "".concat(t3, ".height"), 0, 1e4), GL(e3.zOrder) || UL(e3.zOrder, "".concat(t3, ".zOrder"), 0, 255), GL(e3.alpha) || UL(e3.alpha, "".concat(t3, ".alpha"), 0, 1, false);
      }
      const Qk = { audioBitrate: 48, audioChannels: 1, audioSampleRate: 48e3, backgroundColor: 0, height: 360, lowLatency: false, videoBitrate: 400, videoCodecProfile: 100, videoCodecType: 1, videoFrameRate: 15, videoGop: 30, width: 640, images: [], userConfigs: [], userConfigExtraInfo: "" }, Fk = { audioBitrate: 48, audioChannels: 2, audioVolume: 100, audioSampleRate: 48e3, height: 0, width: 0, videoBitrate: 400, videoFramerate: 15, videoGop: 30 };
      let Vk, jk, Gk, Kk, Hk, Wk, Yk, Jk, qk, Xk, zk, Zk, $k, eB, tB, iB, rB, nB;
      function oB(e3) {
        if (!e3.channelName)
          throw new QD(xD.INVALID_PARAMS, "invalid channelName in info");
        if (!e3.uid || "number" != typeof e3.uid)
          throw new QD(xD.INVALID_PARAMS, "invalid uid in info, uid must be a number");
        return e3.token && QL(e3.token, "info.token", 1, 2047), jL(e3.uid), VL(e3.channelName), true;
      }
      function sB(e3) {
        return ML(e3, "mediaSource", ["screen", "window", "application"]), true;
      }
      !function(e3) {
        e3.WARNING = "@live_uap-warning", e3.ERROR = "@line_uap-error", e3.PUBLISH_STREAM_STATUS = "@live_uap-publish-status", e3.INJECT_STREAM_STATUS = "@live_uap-inject-status", e3.WORKER_STATUS = "@live_uap-worker-status", e3.REQUEST_NEW_ADDRESS = "@live_uap-request-address";
      }(Vk || (Vk = {})), function(e3) {
        e3.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager";
      }(jk || (jk = {})), function(e3) {
        e3[e3.LIVE_STREAM_RESPONSE_SUCCEED = 200] = "LIVE_STREAM_RESPONSE_SUCCEED", e3[e3.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM", e3[e3.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR", e3[e3.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM", e3[e3.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR", e3[e3.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST", e3[e3.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED", e3[e3.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE", e3[e3.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN", e3[e3.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH", e3[e3.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED", e3[e3.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM", e3[e3.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR", e3[e3.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST", e3[e3.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT", e3[e3.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT", e3[e3.ERROR_FAIL_SEND_MESSAGE = 504] = "ERROR_FAIL_SEND_MESSAGE", e3[e3.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE", e3[e3.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT", e3[e3.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH", e3[e3.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN";
      }(Gk || (Gk = {})), function(e3) {
        e3.CONNECT_FAILED = "connect failed", e3.CONNECT_TIMEOUT = "connect timeout", e3.WS_DISCONNECTED = "websocket disconnected", e3.REQUEST_TIMEOUT = "request timeout", e3.REQUEST_FAILED = "request failed", e3.WAIT_STATUS_TIMEOUT = "wait status timeout", e3.WAIT_STATUS_ERROR = "wait status error", e3.BAD_STATE = "bad state", e3.WS_ABORT = "ws abort", e3.AP_REQUEST_TIMEOUT = "AP request timeout", e3.AP_JSON_PARSE_ERROR = "AP json parse error", e3.AP_REQUEST_ERROR = "AP request error", e3.AP_REQUEST_ABORT = "AP request abort";
      }(Kk || (Kk = {})), function(e3) {
        e3[e3.SetSdkProfile = 0] = "SetSdkProfile", e3[e3.SetSourceChannel = 1] = "SetSourceChannel", e3[e3.SetSourceUserId = 2] = "SetSourceUserId", e3[e3.SetDestChannel = 3] = "SetDestChannel", e3[e3.StartPacketTransfer = 4] = "StartPacketTransfer", e3[e3.StopPacketTransfer = 5] = "StopPacketTransfer", e3[e3.UpdateDestChannel = 6] = "UpdateDestChannel", e3[e3.Reconnect = 7] = "Reconnect", e3[e3.SetVideoProfile = 8] = "SetVideoProfile";
      }(Hk || (Hk = {})), function(e3) {
        e3.NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED", e3.NETWORK_CONNECTED = "NETWORK_CONNECTED", e3.PACKET_JOINED_SRC_CHANNEL = "PACKET_JOINED_SRC_CHANNEL", e3.PACKET_JOINED_DEST_CHANNEL = "PACKET_JOINED_DEST_CHANNEL", e3.PACKET_SENT_TO_DEST_CHANNEL = "PACKET_SENT_TO_DEST_CHANNEL", e3.PACKET_RECEIVED_VIDEO_FROM_SRC = "PACKET_RECEIVED_VIDEO_FROM_SRC", e3.PACKET_RECEIVED_AUDIO_FROM_SRC = "PACKET_RECEIVED_AUDIO_FROM_SRC", e3.PACKET_UPDATE_DEST_CHANNEL = "PACKET_UPDATE_DEST_CHANNEL", e3.PACKET_UPDATE_DEST_CHANNEL_REFUSED = "PACKET_UPDATE_DEST_CHANNEL_REFUSED", e3.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = "PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE";
      }(Wk || (Wk = {})), function(e3) {
        e3.RELAY_STATE_IDLE = "RELAY_STATE_IDLE", e3.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING", e3.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING", e3.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE";
      }(Yk || (Yk = {})), function(e3) {
        e3.RELAY_OK = "RELAY_OK", e3.SERVER_CONNECTION_LOST = "SERVER_CONNECTION_LOST", e3.SRC_TOKEN_EXPIRED = "SRC_TOKEN_EXPIRED", e3.DEST_TOKEN_EXPIRED = "DEST_TOKEN_EXPIRED";
      }(Jk || (Jk = {})), function(e3) {
        e3.High = "high", e3.Low = "low", e3.Audio = "audio", e3.Screen = "screen", e3.ScreenLow = "screen_low";
      }(qk || (qk = {})), function(e3) {
        e3.DISCONNECT = "disconnect", e3.CONNECTION_STATE_CHANGE = "connection-state-change", e3.NETWORK_QUALITY = "network-quality", e3.STREAM_TYPE_CHANGE = "stream-type-change", e3.IS_P2P_DISCONNECTED = "is-p2p-dis", e3.DISCONNECT_P2P = "dis-p2p", e3.REQUEST_NEW_GATEWAY_LIST = "req-gate-url", e3.NEED_RENEW_SESSION = "need-sid", e3.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params", e3.JOIN_RESPONSE = "join-response", e3.REQUEST_DC_CONNECTION_PARAMS = "request-dc-connection-params", e3.RESET_CONNECTION_EVENTS = "reset-connection-events", e3.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e3.DATACHANNEL_FAILBACK = "datachannel_failback";
      }(Xk || (Xk = {})), function(e3) {
        e3[e3.Nothing = 0] = "Nothing", e3[e3.Audio = 1] = "Audio", e3[e3.LwoVideo = 2] = "LwoVideo", e3[e3.Video = 4] = "Video", e3[e3.Data = 8] = "Data";
      }(zk || (zk = {})), function(e3) {
        e3.NEED_RENEGOTIATE = "@need_renegotiate", e3.NEED_REPLACE_TRACK = "@need_replace_track", e3.NEED_CLOSE = "@need_close", e3.NEED_ENABLE_TRACK = "@need_enable_track", e3.NEED_DISABLE_TRACK = "@need_disable_track", e3.NEED_SESSION_ID = "@need_sid", e3.SET_OPTIMIZATION_MODE = "@set_optimization_mode", e3.GET_STATS = "@get_stats", e3.GET_LOW_VIDEO_TRACK = "@get_low_video_track", e3.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp", e3.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder", e3.NEED_MUTE_TRACK = "@need_mute_track", e3.NEED_UNMUTE_TRACK = "@need_unmute_track";
      }(Zk || (Zk = {})), function(e3) {
        e3.SCREEN_TRACK = "screen_track", e3.LOW_STREAM = "low_stream";
      }($k || ($k = {})), function(e3) {
        e3[e3.HIGH_STREAM = 0] = "HIGH_STREAM", e3[e3.LOW_STREAM = 1] = "LOW_STREAM";
      }(eB || (eB = {})), function(e3) {
        e3[e3.DISABLE = 0] = "DISABLE", e3[e3.LOW_STREAM = 1] = "LOW_STREAM", e3[e3.AUDIO_ONLY = 2] = "AUDIO_ONLY";
      }(tB || (tB = {})), function(e3) {
        e3.SOURCE_STATE_CHANGE = "source-state-change", e3.TRACK_ENDED = "track-ended", e3.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload", e3.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e3.CLOSED = "closed";
      }(iB || (iB = {})), function(e3) {
        e3.FIRST_FRAME_DECODED = "first-frame-decoded", e3.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status";
      }(rB || (rB = {})), function(e3) {
        e3.CHINA = "CHINA", e3.ASIA = "ASIA", e3.NORTH_AMERICA = "NORTH_AMERICA", e3.EUROPE = "EUROPE", e3.JAPAN = "JAPAN", e3.INDIA = "INDIA", e3.KOREA = "KOREA", e3.HKMC = "HKMC", e3.US = "US", e3.OCEANIA = "OCEANIA", e3.SOUTH_AMERICA = "SOUTH_AMERICA", e3.AFRICA = "AFRICA", e3.OVERSEA = "OVERSEA", e3.GLOBAL = "GLOBAL";
      }(nB || (nB = {}));
      const aB = [nB.AFRICA, nB.ASIA, nB.CHINA, nB.EUROPE, nB.GLOBAL, nB.INDIA, nB.JAPAN, nB.NORTH_AMERICA, nB.OCEANIA, nB.OVERSEA, nB.SOUTH_AMERICA];
      let cB;
      !function(e3) {
        e3.CHINA = "CN", e3.ASIA = "AS", e3.NORTH_AMERICA = "NA", e3.EUROPE = "EU", e3.JAPAN = "JP", e3.INDIA = "IN", e3.KOREA = "KR", e3.HKMC = "HK", e3.US = "US", e3.OCEANIA = "OC", e3.SOUTH_AMERICA = "SA", e3.AFRICA = "AF", e3.OVERSEA = "OVERSEA", e3.GLOBAL = "GLOBAL";
      }(cB || (cB = {}));
      const dB = { CHINA: {}, ASIA: { CODE: cB.ASIA, WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"], PROXY_CS: ["proxy-ap-web-asia.agora.io"], CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"], UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }, NORTH_AMERICA: { CODE: cB.NORTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"], PROXY_CS: ["proxy-ap-web-america.agora.io"], CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }, EUROPE: { CODE: cB.EUROPE, WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"], PROXY_CS: ["proxy-ap-web-europe.agora.io"], CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"], UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }, JAPAN: { CODE: cB.JAPAN, WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"], PROXY_CS: ["proxy-ap-web-japan.agora.io"], CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"], UAP_AP: ["uap-ap-web-japan.agora.io", "	uap-ap-web-japan2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }, INDIA: { CODE: cB.INDIA, WEBCS_DOMAIN: ["ap-web-1-india.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"], PROXY_CS: ["proxy-ap-web-india.agora.io"], CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"], UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"] }, KOREA: { CODE: cB.KOREA, WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"], PROXY_CS: ["proxy-ap-web-korea.agora.io"], CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-korea.agora.io", "sua-ap-web-korea2.agora.io"], UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"], PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"] }, HKMC: { CODE: cB.HKMC, WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"], PROXY_CS: ["proxy-ap-web-hkmc.agora.io"], CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-hkmc.agora.io", "sua-ap-web-hkmc2.agora.io"], UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"], LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"], PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"] }, US: { CODE: cB.US, WEBCS_DOMAIN: ["ap-web-1-us.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"], PROXY_CS: ["proxy-ap-web-us.agora.io"], CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"], UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"], LOG_UPLOAD_SERVER: ["logservice-us.agora.io"], PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"] }, OVERSEA: { CODE: cB.OVERSEA, WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"], PROXY_CS: ["proxy-ap-web-oversea.agora.io"], CDS_AP: ["cds-ap-web-oversea.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"], UAP_AP: ["uap-ap-web-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"] }, GLOBAL: { CODE: cB.GLOBAL, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"], LOG_UPLOAD_SERVER: ["logservice.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"] }, OCEANIA: { CODE: cB.OCEANIA, WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"], PROXY_CS: ["proxy-ap-web-oceania.agora.io"], CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"], UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }, SOUTH_AMERICA: { CODE: cB.SOUTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"], PROXY_CS: ["proxy-ap-web-south-america.agora.io"], CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"], UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }, AFRICA: { CODE: cB.AFRICA, WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"], PROXY_CS: ["proxy-ap-web-africa.agora.io"], CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"], UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"] } };
      let uB, hB, AB, lB, pB, gB, EB, fB, mB, IB, _B, CB, SB, vB, TB;
      SP && (dB.CHINA = { CODE: cB.CHINA, WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["proxy-web.ap.sd-rtn.com"], CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"], EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] }), function(e3) {
        e3.UPDATE_BITRATE_LIMIT = "update_bitrate_limit";
      }(uB || (uB = {}));
      class RB extends MD {
        constructor(e3, t3) {
          super(), MN(this, "onICEConnectionStateChange", void 0), MN(this, "onConnectionStateChange", void 0), MN(this, "onDTLSTransportStateChange", void 0), MN(this, "onDTLSTransportError", void 0), MN(this, "onICETransportStateChange", void 0), MN(this, "onFirstAudioReceived", void 0), MN(this, "onFirstVideoReceived", void 0), MN(this, "onFirstAudioDecoded", void 0), MN(this, "onFirstVideoDecoded", void 0), MN(this, "onFirstVideoDecodedTimeout", void 0), MN(this, "onSelectedLocalCandidateChanged", void 0), MN(this, "onSelectedRemoteCandidateChanged", void 0);
        }
      }
      !function(e3) {
        e3.SEND = "sendonly", e3.RECV = "recvonly", e3.SENDRECV = "sendrecv", e3.INACTIVE = "inactive";
      }(hB || (hB = {})), function(e3) {
        e3.VIDEO = "video", e3.AUDIO = "audio";
      }(AB || (AB = {})), function(e3) {
        e3.LocalVideoTrack = "videoTrack", e3.LocalAudioTrack = "audioTrack", e3.LocalVideoLowTrack = "videoLowTrack";
      }(lB || (lB = {})), function(e3) {
        e3.New = "new", e3.Connected = "connected", e3.Reconnecting = "reconnecting", e3.Disconnected = "disconnected";
      }(pB || (pB = {})), function(e3) {
        e3.StateChange = "stateChange", e3.IceConnectionStateChange = "iceConnectionStateChange", e3.RequestMuteLocal = "requestMuteLocal", e3.RequestUnmuteLocal = "requestUnmuteLocal", e3.RequestRePublish = "requestRePublish", e3.RequestReSubscribe = "requestReSubscribe", e3.RequestUploadStats = "requestUploadStats", e3.MediaReconnectStart = "MediaReconnectStart", e3.MediaReconnectEnd = "MediaReconnectEnd", e3.NeedSignalRTT = "NeedSignalRTT", e3.RequestRestartICE = "RequestRestartIce", e3.PeerConnectionStateChange = "PeerConnectionStateChange", e3.RequestReconnect = "RequestReconnect", e3.RequestReconnectPC = "RequestReconnectPC", e3.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC", e3.P2PLost = "P2PLost", e3.UpdateVideoEncoder = "UpdateVideoEncoder", e3.ConnectionTypeChange = "ConnectionTypeChange", e3.RequestLowStreamParameter = "RequestLowStreamParameter", e3.QueryClientConnectionState = "QueryClientConnectionState";
      }(gB || (gB = {})), function(e3) {
        e3.ONLINE = "ONLINE", e3.OFFLINE = "OFFLINE";
      }(EB || (EB = {})), function(e3) {
        e3.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE", e3.ONLINE = "ONLINE", e3.OFFLINE = "OFFLINE";
      }(fB || (fB = {})), function(e3) {
        e3.ON_TRACK = "on_track", e3.ON_NODE = "on_node";
      }(mB || (mB = {})), function(e3) {
        e3.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints", e3.REQUEST_CONSTRAINTS = "request_constraints";
      }(IB || (IB = {})), function(e3) {
        e3.CONNECTING = "CONNECTING", e3.RECONNECTING = "RECONNECTING", e3.CONNECTED = "CONNECTED", e3.CLOSED = "CLOSED";
      }(_B || (_B = {})), function(e3) {
        e3[e3.CONNECT_AP = 0] = "CONNECT_AP", e3[e3.AP_CONNECTED = 1] = "AP_CONNECTED", e3[e3.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e3[e3.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e3[e3.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e3[e3.CONNECT_WORKER = 5] = "CONNECT_WORKER", e3[e3.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e3[e3.CLOSED = 7] = "CLOSED";
      }(CB || (CB = {})), function(e3) {
        e3.CONNECTION_STATE_CHANGE = "connection-state-change", e3.STATE_CHANGE = "state-change", e3.INSPECT_RESULT = "inspect-result", e3.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e3.REQUEST_NEW_WORKER_URL = "request-new-worker-url";
      }(SB || (SB = {})), function(e3) {
        e3.NETWORK_ERROR = "NETWORK_ERROR", e3.SERVER_ERROR = "SERVER_ERROR", e3.MULTI_IP = "MULTI_IP", e3.TIMEOUT = "TIMEOUT", e3.OFFLINE = "OFFLINE", e3.LEAVE = "LEAVE", e3.P2P_FAILED = "P2P_FAILED", e3.FALLBACK = "FALLBACK";
      }(vB || (vB = {})), function(e3) {
        e3.CONNECTED = "transmitter:connected", e3.RECONNECTING = "transmitter:reconnecting", e3.WILL_RECONNECT = "transmitter:will_reconnect", e3.CLOSED = "transmitter:closed", e3.FAILED = "transmitter:failed", e3.ON_MESSAGE = "transmitter:on_message", e3.REQUEST_NEW_URLS = "transmitter:request_new_urls", e3.RECONNECT_WAITTING_FINISH = "transmitter:reconnect_waitting_finish", e3.RECONNECT_CREATE_CONNECTION = "transmitter:reconnect_create_connection", e3.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "transmitter:on_token_privilege_did_expire", e3.TO_CONNECT_DATACHANNEL = "transmitter:to_connect_datachannel", e3.FAILBACK = "transmitter:failback";
      }(TB || (TB = {}));
      const yB = { getDisplayMedia: false, getStreamFromExtension: false, supportUnifiedPlan: false, supportMinBitrate: false, supportSetRtpSenderParameters: false, supportDualStream: true, webAudioMediaStreamDest: false, supportReplaceTrack: false, supportWebGL: false, webAudioWithAEC: false, supportRequestFrame: false, supportShareAudio: false, supportDualStreamEncoding: false, supportDataChannel: false };
      function wB() {
        return yB;
      }
      var bB = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView, NB = Hi, OB = Zi, DB = i.RangeError, PB = function(e3) {
        if (void 0 === e3)
          return 0;
        var t3 = NB(e3), i3 = OB(t3);
        if (t3 !== i3)
          throw DB("Wrong length or index");
        return i3;
      }, LB = i.Array, kB = Math.abs, BB = Math.pow, MB = Math.floor, UB = Math.log, xB = Math.LN2, QB = { pack: function(e3, t3, i3) {
        var r3, n3, o3, s3 = LB(i3), a3 = 8 * i3 - t3 - 1, c3 = (1 << a3) - 1, d3 = c3 >> 1, u3 = 23 === t3 ? BB(2, -24) - BB(2, -77) : 0, h3 = e3 < 0 || 0 === e3 && 1 / e3 < 0 ? 1 : 0, A3 = 0;
        for ((e3 = kB(e3)) != e3 || e3 === 1 / 0 ? (n3 = e3 != e3 ? 1 : 0, r3 = c3) : (r3 = MB(UB(e3) / xB), e3 * (o3 = BB(2, -r3)) < 1 && (r3--, o3 *= 2), (e3 += r3 + d3 >= 1 ? u3 / o3 : u3 * BB(2, 1 - d3)) * o3 >= 2 && (r3++, o3 /= 2), r3 + d3 >= c3 ? (n3 = 0, r3 = c3) : r3 + d3 >= 1 ? (n3 = (e3 * o3 - 1) * BB(2, t3), r3 += d3) : (n3 = e3 * BB(2, d3 - 1) * BB(2, t3), r3 = 0)); t3 >= 8; )
          s3[A3++] = 255 & n3, n3 /= 256, t3 -= 8;
        for (r3 = r3 << t3 | n3, a3 += t3; a3 > 0; )
          s3[A3++] = 255 & r3, r3 /= 256, a3 -= 8;
        return s3[--A3] |= 128 * h3, s3;
      }, unpack: function(e3, t3) {
        var i3, r3 = e3.length, n3 = 8 * r3 - t3 - 1, o3 = (1 << n3) - 1, s3 = o3 >> 1, a3 = n3 - 7, c3 = r3 - 1, d3 = e3[c3--], u3 = 127 & d3;
        for (d3 >>= 7; a3 > 0; )
          u3 = 256 * u3 + e3[c3--], a3 -= 8;
        for (i3 = u3 & (1 << -a3) - 1, u3 >>= -a3, a3 += t3; a3 > 0; )
          i3 = 256 * i3 + e3[c3--], a3 -= 8;
        if (0 === u3)
          u3 = 1 - s3;
        else {
          if (u3 === o3)
            return i3 ? NaN : d3 ? -1 / 0 : 1 / 0;
          i3 += BB(2, t3), u3 -= s3;
        }
        return (d3 ? -1 : 1) * i3 * BB(2, u3 - t3);
      } }, FB = Pe, VB = qi, jB = er, GB = ct, KB = Tt, HB = E, WB = qi, YB = er, JB = function(e3, t3, i3) {
        var r3 = GB(t3);
        r3 in e3 ? KB.f(e3, r3, HB(0, i3)) : e3[r3] = i3;
      }, qB = i.Array, XB = Math.max, zB = function(e3, t3, i3) {
        for (var r3 = YB(e3), n3 = WB(t3, r3), o3 = WB(void 0 === i3 ? r3 : i3, r3), s3 = qB(XB(o3 - n3, 0)), a3 = 0; n3 < o3; n3++, a3++)
          JB(s3, a3, e3[n3]);
        return s3.length = a3, s3;
      }, ZB = i, $B = S, eM = o, tM = bB, iM = Di, rM = Kt, nM = gT, oM = n, sM = m_, aM = Hi, cM = Zi, dM = PB, uM = QB, hM = jd, AM = lu, lM = ji.f, pM = Tt.f, gM = function(e3) {
        for (var t3 = FB(this), i3 = jB(t3), r3 = arguments.length, n3 = VB(r3 > 1 ? arguments[1] : void 0, i3), o3 = r3 > 2 ? arguments[2] : void 0, s3 = void 0 === o3 ? i3 : VB(o3, i3); s3 > n3; )
          t3[n3++] = e3;
        return t3;
      }, EM = zB, fM = $d, mM = iM.PROPER, IM = iM.CONFIGURABLE, _M = Ri.get, CM = Ri.set, SM = "ArrayBuffer", vM = "DataView", TM = "Wrong index", RM = ZB.ArrayBuffer, yM = RM, wM = yM && yM.prototype, bM = ZB.DataView, NM = bM && bM.prototype, OM = Object.prototype, DM = ZB.Array, PM = ZB.RangeError, LM = $B(gM), kM = $B([].reverse), BM = uM.pack, MM = uM.unpack, UM = function(e3) {
        return [255 & e3];
      }, xM = function(e3) {
        return [255 & e3, e3 >> 8 & 255];
      }, QM = function(e3) {
        return [255 & e3, e3 >> 8 & 255, e3 >> 16 & 255, e3 >> 24 & 255];
      }, FM = function(e3) {
        return e3[3] << 24 | e3[2] << 16 | e3[1] << 8 | e3[0];
      }, VM = function(e3) {
        return BM(e3, 23, 4);
      }, jM = function(e3) {
        return BM(e3, 52, 8);
      }, GM = function(e3, t3) {
        pM(e3.prototype, t3, { get: function() {
          return _M(this)[t3];
        } });
      }, KM = function(e3, t3, i3, r3) {
        var n3 = dM(i3), o3 = _M(e3);
        if (n3 + t3 > o3.byteLength)
          throw PM(TM);
        var s3 = _M(o3.buffer).bytes, a3 = n3 + o3.byteOffset, c3 = EM(s3, a3, a3 + t3);
        return r3 ? c3 : kM(c3);
      }, HM = function(e3, t3, i3, r3, n3, o3) {
        var s3 = dM(i3), a3 = _M(e3);
        if (s3 + t3 > a3.byteLength)
          throw PM(TM);
        for (var c3 = _M(a3.buffer).bytes, d3 = s3 + a3.byteOffset, u3 = r3(+n3), h3 = 0; h3 < t3; h3++)
          c3[d3 + h3] = u3[o3 ? h3 : t3 - h3 - 1];
      };
      if (tM) {
        var WM = mM && RM.name !== SM;
        if (oM(function() {
          RM(1);
        }) && oM(function() {
          new RM(-1);
        }) && !oM(function() {
          return new RM(), new RM(1.5), new RM(NaN), WM && !IM;
        }))
          WM && IM && rM(RM, "name", SM);
        else {
          (yM = function(e3) {
            return sM(this, wM), new RM(dM(e3));
          }).prototype = wM;
          for (var YM, JM = lM(RM), qM = 0; JM.length > qM; )
            (YM = JM[qM++]) in yM || rM(yM, YM, RM[YM]);
          wM.constructor = yM;
        }
        AM && hM(NM) !== OM && AM(NM, OM);
        var XM = new bM(new yM(2)), zM = $B(NM.setInt8);
        XM.setInt8(0, 2147483648), XM.setInt8(1, 2147483649), !XM.getInt8(0) && XM.getInt8(1) || nM(NM, { setInt8: function(e3, t3) {
          zM(this, e3, t3 << 24 >> 24);
        }, setUint8: function(e3, t3) {
          zM(this, e3, t3 << 24 >> 24);
        } }, { unsafe: true });
      } else
        wM = (yM = function(e3) {
          sM(this, wM);
          var t3 = dM(e3);
          CM(this, { bytes: LM(DM(t3), 0), byteLength: t3 }), eM || (this.byteLength = t3);
        }).prototype, NM = (bM = function(e3, t3, i3) {
          sM(this, NM), sM(e3, wM);
          var r3 = _M(e3).byteLength, n3 = aM(t3);
          if (n3 < 0 || n3 > r3)
            throw PM("Wrong offset");
          if (n3 + (i3 = void 0 === i3 ? r3 - n3 : cM(i3)) > r3)
            throw PM("Wrong length");
          CM(this, { buffer: e3, byteLength: i3, byteOffset: n3 }), eM || (this.buffer = e3, this.byteLength = i3, this.byteOffset = n3);
        }).prototype, eM && (GM(yM, "byteLength"), GM(bM, "buffer"), GM(bM, "byteLength"), GM(bM, "byteOffset")), nM(NM, { getInt8: function(e3) {
          return KM(this, 1, e3)[0] << 24 >> 24;
        }, getUint8: function(e3) {
          return KM(this, 1, e3)[0];
        }, getInt16: function(e3) {
          var t3 = KM(this, 2, e3, arguments.length > 1 ? arguments[1] : void 0);
          return (t3[1] << 8 | t3[0]) << 16 >> 16;
        }, getUint16: function(e3) {
          var t3 = KM(this, 2, e3, arguments.length > 1 ? arguments[1] : void 0);
          return t3[1] << 8 | t3[0];
        }, getInt32: function(e3) {
          return FM(KM(this, 4, e3, arguments.length > 1 ? arguments[1] : void 0));
        }, getUint32: function(e3) {
          return FM(KM(this, 4, e3, arguments.length > 1 ? arguments[1] : void 0)) >>> 0;
        }, getFloat32: function(e3) {
          return MM(KM(this, 4, e3, arguments.length > 1 ? arguments[1] : void 0), 23);
        }, getFloat64: function(e3) {
          return MM(KM(this, 8, e3, arguments.length > 1 ? arguments[1] : void 0), 52);
        }, setInt8: function(e3, t3) {
          HM(this, 1, e3, UM, t3);
        }, setUint8: function(e3, t3) {
          HM(this, 1, e3, UM, t3);
        }, setInt16: function(e3, t3) {
          HM(this, 2, e3, xM, t3, arguments.length > 2 ? arguments[2] : void 0);
        }, setUint16: function(e3, t3) {
          HM(this, 2, e3, xM, t3, arguments.length > 2 ? arguments[2] : void 0);
        }, setInt32: function(e3, t3) {
          HM(this, 4, e3, QM, t3, arguments.length > 2 ? arguments[2] : void 0);
        }, setUint32: function(e3, t3) {
          HM(this, 4, e3, QM, t3, arguments.length > 2 ? arguments[2] : void 0);
        }, setFloat32: function(e3, t3) {
          HM(this, 4, e3, VM, t3, arguments.length > 2 ? arguments[2] : void 0);
        }, setFloat64: function(e3, t3) {
          HM(this, 8, e3, jM, t3, arguments.length > 2 ? arguments[2] : void 0);
        } });
      fM(yM, SM), fM(bM, vM);
      var ZM = { ArrayBuffer: yM, DataView: bM }, $M = Gr, eU = S, tU = n, iU = Ot, rU = qi, nU = Zi, oU = bR, sU = ZM.ArrayBuffer, aU = ZM.DataView, cU = aU.prototype, dU = eU(sU.prototype.slice), uU = eU(cU.getUint8), hU = eU(cU.setUint8);
      $M({ target: "ArrayBuffer", proto: true, unsafe: true, forced: tU(function() {
        return !new sU(2).slice(1, void 0).byteLength;
      }) }, { slice: function(e3, t3) {
        if (dU && void 0 === t3)
          return dU(iU(this), e3);
        for (var i3 = iU(this).byteLength, r3 = rU(e3, i3), n3 = rU(void 0 === t3 ? i3 : t3, i3), o3 = new (oU(this, sU))(nU(n3 - r3)), s3 = new aU(this), a3 = new aU(o3), c3 = 0; r3 < n3; )
          hU(a3, c3++, uU(s3, r3++));
        return o3;
      } });
      var AU, lU, pU, gU = { exports: {} }, EU = bB, fU = o, mU = i, IU = x, _U = F, CU = Be, SU = fc, vU = he, TU = Kt, RU = Ht.exports, yU = Tt.f, wU = H, bU = jd, NU = lu, OU = ze, DU = Fe, PU = mU.Int8Array, LU = PU && PU.prototype, kU = mU.Uint8ClampedArray, BU = kU && kU.prototype, MU = PU && bU(PU), UU = LU && bU(LU), xU = Object.prototype, QU = mU.TypeError, FU = OU("toStringTag"), VU = DU("TYPED_ARRAY_TAG"), jU = DU("TYPED_ARRAY_CONSTRUCTOR"), GU = EU && !!NU && "Opera" !== SU(mU.opera), KU = false, HU = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, WU = { BigInt64Array: 8, BigUint64Array: 8 }, YU = function(e3) {
        if (!_U(e3))
          return false;
        var t3 = SU(e3);
        return CU(HU, t3) || CU(WU, t3);
      };
      for (AU in HU)
        (pU = (lU = mU[AU]) && lU.prototype) ? TU(pU, jU, lU) : GU = false;
      for (AU in WU)
        (pU = (lU = mU[AU]) && lU.prototype) && TU(pU, jU, lU);
      if ((!GU || !IU(MU) || MU === Function.prototype) && (MU = function() {
        throw QU("Incorrect invocation");
      }, GU))
        for (AU in HU)
          mU[AU] && NU(mU[AU], MU);
      if ((!GU || !UU || UU === xU) && (UU = MU.prototype, GU))
        for (AU in HU)
          mU[AU] && NU(mU[AU].prototype, UU);
      if (GU && bU(BU) !== UU && NU(BU, UU), fU && !CU(UU, FU))
        for (AU in KU = true, yU(UU, FU, { get: function() {
          return _U(this) ? this[VU] : void 0;
        } }), HU)
          mU[AU] && TU(mU[AU], VU, AU);
      var JU = { NATIVE_ARRAY_BUFFER_VIEWS: GU, TYPED_ARRAY_CONSTRUCTOR: jU, TYPED_ARRAY_TAG: KU && VU, aTypedArray: function(e3) {
        if (YU(e3))
          return e3;
        throw QU("Target is not a typed array");
      }, aTypedArrayConstructor: function(e3) {
        if (IU(e3) && (!NU || wU(MU, e3)))
          return e3;
        throw QU(vU(e3) + " is not a typed array constructor");
      }, exportTypedArrayMethod: function(e3, t3, i3, r3) {
        if (fU) {
          if (i3)
            for (var n3 in HU) {
              var o3 = mU[n3];
              if (o3 && CU(o3.prototype, e3))
                try {
                  delete o3.prototype[e3];
                } catch (i4) {
                  try {
                    o3.prototype[e3] = t3;
                  } catch (e4) {
                  }
                }
            }
          UU[e3] && !i3 || RU(UU, e3, i3 ? t3 : GU && LU[e3] || t3, r3);
        }
      }, exportTypedArrayStaticMethod: function(e3, t3, i3) {
        var r3, n3;
        if (fU) {
          if (NU) {
            if (i3) {
              for (r3 in HU)
                if ((n3 = mU[r3]) && CU(n3, e3))
                  try {
                    delete n3[e3];
                  } catch (e4) {
                  }
            }
            if (MU[e3] && !i3)
              return;
            try {
              return RU(MU, e3, i3 ? t3 : GU && MU[e3] || t3);
            } catch (e4) {
            }
          }
          for (r3 in HU)
            !(n3 = mU[r3]) || n3[e3] && !i3 || RU(n3, e3, t3);
        }
      }, isView: function(e3) {
        if (!_U(e3))
          return false;
        var t3 = SU(e3);
        return "DataView" === t3 || CU(HU, t3) || CU(WU, t3);
      }, isTypedArray: YU, TypedArray: MU, TypedArrayPrototype: UU }, qU = i, XU = n, zU = iR, ZU = JU.NATIVE_ARRAY_BUFFER_VIEWS, $U = qU.ArrayBuffer, ex = qU.Int8Array, tx = !ZU || !XU(function() {
        ex(1);
      }) || !XU(function() {
        new ex(-1);
      }) || !zU(function(e3) {
        new ex(), new ex(null), new ex(1.5), new ex(e3);
      }, true) || XU(function() {
        return 1 !== new ex(new $U(2), 1, void 0).length;
      }), ix = F, rx = Math.floor, nx = Number.isInteger || function(e3) {
        return !ix(e3) && isFinite(e3) && rx(e3) === e3;
      }, ox = Hi, sx = i.RangeError, ax = function(e3) {
        var t3 = ox(e3);
        if (t3 < 0)
          throw sx("The argument can't be less than 0");
        return t3;
      }, cx = i.RangeError, dx = function(e3, t3) {
        var i3 = ax(e3);
        if (i3 % t3)
          throw cx("Wrong offset");
        return i3;
      }, ux = IT, hx = d, Ax = TR, lx = Pe, px = er, gx = BT, Ex = bT, fx = vT, mx = JU.aTypedArrayConstructor, Ix = y, _x = i, Cx = Array.isArray || function(e3) {
        return "Array" == Ix(e3);
      }, Sx = _R, vx = F, Tx = ze("species"), Rx = _x.Array, yx = function(e3) {
        var t3;
        return Cx(e3) && (t3 = e3.constructor, (Sx(t3) && (t3 === Rx || Cx(t3.prototype)) || vx(t3) && null === (t3 = t3[Tx])) && (t3 = void 0)), void 0 === t3 ? Rx : t3;
      }, wx = IT, bx = P, Nx = Pe, Ox = er, Dx = function(e3, t3) {
        return new (yx(e3))(0 === t3 ? 0 : t3);
      }, Px = S([].push), Lx = function(e3) {
        var t3 = 1 == e3, i3 = 2 == e3, r3 = 3 == e3, n3 = 4 == e3, o3 = 6 == e3, s3 = 7 == e3, a3 = 5 == e3 || o3;
        return function(c3, d3, u3, h3) {
          for (var A3, l3, p3 = Nx(c3), g3 = bx(p3), E3 = wx(d3, u3), f3 = Ox(g3), m3 = 0, I3 = h3 || Dx, _3 = t3 ? I3(c3, f3) : i3 || s3 ? I3(c3, 0) : void 0; f3 > m3; m3++)
            if ((a3 || m3 in g3) && (l3 = E3(A3 = g3[m3], m3, p3), e3))
              if (t3)
                _3[m3] = l3;
              else if (l3)
                switch (e3) {
                  case 3:
                    return true;
                  case 5:
                    return A3;
                  case 6:
                    return m3;
                  case 2:
                    Px(_3, A3);
                }
              else
                switch (e3) {
                  case 4:
                    return false;
                  case 7:
                    Px(_3, A3);
                }
          return o3 ? -1 : r3 || n3 ? n3 : _3;
        };
      }, kx = { forEach: Lx(0), map: Lx(1), filter: Lx(2), some: Lx(3), every: Lx(4), find: Lx(5), findIndex: Lx(6), filterReject: Lx(7) }, Bx = Gr, Mx = i, Ux = d, xx = o, Qx = tx, Fx = JU, Vx = ZM, jx = m_, Gx = E, Kx = Kt, Hx = nx, Wx = Zi, Yx = PB, Jx = dx, qx = ct, Xx = Be, zx = fc, Zx = F, $x = de, eQ = zc, tQ = H, iQ = lu, rQ = ji.f, nQ = function(e3) {
        var t3, i3, r3, n3, o3, s3, a3 = Ax(this), c3 = lx(e3), d3 = arguments.length, u3 = d3 > 1 ? arguments[1] : void 0, h3 = void 0 !== u3, A3 = Ex(c3);
        if (A3 && !fx(A3))
          for (s3 = (o3 = gx(c3, A3)).next, c3 = []; !(n3 = hx(s3, o3)).done; )
            c3.push(n3.value);
        for (h3 && d3 > 2 && (u3 = ux(u3, arguments[2])), i3 = px(c3), r3 = new (mx(a3))(i3), t3 = 0; i3 > t3; t3++)
          r3[t3] = h3 ? u3(c3[t3], t3) : c3[t3];
        return r3;
      }, oQ = kx.forEach, sQ = WS, aQ = Tt, cQ = r, dQ = dh, uQ = Ri.get, hQ = Ri.set, AQ = aQ.f, lQ = cQ.f, pQ = Math.round, gQ = Mx.RangeError, EQ = Vx.ArrayBuffer, fQ = EQ.prototype, mQ = Vx.DataView, IQ = Fx.NATIVE_ARRAY_BUFFER_VIEWS, _Q = Fx.TYPED_ARRAY_CONSTRUCTOR, CQ = Fx.TYPED_ARRAY_TAG, SQ = Fx.TypedArray, vQ = Fx.TypedArrayPrototype, TQ = Fx.aTypedArrayConstructor, RQ = Fx.isTypedArray, yQ = "BYTES_PER_ELEMENT", wQ = "Wrong length", bQ = function(e3, t3) {
        TQ(e3);
        for (var i3 = 0, r3 = t3.length, n3 = new e3(r3); r3 > i3; )
          n3[i3] = t3[i3++];
        return n3;
      }, NQ = function(e3, t3) {
        AQ(e3, t3, { get: function() {
          return uQ(this)[t3];
        } });
      }, OQ = function(e3) {
        var t3;
        return tQ(fQ, e3) || "ArrayBuffer" == (t3 = zx(e3)) || "SharedArrayBuffer" == t3;
      }, DQ = function(e3, t3) {
        return RQ(e3) && !$x(t3) && t3 in e3 && Hx(+t3) && t3 >= 0;
      }, PQ = function(e3, t3) {
        return t3 = qx(t3), DQ(e3, t3) ? Gx(2, e3[t3]) : lQ(e3, t3);
      }, LQ = function(e3, t3, i3) {
        return t3 = qx(t3), !(DQ(e3, t3) && Zx(i3) && Xx(i3, "value")) || Xx(i3, "get") || Xx(i3, "set") || i3.configurable || Xx(i3, "writable") && !i3.writable || Xx(i3, "enumerable") && !i3.enumerable ? AQ(e3, t3, i3) : (e3[t3] = i3.value, e3);
      };
      xx ? (IQ || (cQ.f = PQ, aQ.f = LQ, NQ(vQ, "buffer"), NQ(vQ, "byteOffset"), NQ(vQ, "byteLength"), NQ(vQ, "length")), Bx({ target: "Object", stat: true, forced: !IQ }, { getOwnPropertyDescriptor: PQ, defineProperty: LQ }), gU.exports = function(e3, t3, i3) {
        var r3 = e3.match(/\d+$/)[0] / 8, n3 = e3 + (i3 ? "Clamped" : "") + "Array", o3 = "get" + e3, s3 = "set" + e3, a3 = Mx[n3], c3 = a3, d3 = c3 && c3.prototype, u3 = {}, h3 = function(e4, t4) {
          AQ(e4, t4, { get: function() {
            return function(e5, t5) {
              var i4 = uQ(e5);
              return i4.view[o3](t5 * r3 + i4.byteOffset, true);
            }(this, t4);
          }, set: function(e5) {
            return function(e6, t5, n4) {
              var o4 = uQ(e6);
              i3 && (n4 = (n4 = pQ(n4)) < 0 ? 0 : n4 > 255 ? 255 : 255 & n4), o4.view[s3](t5 * r3 + o4.byteOffset, n4, true);
            }(this, t4, e5);
          }, enumerable: true });
        };
        IQ ? Qx && (c3 = t3(function(e4, t4, i4, n4) {
          return jx(e4, d3), dQ(Zx(t4) ? OQ(t4) ? void 0 !== n4 ? new a3(t4, Jx(i4, r3), n4) : void 0 !== i4 ? new a3(t4, Jx(i4, r3)) : new a3(t4) : RQ(t4) ? bQ(c3, t4) : Ux(nQ, c3, t4) : new a3(Yx(t4)), e4, c3);
        }), iQ && iQ(c3, SQ), oQ(rQ(a3), function(e4) {
          e4 in c3 || Kx(c3, e4, a3[e4]);
        }), c3.prototype = d3) : (c3 = t3(function(e4, t4, i4, n4) {
          jx(e4, d3);
          var o4, s4, a4, u4 = 0, A3 = 0;
          if (Zx(t4)) {
            if (!OQ(t4))
              return RQ(t4) ? bQ(c3, t4) : Ux(nQ, c3, t4);
            o4 = t4, A3 = Jx(i4, r3);
            var l3 = t4.byteLength;
            if (void 0 === n4) {
              if (l3 % r3)
                throw gQ(wQ);
              if ((s4 = l3 - A3) < 0)
                throw gQ(wQ);
            } else if ((s4 = Wx(n4) * r3) + A3 > l3)
              throw gQ(wQ);
            a4 = s4 / r3;
          } else
            a4 = Yx(t4), o4 = new EQ(s4 = a4 * r3);
          for (hQ(e4, { buffer: o4, byteOffset: A3, byteLength: s4, length: a4, view: new mQ(o4) }); u4 < a4; )
            h3(e4, u4++);
        }), iQ && iQ(c3, SQ), d3 = c3.prototype = eQ(vQ)), d3.constructor !== c3 && Kx(d3, "constructor", c3), Kx(d3, _Q, c3), CQ && Kx(d3, CQ, n3), u3[n3] = c3, Bx({ global: true, forced: c3 != a3, sham: !IQ }, u3), yQ in c3 || Kx(c3, yQ, r3), yQ in d3 || Kx(d3, yQ, r3), sQ(n3);
      }) : gU.exports = function() {
      }, (0, gU.exports)("Uint8", function(e3) {
        return function(t3, i3, r3) {
          return e3(this, t3, i3, r3);
        };
      });
      var kQ = er, BQ = Hi, MQ = JU.aTypedArray;
      (0, JU.exportTypedArrayMethod)("at", function(e3) {
        var t3 = MQ(this), i3 = kQ(t3), r3 = BQ(e3), n3 = r3 >= 0 ? r3 : i3 + r3;
        return n3 < 0 || n3 >= i3 ? void 0 : t3[n3];
      });
      var UQ = i, xQ = d, QQ = JU, FQ = er, VQ = dx, jQ = Pe, GQ = n, KQ = UQ.RangeError, HQ = UQ.Int8Array, WQ = HQ && HQ.prototype, YQ = WQ && WQ.set, JQ = QQ.aTypedArray, qQ = QQ.exportTypedArrayMethod, XQ = !GQ(function() {
        var e3 = new Uint8ClampedArray(2);
        return xQ(YQ, e3, { length: 1, 0: 3 }, 1), 3 !== e3[1];
      }), zQ = XQ && QQ.NATIVE_ARRAY_BUFFER_VIEWS && GQ(function() {
        var e3 = new HQ(2);
        return e3.set(1), e3.set("2", 1), 0 !== e3[0] || 2 !== e3[1];
      });
      qQ("set", function(e3) {
        JQ(this);
        var t3 = VQ(arguments.length > 1 ? arguments[1] : void 0, 1), i3 = jQ(e3);
        if (XQ)
          return xQ(YQ, this, i3, t3);
        var r3 = this.length, n3 = FQ(i3), o3 = 0;
        if (n3 + t3 > r3)
          throw KQ("Wrong length");
        for (; o3 < n3; )
          this[t3 + o3] = i3[o3++];
      }, !XQ || zQ);
      var ZQ = zB, $Q = Math.floor, eF = function(e3, t3) {
        var i3 = e3.length, r3 = $Q(i3 / 2);
        return i3 < 8 ? tF(e3, t3) : iF(e3, eF(ZQ(e3, 0, r3), t3), eF(ZQ(e3, r3), t3), t3);
      }, tF = function(e3, t3) {
        for (var i3, r3, n3 = e3.length, o3 = 1; o3 < n3; ) {
          for (r3 = o3, i3 = e3[o3]; r3 && t3(e3[r3 - 1], i3) > 0; )
            e3[r3] = e3[--r3];
          r3 !== o3++ && (e3[r3] = i3);
        }
        return e3;
      }, iF = function(e3, t3, i3, r3) {
        for (var n3 = t3.length, o3 = i3.length, s3 = 0, a3 = 0; s3 < n3 || a3 < o3; )
          e3[s3 + a3] = s3 < n3 && a3 < o3 ? r3(t3[s3], i3[a3]) <= 0 ? t3[s3++] : i3[a3++] : s3 < n3 ? t3[s3++] : i3[a3++];
        return e3;
      }, rF = eF, nF = W.match(/firefox\/(\d+)/i), oF = !!nF && +nF[1], sF = /MSIE|Trident/.test(W), aF = W.match(/AppleWebKit\/(\d+)\./), cF = !!aF && +aF[1], dF = i, uF = S, hF = n, AF = ge, lF = rF, pF = JU, gF = oF, EF = sF, fF = $, mF = cF, IF = dF.Array, _F = pF.aTypedArray, CF = pF.exportTypedArrayMethod, SF = dF.Uint16Array, vF = SF && uF(SF.prototype.sort), TF = !(!vF || hF(function() {
        vF(new SF(2), null);
      }) && hF(function() {
        vF(new SF(2), {});
      })), RF = !!vF && !hF(function() {
        if (fF)
          return fF < 74;
        if (gF)
          return gF < 67;
        if (EF)
          return true;
        if (mF)
          return mF < 602;
        var e3, t3, i3 = new SF(516), r3 = IF(516);
        for (e3 = 0; e3 < 516; e3++)
          t3 = e3 % 4, i3[e3] = 515 - e3, r3[e3] = e3 - 2 * t3 + 3;
        for (vF(i3, function(e4, t4) {
          return (e4 / 4 | 0) - (t4 / 4 | 0);
        }), e3 = 0; e3 < 516; e3++)
          if (i3[e3] !== r3[e3])
            return true;
      });
      CF("sort", function(e3) {
        return void 0 !== e3 && AF(e3), RF ? vF(this, e3) : lF(_F(this), function(e4) {
          return function(t3, i3) {
            return void 0 !== e4 ? +e4(t3, i3) || 0 : i3 != i3 ? -1 : t3 != t3 ? 1 : 0 === t3 && 0 === i3 ? 1 / t3 > 0 && 1 / i3 < 0 ? 1 : -1 : t3 > i3;
          };
        }(e3));
      }, !RF || TF);
      var yF = WS, wF = "ArrayBuffer", bF = ZM.ArrayBuffer;
      let NF;
      Gr({ global: true, forced: i.ArrayBuffer !== bF }, { ArrayBuffer: bF }), yF(wF), function(e3) {
        e3[e3.CHOOSE_SERVER = 11] = "CHOOSE_SERVER", e3[e3.CLOUD_PROXY = 18] = "CLOUD_PROXY", e3[e3.CLOUD_PROXY_5 = 20] = "CLOUD_PROXY_5", e3[e3.CLOUD_PROXY_FALLBACK = 26] = "CLOUD_PROXY_FALLBACK";
      }(NF || (NF = {}));
      var OF = Hn, DF = Array.isArray || function(e3) {
        return "Array" == OF(e3);
      }, PF = vn, LF = DF, kF = ZE, BF = no, MF = Es("species"), UF = PF.Array, xF = function(e3) {
        var t3;
        return LF(e3) && (t3 = e3.constructor, (kF(t3) && (t3 === UF || LF(t3.prototype)) || BF(t3) && null === (t3 = t3[MF])) && (t3 = void 0)), void 0 === t3 ? UF : t3;
      }, QF = function(e3, t3) {
        return new (xF(e3))(0 === t3 ? 0 : t3);
      }, FF = ta, VF = zn, jF = zo, GF = Va, KF = QF, HF = _n([].push), WF = function(e3) {
        var t3 = 1 == e3, i3 = 2 == e3, r3 = 3 == e3, n3 = 4 == e3, o3 = 6 == e3, s3 = 7 == e3, a3 = 5 == e3 || o3;
        return function(c3, d3, u3, h3) {
          for (var A3, l3, p3 = jF(c3), g3 = VF(p3), E3 = FF(d3, u3), f3 = GF(g3), m3 = 0, I3 = h3 || KF, _3 = t3 ? I3(c3, f3) : i3 || s3 ? I3(c3, 0) : void 0; f3 > m3; m3++)
            if ((a3 || m3 in g3) && (l3 = E3(A3 = g3[m3], m3, p3), e3))
              if (t3)
                _3[m3] = l3;
              else if (l3)
                switch (e3) {
                  case 3:
                    return true;
                  case 5:
                    return A3;
                  case 6:
                    return m3;
                  case 2:
                    HF(_3, A3);
                }
              else
                switch (e3) {
                  case 4:
                    return false;
                  case 7:
                    HF(_3, A3);
                }
          return o3 ? -1 : r3 || n3 ? n3 : _3;
        };
      }, YF = { forEach: WF(0), map: WF(1), filter: WF(2), some: WF(3), every: WF(4), find: WF(5), findIndex: WF(6), filterReject: WF(7) }, JF = YF.forEach, qF = Xa("forEach") ? [].forEach : function(e3) {
        return JF(this, e3, arguments.length > 1 ? arguments[1] : void 0);
      };
      ka({ target: "Array", proto: true, forced: [].forEach != qF }, { forEach: qF });
      var XF = ic("Array").forEach, zF = Vl, ZF = es, $F = Cn, eV = XF, tV = Array.prototype, iV = { DOMTokenList: true, NodeList: true }, rV = function(e3) {
        var t3 = e3.forEach;
        return e3 === tV || $F(tV, e3) && t3 === tV.forEach || ZF(iV, zF(e3)) ? eV : t3;
      }, nV = zo, oV = el;
      ka({ target: "Object", stat: true, forced: ln(function() {
        oV(1);
      }) }, { keys: function(e3) {
        return oV(nV(e3));
      } });
      var sV = oo.Object.keys, aV = ac, cV = ka, dV = DF, uV = _n([].reverse), hV = [1, 2];
      cV({ target: "Array", proto: true, forced: String(hV) === String(hV.reverse()) }, { reverse: function() {
        return dV(this) && (this.length = this.length), uV(this);
      } });
      var AV = ic("Array").reverse, lV = Cn, pV = AV, gV = Array.prototype, EV = function(e3) {
        var t3 = e3.reverse;
        return e3 === gV || lV(gV, e3) && t3 === gV.reverse ? pV : t3;
      }, fV = ln, mV = Io, IV = Es("species"), _V = function(e3) {
        return mV >= 51 || !fV(function() {
          var t3 = [];
          return (t3.constructor = {})[IV] = function() {
            return { foo: 1 };
          }, 1 !== t3[e3](Boolean).foo;
        });
      }, CV = ka, SV = vn, vV = DF, TV = ZE, RV = no, yV = TA, wV = Va, bV = io, NV = WP, OV = Es, DV = af, PV = _V("slice"), LV = OV("species"), kV = SV.Array, BV = Math.max;
      CV({ target: "Array", proto: true, forced: !PV }, { slice: function(e3, t3) {
        var i3, r3, n3, o3 = bV(this), s3 = wV(o3), a3 = yV(e3, s3), c3 = yV(void 0 === t3 ? s3 : t3, s3);
        if (vV(o3) && (i3 = o3.constructor, (TV(i3) && (i3 === kV || vV(i3.prototype)) || RV(i3) && null === (i3 = i3[LV])) && (i3 = void 0), i3 === kV || void 0 === i3))
          return DV(o3, a3, c3);
        for (r3 = new (void 0 === i3 ? kV : i3)(BV(c3 - a3, 0)), n3 = 0; a3 < c3; a3++, n3++)
          a3 in o3 && NV(r3, n3, o3[a3]);
        return r3.length = n3, r3;
      } });
      var MV = ic("Array").slice, UV = Cn, xV = MV, QV = Array.prototype, FV = function(e3) {
        var t3 = e3.slice;
        return e3 === QV || UV(QV, e3) && t3 === QV.slice ? xV : t3;
      };
      function VV(e3, t3, i3, r3, n3) {
        var o3, s3, a3, c3 = {};
        return rV(o3 = sV(r3)).call(o3, function(e4) {
          c3[e4] = r3[e4];
        }), c3.enumerable = !!c3.enumerable, c3.configurable = !!c3.configurable, ("value" in c3 || c3.initializer) && (c3.writable = true), c3 = aV(s3 = EV(a3 = FV(i3).call(i3)).call(a3)).call(s3, function(i4, r4) {
          return r4(e3, t3, i4) || i4;
        }, c3), n3 && void 0 !== c3.initializer && (c3.value = c3.initializer ? c3.initializer.call(n3) : void 0, c3.initializer = void 0), void 0 === c3.initializer && (BN(e3, t3, c3), c3 = null), c3;
      }
      var jV = ic("Array").keys, GV = Vl, KV = es, HV = Cn, WV = jV, YV = Array.prototype, JV = { DOMTokenList: true, NodeList: true }, qV = function(e3) {
        var t3 = e3.keys;
        return e3 === YV || HV(YV, e3) && t3 === YV.keys || KV(JV, GV(e3)) ? WV : t3;
      };
      function XV(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function zV(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? XV(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : XV(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      let ZV = 0, $V = 0;
      function ej(e3, t3, i3, r3) {
        return new l_((n3, o3) => {
          t3.timeout = t3.timeout || LP("HTTP_CONNECT_TIMEOUT"), t3.responseType = t3.responseType || "json", t3.data && !i3 ? (t3.data = JSON.stringify(t3.data), ZV += gK(t3.data)) : i3 && (t3.data.size ? ZV += t3.data.size : t3.data instanceof FormData ? ZV += function(e4) {
            let t4 = 0;
            /DingTalk/i.test(navigator.userAgent) && e4.realFormData && (e4 = e4.realFormData);
            return e4.forEach((e5) => {
              t4 += "string" == typeof e5 ? gK(e5) : e5.size;
            }), t4 + 138;
          }(t3.data) : ZV += gK(JSON.stringify(t3.data))), t3.headers = t3.headers || {}, t3.headers["Content-Type"] = t3.headers["Content-Type"] || "application/json", t3.method = "POST", t3.url = e3, kD.request(t3).then((e4) => {
            "string" == typeof e4.data ? $V += gK(e4.data) : e4.data instanceof ArrayBuffer || e4.data instanceof Uint8Array ? $V += e4.data.byteLength : $V += gK(JSON.stringify(e4.data)), r3 && n3({ data: e4.data, headers: e4.headers }), n3(e4.data);
          }).catch((e4) => {
            kD.isCancel(e4) ? o3(new QD(xD.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e4.code ? o3(new QD(xD.NETWORK_TIMEOUT, e4.message)) : e4.response ? o3(new QD(xD.NETWORK_RESPONSE_ERROR, e4.response.status)) : o3(new QD(xD.NETWORK_ERROR, e4.message));
          });
        });
      }
      async function tj(e3, t3) {
        const i3 = new Blob([t3.data], { type: "buffer" });
        return await ej(e3, zV(zV({}, t3), {}, { data: i3, headers: { "Content-Type": "application/octet-stream" } }), true);
      }
      const ij = new class extends MD {
        set networkState(e3) {
          JD.info("[".concat(this._moduleName, "]") + "network state changed, " + this._networkState + " -> " + e3), this.emit(fB.NETWORK_STATE_CHANGE, e3, this._networkState), e3 === EB.ONLINE ? this.emit(fB.ONLINE) : e3 === EB.OFFLINE && (this.onlineWaiter = new l_((e4) => {
            this.once(fB.ONLINE, () => {
              this.onlineWaiter = void 0, e4(EB.ONLINE);
            });
          }), this.emit(fB.OFFLINE)), this._networkState = e3;
        }
        get networkState() {
          return this._networkState;
        }
        constructor() {
          super(), MN(this, "_moduleName", "network-indicator"), MN(this, "_networkState", EB.ONLINE), MN(this, "onlineWaiter", void 0), window.addEventListener("online", () => {
            this.networkState = EB.ONLINE;
          }), window.addEventListener("offline", () => {
            this.networkState = EB.OFFLINE;
          });
        }
      }();
      let rj = false;
      const nj = new class extends MD {
        constructor() {
          super(...arguments), MN(this, "onAutoplayFailed", void 0), MN(this, "onAudioAutoplayFailed", void 0);
        }
      }();
      function oj() {
        if (oN(), !rj) {
          const e3 = (t3) => {
            t3.preventDefault(), rj = false, bN() ? document.body.removeEventListener("click", e3, true) : (document.body.removeEventListener("touchstart", e3, true), document.body.removeEventListener("mousedown", e3, true));
          };
          rj = true, bN() ? document.body.addEventListener("click", e3, true) : (document.body.addEventListener("touchstart", e3, true), document.body.addEventListener("mousedown", e3, true)), JD.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"), nj.onAutoplayFailed ? nj.onAutoplayFailed() : nj.onAudioAutoplayFailed ? JD.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .") : JD.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."), nj.emit("autoplay-failed");
        }
      }
      function sj(e3) {
        return new TextEncoder().encode(e3);
      }
      const aj = function(e3, t3) {
        const i3 = new Uint8Array(e3.byteLength + t3.byteLength);
        return i3.set(new Uint8Array(e3), 0), i3.set(new Uint8Array(t3), e3.byteLength), i3;
      };
      const cj = async (e3) => function(e4, t3) {
        let i3 = "";
        return new Uint8Array(e4).forEach((e5) => {
          i3 += e5.toString(t3).padStart(2, "0");
        }), i3;
      }(await crypto.subtle.digest("SHA-256", sj(e3)), 16);
      var dj;
      function uj(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function hj(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? uj(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : uj(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      function Aj() {
        let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { report: pj };
        return function(t3, i3, r3) {
          const n3 = t3[i3];
          if ("function" == typeof n3) {
            const o3 = "AgoraRTCClient" === t3.constructor.name ? "Client" : t3.constructor.name;
            r3.value = function() {
              for (var t4 = arguments.length, r4 = new Array(t4), s3 = 0; s3 < t4; s3++)
                r4[s3] = arguments[s3];
              const a3 = e3.report.reportApiInvoke(this._sessionId || null, { name: "".concat(o3, ".").concat(i3), options: r4, tag: nk.TRACER, reportResult: e3.reportResult });
              try {
                const t5 = n3.apply(this, r4);
                return a3.onSuccess(e3.reportResult && t5), t5;
              } catch (e4) {
                throw a3.onError(e4), e4;
              }
            };
          }
          return r3;
        };
      }
      function lj() {
        let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { report: pj };
        return function(t3, i3, r3) {
          const n3 = r3.value;
          if ("function" == typeof n3) {
            let o3;
            o3 = e3.className ? e3.className : "AgoraRTCClient" === t3.constructor.name ? "Client" : t3.constructor.name, r3.value = async function() {
              let t4;
              for (var r4 = arguments.length, s3 = new Array(r4), a3 = 0; a3 < r4; a3++)
                s3[a3] = arguments[a3];
              try {
                s3.length > 0 && (JSON.stringify(s3), t4 = s3);
              } catch (e4) {
                JD.warning("arguments for method ".concat(o3, ".").concat(i3, " not serializable from apiInvoke.")), t4 = [];
              }
              const c3 = (e3.report || pj).reportApiInvoke(this._sessionId || null, { name: "".concat(o3, ".").concat(i3), options: t4, tag: nk.TRACER });
              try {
                const e4 = await n3.apply(this, s3);
                return c3.onSuccess(), e4;
              } catch (e4) {
                throw c3.onError(e4), e4;
              }
            };
          }
          return r3;
        };
      }
      const pj = new (mP("AgoraRTCEventReport")(dj = class {
        constructor() {
          MN(this, "baseInfoMap", /* @__PURE__ */ new Map()), MN(this, "proxyServer", void 0), MN(this, "clientList", VP), MN(this, "eventUploadTimer", void 0), MN(this, "setSessionIdTimer", void 0), MN(this, "url", void 0), MN(this, "backupUrl", void 0), MN(this, "_appId", void 0), MN(this, "keyEventUploadPendingItems", []), MN(this, "normalEventUploadPendingItems", []), MN(this, "apiInvokeUploadPendingItems", []), MN(this, "apiInvokeCount", 0), MN(this, "ltsList", []), MN(this, "lastSendNormalEventTime", Date.now()), MN(this, "customReportCounterTimer", void 0), MN(this, "customReportCount", 0), MN(this, "extApiInvoke", async (e3) => {
            for (const t3 of e3) {
              const e4 = hj(hj({}, t3), {}, { sid: null, invokeId: ++this.apiInvokeCount, tag: nk.TRACER });
              this.sendApiInvoke(e4);
            }
          }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), LP("EVENT_REPORT_SEND_INTERVAL")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), LP("EVENT_REPORT_SEND_INTERVAL"));
        }
        adjustSessionStartTime(e3) {
          if (!this.baseInfoMap.has(e3) && !this.baseInfoMap.get(e3))
            return JD.error("adjust session ".concat(e3, " start time, sid is not exist or info is undefined")), void gP("error", this, "adjustSessionStartTime", "adjust session ".concat(e3, " start time, sid is not exist or info is undefined"));
          const t3 = this.baseInfoMap.get(e3), i3 = Date.now(), r3 = t3.startTime;
          t3.startTime = i3, JD.debug("rewrite session ".concat(e3, " startTime: ").concat(i3, " , ").concat(i3 - r3, "ms")), gP("debug", this, "adjustSessionStartTime", void 0, "rewrite session ".concat(e3, " startTime: ").concat(i3, " , ").concat(i3 - r3, "ms")), this.baseInfoMap.set(e3, t3);
        }
        setAppId(e3) {
          this._appId = e3;
        }
        reportApiInvoke(e3, t3, i3) {
          t3.timeout = t3.timeout || 6e4, t3.reportResult = void 0 === t3.reportResult || t3.reportResult;
          const r3 = Date.now();
          this.apiInvokeCount += 1;
          const n3 = this.apiInvokeCount, o3 = () => ({ tag: t3.tag, invokeId: n3, sid: e3, name: t3.name, apiInvokeTime: r3, options: t3.options, states: t3.states || null }), s3 = !!LP("SHOW_REPORT_INVOKER_LOG");
          s3 && JD.info("".concat(t3.name, " start"), t3.options);
          let a3 = false;
          EK(t3.timeout).then(() => {
            a3 || (this.sendApiInvoke(hj(hj({}, o3()), {}, { error: xD.API_INVOKE_TIMEOUT, success: false })), JD.debug("".concat(t3.name, " timeout")));
          });
          const c3 = new QD(xD.UNEXPECTED_ERROR, "".concat(t3.name, ": this api invoke is end"));
          return { onSuccess: (e4) => {
            const r4 = () => {
              if (a3)
                throw c3;
              return a3 = true, this.sendApiInvoke(hj(hj({}, o3()), {}, { success: true }, t3.reportResult && { result: e4 })), s3 && JD.info("".concat(t3.name, " onSuccess")), e4;
            };
            return i3 ? MK(r4, t3.name + "Success", i3, () => a3 = true) : r4();
          }, onError: (e4) => {
            const r4 = () => {
              if (a3)
                throw e4;
              a3 = true, this.sendApiInvoke(hj(hj({}, o3()), {}, { success: false, error: e4 })), s3 && JD.info("".concat(t3.name, " onFailure"), e4.toString());
            };
            return i3 ? MK(r4, t3.name + "Error", i3, () => a3 = true) : r4();
          } };
        }
        sessionInit(e3, t3) {
          if (this.baseInfoMap.has(e3))
            return;
          const i3 = Date.now(), r3 = this.createBaseInfo(e3, i3);
          r3.cname = t3.cname;
          const n3 = Object.assign({}, { willUploadConsoleLog: LP("UPLOAD_LOG"), maxTouchPoints: navigator.maxTouchPoints, areaVersion: SP ? "global" : "oversea", areas: LP("AREAS") && LP("AREAS").join(",") }, t3.extend), o3 = Date.now(), s3 = hj(hj({}, r3), {}, { eventType: $L.SESSION_INIT, appid: t3.appid, browser: navigator.userAgent, build: _P, lts: o3, elapse: o3 - i3, extend: JSON.stringify(n3), mode: t3.mode, process: LP("PROCESS_ID"), appType: LP("APP_TYPE"), success: true, version: CP });
          this.send({ type: ek.SESSION, data: s3 }, true);
        }
        joinChooseServer(e3, t3) {
          const i3 = this.baseInfoMap.get(e3);
          if (!i3)
            return;
          const r3 = i3.info, n3 = Date.now(), o3 = hj(hj({}, r3), {}, { eventType: $L.JOIN_CHOOSE_SERVER, lts: n3, eventElapse: n3 - t3.lts, chooseServerAddr: t3.csAddr, errorCode: t3.ec, elapse: n3 - i3.startTime, success: t3.succ, chooseServerAddrList: JSON.stringify(t3.serverList), uid: t3.uid ? parseInt(t3.uid) : null, cid: t3.cid ? parseInt(t3.cid) : null, chooseServerIp: t3.csIp || "", opid: t3.opid, unilbsServerIds: t3.unilbsServerIds, extend: t3.extend || void 0, isHttp3: t3.isHttp3 });
          this.send({ type: ek.JOIN_CHOOSE_SERVER, data: o3 }, true);
        }
        reqUserAccount(e3, t3) {
          const i3 = this.baseInfoMap.get(e3);
          if (!i3)
            return;
          const r3 = i3.info, n3 = Date.now(), o3 = hj(hj({}, r3), {}, { eventType: $L.REQ_USER_ACCOUNT, lts: n3, success: t3.success, serverAddress: t3.serverAddr, stringUid: t3.stringUid, uid: t3.uid, errorCode: t3.errorCode, elapse: n3 - i3.startTime, eventElapse: n3 - t3.lts, extend: JSON.stringify(t3.extend) });
          this.send({ type: ek.REQ_USER_ACCOUNT, data: o3 }, true);
        }
        joinGateway(e3, t3) {
          const i3 = this.baseInfoMap.get(e3);
          if (!i3)
            return;
          const r3 = i3.info;
          t3.vid && (r3.vid = t3.vid), r3.uid = t3.uid, r3.cid = t3.cid;
          const n3 = Date.now(), { firstSuccess: o3, avoidJoinStartTime: s3, isProxy: a3, addr: c3 } = t3, d3 = n3 - (o3 && s3 ? s3 : i3.startTime), u3 = hj(hj({}, r3), {}, { eventType: $L.JOIN_GATEWAY, lts: n3, gatewayAddr: t3.addr, success: t3.succ, errorCode: t3.ec, elapse: d3, eventElapse: n3 - t3.lts, firstSuccess: o3, signalChannel: t3.signalChannel }), h3 = u3.success ? 1 : 0;
          if (t3.succ && (i3.lastJoinSuccessTime = n3), o3)
            this.send({ type: ek.JOIN_GATEWAY, data: u3 }, true);
          else {
            let e4;
            if (c3)
              if (a3) {
                const t5 = c3.match(/h=(\d{1,3}-){3}\d{1,3}/g), i4 = c3.match(/p=[0-9]{1,6}/g);
                e4 = { isSuccess: h3, gatewayIp: t5 && t5.length ? t5[0].split("=")[1].replace(/-/g, ".") : "", port: i4 && i4.length ? i4[0].split("=")[1] : "", isProxy: a3 ? 1 : 0 };
              } else {
                const t5 = c3.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g), i4 = c3.match(/:[0-9]{1,6}/g);
                e4 = { isSuccess: h3, gatewayIp: t5 && t5.length ? t5[0].split("//")[1].replace(/-/g, ".") : "", port: i4 && i4.length ? i4[0].split(":")[1] : "", isProxy: a3 ? 1 : 0 };
              }
            else
              e4 = { isSuccess: h3, gatewayIp: "", port: "", isProxy: a3 ? 1 : 0 };
            delete u3.success, delete u3.eventType, delete u3.firstSuccess, u3.vid = Number(u3.vid);
            const t4 = Object.assign({}, u3, e4, { eventType: $L.REJOIN_GATEWAY });
            this.send({ type: ek.RE_JOIN_GATEWAY, data: t4 }, true);
          }
        }
        joinChannelTimeout(e3, t3) {
          const i3 = this.baseInfoMap.get(e3);
          if (!i3)
            return;
          const r3 = Date.now(), n3 = hj(hj({}, i3.info), {}, { lts: r3, timeout: t3, elapse: r3 - i3.startTime });
          this.send({ type: ek.JOIN_CHANNEL_TIMEOUT, data: n3 }, true);
        }
        publish(e3, t3) {
          const i3 = this.baseInfoMap.get(e3);
          if (!i3)
            return;
          const r3 = i3.info, n3 = Date.now(), o3 = hj(hj({}, r3), {}, { eventType: $L.PUBLISH, lts: n3, eventElapse: t3.eventElapse, elapse: n3 - i3.startTime, success: t3.succ, errorCode: t3.ec, videoName: t3.videoName, audioName: t3.audioName, screenName: t3.screenName, screenshare: t3.screenshare, audio: t3.audio, video: t3.video, p2pid: t3.p2pid, publishRequestid: t3.publishRequestid });
          this.send({ type: ek.PUBLISH, data: o3 }, true);
        }
        subscribe(e3, t3, i3) {
          const r3 = this.baseInfoMap.get(e3);
          if (!r3)
            return;
          const n3 = r3.info, o3 = Date.now(), s3 = hj(hj({}, n3), {}, { eventType: $L.SUBSCRIBE, lts: o3, eventElapse: t3.eventElapse, elapse: o3 - r3.startTime, success: t3.succ, errorCode: t3.ec, video: t3.video, audio: t3.audio, subscribeRequestid: t3.subscribeRequestid, p2pid: t3.p2pid }, i3 && { extend: JSON.stringify({ isMassSubscribe: true }) });
          "string" == typeof t3.peerid ? s3.peerSuid = t3.peerid : s3.peer = t3.peerid, this.send({ type: ek.SUBSCRIBE, data: s3 }, true);
        }
        wsCompressorInit(e3) {
          var t3;
          const i3 = [...qV(t3 = this.baseInfoMap).call(t3)], r3 = i3.length ? i3[0] : "UnableToGetSid", n3 = this.baseInfoMap.get(r3);
          if (!n3)
            return;
          const o3 = n3.info, s3 = Date.now(), a3 = hj(hj({}, o3), {}, { eventType: $L.WS_COMPRESSOR_INIT, lts: s3, eventElapse: e3.eventElapse, elapse: s3 - n3.startTime, status: e3.status ? 1 : 2 });
          this.send({ type: ek.WS_COMPRESSOR_INIT, data: a3 }, true);
        }
        firstRemoteVideoDecode(e3, t3, i3, r3) {
          const n3 = this.baseInfoMap.get(e3);
          if (!n3)
            return;
          const o3 = n3.info, s3 = Date.now(), a3 = hj(hj(hj({}, o3), r3), {}, { elapse: s3 - n3.startTime, eventType: t3, lts: s3, firstDecodeFrame: Math.max(s3 - n3.startTime, 0), apEnd: Math.max(r3.apEnd - n3.startTime, 0), apStart: Math.max(r3.apStart - n3.startTime, 0), joinGwEnd: Math.max(r3.joinGwEnd - n3.startTime, 0), joinGwStart: Math.max(r3.joinGwStart - n3.startTime, 0), pcEnd: Math.max(r3.pcEnd - n3.startTime, 0), pcStart: Math.max(r3.pcStart - n3.startTime, 0), subscriberEnd: Math.max(r3.subscriberEnd - n3.startTime, 0), subscriberStart: Math.max(r3.subscriberStart - n3.startTime, 0), videoAddNotify: Math.max(r3.videoAddNotify - n3.startTime, 0) });
          this.send({ type: i3, data: a3 }, true);
        }
        firstRemoteFrame(e3, t3, i3, r3) {
          const n3 = this.baseInfoMap.get(e3);
          if (!n3)
            return;
          const o3 = n3.info, s3 = Date.now(), a3 = hj(hj(hj({}, o3), r3), {}, { elapse: s3 - n3.startTime, eventType: t3, lts: s3 });
          this.send({ type: i3, data: a3 }, true);
        }
        onGatewayStream(e3, t3, i3, r3) {
          const n3 = this.baseInfoMap.get(e3);
          if (!n3)
            return;
          const o3 = n3.info, s3 = Date.now(), a3 = hj(hj(hj({}, o3), r3), {}, { eventType: t3, lts: s3 });
          this.send({ type: i3, data: a3 }, true);
        }
        streamSwitch(e3, t3) {
          const i3 = this.baseInfoMap.get(e3);
          if (!i3)
            return;
          const r3 = i3.info, n3 = Date.now(), o3 = hj(hj({}, r3), {}, { eventType: $L.STREAM_SWITCH, lts: n3, isDual: t3.isdual, elapse: n3 - i3.startTime, success: t3.succ });
          this.send({ type: ek.STREAM_SWITCH, data: o3 }, true);
        }
        requestProxyAppCenter(e3, t3) {
          const i3 = this.baseInfoMap.get(e3);
          if (!i3)
            return;
          const r3 = i3.info, n3 = Date.now(), o3 = hj(hj({}, r3), {}, { eventType: $L.REQUEST_PROXY_APPCENTER, lts: n3, eventElapse: n3 - t3.lts, elapse: n3 - i3.startTime, APAddr: t3.APAddr, workerManagerList: t3.workerManagerList, response: t3.response, errorCode: t3.ec, success: t3.succ });
          this.send({ type: ek.REQUEST_PROXY_APPCENTER, data: o3 }, true);
        }
        requestProxyWorkerManager(e3, t3) {
          const i3 = this.baseInfoMap.get(e3);
          if (!i3)
            return;
          const r3 = i3.info, n3 = Date.now(), o3 = hj(hj({}, r3), {}, { eventType: $L.REQUEST_PROXY_WORKER_MANAGER, lts: n3, eventElapse: n3 - t3.lts, elapse: n3 - i3.startTime, workerManagerAddr: t3.workerManagerAddr, response: t3.response, errorCode: t3.ec, success: t3.succ });
          this.send({ type: ek.REQUEST_PROXY_WORKER_MANAGER, data: o3 }, true);
        }
        setProxyServer(e3) {
          this.proxyServer = e3, e3 ? JD.debug("reportProxyServerurl: ".concat(e3)) : JD.debug("disable reportProxyServerurl: ".concat(e3)), gP("debug", this, "setProxyServer", e3);
        }
        peerPublishStatus(e3, t3) {
          const i3 = this.baseInfoMap.get(e3);
          if (!i3)
            return;
          const r3 = i3.info, n3 = Date.now(), o3 = hj(hj({}, r3), {}, { subscribeElapse: t3.subscribeElapse, peer: t3.peer, peerPublishDuration: Math.max(t3.audioPublishDuration, t3.videoPublishDuration), audiotag: t3.audioPublishDuration > 0 ? 1 : -1, videotag: t3.videoPublishDuration > 0 ? 1 : -1, lts: n3, elapse: n3 - i3.startTime, joinChannelSuccessElapse: n3 - (i3.lastJoinSuccessTime || n3), peerPublishDurationVideo: t3.videoPublishDuration, peerPublishDurationAudio: t3.audioPublishDuration });
          this.send({ type: ek.PEER_PUBLISH_STATUS, data: o3 }, true);
        }
        workerEvent(e3, t3) {
          const i3 = this.baseInfoMap.get(e3);
          if (!i3)
            return;
          const r3 = i3.info, n3 = Date.now();
          (function(e4, t4, i4) {
            const r4 = e4[t4];
            if (!r4 || "string" != typeof r4)
              return [e4];
            e4[t4] = "";
            const n4 = gK(JSON.stringify(e4));
            let o3 = 0;
            const s3 = [];
            let a3 = 0;
            for (let c3 = 0; c3 < r4.length; c3++)
              a3 += r4.charCodeAt(c3) <= 127 ? 1 : 3, a3 <= i4 - n4 || (s3[s3.length] = pK(pK({}, e4), {}, { [t4]: r4.substring(o3, c3) }), o3 = c3, a3 = r4.charCodeAt(c3) <= 127 ? 1 : 3);
            o3 !== r4.length - 1 && (s3[s3.length] = pK(pK({}, e4), {}, { [t4]: r4.substring(o3) }));
            return s3;
          })(hj(hj(hj({}, r3), t3), {}, { elapse: n3 - i3.startTime, lts: n3, productType: "WebRTC" }), "payload", 1300).forEach((e4) => this.send({ type: ek.WORKER_EVENT, data: e4 }, true));
        }
        apworkerEvent(e3, t3) {
          const i3 = this.baseInfoMap.get(e3);
          if (!i3)
            return;
          const r3 = i3.info, n3 = Date.now(), o3 = hj(hj(hj({}, r3), t3), {}, { elapse: n3 - i3.startTime, lts: n3 });
          this.send({ type: ek.AP_WORKER_EVENT, data: o3 }, true);
        }
        joinWebProxyAP(e3, t3) {
          const i3 = this.baseInfoMap.get(e3);
          if (!i3)
            return;
          const r3 = i3.info, n3 = Date.now(), o3 = hj(hj(hj({}, r3), t3), {}, { elapse: n3 - i3.startTime, lts: n3, extend: t3.extend || void 0 });
          this.send({ type: ek.JOIN_WEB_PROXY_AP, data: o3 }, true);
        }
        WebSocketQuit(e3, t3) {
          const i3 = this.baseInfoMap.get(e3);
          if (!i3)
            return;
          const r3 = i3.info, n3 = Date.now(), o3 = hj(hj(hj({}, r3), t3), {}, { elapse: n3 - i3.startTime, lts: n3 });
          this.send({ type: ek.WEBSOCKET_QUIT, data: o3 }, true);
        }
        async sendCustomReportMessage(e3, t3) {
          if (this.customReportCount += t3.length, this.customReportCount > LP("CUSTOM_REPORT_LIMIT"))
            throw new QD(xD.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
          this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {
            this.customReportCount = 0;
          }, 5e3));
          const i3 = t3.map((t4) => ({ type: ek.USER_ANALYTICS, data: hj({ sid: e3 }, t4) }));
          try {
            LP("NEW_REPORT_SERVER") ? await this.postDataToStatsCollector2(i3) : await this.postDataToStatsCollector(i3);
          } catch (e4) {
            throw JD.error("send custom report message failed", e4.toString()), new QD(xD.CUSTOM_REPORT_SEND_FAILED, e4.message);
          }
        }
        autoplayFailed(e3, t3, i3, r3) {
          if (!e3)
            return;
          const n3 = this.baseInfoMap.get(e3);
          if (!n3)
            return;
          const o3 = n3.info, s3 = Date.now(), a3 = hj(hj({}, o3), {}, { vid: void 0 === o3.vid ? 0 : Number(o3.vid), lts: s3, elapse: s3 - n3.startTime, cbRegistered: nj.onAutoplayFailed || nj.onAudioAutoplayFailed ? 1 : -1, errorMsg: i3, mediaType: t3, trackId: r3, extend: void 0 });
          this.send({ type: ek.AUTOPLAY_FAILED, data: a3 }, true);
        }
        sendApiInvoke(e3) {
          const t3 = LP("NOT_REPORT_EVENT");
          if (e3.tag && t3.includes && t3.includes(e3.tag))
            return false;
          if (null === e3.sid)
            return this.apiInvokeUploadPendingItems.push(e3), false;
          const i3 = this.baseInfoMap.get(e3.sid);
          if (!i3)
            return this.apiInvokeUploadPendingItems.push(e3), false;
          const { cname: r3, uid: n3, cid: o3 } = i3.info;
          e3.lts = e3.lts || Date.now();
          let s3 = void 0;
          if (e3.error)
            if (e3.error instanceof QD) {
              const { code: t4, message: i4 } = e3.error;
              s3 = t4 || (i4 || e3.error.toString());
            } else
              s3 = e3.error.toString();
          const a3 = { invokeId: e3.invokeId, sid: e3.sid, cname: r3, cid: o3, uid: n3, lts: e3.lts, success: e3.success, elapse: e3.lts - i3.startTime, execElapse: e3.lts - e3.apiInvokeTime, apiName: e3.name, options: e3.options ? JSON.stringify(e3.options) : void 0, execStates: e3.states ? JSON.stringify(e3.states) : void 0, execResult: e3.result ? JSON.stringify(e3.result) : void 0, errorCode: e3.error ? s3 : void 0, errorMsg: e3.error ? JSON.stringify(e3.error) : void 0 };
          return this.send({ type: ek.API_INVOKE, data: a3 }, false), true;
        }
        appendSessionId() {
          this.clientList.forEach((e3) => {
            if (e3._sessionId) {
              const t3 = this.apiInvokeUploadPendingItems.length;
              for (let i3 = 0; i3 < t3; i3++) {
                const t4 = this.apiInvokeUploadPendingItems.shift();
                t4 && (t4.sid = e3._sessionId, this.sendApiInvoke(Object.assign({}, t4)));
              }
            }
          });
        }
        send(e3, t3) {
          if (t3)
            return this.keyEventUploadPendingItems.push(e3), void this.sendItems(this.keyEventUploadPendingItems, true);
          this.normalEventUploadPendingItems.push(e3), this.normalEventUploadPendingItems.length > LP("NORMAL_EVENT_QUEUE_CAPACITY") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        doSend() {
          this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, true), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        sendItems(e3, t3) {
          const i3 = [], r3 = [];
          for (; e3.length; ) {
            const t4 = e3.shift();
            i3.length < 20 ? i3.push(t4) : r3.push(t4);
          }
          e3.push(...r3);
          for (const e4 of [...i3]) {
            var n3;
            if (-1 !== this.ltsList.indexOf(e4.data.lts))
              e4.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e4.data.lts);
            else
              this.ltsList.push(e4.data.lts), kL(n3 = this.ltsList).call(n3, (e5, t4) => e5 - t4);
          }
          t3 || (this.lastSendNormalEventTime = Date.now());
          return LP("ENABLE_EVENT_REPORT") ? (i3.length && (LP("NEW_REPORT_SERVER") ? this.postDataToStatsCollector2(i3) : this.postDataToStatsCollector(i3)).catch(((e4) => (i4) => {
            LP("EVENT_REPORT_RETRY") && (t3 ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e4) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e4), this.normalEventUploadPendingItems.length > LP("NORMAL_EVENT_QUEUE_CAPACITY") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - LP("NORMAL_EVENT_QUEUE_CAPACITY")), JD.warning("report: drop normal events"))));
          })(i3)), e3) : e3;
        }
        async postDataToStatsCollector2(e3) {
          ij.networkState === EB.OFFLINE && await l_.race([ij.onlineWaiter, EK(2 * FD.maxRetryTimeout)]);
          const t3 = (e4) => {
            let t4 = new Uint8Array();
            return e4.forEach((e5) => {
              const i4 = sj(JSON.stringify(e5.data)), r4 = new ArrayBuffer(5), n3 = ((e6) => {
                let t5 = 0;
                return Object.entries(ek).forEach((i5) => {
                  let [r5, n4] = i5;
                  n4 === e6.type && (t5 = ik[r5]);
                }), t5;
              })(e5), o3 = new DataView(r4);
              o3.setUint16(0, i4.byteLength, true), o3.setUint8(2, 255 & n3), o3.setUint8(3, n3 >>> 8 & 255), o3.setUint8(4, n3 >>> 16 & 255), t4 = aj(t4, new Uint8Array(r4)), t4 = aj(t4, i4);
            }), t4;
          }, i3 = "event";
          let r3 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(LP("NEW_REPORT_SERVER_DOMAINS")[0], "&p=443&d=").concat(i3) : "https://".concat(LP("NEW_REPORT_SERVER_DOMAINS")[0], "/").concat(i3);
          for (let n3 = 0; n3 < 2; n3 += 1) {
            1 === n3 && (r3 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(LP("NEW_REPORT_SERVER_DOMAINS")[1], "&p=443&d=").concat(i3) : "https://".concat(LP("NEW_REPORT_SERVER_DOMAINS")[1], "/").concat(i3));
            try {
              await ej(r3, { timeout: 1e4, data: t3(e3), headers: hj(hj({ token: "32f24ab2ddb74f508aa9286c356cec84", biz: "webrtc", sendts: Math.round(Date.now() / 1e3), debug: "false" }, this._appId && { appid: this._appId }), {}, { "Content-Type": "application/octet-stream" }) }, true);
            } catch (e4) {
              if (1 === n3)
                throw e4;
              continue;
            }
            return;
          }
        }
        async postDataToStatsCollector(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          const i3 = { msgType: "EventMessages", sentTs: Math.round(Date.now() / 1e3), payloads: e3.map((e4) => JSON.stringify(e4)), vid: ((e4) => {
            const t4 = e4 && e4.data.sid && this.baseInfoMap.get(e4.data.sid);
            return t4 && t4.info.vid && +t4.info.vid || 0;
          })(e3[0]) };
          ij.networkState === EB.OFFLINE && await l_.race([ij.onlineWaiter, EK(2 * FD.maxRetryTimeout)]);
          const r3 = t3 ? "/events/proto-raws" : "/events/messages";
          let n3 = this.url || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(LP("EVENT_REPORT_DOMAIN"), "&p=").concat(LP("STATS_COLLECTOR_PORT"), "&d=").concat(r3) : "https://".concat(LP("EVENT_REPORT_DOMAIN"), ":").concat(LP("STATS_COLLECTOR_PORT")).concat(r3));
          for (let e4 = 0; e4 < 2; e4 += 1) {
            1 === e4 && (n3 = this.backupUrl || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(LP("EVENT_REPORT_BACKUP_DOMAIN"), "&p=").concat(LP("STATS_COLLECTOR_PORT"), "&d=").concat(r3) : "https://".concat(LP("EVENT_REPORT_BACKUP_DOMAIN"), ":").concat(LP("STATS_COLLECTOR_PORT")).concat(r3)));
            try {
              t3 ? await tj(n3, { timeout: 1e4, data: i3 }) : await ej(n3, { timeout: 1e4, data: i3 });
            } catch (t4) {
              if (1 === e4)
                throw t4;
              continue;
            }
            return;
          }
        }
        createBaseInfo(e3, t3) {
          const i3 = Object.assign({}, ZL);
          return i3.sid = e3, this.baseInfoMap.set(e3, { info: i3, startTime: t3 }), i3;
        }
        reportResourceTiming(e3, t3) {
          const i3 = performance.getEntriesByName(e3), r3 = i3[i3.length - 1];
          r3 && this.reportApiInvoke(t3, { name: "Client.resourceTiming", options: r3, tag: nk.TRACER }).onSuccess();
        }
      }) || dj)();
      UD.on("REPORT_LOG_UPLOAD", (e3) => {
        e3.networkState = ij.networkState, pj.reportApiInvoke(null, { name: "logUploadError", options: e3, tag: nk.TRACER });
      });
      class gj extends MD {
        constructor(e3, t3) {
          super(), MN(this, "trackMediaType", void 0), MN(this, "_ID", void 0), MN(this, "_hints", []), MN(this, "_isClosed", false), MN(this, "_originMediaStreamTrack", void 0), MN(this, "_mediaStreamTrack", void 0), MN(this, "_external", {}), this._ID = t3 || mK(8, "track-"), this._originMediaStreamTrack = e3, this._mediaStreamTrack = e3, function(e4) {
            jP.includes(e4) || jP.push(e4);
          }(this);
        }
        toString() {
          return this._ID;
        }
        getTrackId() {
          return this._ID;
        }
        getMediaStreamTrack(e3) {
          if (!e3) {
            const e4 = pj.reportApiInvoke(null, { name: rk.GET_MEDIA_STREAM_TRACK, options: [], tag: nk.TRACER });
            this._mediaStreamTrack && "string" == typeof this._mediaStreamTrack.label ? e4.onSuccess(this._mediaStreamTrack.label) : e4.onSuccess("");
          }
          return this._mediaStreamTrack;
        }
        getMediaStreamTrackSettings() {
          return this.getMediaStreamTrack(true).getSettings();
        }
        close() {
          this._isClosed = true, function(e3) {
            const t3 = jP.indexOf(e3);
            -1 !== t3 && jP.splice(t3, 1);
          }(this), this.emit(iB.CLOSED);
        }
      }
      let Ej = 1;
      class fj {
        constructor(e3) {
          MN(this, "lockingPromise", l_.resolve()), MN(this, "locks", 0), MN(this, "name", ""), MN(this, "lockId", void 0), this.lockId = Ej++, e3 && (this.name = e3), JD.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is created."));
        }
        get isLocked() {
          return this.locks > 0;
        }
        lock(e3) {
          let t3;
          this.locks += 1, JD.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e3 ? e3 : ""));
          const i3 = new l_((i4) => {
            t3 = () => {
              this.locks -= 1, JD.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is not locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e3 ? e3 : "")), i4();
            };
          }), r3 = this.lockingPromise.then(() => t3);
          return this.lockingPromise = this.lockingPromise.then(() => i3), r3;
        }
      }
      function mj(e3, t3) {
        return function(i3, r3, n3) {
          const o3 = n3.value;
          if ("function" != typeof o3)
            throw new Error("Cannot use mutex on object property.");
          return n3.value = async function() {
            const i4 = this[t3];
            if (!i4)
              throw new Error("mutex property key ".concat(t3, " doesn't exist on ").concat(e3));
            const n4 = await i4.lock("From ".concat(e3, ".").concat(r3));
            try {
              for (var s3 = arguments.length, a3 = new Array(s3), c3 = 0; c3 < s3; c3++)
                a3[c3] = arguments[c3];
              return await o3.apply(this, a3);
            } finally {
              n4();
            }
          }, n3;
        };
      }
      class Ij extends gj {
        get muted() {
          return this._muted;
        }
        get enabled() {
          return this._enabled;
        }
        constructor(e3, t3) {
          super(e3, t3), MN(this, "_enabled", true), MN(this, "_muted", false), MN(this, "_isClosed", false), MN(this, "_enabledMutex", void 0), MN(this, "processor", void 0), MN(this, "processorContext", void 0), MN(this, "_handleTrackEnded", () => {
            this.onTrackEnded();
          }), this._enabledMutex = new fj("".concat(t3)), e3.addEventListener("ended", this._handleTrackEnded);
        }
        getTrackLabel() {
          return this._originMediaStreamTrack.label;
        }
        close() {
          this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, JD.debug("[".concat(this.getTrackId(), "] close")), gP("debug", this, "close"), this.emit(Zk.NEED_CLOSE), super.close());
        }
        async _updateOriginMediaStreamTrack(e3, t3) {
          e3 !== this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t3 && this._originMediaStreamTrack.stop(), e3.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e3, this._muted && (this._originMediaStreamTrack.enabled = false), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await TK(this, Zk.NEED_REPLACE_TRACK, this), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }));
        }
        _getDefaultPlayerConfig() {
          return {};
        }
        onTrackEnded() {
          JD.debug("[".concat(this.getTrackId(), "] track ended")), pP("debug", ["MediaStreamTrack", this.getTrackId()], "ended"), this.emit(iB.TRACK_ENDED);
        }
        stateCheck(e3, t3) {
          if (JD.debug("check track state, [muted: ".concat(this._muted, ", enabled: ").concat(this._enabled, "] to [").concat(e3, ": ").concat(t3, "]")), gP("debug", this, "stateCheck", { stateName: e3, state: t3, muted: this._muted, enabled: this._enabled }), BL(t3, e3), this._enabled && this._muted && "enabled" === e3 && false === t3)
            throw new QD(xD.TRACK_STATE_UNREACHABLE, "cannot set enabled while the track is muted").print();
          if (!this._enabled && !this._muted && "muted" === e3 && true === t3)
            throw new QD(xD.TRACK_STATE_UNREACHABLE, "cannot set muted while the track is disabled").print();
        }
        getProcessorStats() {
          return this.processorContext.gatherStats();
        }
        getProcessorUsage() {
          return this.processorContext.gatherUsage();
        }
      }
      let _j;
      function Cj(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      (0, gU.exports)("Float32", function(e3) {
        return function(t3, i3, r3) {
          return e3(this, t3, i3, r3);
        };
      }), function(e3) {
        e3.IOS_15_INTERRUPTION_START = "ios15-interruption-start", e3.IOS_15_INTERRUPTION_END = "ios15-interruption-end", e3.IOS_INTERRUPTION_START = "ios-interruption-start", e3.IOS_INTERRUPTION_END = "ios-interruption-end", e3.STATE_CHANGE = "state-change";
      }(_j || (_j = {}));
      const Sj = window.AudioContext || window.webkitAudioContext;
      let vj = null;
      const Tj = new class extends MD {
        constructor() {
          super(...arguments), MN(this, "prevState", void 0), MN(this, "curState", void 0), MN(this, "currentTime", void 0), MN(this, "currentTimeStuckAt", void 0), MN(this, "interruptDetectorTrack", void 0), MN(this, "onLocalAudioTrackMute", () => {
            JD.info("ios15-interruption-start"), AP("info", ["WebAudio"], "ios15-interruption-start"), this.emit(_j.IOS_15_INTERRUPTION_START);
          }), MN(this, "onLocalAudioTrackUnmute", async () => {
            JD.info("ios15-interruption-end"), AP("info", ["WebAudio"], "ios15-interruption-end"), "running" !== this.curState || this.duringInterruption ? JD.info("ios15-interruption-end-canceled") : (vj && await vj.suspend(), this.emit(_j.IOS_15_INTERRUPTION_END));
          });
        }
        get duringInterruption() {
          return "running" === this.prevState && "interrupted" === this.curState;
        }
        bindInterruptDetectorTrack(e3) {
          JD.debug("webaudio bindInterruptDetectorTrack ".concat(e3.getTrackId())), gP("debug", ["WebAudio"], "bindInterruptDetectorTrack", e3.getTrackId()), this.interruptDetectorTrack || (this.interruptDetectorTrack = e3, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);
        }
        unbindInterruptDetectorTrack(e3) {
          JD.debug("webaudio unbindInterruptDetectorTrack ".concat(e3.getTrackId())), gP("debug", ["WebAudio"], "unbindInterruptDetectorTrack", e3.getTrackId()), this.interruptDetectorTrack && this.interruptDetectorTrack === e3 && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);
        }
      }();
      function Rj() {
        if (!Sj)
          return JD.error("your browser is not support web audio"), void hP("error", ["WebAudio"], "your browser is not support web audio");
        JD.info("create audio context"), EP("info", ["WebAudio"], "WebAudioContext");
        const e3 = function(e4) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var i3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? Cj(Object(i3), true).forEach(function(t4) {
              MN(e4, t4, i3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i3)) : Cj(Object(i3)).forEach(function(t4) {
              Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(i3, t4));
            });
          }
          return e4;
        }({}, LP("WEBAUDIO_INIT_OPTIONS"));
        JD.debug("audio context init option:", JSON.stringify(e3)), vj = new Sj(e3), Tj.curState = vj.state, vj.onstatechange = () => {
          Tj.prevState = Tj.curState, Tj.curState = vj ? vj.state : void 0, (EN() || vN()) && "running" === Tj.prevState && "interrupted" === Tj.curState && (JD.info("ios-interruption-start"), AP("info", ["AudioState"], "ios-interruption-start"), Tj.emit(_j.IOS_INTERRUPTION_START)), (EN() || vN()) && "interrupted" === Tj.prevState && "running" === Tj.curState && (JD.info("ios-interruption-end"), AP("info", ["AudioState"], "ios-interruption-end"), Tj.emit(_j.IOS_INTERRUPTION_END)), Tj.prevState !== Tj.curState && (JD.debug("AudioContext State Change", "".concat(Tj.prevState, "=>").concat(Tj.curState)), pP("debug", ["AudioContext", void 0], "statechange", "".concat(Tj.prevState, "=>").concat(Tj.curState)), Tj.emit(_j.STATE_CHANGE));
        }, setInterval(() => {
          var e4;
          const t3 = null === (e4 = vj) || void 0 === e4 ? void 0 : e4.currentTime;
          if (Tj.currentTime !== t3)
            Tj.currentTimeStuckAt && (JD.debug("AudioContext current time resume at ".concat(t3)), Tj.currentTimeStuckAt = void 0), Tj.currentTime = t3;
          else {
            if (t3 !== Tj.currentTimeStuckAt) {
              pj.reportApiInvoke(null, { name: "WEB_AUDIO_CURRENT_TIME_STUCK", options: { currentTime: t3 }, tag: nk.TRACER }).onSuccess(), JD.warning("AudioContext current time stuck at ".concat(t3));
            }
            Tj.currentTimeStuckAt = t3;
          }
        }, 5e3), async function(e4) {
          const t3 = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"];
          let i3, r3 = false, n3 = false, o3 = false;
          function s3(t4) {
            "running" === e4.state ? a3(false) : EN() || vN() ? "suspended" === e4.state && (a3(true), t4 && e4.resume().then(d3, d3)) : "closed" !== e4.state && (a3(true), t4 && e4.resume().then(d3, d3));
          }
          function a3(e5) {
            if (r3 !== e5) {
              r3 = e5;
              for (let i4 = 0, r4 = t3; i4 < r4.length; i4 += 1) {
                const t4 = r4[i4];
                e5 ? window.addEventListener(t4, u3, { capture: true, passive: true }) : window.removeEventListener(t4, u3, { capture: true, passive: true });
              }
            }
          }
          function c3() {
            s3(true);
          }
          function d3() {
            s3(false);
          }
          function u3() {
            s3(true);
          }
          function h3(e5) {
            if (!o3)
              if (i3.paused)
                if (e5) {
                  A3(false), o3 = true;
                  let e6 = void 0;
                  try {
                    e6 = i3.play(), e6 ? e6.then(l3, l3) : (i3.addEventListener("playing", l3), i3.addEventListener("abort", l3), i3.addEventListener("error", l3));
                  } catch (e7) {
                    l3();
                  }
                } else
                  A3(true);
              else
                A3(false);
          }
          function A3(e5) {
            if (n3 !== e5) {
              n3 = e5;
              for (let i4 = 0, r4 = t3; i4 < r4.length; i4++) {
                const t4 = r4[i4];
                e5 ? window.addEventListener(t4, p3, { capture: true, passive: true }) : window.removeEventListener(t4, p3, { capture: true, passive: true });
              }
            }
          }
          function l3() {
            i3.removeEventListener("playing", l3), i3.removeEventListener("abort", l3), i3.removeEventListener("error", l3), o3 = false, h3(false);
          }
          function p3() {
            h3(true);
          }
          if (EN()) {
            const t4 = e4.createMediaStreamDestination(), r4 = document.createElement("div");
            r4.innerHTML = "<audio x-webkit-airplay='deny'></audio>", i3 = r4.children.item(0), i3.controls = false, i3.disableRemotePlayback = true, i3.preload = "auto", i3.srcObject = t4.stream, h3(true);
          }
          Tj.on(_j.STATE_CHANGE, c3), s3(false);
        }(vj);
      }
      function yj() {
        if (!vj) {
          if (Rj(), !vj)
            throw new QD(xD.NOT_SUPPORTED, "can not create audio context");
          return vj;
        }
        return vj;
      }
      function wj(e3) {
        if (function() {
          if (null !== bj)
            return bj;
          const e4 = yj(), t4 = e4.createBufferSource(), i4 = e4.createGain(), r3 = e4.createGain();
          t4.connect(i4), t4.connect(r3), t4.disconnect(i4);
          let n3 = false;
          try {
            t4.disconnect(i4);
          } catch (e5) {
            n3 = true;
          }
          return t4.disconnect(), bj = n3, n3;
        }())
          return;
        gP("debug", ["WebAudio"], "polyfillAudioNode");
        const t3 = e3.connect, i3 = e3.disconnect;
        e3.connect = (i4, r3, n3) => (e3._inputNodes || (e3._inputNodes = []), e3._inputNodes.includes(i4) || (i4 instanceof AudioNode ? (e3._inputNodes.push(i4), t3.call(e3, i4, r3, n3)) : t3.call(e3, i4, r3)), e3), e3.disconnect = (r3, n3, o3) => {
          i3.call(e3), r3 ? wK(e3._inputNodes, r3) : e3._inputNodes = [];
          for (const i4 of e3._inputNodes)
            t3.call(e3, i4);
        };
      }
      let bj = null;
      function Nj(e3, t3) {
        const i3 = 1 / t3, r3 = yj();
        let n3 = r3.createGain();
        n3.gain.value = 0, n3.connect(r3.destination);
        let o3 = false;
        const s3 = () => {
          if (o3)
            return void (n3 = null);
          const t4 = r3.createOscillator();
          t4.onended = s3, t4.connect(n3), t4.start(0), t4.stop(r3.currentTime + i3), e3(r3.currentTime);
        };
        return s3(), () => {
          o3 = true;
        };
      }
      const Oj = JD.prefix("[inject-node]");
      class Dj {
        constructor() {
          MN(this, "nodeLists", []), MN(this, "prevNode", void 0), MN(this, "nextNode", void 0);
        }
        get firstNode() {
          return this.nodeLists[0];
        }
        get lastNode() {
          return this.nodeLists[this.nodeLists.length - 1];
        }
        get isActive() {
          return !!this.nodeLists.length;
        }
        get isConnected() {
          return !(!this.prevNode || !this.nextNode);
        }
        connect(e3, t3) {
          Oj.debug("connect audio node, current list:" + this.nodeLists.length), this.nodeLists.length ? (this.prevNode && this.prevNode.disconnect(), e3.connect(this.firstNode), this.nextNode && this.lastNode && this.lastNode.disconnect(), this.lastNode.connect(t3), this.nodeLists.forEach((e4, t4) => {
            const i3 = this.nodeLists[t4 + 1];
            i3 && e4.connect(i3);
          })) : e3.connect(t3), this.nextNode = t3, this.prevNode = e3;
        }
        disconnect() {
          var e3;
          Oj.debug("disconnect audio node, current list:" + this.nodeLists.length), this.nodeLists.forEach((e4) => {
            e4.disconnect();
          }), null === (e3 = this.prevNode) || void 0 === e3 || e3.disconnect(), this.prevNode = void 0, this.nextNode = void 0;
        }
        addNode(e3) {
          Oj.debug("add node in inject node, current list:", this.nodeLists.length), this.prevNode && this.nextNode ? (this.firstNode || (Oj.debug("new node is the first node"), this.prevNode.disconnect(), this.prevNode.connect(e3), e3.connect(this.nextNode)), this.nextNode && this.lastNode && (this.lastNode.disconnect(this.nextNode), this.lastNode.connect(e3), e3.connect(this.nextNode)), this.nodeLists.push(e3)) : Oj.debug("add node is called before inject node connected");
        }
        removeNode(e3) {
          Oj.debug("remove node in inject node, current list:", this.nodeLists.length);
          const t3 = this.nodeLists.indexOf(e3);
          if (-1 === t3)
            return void Oj.debug("$[inject-node] cannot find the node to be removed");
          const i3 = this.nodeLists[t3 + 1], r3 = this.nodeLists[t3 - 1];
          0 === t3 && this.prevNode && this.nextNode && (this.prevNode.disconnect(e3), i3 ? this.prevNode.connect(i3) : this.prevNode.connect(this.nextNode)), t3 === this.nodeLists.length - 1 && this.nextNode && r3 && (r3.disconnect(e3), r3.connect(this.nextNode)), 0 !== t3 && t3 !== this.nodeLists.length - 1 && (r3.disconnect(e3), r3.connect(i3)), Oj.debug("remove node in inject node success, current list:", this.nodeLists.length);
        }
      }
      class Pj {
        constructor() {
          MN(this, "context", void 0), MN(this, "analyserNode", void 0), MN(this, "sourceNode", void 0), this.context = yj(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4;
        }
        updateSource(e3) {
          if (e3 !== this.sourceNode) {
            if (this.sourceNode)
              try {
                this.sourceNode.disconnect(this.analyserNode);
              } catch (e4) {
              }
            this.sourceNode = e3, null == e3 || e3.connect(this.analyserNode);
          }
        }
        getVolumeLevel() {
          if (!this.sourceNode)
            return 0;
          if (!this.context || EN() || vN() || "running" !== this.context.state && this.context.resume(), !this.analyserNode)
            return 0;
          const e3 = new Float32Array(this.analyserNode.fftSize);
          if (this.analyserNode.getFloatTimeDomainData)
            this.analyserNode.getFloatTimeDomainData(e3);
          else {
            const t4 = new Uint8Array(this.analyserNode.fftSize);
            this.analyserNode.getByteTimeDomainData(t4);
            for (let i3 = 0; i3 < e3.length; ++i3)
              e3[i3] = t4[i3] / 128 - 1;
          }
          const t3 = cc(e3).call(e3, (e4, t4) => e4 + t4 * t4, 0) / e3.length;
          return Math.max(10 * Math.log10(t3) + 100, 0) / 100;
        }
        getAnalyserNode() {
          return this.analyserNode;
        }
        rebuildAnalyser() {
          try {
            var e3, t3;
            null === (e3 = this.sourceNode) || void 0 === e3 || e3.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4, null === (t3 = this.sourceNode) || void 0 === t3 || t3.connect(this.analyserNode);
          } catch (e4) {
            JD.warning("rebuild analyser node failed.");
          }
        }
        destroy() {
          this.updateSource(void 0);
        }
      }
      class Lj extends MD {
        get processSourceNode() {
          return this.sourceNode;
        }
        set processedNode(e3) {
          var t3;
          if (!this.isDestroyed && this._processedNode !== e3) {
            try {
              var i3;
              null === (i3 = this.sourceNode) || void 0 === i3 || i3.disconnect(this.outputNode);
            } catch (e4) {
            }
            null === (t3 = this._processedNode) || void 0 === t3 || t3.disconnect(), this._processedNode = e3, this.connect();
          }
        }
        get processedNode() {
          return this._processedNode;
        }
        constructor() {
          super(), MN(this, "outputNode", void 0), MN(this, "outputTrack", void 0), MN(this, "isPlayed", false), MN(this, "sourceNode", void 0), MN(this, "context", void 0), MN(this, "audioBufferNode", void 0), MN(this, "destNode", void 0), MN(this, "injectNode", void 0), MN(this, "audioOutputLevel", 0), MN(this, "volumeLevelAnalyser", void 0), MN(this, "_processedNode", void 0), MN(this, "playNode", void 0), MN(this, "isDestroyed", false), MN(this, "onNoAudioInput", void 0), MN(this, "isNoAudioInput", false), MN(this, "_noAudioInputCount", 0), this.context = yj(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), wj(this.outputNode), this.injectNode = new Dj(), this.volumeLevelAnalyser = new Pj();
        }
        startGetAudioBuffer(e3) {
          this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e3), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = (e4) => {
            this.emit(Sk.ON_AUDIO_BUFFER, function(e5) {
              for (let t3 = 0; t3 < e5.outputBuffer.numberOfChannels; t3 += 1) {
                const i3 = e5.outputBuffer.getChannelData(t3);
                for (let e6 = 0; e6 < i3.length; e6 += 1)
                  i3[e6] = 0;
              }
              return e5.inputBuffer;
            }(e4));
          });
        }
        stopGetAudioBuffer() {
          this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);
        }
        createOutputTrack() {
          if (!wB().webAudioMediaStreamDest)
            throw new QD(xD.NOT_SUPPORTED, "your browser is not support audio processor");
          return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;
        }
        play(e3) {
          "running" !== this.context.state && NK(() => {
            Tj.emit("autoplay-failed");
          }), this.isPlayed = true, this.playNode = e3 || this.context.destination, this.outputNode.connect(this.playNode);
        }
        stop() {
          if (this.isPlayed)
            try {
              this.outputNode.disconnect(this.playNode);
            } catch (e3) {
            }
          this.isPlayed = false;
        }
        getAccurateVolumeLevel() {
          return this.volumeLevelAnalyser.getVolumeLevel();
        }
        async checkHasAudioInput() {
          let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
          if (e3 > 5)
            return this.isNoAudioInput = true, this.onNoAudioInput && this.onNoAudioInput(), false;
          EN() || vN() ? "suspended" === this.context.state && this.context.resume() : "running" !== this.context.state && this.context.resume();
          const t3 = this.volumeLevelAnalyser.getAnalyserNode();
          let i3;
          t3.getFloatTimeDomainData ? (i3 = new Float32Array(t3.fftSize), t3.getFloatTimeDomainData(i3)) : (i3 = new Uint8Array(t3.fftSize), t3.getByteTimeDomainData(i3));
          let r3 = false;
          for (let e4 = 0; e4 < i3.length; e4++)
            0 !== i3[e4] && (r3 = true);
          return r3 ? (this.isNoAudioInput = false, true) : (await EK(200), await this.checkHasAudioInput(e3 ? e3 + 1 : 1) && r3);
        }
        getAudioVolume() {
          return this.outputNode.gain.value;
        }
        setVolume(e3) {
          this.outputNode.gain.setValueAtTime(e3, this.context.currentTime);
        }
        destroy() {
          this.disconnect(), this.stop(), this.isDestroyed = true, this.onNoAudioInput = void 0;
        }
        injectAudioNode(e3) {
          this.injectNode.addNode(e3);
        }
        removeAudioNode(e3) {
          this.injectNode.removeNode(e3);
        }
        disconnect() {
          var e3, t3;
          null === (e3 = this.processedNode) || void 0 === e3 || e3.disconnect(), null === (t3 = this.sourceNode) || void 0 === t3 || t3.disconnect(), this.outputNode && this.outputNode.disconnect();
        }
        connect() {
          var e3;
          this.processedNode ? null === (e3 = this.processedNode) || void 0 === e3 || e3.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode);
          this.volumeLevelAnalyser.updateSource(this.outputNode);
        }
      }
      class kj extends Lj {
        get isFreeze() {
          return false;
        }
        constructor(e3, t3, i3) {
          var r3;
          if (super(), MN(this, "sourceNode", void 0), MN(this, "track", void 0), MN(this, "clonedTrack", void 0), MN(this, "audioElement", void 0), MN(this, "isCurrentTrackCloned", false), MN(this, "isRemoteTrack", false), MN(this, "originVolumeLevelAnalyser", void 0), MN(this, "rebuildWebAudio", async () => {
            if (JD.debug("ready to rebuild web audio, state:", this.context.state), this.isNoAudioInput && await this.checkHasAudioInput(), !this.isNoAudioInput || this.isDestroyed)
              return document.body.removeEventListener("click", this.rebuildWebAudio, true), void JD.debug("rebuild web audio success, current volume status", this.getAccurateVolumeLevel());
            this.context.resume().then(() => JD.info("resume success")), JD.debug("rebuild web audio because of ios 12 bugs"), this.disconnect();
            const e4 = this.track;
            this.track = this.track.clone(), this.isCurrentTrackCloned ? e4.stop() : this.isCurrentTrackCloned = true;
            const t4 = new MediaStream([this.track]);
            this.sourceNode = this.context.createMediaStreamSource(t4), wj(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();
            const i4 = this.outputNode.gain.value;
            this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(i4, this.context.currentTime), wj(this.outputNode), this.emit(Sk.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t4, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();
          }), "audio" !== e3.kind)
            throw new QD(xD.UNEXPECTED_ERROR);
          this.track = e3;
          const n3 = new MediaStream([this.track]);
          if (this.isRemoteTrack = !!t3, this.sourceNode = this.context.createMediaStreamSource(n3), wj(this.sourceNode), i3) {
            const e4 = i3.clone();
            e4.enabled = true, this.clonedTrack = e4, JD.debug("create an unmuted track ".concat(e4.id, " from the original track ").concat(i3.id, " to get the volume"));
            const t4 = this.context.createMediaStreamSource(new MediaStream([e4]));
            wj(t4), this.originVolumeLevelAnalyser = new Pj(), this.originVolumeLevelAnalyser.updateSource(t4);
          }
          this.connect(), this.audioElement = document.createElement("audio"), this.audioElement.srcObject = n3;
          const o3 = oN();
          t3 && o3.os === eN.IOS && Number(null === (r3 = o3.osVersion) || void 0 === r3 ? void 0 : r3.split(".")[0]) < 15 && (Tj.on(_j.STATE_CHANGE, () => {
            "suspended" === this.context.state ? document.body.addEventListener("click", this.rebuildWebAudio, true) : "running" === this.context.state && this.rebuildWebAudio();
          }), this.checkHasAudioInput().then((e4) => {
            e4 || document.body.addEventListener("click", this.rebuildWebAudio, true);
          }));
        }
        updateTrack(e3) {
          this.sourceNode.disconnect(), this.track = e3, this.isCurrentTrackCloned = false;
          const t3 = new MediaStream([e3]);
          this.sourceNode = this.context.createMediaStreamSource(t3), wj(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(Sk.UPDATE_SOURCE), this.audioElement.srcObject = t3;
        }
        destroy() {
          var e3;
          this.audioElement.srcObject = null, this.audioElement.remove(), Tj.off("state-change", this.rebuildWebAudio), null === (e3 = this.originVolumeLevelAnalyser) || void 0 === e3 || e3.destroy(), this.clonedTrack = void 0, super.destroy();
        }
        createMediaStreamSourceNode(e3) {
          return this.context.createMediaStreamSource(new MediaStream([e3]));
        }
        updateOriginTrack(e3) {
          const t3 = e3.clone();
          t3.enabled = true, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t3), JD.debug("create an unmuted track ".concat(t3.id, " from the original track ").concat(e3.id, " to get the volume"));
          const i3 = this.context.createMediaStreamSource(new MediaStream([t3]));
          wj(i3), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(i3);
        }
        getOriginVolumeLevel() {
          return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel();
        }
      }
      async function Bj(e3, t3) {
        const i3 = (e4, t4) => e4 ? "number" != typeof e4 ? e4.max || e4.exact || e4.ideal || e4.min || t4 : e4 : t4, r3 = { audio: false, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: e3, maxHeight: i3(t3.height, 1080), maxWidth: i3(t3.width, 1920) } } };
        return t3.frameRate && "number" != typeof t3.frameRate ? (r3.video.mandatory.maxFrameRate = t3.frameRate.max, r3.video.mandatory.minFrameRate = t3.frameRate.min) : "number" == typeof t3.frameRate && (r3.video.mandatory.maxFrameRate = t3.frameRate), await navigator.mediaDevices.getUserMedia(r3);
      }
      async function Mj(e3) {
        const t3 = await Uj(e3.mediaSource), i3 = await function(e4) {
          return new l_((t4, i4) => {
            const r3 = document.createElement("div");
            r3.innerText = "share screen", r3.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
            const n3 = document.createElement("div");
            n3.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
            const o3 = document.createElement("div");
            o3.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", o3.setAttribute("style", "height: 12%;");
            const s3 = document.createElement("div");
            s3.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
            const a3 = document.createElement("div");
            a3.setAttribute("style", "text-align: right; padding: 16px 0;");
            const c3 = document.createElement("button");
            c3.innerHTML = "cancel", c3.setAttribute("style", "width: 85px;"), c3.onclick = () => {
              document.body.removeChild(d3);
              const e5 = new Error("NotAllowedError");
              e5.name = "NotAllowedError", i4(e5);
            }, a3.appendChild(c3), n3.appendChild(o3), n3.appendChild(s3), n3.appendChild(a3);
            const d3 = document.createElement("div");
            d3.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), d3.appendChild(r3), d3.appendChild(n3), document.body.appendChild(d3), e4.map((e5) => {
              if (e5.id) {
                const i5 = document.createElement("div");
                i5.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");
                let r4 = e5.thumbnail;
                const { width: n4 } = r4.getSize();
                n4 > 1920 && (r4 = r4.resize({ width: 1920 })), i5.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + r4.toDataURL() + ' /></div><span style="	height: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + (e5.name.replace(/[\u00A0-\u9999<>\&]/g, function(e6) {
                  return "&#" + e6.charCodeAt(0) + ";";
                }) + "</span>"), i5.onclick = () => {
                  document.body.removeChild(d3), t4(e5.id);
                }, s3.appendChild(i5);
              }
            });
          });
        }(t3);
        return await Bj(i3, e3);
      }
      async function Uj(e3) {
        let t3 = ["window", "screen"];
        "application" !== e3 && "window" !== e3 || (t3 = ["window"]), "screen" === e3 && (t3 = ["screen"]);
        const i3 = Qj();
        if (!i3)
          throw new QD(xD.ELECTRON_IS_NULL);
        let r3 = null;
        try {
          var n3;
          r3 = (null === (n3 = i3.desktopCapturer) || void 0 === n3 ? void 0 : n3.getSources({ types: t3 })) || i3.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES", { types: t3 });
        } catch (e4) {
          r3 = null;
        }
        r3 && r3.then || (r3 = new l_((e4, r4) => {
          i3.desktopCapturer.getSources({ types: t3 }, (t4, i4) => {
            t4 ? r4(t4) : e4(i4);
          });
        }));
        try {
          return await r3;
        } catch (e4) {
          throw new QD(xD.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e4.toString());
        }
      }
      let xj = null;
      function Qj() {
        if (xj)
          return xj;
        try {
          return xj = window.require("electron"), xj;
        } catch (e3) {
          return null;
        }
      }
      const Fj = new fj("safari");
      let Vj = false, jj = false;
      async function Gj(e3, t3) {
        let i3 = 0, r3 = null;
        for (; i3 < 2; )
          try {
            r3 = await Kj(e3, t3, i3 > 0);
            break;
          } catch (r4) {
            if (r4 instanceof QD)
              throw JD.error("[".concat(t3, "] ").concat(r4.toString())), gP("error", [], "getLocalStream", { config: e3, id: t3 }, r4.toString()), r4;
            const n3 = Hj(r4.name || r4.code || r4, r4.message);
            if (n3.code === xD.MEDIA_OPTION_INVALID) {
              JD.debug("[".concat(t3, "] detect media option invalid, retry")), hP("debug", [], "[".concat(t3, "] detect media option invalid, retry")), i3 += 1, await EK(500);
              continue;
            }
            throw JD.error("[".concat(t3, "] ").concat(n3.toString())), gP("error", [], "getLocalStream", { config: e3, id: t3 }, n3.toString()), n3;
          }
        if (!r3)
          throw new QD(xD.UNEXPECTED_ERROR, "can not find stream after getUserMedia");
        return r3;
      }
      async function Kj(e3, t3, i3) {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
          throw new QD(xD.NOT_SUPPORTED, "can not find getUserMedia");
        i3 && (e3.video && (delete e3.video.width, delete e3.video.height), e3.screen && (delete e3.screen.width, delete e3.screen.height));
        const r3 = wB(), n3 = new MediaStream();
        if (e3.audioSource && n3.addTrack(e3.audioSource), e3.videoSource && n3.addTrack(e3.videoSource), !e3.audio && !e3.video && !e3.screen)
          return JD.debug("Using Video Source/ Audio Source"), hP("debug", [], "Using Video Source/ Audio Source"), n3;
        if (e3.screen)
          if (Qj())
            if (e3.screen.sourceId) {
              Wj(n3, await Bj(e3.screen.sourceId, e3.screen));
            } else {
              Wj(n3, await Mj(e3.screen));
            }
          else if (lN() && e3.screen.extensionId && e3.screen.mandatory) {
            if (!r3.getStreamFromExtension)
              throw new QD(xD.NOT_SUPPORTED, "This browser does not support screen sharing");
            JD.debug("[".concat(t3, '] Screen access on chrome stable, looking for extension"')), hP("debug", [], "[".concat(t3, '] Screen access on chrome stable, looking for extension"'));
            const i4 = await (o3 = e3.screen.extensionId, s3 = t3, new l_((e4, t4) => {
              try {
                chrome.runtime.sendMessage(o3, { getStream: true }, (i5) => {
                  if (!i5 || !i5.streamId)
                    return JD.error("[".concat(s3, "] No response from Chrome Plugin. Plugin not installed properly"), i5), gP("error", [], "getSourceIdFromExtension", { extensionId: o3, streamId: s3 }, "No response from Chrome Plugin. Plugin not installed properly, ".concat(i5)), void t4(new QD(xD.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly"));
                  e4(i5.streamId);
                });
              } catch (e5) {
                JD.error("[".concat(s3, "] AgoraRTC screensharing plugin is not accessible(").concat(o3, ")"), e5.toString()), gP("error", [], "getSourceIdFromExtension", { extensionId: o3, streamId: s3 }, "AgoraRTC screensharing plugin is not accessible(".concat(o3, "), ").concat(e5.toString())), t4(new QD(xD.CHROME_PLUGIN_NOT_INSTALL));
              }
            }));
            e3.screen.mandatory.chromeMediaSourceId = i4;
            Wj(n3, await navigator.mediaDevices.getUserMedia({ video: { mandatory: e3.screen.mandatory } }));
          } else if (r3.getDisplayMedia) {
            e3.screen.mediaSource && sB(e3.screen.mediaSource);
            const i4 = { width: e3.screen.width, height: e3.screen.height, frameRate: e3.screen.frameRate, displaySurface: "screen" === e3.screen.mediaSource ? "monitor" : e3.screen.mediaSource };
            JD.debug("[".concat(t3, "] getDisplayMedia:"), JSON.stringify({ video: i4, audio: !!e3.screenAudio })), EP("debug", ["mediaDevices", t3], "getDisplayMedia", { video: i4, audio: !!e3.screenAudio, trackId: t3 });
            Wj(n3, await navigator.mediaDevices.getDisplayMedia({ video: i4, audio: !!e3.screenAudio }));
          } else {
            if (!gN())
              throw JD.error("[".concat(t3, "] This browser does not support screenSharing")), new QD(xD.NOT_SUPPORTED, "This browser does not support screen sharing");
            {
              e3.screen.mediaSource && sB(e3.screen.mediaSource);
              const i4 = { video: { mediaSource: e3.screen.mediaSource, width: e3.screen.width, height: e3.screen.height, frameRate: e3.screen.frameRate } };
              JD.debug("[".concat(t3, "] getUserMedia: ").concat(JSON.stringify(i4))), EP("debug", ["mediaDevices", t3], "getUserMedia", i4);
              Wj(n3, await navigator.mediaDevices.getUserMedia(i4));
            }
          }
        var o3, s3;
        if (!e3.video && !e3.audio)
          return n3;
        let a3 = { video: e3.video, audio: e3.audio }, c3 = LP("MEDIA_DEVICE_CONSTRAINTS");
        if (c3)
          try {
            "string" == typeof c3 && (c3 = JSON.parse(c3)), a3 = function e4(t4, i4) {
              if (!xK(t4) || !xK(i4))
                return i4;
              if (Array.isArray(t4) && !Array.isArray(i4) || !Array.isArray(t4) && Array.isArray(i4))
                return i4;
              if (Array.isArray(i4) && Array.isArray(t4)) {
                const r4 = [...t4];
                for (let n4 = 0; n4 < i4.length; n4++)
                  r4[n4] = e4(t4[n4], i4[n4]);
                return r4;
              }
              {
                const r4 = pK({}, t4);
                for (const n4 in i4)
                  Object.prototype.hasOwnProperty.call(i4, n4) && (Object.prototype.hasOwnProperty.call(t4, n4) ? r4[n4] = e4(t4[n4], i4[n4]) : r4[n4] = i4[n4]);
                return r4;
              }
            }(a3, c3), hP("debug", ["mediaDevices", t3], "merge configConstraints ".concat(JSON.stringify(c3)));
          } catch (e4) {
          }
        JD.debug("[".concat(t3, "] GetUserMedia"), JSON.stringify(a3)), EP("debug", ["mediaDevices", t3], "getUserMedia", a3), oN();
        let d3, u3 = null;
        (pN() || EN() || uN()) && (u3 = await Fj.lock());
        try {
          d3 = await navigator.mediaDevices.getUserMedia(a3);
        } catch (e4) {
          throw u3 && u3(), e4;
        }
        return a3.audio && (Vj = true), a3.video && (jj = true), Wj(n3, d3), u3 && u3(), n3;
      }
      function Hj(e3, t3) {
        switch (e3) {
          case "Starting video failed":
          case "OverconstrainedError":
          case "TrackStartError":
            return new QD(xD.MEDIA_OPTION_INVALID, "".concat(e3, ": ").concat(t3));
          case "NotFoundError":
          case "DevicesNotFoundError":
            return new QD(xD.DEVICE_NOT_FOUND, "".concat(e3, ": ").concat(t3));
          case "NotSupportedError":
            return new QD(xD.NOT_SUPPORTED, "".concat(e3, ": ").concat(t3));
          case "NotReadableError":
            return new QD(xD.NOT_READABLE, "".concat(e3, ": ").concat(t3));
          case "InvalidStateError":
          case "NotAllowedError":
          case "PERMISSION_DENIED":
          case "PermissionDeniedError":
            return new QD(xD.PERMISSION_DENIED, "".concat(e3, ": ").concat(t3));
          case "ConstraintNotSatisfiedError":
            return new QD(xD.CONSTRAINT_NOT_SATISFIED, "".concat(e3, ": ").concat(t3));
          default:
            return JD.error("getUserMedia unexpected error", e3), gP("error", [], "handleGetUserMediaError", void 0, e3), new QD(xD.UNEXPECTED_ERROR, "".concat(e3, ": ").concat(t3));
        }
      }
      function Wj(e3, t3) {
        const i3 = e3.getVideoTracks()[0], r3 = e3.getAudioTracks()[0], n3 = t3.getVideoTracks()[0], o3 = t3.getAudioTracks()[0];
        o3 && (r3 && e3.removeTrack(r3), e3.addTrack(o3)), n3 && (i3 && e3.removeTrack(i3), e3.addTrack(n3));
      }
      const Yj = new class extends MD {
        get state() {
          return this._state;
        }
        set state(e3) {
          e3 !== this._state && (this.emit(sk.STATE_CHANGE, e3), this._state = e3);
        }
        constructor() {
          super(), MN(this, "_state", ok.IDLE), MN(this, "isAccessMicrophonePermission", false), MN(this, "isAccessCameraPermission", false), MN(this, "lastAccessMicrophonePermission", false), MN(this, "lastAccessCameraPermission", false), MN(this, "checkdeviceMatched", false), MN(this, "deviceInfoMap", /* @__PURE__ */ new Map()), this.init().then(() => {
            navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", this.updateDevicesInfo.bind(this)), window.setInterval(() => {
              (LP("ENUMERATE_DEVICES_INTERVAL") || wN() && yN()) && this.updateDevicesInfo();
            }, LP("ENUMERATE_DEVICES_INTERVAL_TIME"));
          }).catch((e3) => JD.error(e3.toString()));
        }
        async enumerateDevices(e3, t3) {
          let i3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
            return new QD(xD.NOT_SUPPORTED, "enumerateDevices() not supported.").throw();
          }
          const r3 = await navigator.mediaDevices.enumerateDevices(), n3 = this.checkMediaDeviceInfoIsOk(r3);
          let o3 = !this.isAccessMicrophonePermission && e3, s3 = !this.isAccessCameraPermission && t3;
          n3.audio && (o3 = false), n3.video && (s3 = false);
          let a3 = null, c3 = null, d3 = null;
          if (!i3 && (o3 || s3)) {
            if (Fj.isLocked) {
              JD.debug("[device manager] wait GUM lock");
              (await Fj.lock())(), JD.debug("[device manager] GUM unlock");
            }
            if (Vj && (o3 = false, this.isAccessMicrophonePermission = true), jj && (s3 = false, this.isAccessCameraPermission = true), JD.debug("[device manager] check media device permissions", e3, t3, o3, s3), o3 && s3) {
              try {
                d3 = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
              } catch (e4) {
                const t4 = Hj(e4.name || e4.code || e4, e4.message);
                if (t4.code === xD.PERMISSION_DENIED)
                  throw t4;
                JD.warning("getUserMedia failed in getDevices", t4);
              }
              this.isAccessCameraPermission = true, this.isAccessMicrophonePermission = true;
            } else if (o3) {
              try {
                a3 = await navigator.mediaDevices.getUserMedia({ audio: e3 });
              } catch (e4) {
                const t4 = Hj(e4.name || e4.code || e4, e4.message);
                if (t4.code === xD.PERMISSION_DENIED)
                  throw t4;
                JD.warning("getUserMedia failed in getDevices", t4);
              }
              this.isAccessMicrophonePermission = true;
            } else if (s3) {
              try {
                c3 = await navigator.mediaDevices.getUserMedia({ video: t3 });
              } catch (e4) {
                const t4 = Hj(e4.name || e4.code || e4, e4.message);
                if (t4.code === xD.PERMISSION_DENIED)
                  throw t4;
                JD.warning("getUserMedia failed in getDevices", t4);
              }
              this.isAccessCameraPermission = true;
            }
            JD.debug("[device manager] mic permission", e3, "cam permission", t3);
          }
          try {
            const e4 = await navigator.mediaDevices.enumerateDevices();
            return a3 && a3.getTracks().forEach((e5) => e5.stop()), c3 && c3.getTracks().forEach((e5) => e5.stop()), d3 && d3.getTracks().forEach((e5) => e5.stop()), a3 = null, c3 = null, d3 = null, e4;
          } catch (e4) {
            a3 && a3.getTracks().forEach((e5) => e5.stop()), c3 && c3.getTracks().forEach((e5) => e5.stop()), d3 && d3.getTracks().forEach((e5) => e5.stop()), a3 = null, c3 = null, d3 = null;
            return new QD(xD.ENUMERATE_DEVICES_FAILED, e4.toString()).throw();
          }
        }
        async getRecordingDevices() {
          let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(true, false, e3)).filter((e4) => "audioinput" === e4.kind);
        }
        async getCamerasDevices() {
          let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(false, true, e3)).filter((e4) => "videoinput" === e4.kind);
        }
        async getSpeakers() {
          let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(true, false, e3)).filter((e4) => "audiooutput" === e4.kind);
        }
        searchDeviceIdByName(e3) {
          let t3 = null;
          return this.deviceInfoMap.forEach((i3) => {
            i3.device.label === e3 && (t3 = i3.device.deviceId);
          }), t3;
        }
        async getDeviceById(e3) {
          const t3 = (await this.enumerateDevices(true, true, true)).find((t4) => t4.deviceId === e3);
          if (!t3)
            throw new QD(xD.DEVICE_NOT_FOUND, "deviceId: ".concat(e3));
          return t3;
        }
        async init() {
          this.state = ok.INITING;
          try {
            await this.updateDevicesInfo(), this.state = ok.INITEND;
          } catch (e3) {
            if (JD.warning("Device Detection functionality cannot start properly.", e3.toString()), this.state = ok.IDLE, !function() {
              if ("boolean" == typeof isSecureContext)
                return isSecureContext;
              return "https:" === location.protocol || "file:" === location.protocol || "localhost" === location.hostname || "127.0.0.1" === location.hostname || "::1" === location.hostname;
            }()) {
              new QD(xD.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.").throw();
            }
            throw e3;
          }
        }
        async updateDevicesInfo() {
          const e3 = await this.enumerateDevices(true, true, true), t3 = Date.now(), i3 = [];
          if (e3[0] && e3[0].label && false === this.checkdeviceMatched) {
            this.checkdeviceMatched = true;
            const t4 = e3.find((e4) => "audioinput" === e4.kind && "default" === e4.deviceId), i4 = e3.find((e4) => "audiooutput" === e4.kind && "default" === e4.deviceId);
            t4 && i4 ? i4.groupId === t4.groupId ? JD.debug("[device-check] default input ".concat(t4.label, " and output ").concat(i4.label, " is the same group")) : JD.warning("[device-check] default input ".concat(t4.label, " and output ").concat(i4.label, " is not the same group")) : JD.debug("[device-check] default input or output not found");
          }
          const r3 = this.checkMediaDeviceInfoIsOk(e3);
          if (e3.forEach((e4) => {
            if (!e4.deviceId)
              return;
            const r4 = this.deviceInfoMap.get("".concat(e4.kind, "_").concat(e4.deviceId));
            if ("ACTIVE" !== (r4 ? r4.state : "INACTIVE")) {
              const r5 = { initAt: t3, updateAt: t3, device: e4, state: "ACTIVE" };
              this.deviceInfoMap.set("".concat(e4.kind, "_").concat(e4.deviceId), r5), i3.push(r5);
            }
            r4 && (r4.updateAt = t3);
          }), this.deviceInfoMap.forEach((e4, r4) => {
            "ACTIVE" === e4.state && e4.updateAt !== t3 && (e4.state = "INACTIVE", i3.push(e4));
          }), this.state !== ok.INITEND)
            return r3.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), void (r3.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true));
          i3.forEach((e4) => {
            switch (e4.device.kind) {
              case "audioinput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(sk.RECORDING_DEVICE_CHANGED, e4);
                break;
              case "videoinput":
                this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(sk.CAMERA_DEVICE_CHANGED, e4);
                break;
              case "audiooutput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(sk.PLAYOUT_DEVICE_CHANGED, e4);
            }
          }), r3.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), r3.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true);
        }
        checkMediaDeviceInfoIsOk(e3) {
          const t3 = e3.filter((e4) => "audioinput" === e4.kind), i3 = e3.filter((e4) => "videoinput" === e4.kind), r3 = { audio: false, video: false };
          for (const e4 of t3)
            if (e4.label && e4.deviceId) {
              r3.audio = true;
              break;
            }
          for (const e4 of i3)
            if (e4.label && e4.deviceId) {
              r3.video = true;
              break;
            }
          return r3;
        }
      }();
      var Jj;
      let qj = mP("AudioElementPlayCenter")(Jj = class {
        constructor() {
          MN(this, "onAutoplayFailed", void 0), MN(this, "elementMap", /* @__PURE__ */ new Map()), MN(this, "elementStateMap", /* @__PURE__ */ new Map()), MN(this, "elementsNeedToResume", []), MN(this, "sinkIdMap", /* @__PURE__ */ new Map()), MN(this, "autoResumeAfterInterruption", () => {
            Array.from(this.elementMap.entries()).forEach((e3) => {
              let [t3, i3] = e3;
              const r3 = this.elementStateMap.get(t3), n3 = i3.srcObject.getAudioTracks()[0];
              IN() ? n3 && "live" === n3.readyState && "running" === Tj.curState && (JD.debug("auto resume after interruption for iOS 15"), hP("debug", ["AudioElementPlayCenter", t3], "auto resume after interruption for iOS15"), i3.pause(), i3.play()) : r3 && "paused" === r3 && n3 && "live" === n3.readyState && "running" === Tj.curState && (JD.debug("auto resume after interruption for iOS"), hP("debug", ["AudioElementPlayCenter", t3], "auto resume after interruption for iOS"), i3.play());
            });
          }), MN(this, "autoResumeAfterInterruptionOnIOS15", () => {
            Array.from(this.elementMap.entries()).forEach((e3) => {
              let [t3, i3] = e3;
              const r3 = i3.srcObject.getAudioTracks()[0];
              r3 && "live" === r3.readyState && (JD.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"), gP("debug", ["AudioElementPlayCenter", t3], "autoResumeAfterInterruptionOnIOS15"), i3.pause(), i3.play());
            });
          }), this.autoResumeAudioElement(), Tj.on(_j.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), Tj.on(_j.IOS_15_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15), Tj.on(_j.STATE_CHANGE, () => {
            EN() && "suspended" === Tj.prevState && "running" === Tj.curState && this.autoResumeAfterInterruption();
          });
        }
        async setSinkID(e3, t3) {
          const i3 = this.elementMap.get(e3);
          if (this.sinkIdMap.set(e3, t3), i3)
            try {
              await i3.setSinkId(t3);
            } catch (e4) {
              throw new QD(xD.PERMISSION_DENIED, "can not set sink id: " + e4.toString());
            }
        }
        play(e3, t3, i3, r3) {
          if (this.elementMap.has(t3))
            return;
          const n3 = document.createElement("audio");
          n3.autoplay = true, n3.srcObject = new MediaStream([e3]), this.bindAudioElementEvents(t3, n3), this.elementMap.set(t3, n3), this.elementStateMap.set(t3, qL.INIT), this.setVolume(t3, i3);
          const o3 = this.sinkIdMap.get(t3);
          if (o3)
            try {
              n3.setSinkId(o3).catch((e4) => {
                JD.warning("[".concat(t3, "] set sink id failed"), e4.toString()), EP("warning", ["HTMLAudioElement", t3], "setSinkId", e4.toString());
              });
            } catch (e4) {
              JD.warning("[".concat(t3, "] set sink id failed"), e4.toString());
            }
          const s3 = n3.play();
          s3 && s3.then && s3.catch((e4) => {
            r3 && pj.autoplayFailed(r3, "audio", e4.message, t3), JD.warning("audio element play warning", e4.toString()), EP("warning", ["HTMLAudioElement", t3], "play", e4.toString()), this.elementMap.has(t3) && "NotAllowedError" === e4.name && (JD.warning("detected audio element autoplay failed"), gP("warning", ["AudioElementPlayCenter", t3], "play", e4.toString()), this.elementsNeedToResume.push(n3), NK(() => {
              this.onAutoplayFailed && this.onAutoplayFailed(), oj();
            }));
          });
        }
        updateTrack(e3, t3) {
          const i3 = this.elementMap.get(e3);
          i3 && (i3.srcObject = new MediaStream([t3]));
        }
        isPlaying(e3) {
          return this.elementMap.has(e3);
        }
        setVolume(e3, t3) {
          const i3 = this.elementMap.get(e3);
          i3 && (t3 = Math.max(0, Math.min(100, t3)), i3.volume = t3 / 100);
        }
        stop(e3) {
          const t3 = this.elementMap.get(e3);
          if (this.sinkIdMap.delete(e3), !t3)
            return;
          const i3 = this.elementsNeedToResume.indexOf(t3);
          this.elementsNeedToResume.splice(i3, 1), t3.srcObject = null, t3.remove(), this.elementMap.delete(e3), this.elementStateMap.delete(e3);
        }
        bindAudioElementEvents(e3, t3) {
          Xj.forEach((i3) => {
            t3.addEventListener(i3, (t4) => {
              const i4 = this.elementStateMap.get(e3), r3 = "pause" === t4.type ? "paused" : t4.type;
              JD.debug("[".concat(e3, "] audio-element-status change ").concat(i4, " => ").concat(r3)), pP("debug", ["HTMLAudioElement", e3], "statusChange", "".concat(i4, " => ").concat(r3)), this.elementStateMap.set(e3, r3);
            });
          });
        }
        getPlayerState(e3) {
          return this.elementStateMap.get(e3) || "uninit";
        }
        autoResumeAudioElement() {
          const e3 = () => {
            this.elementsNeedToResume.forEach((e4) => {
              e4.play().then((e5) => {
                JD.debug("Auto resume audio element success"), gP("debug", ["AudioElementPlayCenter"], "autoResumeAudioElement");
              }).catch((e5) => {
                JD.warning("Auto resume audio element failed!", e5), gP("warning", ["AudioElementPlayCenter"], "autoResumeAudioElement", e5.toString());
              });
            }), this.elementsNeedToResume = [];
          };
          new l_((e4) => {
            document.body ? e4() : window.addEventListener("load", () => e4());
          }).then(() => {
            bN() ? document.body.addEventListener("click", e3, true) : (document.body.addEventListener("touchstart", e3, true), document.body.addEventListener("mousedown", e3, true));
          });
        }
      }) || Jj;
      const Xj = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended"], zj = new qj();
      function Zj() {
        return function(e3, t3, i3) {
          const r3 = i3.value;
          return "function" == typeof r3 && (i3.value = function() {
            this._isClosed && new QD(xD.INVALID_OPERATION, "[".concat(this.getTrackId(), "] cannot operate a closed track")).print("warning");
            for (var e4 = arguments.length, t4 = new Array(e4), i4 = 0; i4 < e4; i4++)
              t4[i4] = arguments[i4];
            const n3 = r3.apply(this, t4);
            return n3 instanceof l_ ? new l_((e5, t5) => {
              n3.then(e5).catch(t5);
            }) : n3;
          }), i3;
        };
      }
      var $j, eG, tG, iG, rG, nG, oG, sG, aG, cG, dG, uG, hG, AG, lG, pG, gG, EG, fG, mG, IG, _G, CG, SG, vG, TG, RG, yG, wG, bG, NG = ic("Array").values, OG = Vl, DG = es, PG = Cn, LG = NG, kG = Array.prototype, BG = { DOMTokenList: true, NodeList: true }, MG = function(e3) {
        var t3 = e3.values;
        return e3 === kG || PG(kG, e3) && t3 === kG.values || DG(BG, OG(e3)) ? LG : t3;
      };
      function UG(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function xG(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? UG(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : UG(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      class QG extends MD {
        constructor(e3) {
          super(), MN(this, "name", "VideoProcessorDestination"), MN(this, "ID", "0"), MN(this, "_source", void 0), MN(this, "videoContext", void 0), MN(this, "inputTrack", void 0), this.videoContext = e3;
        }
        get kind() {
          return "video";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new QD(xD.NOT_SUPPORTED, "VideoProcessor cannot pipe to any other Processor");
        }
        unpipe() {
          throw new QD(xD.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        updateInput(e3) {
          if (e3.context !== this.videoContext)
            throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).");
          e3.track && e3.track !== this.inputTrack && (this.videoContext.chained = true, this.inputTrack = e3.track, this.emit(mB.ON_TRACK, e3.track));
        }
        reset() {
          this.inputTrack = void 0, this.videoContext.chained = false, this.emit(mB.ON_TRACK, void 0);
        }
      }
      class FG extends MD {
        set chained(e3) {
          this._chained = e3;
        }
        get chained() {
          return this._chained;
        }
        constructor(e3, t3) {
          super(), MN(this, "constraintsMap", /* @__PURE__ */ new Map()), MN(this, "statsRegistry", []), MN(this, "usageRegistry", []), MN(this, "trackId", void 0), MN(this, "direction", void 0), MN(this, "_chained", false), this.trackId = e3, this.direction = t3;
        }
        async getConstraints() {
          return await vK(this, IB.REQUEST_CONSTRAINTS);
        }
        async requestApplyConstraints(e3, t3) {
          var i3;
          return JD.info("processor ".concat(t3.name, " requestApplyConstraints for ").concat(this.trackId)), e3 && this.constraintsMap.set(t3, e3), TK(this, IB.REQUEST_UPDATE_CONSTRAINTS, Array.from(MG(i3 = this.constraintsMap).call(i3)));
        }
        async requestRevertConstraints(e3) {
          var t3;
          if (this.constraintsMap.has(e3))
            return JD.info("processor ".concat(e3.name, " requestRevertConstraints for ").concat(this.trackId)), this.constraintsMap.delete(e3), TK(this, IB.REQUEST_UPDATE_CONSTRAINTS, Array.from(MG(t3 = this.constraintsMap).call(t3)));
        }
        registerStats(e3, t3, i3) {
          this.statsRegistry.find((i4) => i4.processorID === e3.ID && i4.processorName === e3.name && i4.type === t3) || this.statsRegistry.push({ processorName: e3.name, processorID: e3.ID, type: t3, cb: i3 });
        }
        unregisterStats(e3, t3) {
          const i3 = this.statsRegistry.findIndex((i4) => i4.processorID === e3.ID && i4.processorName === e3.name && i4.type === t3);
          -1 !== i3 && this.statsRegistry.splice(i3, 1);
        }
        gatherStats() {
          const e3 = [];
          for (const { processorID: t3, processorName: i3, type: r3, cb: n3 } of this.statsRegistry)
            try {
              const o3 = n3();
              e3.push({ processorID: t3, processorName: i3, type: r3, stats: o3 });
            } catch (e4) {
              JD.error(new QD(xD.UNEXPECTED_ERROR, e4.message));
            }
          return e3;
        }
        registerUsage(e3, t3) {
          this.usageRegistry.find((t4) => t4.processorID === e3.ID && t4.processorName === e3.name) || this.usageRegistry.push({ processorID: e3.ID, processorName: e3.name, cb: t3 });
        }
        unregisterUsage(e3) {
          const t3 = this.usageRegistry.findIndex((t4) => t4.processorID === e3.ID && t4.processorName === e3.name);
          -1 !== t3 && this.usageRegistry.splice(t3, 1);
        }
        async gatherUsage() {
          const e3 = [];
          if (!this.chained)
            return [];
          for (const { cb: t3 } of this.usageRegistry)
            try {
              let i3 = t3();
              i3 instanceof l_ && (i3 = await i3), e3.push(xG(xG({}, i3), {}, { direction: this.direction }));
            } catch (e4) {
              JD.error("gather extension usage error", e4);
            }
          return e3;
        }
        getDirection() {
          return this.direction;
        }
      }
      class VG extends MD {
        constructor(e3) {
          super(), MN(this, "name", "AudioProcessorDestination"), MN(this, "ID", "0"), MN(this, "inputTrack", void 0), MN(this, "inputNode", void 0), MN(this, "audioProcessorContext", void 0), MN(this, "_source", void 0), this.audioProcessorContext = e3;
        }
        get kind() {
          return "audio";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new QD(xD.NOT_SUPPORTED, "AudioProcessorDestination cannot pipe to any other Processor");
        }
        unpipe() {
          throw new QD(xD.NOT_SUPPORTED, "AudioProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        reset() {
          this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = false, this.emit(mB.ON_TRACK, void 0), this.emit(mB.ON_NODE, void 0);
        }
        updateInput(e3) {
          if (e3.context !== this.audioProcessorContext)
            throw new Error("ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).");
          e3.track && this.inputTrack !== e3.track && (this.audioProcessorContext.chained = true, this.inputTrack = e3.track, this.emit(mB.ON_TRACK, this.inputTrack)), e3.node && this.inputNode !== e3.node && (this.audioProcessorContext.chained = true, this.inputNode = e3.node, this.emit(mB.ON_NODE, this.inputNode));
        }
      }
      class jG extends MD {
        set chained(e3) {
          this._chained = e3;
        }
        get chained() {
          return this._chained;
        }
        constructor(e3, t3, i3) {
          super(), MN(this, "constraintsMap", /* @__PURE__ */ new Map()), MN(this, "statsRegistry", []), MN(this, "audioContext", void 0), MN(this, "trackId", void 0), MN(this, "direction", void 0), MN(this, "usageRegistry", []), MN(this, "_chained", false), this.audioContext = e3, this.trackId = t3, this.direction = i3;
        }
        async getConstraints() {
          return vK(this, IB.REQUEST_CONSTRAINTS);
        }
        getAudioContext() {
          return this.audioContext;
        }
        async requestApplyConstraints(e3, t3) {
          var i3;
          return JD.info("processor ".concat(t3.name, " requestApplyConstraints for ").concat(this.trackId)), e3 && this.constraintsMap.set(t3, e3), TK(this, IB.REQUEST_UPDATE_CONSTRAINTS, Array.from(MG(i3 = this.constraintsMap).call(i3)));
        }
        async requestRevertConstraints(e3) {
          var t3;
          if (this.constraintsMap.has(e3))
            return this.constraintsMap.delete(e3), TK(this, IB.REQUEST_UPDATE_CONSTRAINTS, Array.from(MG(t3 = this.constraintsMap).call(t3)));
        }
        registerStats(e3, t3, i3) {
          this.statsRegistry.find((i4) => i4.processorID === e3.ID && i4.processorName === e3.name && i4.type === t3) || this.statsRegistry.push({ processorName: e3.name, processorID: e3.ID, type: t3, cb: i3 });
        }
        unregisterStats(e3, t3) {
          const i3 = this.statsRegistry.findIndex((i4) => i4.processorID === e3.ID && i4.processorName === e3.name && i4.type === t3);
          -1 !== i3 && this.statsRegistry.splice(i3, 1);
        }
        gatherStats() {
          const e3 = [];
          for (const { processorID: t3, processorName: i3, type: r3, cb: n3 } of this.statsRegistry)
            try {
              const o3 = n3();
              e3.push({ processorID: t3, processorName: i3, type: r3, stats: o3 });
            } catch (e4) {
              JD.error(new QD(xD.UNEXPECTED_ERROR, e4.message));
            }
          return e3;
        }
        registerUsage(e3, t3) {
          this.usageRegistry.find((t4) => t4.processorID === e3.ID && t4.processorName === e3.name) || this.usageRegistry.push({ processorID: e3.ID, processorName: e3.name, cb: t3 });
        }
        unregisterUsage(e3) {
          const t3 = this.usageRegistry.findIndex((t4) => t4.processorID === e3.ID && t4.processorName === e3.name);
          -1 !== t3 && this.usageRegistry.splice(t3, 1);
        }
        async gatherUsage() {
          const e3 = [];
          if (!this.chained)
            return [];
          for (const { cb: t3 } of this.usageRegistry)
            try {
              let i3 = t3();
              i3 instanceof l_ && (i3 = await i3), e3.push(xG(xG({}, i3), {}, { direction: this.direction }));
            } catch (e4) {
              JD.error("gather extension usage error", e4);
            }
          return e3;
        }
        getDirection() {
          return this.direction;
        }
      }
      function GG(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function KG(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? GG(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : GG(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      let HG = ($j = mP("LocalAudioTrack", "getTrackId"), eG = Zj(), tG = mj("LocalAudioTrack", "_enabledMutex"), iG = lj({ className: "LocalAudioTrack" }), rG = Zj(), nG = mj("LocalAudioTrack", "_enabledMutex"), oG = lj({ className: "LocalAudioTrack" }), sG = Zj(), aG = Zj(), cG = Zj(), dG = Zj(), uG = Zj(), $j((VV((AG = class extends Ij {
        get isPlaying() {
          return this._useAudioElement ? zj.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        constructor(e3, t3, i3, r3) {
          super(e3, i3), MN(this, "trackMediaType", "audio"), MN(this, "_encoderConfig", void 0), MN(this, "_source", void 0), MN(this, "_enabled", true), MN(this, "_volume", 100), MN(this, "_useAudioElement", false), MN(this, "_bypassWebAudio", false), MN(this, "processor", void 0), MN(this, "processorContext", void 0), MN(this, "processorDestination", void 0), MN(this, "_getOriginVolumeLevel", void 0), this._encoderConfig = t3, this._getOriginVolumeLevel = !!r3, this._source = new kj(e3, false, this._getOriginVolumeLevel ? e3 : void 0), LP("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") || (this._useAudioElement = true), this.processorContext = new jG(this._source.context, this.getTrackId(), "local"), this.processorDestination = new VG(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(Sk.UPDATE_SOURCE, () => {
            this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
          });
        }
        setVolume(e3) {
          UL(e3, "volume", 0, 1e3);
          const t3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.LOCAL_AUDIO_TRACK_SET_VOLUME, options: [this.getTrackId(), e3] }, 300);
          this._volume = e3, this._source.setVolume(e3 / 100), this._useAudioElement && zj.setVolume(this.getTrackId(), e3);
          try {
            if (this._bypassWebAudio)
              return JD.debug("[".concat(this.getTrackId(), "] setVolume returned because no pass through WebAudio.")), void t3.onSuccess();
            const e4 = this._source.createOutputTrack();
            this._mediaStreamTrack !== e4 && (this._mediaStreamTrack = e4, TK(this, Zk.NEED_REPLACE_TRACK, this).then(() => {
              JD.debug("[".concat(this.getTrackId(), "] replace web audio track success")), hP("debug", this, "replace web audio track success");
            }).catch((e5) => {
              JD.warning("[".concat(this.getTrackId(), "] replace web audio track failed"), e5), hP("warning", this, "replace web audio track failed ".concat(e5.toString()));
            }));
          } catch (e4) {
          }
          t3.onSuccess();
        }
        getVolumeLevel() {
          return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel();
        }
        async setPlaybackDevice(e3) {
          const t3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.REMOTE_AUDIO_SET_OUTPUT_DEVICE, options: [this.getTrackId(), e3] });
          if (!this._useAudioElement)
            throw new QD(xD.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          try {
            await zj.setSinkID(this.getTrackId(), e3);
          } catch (e4) {
            throw t3.onError(e4), e4;
          }
          t3.onSuccess();
        }
        async setEnabled(e3, t3, i3) {
          return this._setEnabled(e3, t3, i3);
        }
        async _setEnabled(e3, t3, i3) {
          if (!i3) {
            if (e3 === this._enabled)
              return;
            this.stateCheck("enabled", e3);
          }
          if (JD.info("[".concat(this.getTrackId(), "] start setEnabled"), e3), gP("info", this, "setEnabled", e3), e3) {
            this._originMediaStreamTrack.enabled = true;
            try {
              i3 || (this._enabled = true), await TK(this, Zk.NEED_ENABLE_TRACK, this), JD.info("[".concat(this.getTrackId(), "] setEnabled to ").concat(e3, " success")), gP("info", this, "setEnabled", e3, "success");
            } catch (t4) {
              throw i3 || (this._enabled = false), JD.error("[".concat(this.getTrackId(), "] setEnabled to true error"), t4.toString()), gP("error", this, "setEnabled", e3, t4.toString()), t4;
            }
          } else {
            this._originMediaStreamTrack.enabled = false, i3 || (this._enabled = false);
            try {
              await TK(this, Zk.NEED_DISABLE_TRACK, this);
            } catch (t4) {
              throw i3 || (this._enabled = true), JD.error("[".concat(this.getTrackId(), "] setEnabled to false error"), t4.toString()), gP("info", this, "setEnabled", e3, t4.toString()), t4;
            }
          }
        }
        async setMuted(e3) {
          e3 !== this._muted && (this.stateCheck("muted", e3), this._muted = e3, this._originMediaStreamTrack.enabled = !e3, JD.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e3)), gP("debug", this, "setMuted", e3), e3 ? await TK(this, Zk.NEED_MUTE_TRACK, this) : await TK(this, Zk.NEED_UNMUTE_TRACK, this));
        }
        getStats() {
          PK(() => {
            JD.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead"), hP("warning", this, "LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");
          }, "localAudioTrackGetStatsWarning");
          const e3 = RK(this, Zk.GET_STATS);
          return e3 || KG({}, bk);
        }
        setAudioFrameCallback(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
          if (!e3)
            return this._source.removeAllListeners(Sk.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t3), this._source.removeAllListeners(Sk.ON_AUDIO_BUFFER), this._source.on(Sk.ON_AUDIO_BUFFER, (t4) => e3(t4));
        }
        play() {
          const e3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.LOCAL_AUDIO_TRACK_PLAY, options: [this.getTrackId()] });
          JD.debug("[".concat(this.getTrackId(), "] start audio playback")), gP("debug", this, "play"), this._useAudioElement ? (JD.debug("[".concat(this.getTrackId(), "] start audio playback in element")), hP("debug", this, "start audio playback in element"), zj.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play(), e3.onSuccess();
        }
        stop() {
          const e3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.LOCAL_AUDIO_TRACK_STOP, options: [this.getTrackId()] });
          JD.debug("[".concat(this.getTrackId(), "] stop audio playback")), gP("debug", this, "stop"), this._useAudioElement ? zj.stop(this.getTrackId()) : this._source.stop(), e3.onSuccess();
        }
        close() {
          super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe(), this._source.destroy();
        }
        _updatePlayerSource() {
          let e3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          JD.debug("[".concat(this.getTrackId(), "] update player source track")), gP("debug", this, "_updatePlayerSource"), e3 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && zj.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
        async _updateOriginMediaStreamTrack(e3, t3) {
          this._originMediaStreamTrack !== e3 && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), e3.addEventListener("ended", this._handleTrackEnded), t3 && this._originMediaStreamTrack.stop(), this._originMediaStreamTrack = e3, this._muted && (this._originMediaStreamTrack.enabled = false), this.processor && this.processor.updateInput({ track: e3, context: this.processorContext }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await TK(this, Zk.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e3));
        }
        renewMediaStreamTrack(e3) {
          return l_.resolve(void 0);
        }
        pipe(e3) {
          if (this._bypassWebAudio)
            throw new QD(xD.INVALID_OPERATION, "Can not process AudioTrack when bypassWebAudio set to true.");
          if (this.processor === e3)
            return e3;
          if (e3._source)
            throw new QD(xD.INVALID_OPERATION, "Processor ".concat(e3.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e3, this.processor._source = this, e3.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e3;
        }
        unpipe() {
          var e3;
          if (!this.processor)
            return;
          const t3 = this.processor;
          null === (e3 = this._source.processSourceNode) || void 0 === e3 || e3.disconnect(), this.processor._source = false, this.processor = void 0, t3.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(mB.ON_TRACK, async (e3) => {
            e3 ? e3 !== this._mediaStreamTrack && (this._mediaStreamTrack = e3, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e3), await TK(this, Zk.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await TK(this, Zk.NEED_REPLACE_TRACK, this));
          }), this.processorDestination.on(mB.ON_NODE, (e3) => {
            this._source.processedNode = e3;
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(mB.ON_TRACK), this.processorDestination.removeAllListeners(mB.ON_NODE);
        }
        unbindProcessorContextEvents() {
          this.processorContext.removeAllListeners(IB.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(IB.REQUEST_CONSTRAINTS);
        }
      }).prototype, "setPlaybackDevice", [eG], Object.getOwnPropertyDescriptor(AG.prototype, "setPlaybackDevice"), AG.prototype), VV(AG.prototype, "setEnabled", [tG, iG, rG], Object.getOwnPropertyDescriptor(AG.prototype, "setEnabled"), AG.prototype), VV(AG.prototype, "setMuted", [nG, oG, sG], Object.getOwnPropertyDescriptor(AG.prototype, "setMuted"), AG.prototype), VV(AG.prototype, "getStats", [aG], Object.getOwnPropertyDescriptor(AG.prototype, "getStats"), AG.prototype), VV(AG.prototype, "setAudioFrameCallback", [cG], Object.getOwnPropertyDescriptor(AG.prototype, "setAudioFrameCallback"), AG.prototype), VV(AG.prototype, "play", [dG], Object.getOwnPropertyDescriptor(AG.prototype, "play"), AG.prototype), VV(AG.prototype, "stop", [uG], Object.getOwnPropertyDescriptor(AG.prototype, "stop"), AG.prototype), hG = AG)) || hG), WG = (lG = mP("MicrophoneAudioTrack", "getTrackId"), pG = Zj(), gG = mj("MicrophoneAudioTrack", "_enabledMutex"), EG = lj({ className: "MicrophoneAudioTrack" }), fG = Zj(), lG((VV((IG = class extends HG {
        constructor(e3, t3, i3, r3) {
          super(e3, t3.encoderConfig ? DP(t3.encoderConfig) : {}, r3, LP("GET_VOLUME_OF_MUTED_AUDIO_TRACK")), MN(this, "_config", void 0), MN(this, "_deviceName", "default"), MN(this, "_constraints", void 0), MN(this, "_originalConstraints", void 0), MN(this, "_enabled", true), fP("info", this, "constructor", { trackId: r3, deviceId: e3.label, constraints: i3 }), this._config = t3, this._constraints = i3, this._originalConstraints = i3, this._deviceName = e3.label, "boolean" == typeof t3.bypassWebAudio && (this._bypassWebAudio = t3.bypassWebAudio), IN() && Tj.bindInterruptDetectorTrack(this), this.bindProcessorContextEvents();
        }
        async setDevice(e3) {
          const t3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.MIC_AUDIO_TRACK_SET_DEVICE, options: [this.getTrackId(), e3] });
          if (JD.info("[".concat(this.getTrackId(), "] start set device to ").concat(e3)), gP("info", this, "setDevice", e3), this._enabled)
            try {
              const t4 = await Yj.getDeviceById(e3), i3 = {};
              i3.audio = KG({}, this._constraints), i3.audio.deviceId = { exact: e3 }, this._originMediaStreamTrack.stop();
              let r3 = null;
              try {
                r3 = await Gj(i3, this.getTrackId());
              } catch (t5) {
                throw JD.error("[".concat(this.getTrackId(), "] setDevice failed"), t5.toString()), gP("error", this, "setDevice", e3, t5.toString()), r3 = await Gj({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(r3.getAudioTracks()[0], false), t5;
              }
              await this._updateOriginMediaStreamTrack(r3.getAudioTracks()[0], false), this._deviceName = t4.label, this._config.microphoneId = e3, this._constraints.deviceId = { exact: e3 };
            } catch (i3) {
              throw t3.onError(i3), JD.error("[".concat(this.getTrackId(), "] setDevice error"), i3.toString()), gP("error", this, "setDevice", e3, i3.toString()), i3;
            }
          else
            try {
              const t4 = await Yj.getDeviceById(e3);
              this._deviceName = t4.label, this._config.microphoneId = e3, this._constraints.deviceId = { exact: e3 };
            } catch (i3) {
              throw t3.onError(i3), JD.error("[".concat(this.getTrackId(), "] setDevice error"), i3.toString()), gP("error", this, "setDevice", e3, i3.toString()), i3;
            }
          t3.onSuccess(), JD.info("[".concat(this.getTrackId(), "] set device to ").concat(e3, " success")), gP("info", this, "setDevice", e3, "success");
        }
        async setEnabled(e3, t3, i3) {
          if (t3)
            return JD.debug("[".concat(this.getTrackId(), "] setEnabled false (do not close microphone)")), hP("debug", this, "setEnabled false (do not close microphone)"), await super._setEnabled(e3);
          if (!i3) {
            if (e3 === this._enabled)
              return;
            this.stateCheck("enabled", e3);
          }
          if (JD.info("[".concat(this.getTrackId(), "] start setEnabled"), e3), gP("info", this, "setEnabled", e3), !e3) {
            var r3;
            this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (r3 = this._source.clonedTrack) || void 0 === r3 || r3.stop(), i3 || (this._enabled = false);
            try {
              await TK(this, Zk.NEED_DISABLE_TRACK, this);
            } catch (t4) {
              throw JD.error("[".concat(this.getTrackId(), "] setEnabled false failed"), t4.toString()), gP("error", this, "setEnabled", e3, t4.toString()), t4;
            }
            return;
          }
          const n3 = KG({}, this._constraints), o3 = Yj.searchDeviceIdByName(this._deviceName);
          o3 && !n3.deviceId && (n3.deviceId = o3);
          try {
            i3 || (this._enabled = true);
            const e4 = await Gj({ audio: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e4.getAudioTracks()[0], false), await TK(this, Zk.NEED_ENABLE_TRACK, this);
          } catch (t4) {
            throw i3 || (this._enabled = false), JD.error("[".concat(this.getTrackId(), "] setEnabled true failed"), t4.toString()), gP("error", this, "setEnabled", e3, t4.toString()), t4;
          }
          JD.info("[".concat(this.getTrackId(), "] setEnabled success")), gP("info", this, "setEnabled", e3, "success");
        }
        close() {
          super.close(), IN() && Tj.unbindInterruptDetectorTrack(this);
        }
        onTrackEnded() {
          if ((EN() || vN()) && this._enabled && !this._isClosed && Tj.duringInterruption) {
            const e3 = async () => {
              Tj.off(_j.IOS_INTERRUPTION_END, e3), this._enabled && !this._isClosed && (JD.debug("[".concat(this.getTrackId(), "] try capture microphone media device for interrupted iOS device.")), hP("debug", this, "try capture microphone media device for interrupted iOS device"), await this.setEnabled(false), await this.setEnabled(true));
            };
            Tj.on(_j.IOS_INTERRUPTION_END, e3);
          } else
            JD.debug("[".concat(this.getTrackId(), "] track ended")), pP("debug", ["MediaStreamTrack", this.getTrackId()], "ended"), this.emit(iB.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e3) {
          const t3 = e3 || this._constraints, i3 = Yj.searchDeviceIdByName(this._deviceName);
          if (i3 && !t3.deviceId && (t3.deviceId = i3), this._constraints = t3, this._enabled) {
            this._originMediaStreamTrack.stop();
            const e4 = await Gj({ audio: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e4.getAudioTracks()[0], true);
          }
        }
        bindProcessorContextEvents() {
          this.processorContext.on(IB.REQUEST_UPDATE_CONSTRAINTS, async (e3, t3, i3) => {
            try {
              const i4 = Object.assign({}, this._originalConstraints, ...e3);
              await this.renewMediaStreamTrack(i4), t3();
            } catch (e4) {
              i3(e4);
            }
          }), this.processorContext.on(IB.REQUEST_CONSTRAINTS, async (e3) => {
            e3(this._originMediaStreamTrack.getSettings());
          });
        }
      }).prototype, "setDevice", [pG], Object.getOwnPropertyDescriptor(IG.prototype, "setDevice"), IG.prototype), VV(IG.prototype, "setEnabled", [gG, EG, fG], Object.getOwnPropertyDescriptor(IG.prototype, "setEnabled"), IG.prototype), mG = IG)) || mG), YG = (_G = mP("BufferSourceAudioTrack", "getTrackId"), CG = Zj(), SG = Zj(), vG = Zj(), TG = Zj(), RG = Zj(), _G((VV((wG = class extends HG {
        constructor(e3, t3, i3, r3) {
          super(t3.createOutputTrack(), i3, r3), MN(this, "source", void 0), MN(this, "_bufferSource", void 0), fP("info", this, "constructor", { trackId: r3 }), this.source = e3, this._bufferSource = t3, this._bufferSource.on(Sk.AUDIO_SOURCE_STATE_CHANGE, (e4) => {
            this.emit(iB.SOURCE_STATE_CHANGE, e4);
          });
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e4) {
          }
        }
        get currentState() {
          return this._bufferSource.currentState;
        }
        get duration() {
          return this._bufferSource.duration;
        }
        getCurrentTime() {
          return this._bufferSource.currentTime;
        }
        startProcessAudioBuffer(e3) {
          const t3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.BUFFER_AUDIO_TRACK_START, options: [this.getTrackId(), e3, this.duration] });
          e3 && this._bufferSource.updateOptions(e3), this._bufferSource.startProcessAudioBuffer(), t3.onSuccess();
        }
        pauseProcessAudioBuffer() {
          const e3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.BUFFER_AUDIO_TRACK_PAUSE, options: [this.getTrackId()] });
          this._bufferSource.pauseProcessAudioBuffer(), e3.onSuccess();
        }
        seekAudioBuffer(e3) {
          const t3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.BUFFER_AUDIO_TRACK_SEEK, options: [this.getTrackId()] });
          this._bufferSource.seekAudioBuffer(e3), t3.onSuccess();
        }
        resumeProcessAudioBuffer() {
          const e3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.BUFFER_AUDIO_TRACK_RESUME, options: [this.getTrackId()] });
          this._bufferSource.resumeProcessAudioBuffer(), e3.onSuccess();
        }
        stopProcessAudioBuffer() {
          const e3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.BUFFER_AUDIO_TRACK_STOP, options: [this.getTrackId()] });
          this._bufferSource.stopProcessAudioBuffer(), e3.onSuccess();
        }
      }).prototype, "startProcessAudioBuffer", [CG], Object.getOwnPropertyDescriptor(wG.prototype, "startProcessAudioBuffer"), wG.prototype), VV(wG.prototype, "pauseProcessAudioBuffer", [SG], Object.getOwnPropertyDescriptor(wG.prototype, "pauseProcessAudioBuffer"), wG.prototype), VV(wG.prototype, "seekAudioBuffer", [vG], Object.getOwnPropertyDescriptor(wG.prototype, "seekAudioBuffer"), wG.prototype), VV(wG.prototype, "resumeProcessAudioBuffer", [TG], Object.getOwnPropertyDescriptor(wG.prototype, "resumeProcessAudioBuffer"), wG.prototype), VV(wG.prototype, "stopProcessAudioBuffer", [RG], Object.getOwnPropertyDescriptor(wG.prototype, "stopProcessAudioBuffer"), wG.prototype), yG = wG)) || yG), JG = mP("MixingAudioTrack", "getTrackId")(bG = class extends HG {
        get isActive() {
          for (const e3 of this.trackList)
            if (e3._enabled && !e3._isClosed && !e3.muted)
              return true;
          return false;
        }
        constructor() {
          const e3 = yj().createMediaStreamDestination();
          super(e3.stream.getAudioTracks()[0], void 0, mK(8, "track-mix-")), MN(this, "trackList", void 0), MN(this, "destNode", void 0);
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e4) {
          }
          this.destNode = e3, this.trackList = [];
        }
        hasAudioTrack(e3) {
          return -1 !== this.trackList.indexOf(e3);
        }
        addAudioTrack(e3) {
          if (-1 !== this.trackList.indexOf(e3))
            return JD.debug("track ".concat(e3.getTrackId(), " is already added")), void hP("debug", this, "track already added");
          JD.debug("add ".concat(e3.getTrackId(), " to mixing track")), gP("debug", this, "addAudioTrack", e3.getTrackId()), e3._source.outputNode.connect(this.destNode), this.trackList.push(e3), this.updateEncoderConfig();
        }
        removeAudioTrack(e3) {
          if (-1 !== this.trackList.indexOf(e3)) {
            JD.debug("remove ".concat(e3.getTrackId(), " from mixing track")), gP("debug", this, "removeAudioTrack", e3.getTrackId());
            try {
              e3._source.outputNode.disconnect(this.destNode);
            } catch (e4) {
            }
            wK(this.trackList, e3), this.updateEncoderConfig();
          }
        }
        updateEncoderConfig() {
          const e3 = {};
          this.trackList.forEach((t3) => {
            t3._encoderConfig && ((t3._encoderConfig.bitrate || 0) > (e3.bitrate || 0) && (e3.bitrate = t3._encoderConfig.bitrate), (t3._encoderConfig.sampleRate || 0) > (e3.sampleRate || 0) && (e3.sampleRate = t3._encoderConfig.sampleRate), (t3._encoderConfig.sampleSize || 0) > (e3.sampleSize || 0) && (e3.sampleSize = t3._encoderConfig.sampleSize), t3._encoderConfig.stereo && (e3.stereo = true));
          }), this._encoderConfig = e3;
        }
      }) || bG;
      class qG extends MD {
        constructor() {
          super(...arguments), MN(this, "resultStorage", /* @__PURE__ */ new Map());
        }
        setLocalAudioStats(e3, t3, i3) {
          this.record("AUDIO_INPUT_LEVEL_TOO_LOW", e3, this.checkAudioInputLevel(i3, t3)), this.record("SEND_AUDIO_BITRATE_TOO_LOW", e3, this.checkSendAudioBitrate(i3, t3));
        }
        setLocalVideoStats(e3, t3, i3) {
          this.record("SEND_VIDEO_BITRATE_TOO_LOW", e3, this.checkSendVideoBitrate(i3, t3)), this.record("FRAMERATE_INPUT_TOO_LOW", e3, this.checkFramerateInput(i3, t3)), this.record("FRAMERATE_SENT_TOO_LOW", e3, this.checkFramerateSent(i3));
        }
        setRemoteAudioStats(e3, t3) {
          const i3 = e3.getUserId();
          this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", i3, this.checkAudioOutputLevel(t3));
        }
        setRemoteVideoStats(e3, t3) {
          const i3 = e3.getUserId();
          this.record("RECV_VIDEO_DECODE_FAILED", i3, this.checkVideoDecode(t3));
        }
        record(e3, t3, i3) {
          this.resultStorage.has(e3) || this.resultStorage.set(e3, { result: [], isPrevNormal: true });
          const r3 = this.resultStorage.get(e3);
          if (r3 && (r3.result.push(i3), r3.result.length >= 5)) {
            const i4 = r3.result.includes(true);
            r3.isPrevNormal && !i4 && this.emit("exception", XG[e3], e3, t3), !r3.isPrevNormal && i4 && this.emit("exception", XG[e3] + 2e3, e3 + "_RECOVER", t3), r3.isPrevNormal = i4, r3.result = [];
          }
        }
        checkAudioOutputLevel(e3) {
          return !(e3.receiveBitrate > 0 && 0 === e3.receiveLevel);
        }
        checkAudioInputLevel(e3, t3) {
          return t3 instanceof JG && !t3.isActive || (!!t3.muted || 0 !== e3.sendVolumeLevel);
        }
        checkFramerateInput(e3, t3) {
          let i3 = null;
          t3._encoderConfig && t3._encoderConfig.frameRate && (i3 = oK(t3._encoderConfig.frameRate));
          const r3 = e3.captureFrameRate;
          return !i3 || !r3 || !(i3 > 10 && r3 < 5 || i3 < 10 && i3 >= 5 && r3 <= 1);
        }
        checkFramerateSent(e3) {
          return !(e3.captureFrameRate && e3.sendFrameRate && e3.captureFrameRate > 5 && e3.sendFrameRate <= 1);
        }
        checkSendVideoBitrate(e3, t3) {
          return !!t3.muted || 0 !== e3.sendBitrate;
        }
        checkSendAudioBitrate(e3, t3) {
          return t3 instanceof JG && !t3.isActive || (!!t3.muted || 0 !== e3.sendBitrate);
        }
        checkVideoDecode(e3) {
          return 0 === e3.receiveBitrate || 0 !== e3.decodeFrameRate;
        }
      }
      const XG = { FRAMERATE_INPUT_TOO_LOW: 1001, FRAMERATE_SENT_TOO_LOW: 1002, SEND_VIDEO_BITRATE_TOO_LOW: 1003, RECV_VIDEO_DECODE_FAILED: 1005, AUDIO_INPUT_LEVEL_TOO_LOW: 2001, AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002, SEND_AUDIO_BITRATE_TOO_LOW: 2003 };
      const zG = new class {
        markSubscribeStart(e3, t3) {
          performance.mark("agora-web-sdk/".concat(e3, "/subscribe-").concat(t3));
        }
        markPublishStart(e3, t3) {
          performance.mark("agora-web-sdk/".concat(e3, "/publish-").concat(t3));
        }
        measureFromSubscribeStart(e3, t3) {
          const i3 = performance.getEntriesByName("agora-web-sdk/".concat(e3, "/subscribe-").concat(t3));
          if (i3.length > 0) {
            const e4 = i3[i3.length - 1];
            return Math.round(performance.now() - e4.startTime);
          }
          return 0;
        }
        measureFromPublishStart(e3, t3) {
          const i3 = performance.getEntriesByName("agora-web-sdk/".concat(e3, "/publish-").concat(t3));
          if (i3.length > 0) {
            const e4 = i3[i3.length - 1];
            return Math.round(performance.now() - e4.startTime);
          }
          return 0;
        }
      }();
      function ZG(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function $G(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? ZG(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : ZG(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      class eK {
        constructor(e3) {
          MN(this, "store", void 0), MN(this, "onStatsException", void 0), MN(this, "onUploadPublishDuration", void 0), MN(this, "localStats", /* @__PURE__ */ new Map()), MN(this, "remoteStats", /* @__PURE__ */ new Map()), MN(this, "updateStatsInterval", void 0), MN(this, "trafficStats", void 0), MN(this, "trafficStatsPeerList", []), MN(this, "uplinkStats", void 0), MN(this, "exceptionMonitor", void 0), MN(this, "p2pChannel", void 0), MN(this, "updateStats", () => {
            this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));
          }), this.store = e3, this.updateStatsInterval = window.setInterval(this.updateStats, 1e3), this.exceptionMonitor = new qG(), this.exceptionMonitor.on("exception", (e4, t3, i3) => {
            this.onStatsException && this.onStatsException(e4, t3, i3);
          });
        }
        reset() {
          this.localStats = /* @__PURE__ */ new Map(), this.remoteStats = /* @__PURE__ */ new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;
        }
        getLocalAudioTrackStats() {
          return this.localStats.get(lB.LocalAudioTrack) || $G({}, bk);
        }
        getLocalVideoTrackStats() {
          return this.localStats.get(lB.LocalVideoTrack) || $G({}, Nk);
        }
        getRemoteAudioTrackStats(e3) {
          const t3 = (e4, t4) => {
            if (!this.trafficStats)
              return t4;
            const i4 = this.trafficStats.peer_delay.find((t5) => t5.peer_uid === e4);
            return i4 && (t4.publishDuration = i4.B_ppad + (Date.now() - this.trafficStats.timestamp)), t4;
          }, i3 = {};
          if (e3) {
            var r3;
            const n3 = null === (r3 = this.remoteStats.get(e3)) || void 0 === r3 ? void 0 : r3.audioStats;
            n3 && (i3[e3] = t3(e3, n3));
          } else
            Array.from(this.remoteStats.entries()).forEach((e4) => {
              let [r4, { audioStats: n3 }] = e4;
              n3 && (i3[r4] = t3(r4, n3));
            });
          return i3;
        }
        getRemoteNetworkQualityStats(e3) {
          const t3 = {};
          if (e3) {
            var i3;
            const r3 = null === (i3 = this.remoteStats.get(e3)) || void 0 === i3 ? void 0 : i3.networkStats;
            r3 && (t3[e3] = r3);
          } else
            Array.from(this.remoteStats.entries()).forEach((e4) => {
              let [i4, { networkStats: r3 }] = e4;
              r3 && (t3[i4] = r3);
            });
          return t3;
        }
        getRemoteVideoTrackStats(e3) {
          const t3 = (e4, t4) => {
            if (!this.trafficStats)
              return t4;
            const i4 = this.trafficStats.peer_delay.find((t5) => t5.peer_uid === e4);
            return i4 && (t4.publishDuration = i4.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t4;
          }, i3 = {};
          if (e3) {
            var r3;
            const n3 = null === (r3 = this.remoteStats.get(e3)) || void 0 === r3 ? void 0 : r3.videoStats;
            n3 && (i3[e3] = t3(e3, n3));
          } else
            Array.from(this.remoteStats.entries()).forEach((e4) => {
              let [r4, { videoStats: n3 }] = e4;
              n3 && (i3[r4] = t3(r4, n3));
            });
          return i3;
        }
        getRTCStats() {
          let e3 = 0, t3 = 0, i3 = 0, r3 = 0;
          const n3 = this.localStats.get(lB.LocalAudioTrack);
          n3 && (e3 += n3.sendBytes, t3 += n3.sendBitrate);
          const o3 = this.localStats.get(lB.LocalVideoTrack);
          o3 && (e3 += o3.sendBytes, t3 += o3.sendBitrate);
          const s3 = this.localStats.get(lB.LocalVideoLowTrack);
          s3 && (e3 += s3.sendBytes, t3 += s3.sendBitrate), this.remoteStats.forEach((e4) => {
            let { audioStats: t4, videoStats: n4 } = e4;
            t4 && (i3 += t4.receiveBytes, r3 += t4.receiveBitrate), n4 && (i3 += n4.receiveBytes, r3 += n4.receiveBitrate);
          });
          let a3 = 1;
          return this.trafficStats && (a3 += this.trafficStats.peer_delay.length), { Duration: 0, UserCount: a3, SendBitrate: t3, SendBytes: e3, RecvBytes: i3, RecvBitrate: r3, OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0, RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0 };
        }
        addLocalStats(e3) {
          this.localStats.set(e3, void 0);
        }
        removeLocalStats(e3) {
          e3 ? this.localStats.delete(e3) : this.localStats.clear();
        }
        addRemoteStats(e3) {
          this.remoteStats.set(e3, {});
        }
        removeRemoteStats(e3) {
          e3 ? this.remoteStats.delete(e3) : this.remoteStats.clear();
        }
        addP2PChannel(e3) {
          this.p2pChannel = e3;
        }
        updateTrafficStats(e3) {
          e3.peer_delay = e3.peer_delay.filter((e4) => void 0 !== e4.B_ppad || void 0 !== e4.B_ppvd);
          e3.peer_delay.filter((e4) => -1 === this.trafficStatsPeerList.indexOf(e4.peer_uid)).forEach((e4) => {
            var t3;
            const i3 = null === (t3 = this.p2pChannel) || void 0 === t3 ? void 0 : t3.getRemoteMedia(e4.peer_uid), r3 = null != i3 && i3.videoSSRC ? zG.measureFromSubscribeStart(this.store.clientId, i3.videoSSRC) : 0, n3 = null != i3 && i3.audioSSRC ? zG.measureFromSubscribeStart(this.store.clientId, i3.audioSSRC) : 0;
            void 0 !== e4.B_ppad && void 0 !== e4.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(e4.peer_uid, e4.B_ppad, e4.B_ppvd, r3 > n3 ? r3 : n3), this.trafficStatsPeerList.push(e4.peer_uid));
          }), this.trafficStats = e3;
        }
        updateUplinkStats(e3) {
          this.uplinkStats && this.uplinkStats.B_fir !== e3.B_fir && JD.debug("[".concat(this.store.clientId, "]: Period fir changes to ").concat(e3.B_fir)), this.uplinkStats = e3;
        }
        static isRemoteVideoFreeze(e3, t3, i3) {
          if (!e3)
            return false;
          const r3 = !!i3 && t3.framesDecodeFreezeTime > i3.framesDecodeFreezeTime, n3 = !i3 || t3.framesDecodeCount > i3.framesDecodeCount;
          return r3 || !n3;
        }
        static isRemoteAudioFreeze(e3) {
          return !!e3 && e3._isFreeze();
        }
        isLocalVideoFreeze(e3) {
          return !(!e3.inputFrame || !e3.sentFrame) && (e3.inputFrame.frameRate > 5 && e3.sentFrame.frameRate < 3);
        }
        updateLocalStats(e3) {
          Array.from(this.localStats.entries()).forEach((t3) => {
            let [i3, r3] = t3;
            switch (i3) {
              case lB.LocalVideoTrack:
              case lB.LocalVideoLowTrack: {
                const t4 = r3, n3 = $G({}, Nk), o3 = e3.getStats(), s3 = e3.getLocalMedia(i3);
                if (o3) {
                  const i4 = o3.videoSend.find((e4) => e4.ssrc === (null == s3 ? void 0 : s3.ssrcs[0].ssrcId));
                  if (i4) {
                    const r4 = e3.getLocalVideoSize(), o4 = e3.getEncoderConfig(lB.LocalVideoTrack);
                    "H264" !== i4.codec && "VP8" !== i4.codec && "VP9" !== i4.codec && "AV1X" !== i4.codec && "AV1" !== i4.codec || (n3.codecType = i4.codec), n3.sendBytes = i4.bytes, n3.sendBitrate = t4 ? 8 * Math.max(0, n3.sendBytes - t4.sendBytes) : 0, i4.inputFrame ? (n3.captureFrameRate = i4.inputFrame.frameRate, n3.captureResolutionHeight = i4.inputFrame.height, n3.captureResolutionWidth = i4.inputFrame.width) : r4 && (n3.captureResolutionWidth = r4.width, n3.captureResolutionHeight = r4.height), i4.sentFrame ? (n3.sendFrameRate = i4.sentFrame.frameRate, n3.sendResolutionHeight = i4.sentFrame.height, n3.sendResolutionWidth = i4.sentFrame.width) : r4 && (n3.sendResolutionWidth = r4.width, n3.sendResolutionHeight = r4.height), i4.avgEncodeMs && (n3.encodeDelay = i4.avgEncodeMs), o4 && o4.bitrateMax && (n3.targetSendBitrate = 1e3 * o4.bitrateMax), n3.sendPackets = i4.packets, n3.sendPacketsLost = i4.packetsLost, n3.totalDuration = t4 ? t4.totalDuration + 1 : 1, n3.totalFreezeTime = t4 ? t4.totalFreezeTime : 0, this.isLocalVideoFreeze(i4) && (n3.totalFreezeTime += 1);
                  }
                  this.trafficStats && (n3.sendPacketsLost = this.trafficStats.B_pvlr4 / 100);
                }
                this.localStats.set(i3, n3), n3 && s3 && this.exceptionMonitor.setLocalVideoStats(this.store.uid, s3.track, n3);
                break;
              }
              case lB.LocalAudioTrack: {
                const t4 = r3, n3 = $G({}, bk), o3 = e3.getStats(), s3 = e3.getLocalMedia(i3);
                if (o3) {
                  const i4 = o3.audioSend.find((e4) => e4.ssrc === (null == s3 ? void 0 : s3.ssrcs[0].ssrcId));
                  if (i4) {
                    if ("opus" !== i4.codec && "aac" !== i4.codec && "PCMU" !== i4.codec && "PCMA" !== i4.codec && "G722" !== i4.codec || (n3.codecType = i4.codec), i4.inputLevel)
                      n3.sendVolumeLevel = Math.round(32767 * i4.inputLevel);
                    else {
                      const t5 = e3.getLocalAudioVolume();
                      t5 && (n3.sendVolumeLevel = Math.round(32767 * t5));
                    }
                    n3.sendBytes = i4.bytes, n3.sendPackets = i4.packets, n3.sendPacketsLost = i4.packetsLost, n3.sendBitrate = t4 ? 8 * Math.max(0, n3.sendBytes - t4.sendBytes) : 0;
                  }
                }
                this.trafficStats && (n3.sendPacketsLost = this.trafficStats.B_pvlr4 / 100), this.localStats.set(lB.LocalAudioTrack, n3), n3 && s3 && this.exceptionMonitor.setLocalAudioStats(this.store.uid, s3.track, n3);
                break;
              }
            }
          });
        }
        updateRemoteStats(e3) {
          Array.from(this.remoteStats.entries()).forEach((t3) => {
            let [i3, { videoStats: r3, audioStats: n3, videoPcStats: o3 }] = t3;
            const s3 = n3, a3 = r3, c3 = o3, d3 = $G({}, Ok), u3 = $G({}, Pk), h3 = $G({}, Dk), { audioTrack: A3, videoTrack: l3, audioSSRC: p3, videoSSRC: g3 } = e3.getRemoteMedia(i3), E3 = e3.getStats(), f3 = null == E3 ? void 0 : E3.audioRecv.find((e4) => e4.ssrc === p3), m3 = null == E3 ? void 0 : E3.videoRecv.find((e4) => e4.ssrc === g3), I3 = this.trafficStats && this.trafficStats.peer_delay.find((e4) => e4.peer_uid === i3);
            if (f3 && ("opus" !== f3.codec && "aac" !== f3.codec && "PCMU" !== f3.codec && "PCMA" !== f3.codec && "G722" !== f3.codec || (d3.codecType = f3.codec), f3.outputLevel ? d3.receiveLevel = Math.round(32767 * f3.outputLevel) : A3 && (d3.receiveLevel = Math.round(32767 * A3.getVolumeLevel())), d3.receiveBytes = f3.bytes, d3.receivePackets = f3.packets, d3.receivePacketsLost = f3.packetsLost, d3.packetLossRate = d3.receivePacketsLost / (d3.receivePackets + d3.receivePacketsLost), d3.receiveBitrate = s3 ? 8 * Math.max(0, d3.receiveBytes - s3.receiveBytes) : 0, d3.totalDuration = s3 ? s3.totalDuration + 1 : 1, d3.totalFreezeTime = s3 ? s3.totalFreezeTime : 0, d3.freezeRate = d3.totalFreezeTime / d3.totalDuration, d3.receiveDelay = f3.jitterBufferMs, d3.totalDuration > 10 && eK.isRemoteAudioFreeze(A3) && (d3.totalFreezeTime += 1)), m3) {
              "H264" !== m3.codec && "VP8" !== m3.codec && "VP9" !== m3.codec && "AV1X" !== m3.codec && "AV1" !== m3.codec || (u3.codecType = m3.codec), u3.receiveBytes = m3.bytes, u3.receiveBitrate = a3 ? 8 * Math.max(0, u3.receiveBytes - a3.receiveBytes) : 0, u3.decodeFrameRate = m3.decodeFrameRate < 0 ? 0 : m3.decodeFrameRate, u3.renderFrameRate = m3.decodeFrameRate < 0 ? 0 : m3.decodeFrameRate, m3.outputFrame && (u3.renderFrameRate = m3.outputFrame.frameRate), m3.receivedFrame ? (u3.receiveFrameRate = m3.receivedFrame.frameRate, u3.receiveResolutionHeight = m3.receivedFrame.height, u3.receiveResolutionWidth = m3.receivedFrame.width) : l3 && (u3.receiveResolutionHeight = l3._videoHeight || 0, u3.receiveResolutionWidth = l3._videoWidth || 0), void 0 !== m3.framesRateFirefox && (u3.receiveFrameRate = Math.round(m3.framesRateFirefox)), u3.receivePackets = m3.packets, u3.receivePacketsLost = m3.packetsLost, u3.packetLossRate = u3.receivePacketsLost / (u3.receivePackets + u3.receivePacketsLost), u3.totalDuration = a3 ? a3.totalDuration + 1 : 1, u3.totalFreezeTime = a3 ? a3.totalFreezeTime : 0, u3.receiveDelay = m3.jitterBufferMs || 0;
              const t4 = !!g3 && e3.getRemoteVideoIsReady(g3);
              l3 && t4 && eK.isRemoteVideoFreeze(l3, m3, c3) && (u3.totalFreezeTime += 1), u3.freezeRate = u3.totalFreezeTime / u3.totalDuration;
            }
            I3 && (d3.end2EndDelay = I3.B_ad, u3.end2EndDelay = I3.B_vd, d3.transportDelay = I3.B_ed, u3.transportDelay = I3.B_ed, d3.currentPacketLossRate = I3.B_ealr4 / 100, u3.currentPacketLossRate = I3.B_evlr4 / 100, h3.uplinkNetworkQuality = I3.B_punq ? I3.B_punq : 0, h3.downlinkNetworkQuality = I3.B_pdnq ? I3.B_pdnq : 0), this.remoteStats.set(i3, { audioStats: d3, videoStats: u3, videoPcStats: m3, networkStats: h3 }), A3 && this.exceptionMonitor.setRemoteAudioStats(A3, d3), l3 && this.exceptionMonitor.setRemoteVideoStats(l3, u3);
          });
        }
      }
      function tK(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function iK(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? tK(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : tK(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      function rK(e3) {
        return e3.match(/^[\.\:\d]+$/) ? "".concat(e3.replace(/[^\d]/g, "-"), ".").concat(LP("TURN_DOMAIN")) : (JD.info("Cannot recognized as IP address ".concat(e3, ". Used As Host instead")), e3);
      }
      function nK(e3, t3) {
        var i3, r3;
        const n3 = LP("GATEWAY_DOMAINS");
        let o3 = n3[1] && -1 !== t3.indexOf(n3[1]) ? 1 : 0;
        e3.addresses = e3.addresses || [];
        const s3 = e3.addresses.map((e4) => e4.domain_prefix ? { address: "".concat(e4.domain_prefix, ".").concat(n3[o3++ % n3.length], ":").concat(e4.port) } : e4.ip.match(/^[\.\:\d]+$/) ? { ip: e4.ip, port: e4.port, address: "".concat(e4.ip.replace(/[^\d]/g, "-"), ".").concat(n3[o3++ % n3.length], ":").concat(e4.port) } : (JD.info("Cannot recognized as IP address ".concat(e4.ip, ". Used As Host instead")), { ip: e4.ip, port: e4.port, address: "".concat(e4.ip, ":").concat(e4.port) }));
        if (null !== (i3 = e3.detail) && void 0 !== i3 && i3[18] && "string" == typeof (null === (r3 = e3.detail) || void 0 === r3 ? void 0 : r3[18])) {
          const t4 = e3.detail[18], i4 = null == t4 ? void 0 : t4.split(";");
          for (let e4 = 0; e4 < i4.length; e4++) {
            var a3;
            const t5 = Gb(a3 = i4[e4]).call(a3);
            s3[e4] && t5 && (s3[e4].ip6 = t5);
          }
        }
        return { gatewayAddrs: s3, uid: e3.uid, cid: e3.cid, cert: e3.cert, vid: e3.detail && e3.detail[8], uni_lbs_ip: e3.detail && e3.detail[1], res: e3, csIp: e3.detail && e3.detail[502] };
      }
      function oK(e3) {
        return "number" == typeof e3 ? e3 : e3.exact || e3.ideal || e3.max || e3.min || 0;
      }
      function sK(e3) {
        const t3 = e3._encoderConfig;
        if (!t3)
          return {};
        const i3 = { resolution: t3.width && t3.height ? "".concat(oK(t3.width), "x").concat(oK(t3.height)) : void 0, maxVideoBW: t3.bitrateMax, minVideoBW: t3.bitrateMin };
        return "number" == typeof t3.frameRate ? (i3.maxFrameRate = t3.frameRate, i3.minFrameRate = t3.frameRate) : t3.frameRate && (i3.maxFrameRate = t3.frameRate.max || t3.frameRate.ideal || t3.frameRate.exact || t3.frameRate.min, i3.minFrameRate = t3.frameRate.min || t3.frameRate.ideal || t3.frameRate.exact || t3.frameRate.max), i3;
      }
      function aK(e3, t3, i3) {
        var r3;
        const n3 = t3.videoSend.find((t4) => t4.ssrc === e3);
        if (!n3)
          return null;
        const o3 = null == i3 || null === (r3 = i3.videoSend.find((t4) => t4.ssrc === e3)) || void 0 === r3 ? void 0 : r3.inputFrame, s3 = { id: mK(10, ""), timestamp: new Date(t3.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: n3.ssrc.toString() };
        return n3.inputFrame && (o3 && n3.inputFrame.height === o3.height || (s3.A_fhi = n3.inputFrame.height ? n3.inputFrame.height.toString() : "0"), o3 && n3.inputFrame.width === o3.width || (s3.A_fwi = n3.inputFrame.width ? n3.inputFrame.width.toString() : "0"), o3 && n3.inputFrame.frameRate === o3.frameRate || (s3.A_fri = n3.inputFrame.frameRate ? n3.inputFrame.frameRate.toString() : "0")), s3;
      }
      function cK(e3) {
        return e3 >= 0 && e3 < 0.17 ? 1 : e3 >= 0.17 && e3 < 0.36 ? 2 : e3 >= 0.36 && e3 < 0.59 ? 3 : e3 >= 0.59 && e3 <= 1 ? 4 : e3 > 1 ? 5 : 0;
      }
      function dK(e3, t3) {
        let i3, r3, n3 = void 0;
        switch (t3) {
          case NF.CHOOSE_SERVER:
            i3 = 4096, r3 = "choose server";
            break;
          case NF.CLOUD_PROXY:
            i3 = 1048576, r3 = "proxy";
            break;
          case NF.CLOUD_PROXY_5:
            i3 = 4194304, r3 = "proxy5";
            break;
          case NF.CLOUD_PROXY_FALLBACK:
            i3 = 4194310, r3 = "proxy fallback";
            break;
          default:
            throw new QD(xD.UNEXPECTED_ERROR, "multi unlibs response transformer get unknown service id", { csIp: e3.detail && e3.detail[502], retry: false });
        }
        if (e3.response_body.forEach((t4) => {
          t4.buffer && t4.buffer.flag === i3 && (n3 = { code: t4.buffer.code, addresses: (t4.buffer.edges_services || []).map((e4) => iK(iK({}, e4), {}, { ticket: t4.buffer.cert })), server_ts: e3.enter_ts, uid: t4.buffer.uid, cid: t4.buffer.cid, cname: t4.buffer.cname, detail: iK(iK({}, t4.buffer.detail), e3.detail), flag: t4.buffer.flag, opid: e3.opid, cert: t4.buffer.cert });
        }), !n3)
          throw new QD(xD.MULTI_UNILBS_RESPONSE_ERROR, "cannot parse response ".concat(r3, " from multi unilbs response"), { csIp: e3.detail && e3.detail[502] });
        return n3;
      }
      async function uK(e3, t3) {
        return await l_.all(e3.addresses.map(async (e4) => ({ address: rK(e4.ip), tcpport: e4.port, udpport: e4.port, username: t3 && LP("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? t3.toString() : vP.username, password: t3 && LP("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? await cj(t3.toString()) : vP.password })));
      }
      function hK(e3, t3) {
        const i3 = t3._videoWidth || t3.getMediaStreamTrack(true).getSettings().width;
        return i3 || JD.warning("cannot get original video track's width, default scale down 4 times for low stream"), i3 ? i3 / oK(e3.width) : 4;
      }
      function AK(e3) {
        let { candidateType: t3, relayProtocol: i3, type: r3, address: n3, port: o3, protocol: s3 } = e3;
        return "local-candidate" === r3 ? { candidateType: t3, relayProtocol: i3, protocol: s3 } : { candidateType: t3, relayProtocol: i3, address: n3, port: o3, protocol: s3 };
      }
      function lK(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function pK(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? lK(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : lK(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      function gK(e3) {
        return window.TextEncoder ? new TextEncoder().encode(e3).length : e3.length;
      }
      function EK(e3) {
        return new l_((t3) => {
          window.setTimeout(t3, e3);
        });
      }
      function fK(e3) {
        const t3 = new QD(xD.TIMEOUT, "timeout");
        return new l_((i3, r3) => {
          window.setTimeout(() => r3(t3), e3);
        });
      }
      function mK() {
        let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7, t3 = arguments.length > 1 ? arguments[1] : void 0;
        const i3 = Math.random().toString(16).substr(2, e3).toLowerCase();
        return i3.length === e3 ? "".concat(t3).concat(i3) : "".concat(t3).concat(i3) + mK(e3 - i3.length, "");
      }
      function IK() {
        return mK(32, "").toUpperCase();
      }
      const _K = () => {
      };
      function CK(e3) {
        return new l_((t3, i3) => {
          let r3 = false;
          const n3 = document.createElement("video");
          n3.setAttribute("autoplay", ""), n3.setAttribute("muted", ""), n3.muted = true, n3.autoplay = true, n3.setAttribute("playsinline", ""), n3.setAttribute("style", "position: fixed; top: 0; left: 0; width: 1px; height: 1px"), document.body.appendChild(n3);
          const o3 = EN() ? "canplay" : "playing";
          n3.addEventListener(o3, () => {
            const e4 = n3.videoWidth, i4 = n3.videoHeight;
            !e4 && gN() || (r3 = true, n3.srcObject = null, n3.remove(), t3([e4, i4]));
          }), n3.srcObject = new MediaStream([e3]), n3.play().catch(_K), setTimeout(() => {
            r3 || (n3.srcObject = null, n3.remove(), t3([n3.videoWidth, n3.videoHeight]));
          }, 4e3);
        });
      }
      function SK(e3) {
        return l_.all(e3.map((e4) => e4.then((e5) => {
          throw e5;
        }, (e5) => e5))).then((e4) => {
          throw e4;
        }, (e4) => e4);
      }
      function vK(e3, t3) {
        for (var i3 = arguments.length, r3 = new Array(i3 > 2 ? i3 - 2 : 0), n3 = 2; n3 < i3; n3++)
          r3[n3 - 2] = arguments[n3];
        return 0 === e3.getListeners(t3).length ? l_.reject(new QD(xD.UNEXPECTED_ERROR, "can not emit promise")) : new l_((i4, n4) => {
          e3.emit(t3, ...r3, i4, n4);
        });
      }
      function TK(e3, t3) {
        if (0 === e3.getListeners(t3).length)
          return l_.resolve();
        for (var i3 = arguments.length, r3 = new Array(i3 > 2 ? i3 - 2 : 0), n3 = 2; n3 < i3; n3++)
          r3[n3 - 2] = arguments[n3];
        return vK(e3, t3, ...r3);
      }
      function RK(e3, t3) {
        if (0 === e3.getListeners(t3).length)
          return null;
        for (var i3 = arguments.length, r3 = new Array(i3 > 2 ? i3 - 2 : 0), n3 = 2; n3 < i3; n3++)
          r3[n3 - 2] = arguments[n3];
        return yK(e3, t3, ...r3);
      }
      function yK(e3, t3) {
        let i3 = null, r3 = null;
        for (var n3 = arguments.length, o3 = new Array(n3 > 2 ? n3 - 2 : 0), s3 = 2; s3 < n3; s3++)
          o3[s3 - 2] = arguments[s3];
        if (e3.emit(t3, ...o3, (e4) => {
          i3 = e4;
        }, (e4) => {
          r3 = e4;
        }), null !== r3)
          throw r3;
        if (null === i3)
          throw new QD(xD.UNEXPECTED_ERROR, "handler is not sync");
        return i3;
      }
      function wK(e3, t3) {
        const i3 = e3.indexOf(t3);
        -1 !== i3 && e3.splice(i3, 1);
      }
      function bK(e3) {
        const t3 = [];
        return e3.forEach((e4) => {
          -1 === t3.indexOf(e4) && t3.push(e4);
        }), t3;
      }
      function NK(e3) {
        l_.resolve().then(e3);
      }
      function OK(e3) {
        return JSON.parse(JSON.stringify(e3));
      }
      const DK = {};
      function PK(e3, t3) {
        DK[t3] || (DK[t3] = true, e3());
      }
      function LK(e3) {
        const t3 = window.atob(e3), i3 = new Uint8Array(new ArrayBuffer(t3.length));
        for (let e4 = 0; e4 < t3.length; e4 += 1)
          i3[e4] = t3.charCodeAt(e4);
        return i3;
      }
      function kK(e3) {
        let t3 = "";
        for (let i3 = 0; i3 < e3.length; i3 += 1)
          t3 += String.fromCharCode(e3[i3]);
        return window.btoa(t3);
      }
      const BK = new class {
        constructor() {
          MN(this, "fnMap", /* @__PURE__ */ new Map());
        }
        throttleByKey(e3, t3, i3, r3) {
          for (var n3 = arguments.length, o3 = new Array(n3 > 4 ? n3 - 4 : 0), s3 = 4; s3 < n3; s3++)
            o3[s3 - 4] = arguments[s3];
          if (this.fnMap.has(t3)) {
            const n4 = this.fnMap.get(t3);
            if (n4.threshold !== i3) {
              n4.fn(...n4.args), clearTimeout(n4.timer);
              const s4 = window.setTimeout(() => {
                const e4 = this.fnMap.get(t3);
                e4 && e4.fn(...e4.args), this.fnMap.delete(t3);
              }, i3);
              this.fnMap.set(t3, { fn: e3, threshold: i3, timer: s4, args: o3, skipFn: r3 });
            } else
              n4.skipFn && n4.skipFn(...n4.args), this.fnMap.set(t3, pK(pK({}, n4), {}, { fn: e3, args: o3, skipFn: r3 }));
          } else {
            const n4 = window.setTimeout(() => {
              const e4 = this.fnMap.get(t3);
              e4 && e4.fn(...e4.args), this.fnMap.delete(t3);
            }, i3);
            this.fnMap.set(t3, { fn: e3, threshold: i3, timer: n4, args: o3, skipFn: r3 });
          }
        }
      }(), MK = BK.throttleByKey.bind(BK), UK = async (e3) => {
        let { fragementLength: t3, referenceList: i3, asyncMapHandler: r3, allFailedhandler: n3, promisesCollector: o3 } = e3, s3 = 0;
        const a3 = t3;
        let c3, d3 = 0;
        const u3 = async () => {
          const e4 = (() => {
            const e5 = s3 * a3, t4 = e5 + a3;
            return i3.slice(e5, t4).map(r3);
          })();
          o3 && o3.push(...e4);
          try {
            c3 = await SK(e4);
          } catch (e5) {
            if (d3 += a3, s3++, !(d3 >= i3.length))
              return void await u3();
            n3(e5);
          }
          e4.forEach((e5) => e5.cancel());
        };
        return await u3(), c3;
      };
      function xK(e3) {
        return "object" == typeof e3 && null !== e3 && !(e3 instanceof RegExp);
      }
      var QK = ln, FK = Es("iterator"), VK = !QK(function() {
        var e3 = new URL("b?a=1&b=2&c=3", "http://a"), t3 = e3.searchParams, i3 = "";
        return e3.pathname = "c%20d", t3.forEach(function(e4, r3) {
          t3.delete("b"), i3 += r3 + e4;
        }), !e3.toJSON || !t3.sort || "http://a/c%20d?a=1&c=3" !== e3.href || "3" !== t3.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t3[FK] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://\u0442\u0435\u0441\u0442").host || "#%D0%B1" !== new URL("http://a#\u0431").hash || "a1c3" !== i3 || "x" !== new URL("http://x", void 0).host;
      }), jK = Dn, GK = _n, KK = kn, HK = ln, WK = el, YK = FA, JK = Bn, qK = zo, XK = zn, zK = Object.assign, ZK = Object.defineProperty, $K = GK([].concat), eH = !zK || HK(function() {
        if (jK && 1 !== zK({ b: 1 }, zK(ZK({}, "a", { enumerable: true, get: function() {
          ZK(this, "b", { value: 3, enumerable: false });
        } }), { b: 2 })).b)
          return true;
        var e3 = {}, t3 = {}, i3 = Symbol(), r3 = "abcdefghijklmnopqrst";
        return e3[i3] = 7, r3.split("").forEach(function(e4) {
          t3[e4] = e4;
        }), 7 != zK({}, e3)[i3] || WK(zK({}, t3)).join("") != r3;
      }) ? function(e3, t3) {
        for (var i3 = qK(e3), r3 = arguments.length, n3 = 1, o3 = YK.f, s3 = JK.f; r3 > n3; )
          for (var a3, c3 = XK(arguments[n3++]), d3 = o3 ? $K(WK(c3), o3(c3)) : WK(c3), u3 = d3.length, h3 = 0; u3 > h3; )
            a3 = d3[h3++], jK && !KK(s3, c3, a3) || (i3[a3] = c3[a3]);
        return i3;
      } : zK, tH = ca, iH = rp, rH = ta, nH = kn, oH = zo, sH = function(e3, t3, i3, r3) {
        try {
          return r3 ? t3(tH(i3)[0], i3[1]) : t3(i3);
        } catch (t4) {
          iH(e3, "throw", t4);
        }
      }, aH = Dl, cH = ZE, dH = Va, uH = WP, hH = $l, AH = Wl, lH = vn.Array, pH = _n, gH = 2147483647, EH = /[^\0-\u007E]/, fH = /[.\u3002\uFF0E\uFF61]/g, mH = "Overflow: input needs wider integers to process", IH = vn.RangeError, _H = pH(fH.exec), CH = Math.floor, SH = String.fromCharCode, vH = pH("".charCodeAt), TH = pH([].join), RH = pH([].push), yH = pH("".replace), wH = pH("".split), bH = pH("".toLowerCase), NH = function(e3) {
        return e3 + 22 + 75 * (e3 < 26);
      }, OH = function(e3, t3, i3) {
        var r3 = 0;
        for (e3 = i3 ? CH(e3 / 700) : e3 >> 1, e3 += CH(e3 / t3); e3 > 455; )
          e3 = CH(e3 / 35), r3 += 36;
        return CH(r3 + 36 * e3 / (e3 + 38));
      }, DH = function(e3) {
        var t3, i3, r3 = [], n3 = (e3 = function(e4) {
          for (var t4 = [], i4 = 0, r4 = e4.length; i4 < r4; ) {
            var n4 = vH(e4, i4++);
            if (n4 >= 55296 && n4 <= 56319 && i4 < r4) {
              var o4 = vH(e4, i4++);
              56320 == (64512 & o4) ? RH(t4, ((1023 & n4) << 10) + (1023 & o4) + 65536) : (RH(t4, n4), i4--);
            } else
              RH(t4, n4);
          }
          return t4;
        }(e3)).length, o3 = 128, s3 = 0, a3 = 72;
        for (t3 = 0; t3 < e3.length; t3++)
          (i3 = e3[t3]) < 128 && RH(r3, SH(i3));
        var c3 = r3.length, d3 = c3;
        for (c3 && RH(r3, "-"); d3 < n3; ) {
          var u3 = gH;
          for (t3 = 0; t3 < e3.length; t3++)
            (i3 = e3[t3]) >= o3 && i3 < u3 && (u3 = i3);
          var h3 = d3 + 1;
          if (u3 - o3 > CH((gH - s3) / h3))
            throw IH(mH);
          for (s3 += (u3 - o3) * h3, o3 = u3, t3 = 0; t3 < e3.length; t3++) {
            if ((i3 = e3[t3]) < o3 && ++s3 > gH)
              throw IH(mH);
            if (i3 == o3) {
              for (var A3 = s3, l3 = 36; ; ) {
                var p3 = l3 <= a3 ? 1 : l3 >= a3 + 26 ? 26 : l3 - a3;
                if (A3 < p3)
                  break;
                var g3 = A3 - p3, E3 = 36 - p3;
                RH(r3, SH(NH(p3 + g3 % E3))), A3 = CH(g3 / E3), l3 += 36;
              }
              RH(r3, SH(NH(A3))), a3 = OH(s3, h3, d3 == c3), s3 = 0, d3++;
            }
          }
          s3++, o3++;
        }
        return TH(r3, "");
      }, PH = vn.TypeError, LH = ka, kH = vn, BH = ho, MH = kn, UH = _n, xH = VK, QH = wg, FH = vE, VH = Hg, jH = Zg, GH = Ig, KH = OE, HH = Nn, WH = es, YH = ta, JH = Vl, qH = ca, XH = no, zH = _p, ZH = _l, $H = Vn, eW = $l, tW = Wl, iW = function(e3, t3) {
        if (e3 < t3)
          throw PH("Not enough arguments");
        return e3;
      }, rW = nL, nW = Es("iterator"), oW = "URLSearchParams", sW = "URLSearchParamsIterator", aW = GH.set, cW = GH.getterFor(oW), dW = GH.getterFor(sW), uW = BH("fetch"), hW = BH("Request"), AW = BH("Headers"), lW = hW && hW.prototype, pW = AW && AW.prototype, gW = kH.RegExp, EW = kH.TypeError, fW = kH.decodeURIComponent, mW = kH.encodeURIComponent, IW = UH("".charAt), _W = UH([].join), CW = UH([].push), SW = UH("".replace), vW = UH([].shift), TW = UH([].splice), RW = UH("".split), yW = UH("".slice), wW = /\+/g, bW = Array(4), NW = function(e3) {
        return bW[e3 - 1] || (bW[e3 - 1] = gW("((?:%[\\da-f]{2}){" + e3 + "})", "gi"));
      }, OW = function(e3) {
        try {
          return fW(e3);
        } catch (t3) {
          return e3;
        }
      }, DW = function(e3) {
        var t3 = SW(e3, wW, " "), i3 = 4;
        try {
          return fW(t3);
        } catch (e4) {
          for (; i3; )
            t3 = SW(t3, NW(i3--), OW);
          return t3;
        }
      }, PW = /[!'()~]|%20/g, LW = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" }, kW = function(e3) {
        return LW[e3];
      }, BW = function(e3) {
        return SW(mW(e3), PW, kW);
      }, MW = jH(function(e3, t3) {
        aW(this, { type: sW, iterator: eW(cW(e3).entries), kind: t3 });
      }, "Iterator", function() {
        var e3 = dW(this), t3 = e3.kind, i3 = e3.iterator.next(), r3 = i3.value;
        return i3.done || (i3.value = "keys" === t3 ? r3.key : "values" === t3 ? r3.value : [r3.key, r3.value]), i3;
      }, true), UW = function(e3) {
        this.entries = [], this.url = null, void 0 !== e3 && (XH(e3) ? this.parseObject(e3) : this.parseQuery("string" == typeof e3 ? "?" === IW(e3, 0) ? yW(e3, 1) : e3 : zH(e3)));
      };
      UW.prototype = { type: oW, bindURL: function(e3) {
        this.url = e3, this.update();
      }, parseObject: function(e3) {
        var t3, i3, r3, n3, o3, s3, a3, c3 = tW(e3);
        if (c3)
          for (i3 = (t3 = eW(e3, c3)).next; !(r3 = MH(i3, t3)).done; ) {
            if (o3 = (n3 = eW(qH(r3.value))).next, (s3 = MH(o3, n3)).done || (a3 = MH(o3, n3)).done || !MH(o3, n3).done)
              throw EW("Expected sequence with length 2");
            CW(this.entries, { key: zH(s3.value), value: zH(a3.value) });
          }
        else
          for (var d3 in e3)
            WH(e3, d3) && CW(this.entries, { key: d3, value: zH(e3[d3]) });
      }, parseQuery: function(e3) {
        if (e3)
          for (var t3, i3, r3 = RW(e3, "&"), n3 = 0; n3 < r3.length; )
            (t3 = r3[n3++]).length && (i3 = RW(t3, "="), CW(this.entries, { key: DW(vW(i3)), value: DW(_W(i3, "=")) }));
      }, serialize: function() {
        for (var e3, t3 = this.entries, i3 = [], r3 = 0; r3 < t3.length; )
          e3 = t3[r3++], CW(i3, BW(e3.key) + "=" + BW(e3.value));
        return _W(i3, "&");
      }, update: function() {
        this.entries.length = 0, this.parseQuery(this.url.query);
      }, updateURL: function() {
        this.url && this.url.update();
      } };
      var xW = function() {
        KH(this, QW);
        var e3 = arguments.length > 0 ? arguments[0] : void 0;
        aW(this, new UW(e3));
      }, QW = xW.prototype;
      if (FH(QW, { append: function(e3, t3) {
        iW(arguments.length, 2);
        var i3 = cW(this);
        CW(i3.entries, { key: zH(e3), value: zH(t3) }), i3.updateURL();
      }, delete: function(e3) {
        iW(arguments.length, 1);
        for (var t3 = cW(this), i3 = t3.entries, r3 = zH(e3), n3 = 0; n3 < i3.length; )
          i3[n3].key === r3 ? TW(i3, n3, 1) : n3++;
        t3.updateURL();
      }, get: function(e3) {
        iW(arguments.length, 1);
        for (var t3 = cW(this).entries, i3 = zH(e3), r3 = 0; r3 < t3.length; r3++)
          if (t3[r3].key === i3)
            return t3[r3].value;
        return null;
      }, getAll: function(e3) {
        iW(arguments.length, 1);
        for (var t3 = cW(this).entries, i3 = zH(e3), r3 = [], n3 = 0; n3 < t3.length; n3++)
          t3[n3].key === i3 && CW(r3, t3[n3].value);
        return r3;
      }, has: function(e3) {
        iW(arguments.length, 1);
        for (var t3 = cW(this).entries, i3 = zH(e3), r3 = 0; r3 < t3.length; )
          if (t3[r3++].key === i3)
            return true;
        return false;
      }, set: function(e3, t3) {
        iW(arguments.length, 1);
        for (var i3, r3 = cW(this), n3 = r3.entries, o3 = false, s3 = zH(e3), a3 = zH(t3), c3 = 0; c3 < n3.length; c3++)
          (i3 = n3[c3]).key === s3 && (o3 ? TW(n3, c3--, 1) : (o3 = true, i3.value = a3));
        o3 || CW(n3, { key: s3, value: a3 }), r3.updateURL();
      }, sort: function() {
        var e3 = cW(this);
        rW(e3.entries, function(e4, t3) {
          return e4.key > t3.key ? 1 : -1;
        }), e3.updateURL();
      }, forEach: function(e3) {
        for (var t3, i3 = cW(this).entries, r3 = YH(e3, arguments.length > 1 ? arguments[1] : void 0), n3 = 0; n3 < i3.length; )
          r3((t3 = i3[n3++]).value, t3.key, this);
      }, keys: function() {
        return new MW(this, "keys");
      }, values: function() {
        return new MW(this, "values");
      }, entries: function() {
        return new MW(this, "entries");
      } }, { enumerable: true }), QH(QW, nW, QW.entries, { name: "entries" }), QH(QW, "toString", function() {
        return cW(this).serialize();
      }, { enumerable: true }), VH(xW, oW), LH({ global: true, forced: !xH }, { URLSearchParams: xW }), !xH && HH(AW)) {
        var FW = UH(pW.has), VW = UH(pW.set), jW = function(e3) {
          if (XH(e3)) {
            var t3, i3 = e3.body;
            if (JH(i3) === oW)
              return t3 = e3.headers ? new AW(e3.headers) : new AW(), FW(t3, "content-type") || VW(t3, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), ZH(e3, { body: $H(0, zH(i3)), headers: $H(0, t3) });
          }
          return e3;
        };
        if (HH(uW) && LH({ global: true, enumerable: true, forced: true }, { fetch: function(e3) {
          return uW(e3, arguments.length > 1 ? jW(arguments[1]) : {});
        } }), HH(hW)) {
          var GW = function(e3) {
            return KH(this, lW), new hW(e3, arguments.length > 1 ? jW(arguments[1]) : {});
          };
          lW.constructor = GW, GW.prototype = lW, LH({ global: true, forced: true }, { Request: GW });
        }
      }
      var KW, HW = { URLSearchParams: xW, getState: cW }, WW = ka, YW = Dn, JW = VK, qW = vn, XW = ta, zW = _n, ZW = zA.f, $W = wg, eY = OE, tY = es, iY = eH, rY = function(e3) {
        var t3 = oH(e3), i3 = cH(this), r3 = arguments.length, n3 = r3 > 1 ? arguments[1] : void 0, o3 = void 0 !== n3;
        o3 && (n3 = rH(n3, r3 > 2 ? arguments[2] : void 0));
        var s3, a3, c3, d3, u3, h3, A3 = AH(t3), l3 = 0;
        if (!A3 || this == lH && aH(A3))
          for (s3 = dH(t3), a3 = i3 ? new this(s3) : lH(s3); s3 > l3; l3++)
            h3 = o3 ? n3(t3[l3], l3) : t3[l3], uH(a3, l3, h3);
        else
          for (u3 = (d3 = hH(t3, A3)).next, a3 = i3 ? new this() : []; !(c3 = nH(u3, d3)).done; l3++)
            h3 = o3 ? sH(d3, n3, [c3.value, l3], true) : c3.value, uH(a3, l3, h3);
        return a3.length = l3, a3;
      }, nY = ZP, oY = JI.codeAt, sY = function(e3) {
        var t3, i3, r3 = [], n3 = wH(yH(bH(e3), fH, "."), ".");
        for (t3 = 0; t3 < n3.length; t3++)
          i3 = n3[t3], RH(r3, _H(EH, i3) ? "xn--" + DH(i3) : i3);
        return TH(r3, ".");
      }, aY = _p, cY = Hg, dY = HW, uY = Ig, hY = uY.set, AY = uY.getterFor("URL"), lY = dY.URLSearchParams, pY = dY.getState, gY = qW.URL, EY = qW.TypeError, fY = qW.parseInt, mY = Math.floor, IY = Math.pow, _Y = zW("".charAt), CY = zW(/./.exec), SY = zW([].join), vY = zW(1 .toString), TY = zW([].pop), RY = zW([].push), yY = zW("".replace), wY = zW([].shift), bY = zW("".split), NY = zW("".slice), OY = zW("".toLowerCase), DY = zW([].unshift), PY = "Invalid scheme", LY = "Invalid host", kY = "Invalid port", BY = /[a-z]/i, MY = /[\d+-.a-z]/i, UY = /\d/, xY = /^0x/i, QY = /^[0-7]+$/, FY = /^\d+$/, VY = /^[\da-f]+$/i, jY = /[\0\t\n\r #%/:<>?@[\\\]^|]/, GY = /[\0\t\n\r #/:<>?@[\\\]^|]/, KY = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g, HY = /[\t\n\r]/g, WY = function(e3) {
        var t3, i3, r3, n3;
        if ("number" == typeof e3) {
          for (t3 = [], i3 = 0; i3 < 4; i3++)
            DY(t3, e3 % 256), e3 = mY(e3 / 256);
          return SY(t3, ".");
        }
        if ("object" == typeof e3) {
          for (t3 = "", r3 = function(e4) {
            for (var t4 = null, i4 = 1, r4 = null, n4 = 0, o3 = 0; o3 < 8; o3++)
              0 !== e4[o3] ? (n4 > i4 && (t4 = r4, i4 = n4), r4 = null, n4 = 0) : (null === r4 && (r4 = o3), ++n4);
            return n4 > i4 && (t4 = r4, i4 = n4), t4;
          }(e3), i3 = 0; i3 < 8; i3++)
            n3 && 0 === e3[i3] || (n3 && (n3 = false), r3 === i3 ? (t3 += i3 ? ":" : "::", n3 = true) : (t3 += vY(e3[i3], 16), i3 < 7 && (t3 += ":")));
          return "[" + t3 + "]";
        }
        return e3;
      }, YY = {}, JY = iY({}, YY, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }), qY = iY({}, JY, { "#": 1, "?": 1, "{": 1, "}": 1 }), XY = iY({}, qY, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }), zY = function(e3, t3) {
        var i3 = oY(e3, 0);
        return i3 > 32 && i3 < 127 && !tY(t3, e3) ? e3 : encodeURIComponent(e3);
      }, ZY = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, $Y = function(e3, t3) {
        var i3;
        return 2 == e3.length && CY(BY, _Y(e3, 0)) && (":" == (i3 = _Y(e3, 1)) || !t3 && "|" == i3);
      }, eJ = function(e3) {
        var t3;
        return e3.length > 1 && $Y(NY(e3, 0, 2)) && (2 == e3.length || "/" === (t3 = _Y(e3, 2)) || "\\" === t3 || "?" === t3 || "#" === t3);
      }, tJ = function(e3) {
        return "." === e3 || "%2e" === OY(e3);
      }, iJ = {}, rJ = {}, nJ = {}, oJ = {}, sJ = {}, aJ = {}, cJ = {}, dJ = {}, uJ = {}, hJ = {}, AJ = {}, lJ = {}, pJ = {}, gJ = {}, EJ = {}, fJ = {}, mJ = {}, IJ = {}, _J = {}, CJ = {}, SJ = {}, vJ = function(e3, t3, i3) {
        var r3, n3, o3, s3 = aY(e3);
        if (t3) {
          if (n3 = this.parse(s3))
            throw EY(n3);
          this.searchParams = null;
        } else {
          if (void 0 !== i3 && (r3 = new vJ(i3, true)), n3 = this.parse(s3, null, r3))
            throw EY(n3);
          (o3 = pY(new lY())).bindURL(this), this.searchParams = o3;
        }
      };
      vJ.prototype = { type: "URL", parse: function(e3, t3, i3) {
        var r3, n3, o3, s3, a3, c3 = this, d3 = t3 || iJ, u3 = 0, h3 = "", A3 = false, l3 = false, p3 = false;
        for (e3 = aY(e3), t3 || (c3.scheme = "", c3.username = "", c3.password = "", c3.host = null, c3.port = null, c3.path = [], c3.query = null, c3.fragment = null, c3.cannotBeABaseURL = false, e3 = yY(e3, KY, "")), e3 = yY(e3, HY, ""), r3 = rY(e3); u3 <= r3.length; ) {
          switch (n3 = r3[u3], d3) {
            case iJ:
              if (!n3 || !CY(BY, n3)) {
                if (t3)
                  return PY;
                d3 = nJ;
                continue;
              }
              h3 += OY(n3), d3 = rJ;
              break;
            case rJ:
              if (n3 && (CY(MY, n3) || "+" == n3 || "-" == n3 || "." == n3))
                h3 += OY(n3);
              else {
                if (":" != n3) {
                  if (t3)
                    return PY;
                  h3 = "", d3 = nJ, u3 = 0;
                  continue;
                }
                if (t3 && (c3.isSpecial() != tY(ZY, h3) || "file" == h3 && (c3.includesCredentials() || null !== c3.port) || "file" == c3.scheme && !c3.host))
                  return;
                if (c3.scheme = h3, t3)
                  return void (c3.isSpecial() && ZY[c3.scheme] == c3.port && (c3.port = null));
                h3 = "", "file" == c3.scheme ? d3 = gJ : c3.isSpecial() && i3 && i3.scheme == c3.scheme ? d3 = oJ : c3.isSpecial() ? d3 = dJ : "/" == r3[u3 + 1] ? (d3 = sJ, u3++) : (c3.cannotBeABaseURL = true, RY(c3.path, ""), d3 = _J);
              }
              break;
            case nJ:
              if (!i3 || i3.cannotBeABaseURL && "#" != n3)
                return PY;
              if (i3.cannotBeABaseURL && "#" == n3) {
                c3.scheme = i3.scheme, c3.path = nY(i3.path), c3.query = i3.query, c3.fragment = "", c3.cannotBeABaseURL = true, d3 = SJ;
                break;
              }
              d3 = "file" == i3.scheme ? gJ : aJ;
              continue;
            case oJ:
              if ("/" != n3 || "/" != r3[u3 + 1]) {
                d3 = aJ;
                continue;
              }
              d3 = uJ, u3++;
              break;
            case sJ:
              if ("/" == n3) {
                d3 = hJ;
                break;
              }
              d3 = IJ;
              continue;
            case aJ:
              if (c3.scheme = i3.scheme, n3 == KW)
                c3.username = i3.username, c3.password = i3.password, c3.host = i3.host, c3.port = i3.port, c3.path = nY(i3.path), c3.query = i3.query;
              else if ("/" == n3 || "\\" == n3 && c3.isSpecial())
                d3 = cJ;
              else if ("?" == n3)
                c3.username = i3.username, c3.password = i3.password, c3.host = i3.host, c3.port = i3.port, c3.path = nY(i3.path), c3.query = "", d3 = CJ;
              else {
                if ("#" != n3) {
                  c3.username = i3.username, c3.password = i3.password, c3.host = i3.host, c3.port = i3.port, c3.path = nY(i3.path), c3.path.length--, d3 = IJ;
                  continue;
                }
                c3.username = i3.username, c3.password = i3.password, c3.host = i3.host, c3.port = i3.port, c3.path = nY(i3.path), c3.query = i3.query, c3.fragment = "", d3 = SJ;
              }
              break;
            case cJ:
              if (!c3.isSpecial() || "/" != n3 && "\\" != n3) {
                if ("/" != n3) {
                  c3.username = i3.username, c3.password = i3.password, c3.host = i3.host, c3.port = i3.port, d3 = IJ;
                  continue;
                }
                d3 = hJ;
              } else
                d3 = uJ;
              break;
            case dJ:
              if (d3 = uJ, "/" != n3 || "/" != _Y(h3, u3 + 1))
                continue;
              u3++;
              break;
            case uJ:
              if ("/" != n3 && "\\" != n3) {
                d3 = hJ;
                continue;
              }
              break;
            case hJ:
              if ("@" == n3) {
                A3 && (h3 = "%40" + h3), A3 = true, o3 = rY(h3);
                for (var g3 = 0; g3 < o3.length; g3++) {
                  var E3 = o3[g3];
                  if (":" != E3 || p3) {
                    var f3 = zY(E3, XY);
                    p3 ? c3.password += f3 : c3.username += f3;
                  } else
                    p3 = true;
                }
                h3 = "";
              } else if (n3 == KW || "/" == n3 || "?" == n3 || "#" == n3 || "\\" == n3 && c3.isSpecial()) {
                if (A3 && "" == h3)
                  return "Invalid authority";
                u3 -= rY(h3).length + 1, h3 = "", d3 = AJ;
              } else
                h3 += n3;
              break;
            case AJ:
            case lJ:
              if (t3 && "file" == c3.scheme) {
                d3 = fJ;
                continue;
              }
              if (":" != n3 || l3) {
                if (n3 == KW || "/" == n3 || "?" == n3 || "#" == n3 || "\\" == n3 && c3.isSpecial()) {
                  if (c3.isSpecial() && "" == h3)
                    return LY;
                  if (t3 && "" == h3 && (c3.includesCredentials() || null !== c3.port))
                    return;
                  if (s3 = c3.parseHost(h3))
                    return s3;
                  if (h3 = "", d3 = mJ, t3)
                    return;
                  continue;
                }
                "[" == n3 ? l3 = true : "]" == n3 && (l3 = false), h3 += n3;
              } else {
                if ("" == h3)
                  return LY;
                if (s3 = c3.parseHost(h3))
                  return s3;
                if (h3 = "", d3 = pJ, t3 == lJ)
                  return;
              }
              break;
            case pJ:
              if (!CY(UY, n3)) {
                if (n3 == KW || "/" == n3 || "?" == n3 || "#" == n3 || "\\" == n3 && c3.isSpecial() || t3) {
                  if ("" != h3) {
                    var m3 = fY(h3, 10);
                    if (m3 > 65535)
                      return kY;
                    c3.port = c3.isSpecial() && m3 === ZY[c3.scheme] ? null : m3, h3 = "";
                  }
                  if (t3)
                    return;
                  d3 = mJ;
                  continue;
                }
                return kY;
              }
              h3 += n3;
              break;
            case gJ:
              if (c3.scheme = "file", "/" == n3 || "\\" == n3)
                d3 = EJ;
              else {
                if (!i3 || "file" != i3.scheme) {
                  d3 = IJ;
                  continue;
                }
                if (n3 == KW)
                  c3.host = i3.host, c3.path = nY(i3.path), c3.query = i3.query;
                else if ("?" == n3)
                  c3.host = i3.host, c3.path = nY(i3.path), c3.query = "", d3 = CJ;
                else {
                  if ("#" != n3) {
                    eJ(SY(nY(r3, u3), "")) || (c3.host = i3.host, c3.path = nY(i3.path), c3.shortenPath()), d3 = IJ;
                    continue;
                  }
                  c3.host = i3.host, c3.path = nY(i3.path), c3.query = i3.query, c3.fragment = "", d3 = SJ;
                }
              }
              break;
            case EJ:
              if ("/" == n3 || "\\" == n3) {
                d3 = fJ;
                break;
              }
              i3 && "file" == i3.scheme && !eJ(SY(nY(r3, u3), "")) && ($Y(i3.path[0], true) ? RY(c3.path, i3.path[0]) : c3.host = i3.host), d3 = IJ;
              continue;
            case fJ:
              if (n3 == KW || "/" == n3 || "\\" == n3 || "?" == n3 || "#" == n3) {
                if (!t3 && $Y(h3))
                  d3 = IJ;
                else if ("" == h3) {
                  if (c3.host = "", t3)
                    return;
                  d3 = mJ;
                } else {
                  if (s3 = c3.parseHost(h3))
                    return s3;
                  if ("localhost" == c3.host && (c3.host = ""), t3)
                    return;
                  h3 = "", d3 = mJ;
                }
                continue;
              }
              h3 += n3;
              break;
            case mJ:
              if (c3.isSpecial()) {
                if (d3 = IJ, "/" != n3 && "\\" != n3)
                  continue;
              } else if (t3 || "?" != n3)
                if (t3 || "#" != n3) {
                  if (n3 != KW && (d3 = IJ, "/" != n3))
                    continue;
                } else
                  c3.fragment = "", d3 = SJ;
              else
                c3.query = "", d3 = CJ;
              break;
            case IJ:
              if (n3 == KW || "/" == n3 || "\\" == n3 && c3.isSpecial() || !t3 && ("?" == n3 || "#" == n3)) {
                if (".." === (a3 = OY(a3 = h3)) || "%2e." === a3 || ".%2e" === a3 || "%2e%2e" === a3 ? (c3.shortenPath(), "/" == n3 || "\\" == n3 && c3.isSpecial() || RY(c3.path, "")) : tJ(h3) ? "/" == n3 || "\\" == n3 && c3.isSpecial() || RY(c3.path, "") : ("file" == c3.scheme && !c3.path.length && $Y(h3) && (c3.host && (c3.host = ""), h3 = _Y(h3, 0) + ":"), RY(c3.path, h3)), h3 = "", "file" == c3.scheme && (n3 == KW || "?" == n3 || "#" == n3))
                  for (; c3.path.length > 1 && "" === c3.path[0]; )
                    wY(c3.path);
                "?" == n3 ? (c3.query = "", d3 = CJ) : "#" == n3 && (c3.fragment = "", d3 = SJ);
              } else
                h3 += zY(n3, qY);
              break;
            case _J:
              "?" == n3 ? (c3.query = "", d3 = CJ) : "#" == n3 ? (c3.fragment = "", d3 = SJ) : n3 != KW && (c3.path[0] += zY(n3, YY));
              break;
            case CJ:
              t3 || "#" != n3 ? n3 != KW && ("'" == n3 && c3.isSpecial() ? c3.query += "%27" : c3.query += "#" == n3 ? "%23" : zY(n3, YY)) : (c3.fragment = "", d3 = SJ);
              break;
            case SJ:
              n3 != KW && (c3.fragment += zY(n3, JY));
          }
          u3++;
        }
      }, parseHost: function(e3) {
        var t3, i3, r3;
        if ("[" == _Y(e3, 0)) {
          if ("]" != _Y(e3, e3.length - 1))
            return LY;
          if (!(t3 = function(e4) {
            var t4, i4, r4, n3, o3, s3, a3, c3 = [0, 0, 0, 0, 0, 0, 0, 0], d3 = 0, u3 = null, h3 = 0, A3 = function() {
              return _Y(e4, h3);
            };
            if (":" == A3()) {
              if (":" != _Y(e4, 1))
                return;
              h3 += 2, u3 = ++d3;
            }
            for (; A3(); ) {
              if (8 == d3)
                return;
              if (":" != A3()) {
                for (t4 = i4 = 0; i4 < 4 && CY(VY, A3()); )
                  t4 = 16 * t4 + fY(A3(), 16), h3++, i4++;
                if ("." == A3()) {
                  if (0 == i4)
                    return;
                  if (h3 -= i4, d3 > 6)
                    return;
                  for (r4 = 0; A3(); ) {
                    if (n3 = null, r4 > 0) {
                      if (!("." == A3() && r4 < 4))
                        return;
                      h3++;
                    }
                    if (!CY(UY, A3()))
                      return;
                    for (; CY(UY, A3()); ) {
                      if (o3 = fY(A3(), 10), null === n3)
                        n3 = o3;
                      else {
                        if (0 == n3)
                          return;
                        n3 = 10 * n3 + o3;
                      }
                      if (n3 > 255)
                        return;
                      h3++;
                    }
                    c3[d3] = 256 * c3[d3] + n3, 2 != ++r4 && 4 != r4 || d3++;
                  }
                  if (4 != r4)
                    return;
                  break;
                }
                if (":" == A3()) {
                  if (h3++, !A3())
                    return;
                } else if (A3())
                  return;
                c3[d3++] = t4;
              } else {
                if (null !== u3)
                  return;
                h3++, u3 = ++d3;
              }
            }
            if (null !== u3)
              for (s3 = d3 - u3, d3 = 7; 0 != d3 && s3 > 0; )
                a3 = c3[d3], c3[d3--] = c3[u3 + s3 - 1], c3[u3 + --s3] = a3;
            else if (8 != d3)
              return;
            return c3;
          }(NY(e3, 1, -1))))
            return LY;
          this.host = t3;
        } else if (this.isSpecial()) {
          if (e3 = sY(e3), CY(jY, e3))
            return LY;
          if (null === (t3 = function(e4) {
            var t4, i4, r4, n3, o3, s3, a3, c3 = bY(e4, ".");
            if (c3.length && "" == c3[c3.length - 1] && c3.length--, (t4 = c3.length) > 4)
              return e4;
            for (i4 = [], r4 = 0; r4 < t4; r4++) {
              if ("" == (n3 = c3[r4]))
                return e4;
              if (o3 = 10, n3.length > 1 && "0" == _Y(n3, 0) && (o3 = CY(xY, n3) ? 16 : 8, n3 = NY(n3, 8 == o3 ? 1 : 2)), "" === n3)
                s3 = 0;
              else {
                if (!CY(10 == o3 ? FY : 8 == o3 ? QY : VY, n3))
                  return e4;
                s3 = fY(n3, o3);
              }
              RY(i4, s3);
            }
            for (r4 = 0; r4 < t4; r4++)
              if (s3 = i4[r4], r4 == t4 - 1) {
                if (s3 >= IY(256, 5 - t4))
                  return null;
              } else if (s3 > 255)
                return null;
            for (a3 = TY(i4), r4 = 0; r4 < i4.length; r4++)
              a3 += i4[r4] * IY(256, 3 - r4);
            return a3;
          }(e3)))
            return LY;
          this.host = t3;
        } else {
          if (CY(GY, e3))
            return LY;
          for (t3 = "", i3 = rY(e3), r3 = 0; r3 < i3.length; r3++)
            t3 += zY(i3[r3], YY);
          this.host = t3;
        }
      }, cannotHaveUsernamePasswordPort: function() {
        return !this.host || this.cannotBeABaseURL || "file" == this.scheme;
      }, includesCredentials: function() {
        return "" != this.username || "" != this.password;
      }, isSpecial: function() {
        return tY(ZY, this.scheme);
      }, shortenPath: function() {
        var e3 = this.path, t3 = e3.length;
        !t3 || "file" == this.scheme && 1 == t3 && $Y(e3[0], true) || e3.length--;
      }, serialize: function() {
        var e3 = this, t3 = e3.scheme, i3 = e3.username, r3 = e3.password, n3 = e3.host, o3 = e3.port, s3 = e3.path, a3 = e3.query, c3 = e3.fragment, d3 = t3 + ":";
        return null !== n3 ? (d3 += "//", e3.includesCredentials() && (d3 += i3 + (r3 ? ":" + r3 : "") + "@"), d3 += WY(n3), null !== o3 && (d3 += ":" + o3)) : "file" == t3 && (d3 += "//"), d3 += e3.cannotBeABaseURL ? s3[0] : s3.length ? "/" + SY(s3, "/") : "", null !== a3 && (d3 += "?" + a3), null !== c3 && (d3 += "#" + c3), d3;
      }, setHref: function(e3) {
        var t3 = this.parse(e3);
        if (t3)
          throw EY(t3);
        this.searchParams.update();
      }, getOrigin: function() {
        var e3 = this.scheme, t3 = this.port;
        if ("blob" == e3)
          try {
            return new TJ(e3.path[0]).origin;
          } catch (e4) {
            return "null";
          }
        return "file" != e3 && this.isSpecial() ? e3 + "://" + WY(this.host) + (null !== t3 ? ":" + t3 : "") : "null";
      }, getProtocol: function() {
        return this.scheme + ":";
      }, setProtocol: function(e3) {
        this.parse(aY(e3) + ":", iJ);
      }, getUsername: function() {
        return this.username;
      }, setUsername: function(e3) {
        var t3 = rY(aY(e3));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.username = "";
          for (var i3 = 0; i3 < t3.length; i3++)
            this.username += zY(t3[i3], XY);
        }
      }, getPassword: function() {
        return this.password;
      }, setPassword: function(e3) {
        var t3 = rY(aY(e3));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.password = "";
          for (var i3 = 0; i3 < t3.length; i3++)
            this.password += zY(t3[i3], XY);
        }
      }, getHost: function() {
        var e3 = this.host, t3 = this.port;
        return null === e3 ? "" : null === t3 ? WY(e3) : WY(e3) + ":" + t3;
      }, setHost: function(e3) {
        this.cannotBeABaseURL || this.parse(e3, AJ);
      }, getHostname: function() {
        var e3 = this.host;
        return null === e3 ? "" : WY(e3);
      }, setHostname: function(e3) {
        this.cannotBeABaseURL || this.parse(e3, lJ);
      }, getPort: function() {
        var e3 = this.port;
        return null === e3 ? "" : aY(e3);
      }, setPort: function(e3) {
        this.cannotHaveUsernamePasswordPort() || ("" == (e3 = aY(e3)) ? this.port = null : this.parse(e3, pJ));
      }, getPathname: function() {
        var e3 = this.path;
        return this.cannotBeABaseURL ? e3[0] : e3.length ? "/" + SY(e3, "/") : "";
      }, setPathname: function(e3) {
        this.cannotBeABaseURL || (this.path = [], this.parse(e3, mJ));
      }, getSearch: function() {
        var e3 = this.query;
        return e3 ? "?" + e3 : "";
      }, setSearch: function(e3) {
        "" == (e3 = aY(e3)) ? this.query = null : ("?" == _Y(e3, 0) && (e3 = NY(e3, 1)), this.query = "", this.parse(e3, CJ)), this.searchParams.update();
      }, getSearchParams: function() {
        return this.searchParams.facade;
      }, getHash: function() {
        var e3 = this.fragment;
        return e3 ? "#" + e3 : "";
      }, setHash: function(e3) {
        "" != (e3 = aY(e3)) ? ("#" == _Y(e3, 0) && (e3 = NY(e3, 1)), this.fragment = "", this.parse(e3, SJ)) : this.fragment = null;
      }, update: function() {
        this.query = this.searchParams.serialize() || null;
      } };
      var TJ = function(e3) {
        var t3 = eY(this, RJ), i3 = arguments.length > 1 ? arguments[1] : void 0, r3 = hY(t3, new vJ(e3, false, i3));
        YW || (t3.href = r3.serialize(), t3.origin = r3.getOrigin(), t3.protocol = r3.getProtocol(), t3.username = r3.getUsername(), t3.password = r3.getPassword(), t3.host = r3.getHost(), t3.hostname = r3.getHostname(), t3.port = r3.getPort(), t3.pathname = r3.getPathname(), t3.search = r3.getSearch(), t3.searchParams = r3.getSearchParams(), t3.hash = r3.getHash());
      }, RJ = TJ.prototype, yJ = function(e3, t3) {
        return { get: function() {
          return AY(this)[e3]();
        }, set: t3 && function(e4) {
          return AY(this)[t3](e4);
        }, configurable: true, enumerable: true };
      };
      if (YW && ZW(RJ, { href: yJ("serialize", "setHref"), origin: yJ("getOrigin"), protocol: yJ("getProtocol", "setProtocol"), username: yJ("getUsername", "setUsername"), password: yJ("getPassword", "setPassword"), host: yJ("getHost", "setHost"), hostname: yJ("getHostname", "setHostname"), port: yJ("getPort", "setPort"), pathname: yJ("getPathname", "setPathname"), search: yJ("getSearch", "setSearch"), searchParams: yJ("getSearchParams"), hash: yJ("getHash", "setHash") }), $W(RJ, "toJSON", function() {
        return AY(this).serialize();
      }, { enumerable: true }), $W(RJ, "toString", function() {
        return AY(this).serialize();
      }, { enumerable: true }), gY) {
        var wJ = gY.createObjectURL, bJ = gY.revokeObjectURL;
        wJ && $W(TJ, "createObjectURL", XW(wJ, gY)), bJ && $W(TJ, "revokeObjectURL", XW(bJ, gY));
      }
      cY(TJ, "URL"), WW({ global: true, forced: !JW, sham: !YW }, { URL: TJ });
      var NJ = oo.URL;
      const OJ = { [ak.ACCESS_POINT]: { [uk.NO_FLAG_SET]: { desc: "flag is zero", retry: false }, [uk.FLAG_SET_BUT_EMPTY]: { desc: "flag is empty", retry: false }, [uk.INVALID_FALG_SET]: { desc: "invalid flag", retry: false }, [uk.FLAG_SET_BUT_NO_RE]: { desc: "flag set unilbs but no request", retry: false }, [uk.INVALID_SERVICE_ID]: { desc: "invalid service id", retry: false }, [uk.NO_SERVICE_AVAILABLE]: { desc: "no service available", retry: true }, [uk.NO_SERVICE_AVAILABLE_P2P]: { desc: "no unilbs p2p service available", retry: true }, [uk.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voice service available", retry: true }, [uk.NO_SERVICE_AVAILABLE_WEBRTC]: { desc: "no unilbs webrtc service available", retry: true }, [uk.NO_SERVICE_AVAILABLE_CDS]: { desc: "no cds service available", retry: true }, [uk.NO_SERVICE_AVAILABLE_CDN]: { desc: "no cdn dispatcher service available", retry: true }, [uk.NO_SERVICE_AVAILABLE_TDS]: { desc: "no tds service available", retry: true }, [uk.NO_SERVICE_AVAILABLE_REPORT]: { desc: "no unilbs report service available", retry: true }, [uk.NO_SERVICE_AVAILABLE_APP_CENTER]: { desc: "no app center service available", retry: true }, [uk.NO_SERVICE_AVAILABLE_ENV0]: { desc: "no unilbs sig env0 service available", retry: true }, [uk.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voet service available", retry: true }, [uk.NO_SERVICE_AVAILABLE_STRING_UID]: { desc: "no string uid service available", retry: true }, [uk.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: { desc: "no webrtc unilbs service available", retry: true } }, [ak.UNILBS]: { [dk.INVALID_VENDOR_KEY]: { desc: "invalid vendor key, can not find appid", retry: false }, [dk.INVALID_CHANNEL_NAME]: { desc: "invalid channel name", retry: false }, [dk.INTERNAL_ERROR]: { desc: "unilbs internal error", retry: false }, [dk.NO_AUTHORIZED]: { desc: "invalid token, authorized failed", retry: false }, [dk.DYNAMIC_KEY_TIMEOUT]: { desc: "dynamic key or token timeout", retry: false }, [dk.NO_ACTIVE_STATUS]: { desc: "no active status", retry: false }, [dk.DYNAMIC_KEY_EXPIRED]: { desc: "dynamic key expired", retry: false }, [dk.STATIC_USE_DYNAMIC_KEY]: { desc: "static use dynamic key", retry: false }, [dk.DYNAMIC_USE_STATIC_KEY]: { desc: "dynamic use static key", retry: false }, [dk.USER_OVERLOAD]: { desc: "amount of users over load", retry: false }, [dk.FORBIDDEN_REGION]: { desc: "the request is forbidden in this area", retry: false }, [dk.CANNOT_MEET_AREA_DEMAND]: { desc: "unable to allocate services in this area", retry: false } }, [ak.STRING_UID_ALLOCATOR]: { [ck.IIIEGAL_APPID]: { desc: "invalid appid", retry: false }, [ck.IIIEGAL_UID]: { desc: "invalid string uid", retry: false }, [ck.INTERNAL_ERROR]: { desc: "string uid allocator internal error", retry: true } } };
      function DJ(e3) {
        const t3 = OJ[Math.floor(e3 / 1e4)];
        if (!t3)
          return { desc: "unkonw error", retry: false };
        const i3 = t3[e3 % 1e4];
        if (!i3) {
          if (Math.floor(e3 / 1e4) === ak.ACCESS_POINT) {
            const t4 = e3 % 1e4;
            if ("1" === t4.toString()[0])
              return { desc: e3.toString(), retry: false };
            if ("2" === t4.toString()[0])
              return { desc: e3.toString(), retry: true };
          }
          return { desc: "unkonw error", retry: false };
        }
        return i3;
      }
      const PJ = { [hk.K_TIMESTAMP_EXPIRED]: { desc: "K_TIMESTAMP_EXPIRED", action: "failed" }, [hk.K_CHANNEL_PERMISSION_INVALID]: { desc: "K_CHANNEL_PERMISSION_INVALID", action: "failed" }, [hk.K_CERTIFICATE_INVALID]: { desc: "K_CERTIFICATE_INVALID", action: "failed" }, [hk.K_CHANNEL_NAME_EMPTY]: { desc: "K_CHANNEL_NAME_EMPTY", action: "failed" }, [hk.K_CHANNEL_NOT_FOUND]: { desc: "K_CHANNEL_NOT_FOUND", action: "failed" }, [hk.K_TICKET_INVALID]: { desc: "K_TICKET_INVALID", action: "failed" }, [hk.K_CHANNEL_CONFLICTED]: { desc: "K_CHANNEL_CONFLICTED", action: "failed" }, [hk.K_SERVICE_NOT_READY]: { desc: "K_SERVICE_NOT_READY", action: "tryNext" }, [hk.K_SERVICE_TOO_HEAVY]: { desc: "K_SERVICE_TOO_HEAVY", action: "tryNext" }, [hk.K_UID_BANNED]: { desc: "K_UID_BANNED", action: "failed" }, [hk.K_IP_BANNED]: { desc: "K_IP_BANNED", action: "failed" }, [hk.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [hk.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [hk.WARN_NO_AVAILABLE_CHANNEL]: { desc: "WARN_NO_AVAILABLE_CHANNEL", action: "failed" }, [hk.WARN_LOOKUP_CHANNEL_TIMEOUT]: { desc: "WARN_LOOKUP_CHANNEL_TIMEOUT", action: "tryNext" }, [hk.WARN_LOOKUP_CHANNEL_REJECTED]: { desc: "WARN_LOOKUP_CHANNEL_REJECTED", action: "failed" }, [hk.WARN_OPEN_CHANNEL_TIMEOUT]: { desc: "WARN_OPEN_CHANNEL_TIMEOUT", action: "tryNext" }, [hk.WARN_OPEN_CHANNEL_REJECTED]: { desc: "WARN_OPEN_CHANNEL_REJECTED", action: "failed" }, [hk.WARN_REQUEST_DEFERRED]: { desc: "WARN_REQUEST_DEFERRED", action: "failed" }, [hk.ERR_DYNAMIC_KEY_TIMEOUT]: { desc: "ERR_DYNAMIC_KEY_TIMEOUT", action: "failed" }, [hk.ERR_NO_AUTHORIZED]: { desc: "ERR_NO_AUTHORIZED", action: "failed" }, [hk.ERR_VOM_SERVICE_UNAVAILABLE]: { desc: "ERR_VOM_SERVICE_UNAVAILABLE", action: "tryNext" }, [hk.ERR_NO_CHANNEL_AVAILABLE_CODE]: { desc: "ERR_NO_CHANNEL_AVAILABLE_CODE", action: "failed" }, [hk.ERR_MASTER_VOCS_UNAVAILABLE]: { desc: "ERR_MASTER_VOCS_UNAVAILABLE", action: "tryNext" }, [hk.ERR_INTERNAL_ERROR]: { desc: "ERR_INTERNAL_ERROR", action: "tryNext" }, [hk.ERR_NO_ACTIVE_STATUS]: { desc: "ERR_NO_ACTIVE_STATUS", action: "failed" }, [hk.ERR_INVALID_UID]: { desc: "ERR_INVALID_UID", action: "failed" }, [hk.ERR_DYNAMIC_KEY_EXPIRED]: { desc: "ERR_DYNAMIC_KEY_EXPIRED", action: "failed" }, [hk.ERR_STATIC_USE_DYANMIC_KE]: { desc: "ERR_STATIC_USE_DYANMIC_KE", action: "failed" }, [hk.ERR_DYNAMIC_USE_STATIC_KE]: { desc: "ERR_DYNAMIC_USE_STATIC_KE", action: "failed" }, [hk.ERR_NO_VOCS_AVAILABLE]: { desc: "ERR_NO_VOCS_AVAILABLE", action: "tryNext" }, [hk.ERR_NO_VOS_AVAILABLE]: { desc: "ERR_NO_VOS_AVAILABLE", action: "tryNext" }, [hk.ERR_JOIN_CHANNEL_TIMEOUT]: { desc: "ERR_JOIN_CHANNEL_TIMEOUT", action: "tryNext" }, [hk.ERR_JOIN_BY_MULTI_IP]: { desc: "ERR_JOIN_BY_MULTI_IP", action: "recover" }, [hk.ERR_NOT_JOINED]: { desc: "ERR_NOT_JOINED", action: "failed" }, [hk.ERR_REPEAT_JOIN_REQUEST]: { desc: "ERR_REPEAT_JOIN_REQUEST", action: "quit" }, [hk.ERR_REPEAT_JOIN_CHANNEL]: { desc: "ERR_REPEAT_JOIN_CHANNEL", action: "quit" }, [hk.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [hk.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [hk.ERR_INVALID_STRINGUID]: { desc: "ERR_INVALID_STRINGUID", action: "failed" }, [hk.ERR_TOO_MANY_USERS]: { desc: "ERR_TOO_MANY_USERS", action: "tryNext" }, [hk.ERR_SET_CLIENT_ROLE_TIMEOUT]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [hk.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [hk.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: { desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", action: "success" }, [hk.ERR_PUBLISH_REQUEST_INVALID]: { desc: "ERR_PUBLISH_REQUEST_INVALID", action: "failed" }, [hk.ERR_SUBSCRIBE_REQUEST_INVALID]: { desc: "ERR_SUBSCRIBE_REQUEST_INVALID", action: "failed" }, [hk.ERR_NOT_SUPPORTED_MESSAGE]: { desc: "ERR_NOT_SUPPORTED_MESSAGE", action: "failed" }, [hk.ERR_ILLEAGAL_PLUGIN]: { desc: "ERR_ILLEAGAL_PLUGIN", action: "failed" }, [hk.ILLEGAL_CLIENT_ROLE_LEVEL]: { desc: "ILLEGAL_CLIENT_ROLE_LEVEL", action: "failed" }, [hk.ERR_REJOIN_TOKEN_INVALID]: { desc: "ERR_REJOIN_TOKEN_INVALID", action: "failed" }, [hk.ERR_REJOIN_USER_NOT_JOINED]: { desc: "ERR_REJOIN_NOT_JOINED", action: "failed" }, [hk.ERR_INVALID_OPTIONAL_INFO]: { desc: "ERR_INVALID_OPTIONAL_INFO", action: "quit" }, [hk.ERR_TEST_RECOVER]: { desc: "ERR_TEST_RECOVER", action: "recover" }, [hk.ERR_TEST_TRYNEXT]: { desc: "ERR_TEST_TRYNEXT", action: "recover" }, [hk.ERR_TEST_RETRY]: { desc: "ERR_TEST_RETRY", action: "recover" }, [hk.ILLEGAL_AES_PASSWORD]: { desc: "ERR_TEST_RETRY", action: "failed" }, [hk.ERR_TOO_MANY_BROADCASTERS]: { desc: "ERR_TOO_MANY_BROADCASTERS", action: "failed" }, [hk.ERR_TOO_MANY_SUBSCRIBERS]: { desc: "ERR_TOO_MANY_SUBSCRIBERS", action: "failed" }, [hk.ERR_LICENSE_ILLEGAL]: { desc: "ERR_LICENSE_ILLEGAL", action: "quit" }, [hk.ERR_LICENSE_MISSING]: { desc: "ERR_LICENSE_MISSING", action: "quit" }, [hk.ERR_LICENSE_EXPIRED]: { desc: "ERR_LICENSE_EXPIRED", action: "quit" }, [hk.ERR_LICENSE_MINUTES_EXCEEDED]: { desc: "ERR_LICENSE_MINUTES_EXCEEDED", action: "quit" }, [hk.ERR_LICENSE_PERIOD_INVALID]: { desc: "ERR_LICENSE_PERIOD_INVALID", action: "quit" }, [hk.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: { desc: "ERR_LICENSE_MULTIPLE_SDK_SERVICE", action: "quit" } };
      function LJ(e3) {
        const t3 = PJ[e3];
        return t3 || { desc: "UNKNOW_ERROR_".concat(e3), action: "failed" };
      }
      var kJ = { exports: {} };
      !function(e3, t3) {
        e3.exports = function() {
          var e4 = { d: function(t5, i4) {
            for (var r4 in i4)
              e4.o(i4, r4) && !e4.o(t5, r4) && Object.defineProperty(t5, r4, { enumerable: true, get: i4[r4] });
          }, o: function(e5, t5) {
            return Object.prototype.hasOwnProperty.call(e5, t5);
          }, r: function(e5) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e5, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e5, "__esModule", { value: true });
          } }, t4 = {};
          e4.r(t4), e4.d(t4, { DataViewIndexOutOfBoundsError: function() {
            return F3;
          }, DecodeError: function() {
            return m3;
          }, Decoder: function() {
            return G3;
          }, EXT_TIMESTAMP: function() {
            return I3;
          }, Encoder: function() {
            return N3;
          }, ExtData: function() {
            return E3;
          }, ExtensionCodec: function() {
            return y3;
          }, decode: function() {
            return H3;
          }, decodeArrayStream: function() {
            return $2;
          }, decodeAsync: function() {
            return Z2;
          }, decodeMulti: function() {
            return W3;
          }, decodeMultiStream: function() {
            return ee2;
          }, decodeStream: function() {
            return te2;
          }, decodeTimestampExtension: function() {
            return T3;
          }, decodeTimestampToTimeSpec: function() {
            return v3;
          }, encode: function() {
            return D3;
          }, encodeDateToTimeSpec: function() {
            return C3;
          }, encodeTimeSpecToTimestamp: function() {
            return _3;
          }, encodeTimestampExtension: function() {
            return S3;
          } });
          var i3 = 4294967295;
          function r3(e5, t5, i4) {
            var r4 = Math.floor(i4 / 4294967296), n4 = i4;
            e5.setUint32(t5, r4), e5.setUint32(t5 + 4, n4);
          }
          function n3(e5, t5) {
            return 4294967296 * e5.getInt32(t5) + e5.getUint32(t5 + 4);
          }
          var o3 = function(e5, t5) {
            var i4 = "function" == typeof Symbol && e5[Symbol.iterator];
            if (!i4)
              return e5;
            var r4, n4, o4 = i4.call(e5), s4 = [];
            try {
              for (; (void 0 === t5 || t5-- > 0) && !(r4 = o4.next()).done; )
                s4.push(r4.value);
            } catch (e6) {
              n4 = { error: e6 };
            } finally {
              try {
                r4 && !r4.done && (i4 = o4.return) && i4.call(o4);
              } finally {
                if (n4)
                  throw n4.error;
              }
            }
            return s4;
          }, s3 = function(e5, t5) {
            for (var i4 = 0, r4 = t5.length, n4 = e5.length; i4 < r4; i4++, n4++)
              e5[n4] = t5[i4];
            return e5;
          }, a3 = "undefined" != typeof TextEncoder && "undefined" != typeof TextDecoder;
          function c3(e5) {
            for (var t5 = e5.length, i4 = 0, r4 = 0; r4 < t5; ) {
              var n4 = e5.charCodeAt(r4++);
              if (0 != (4294967168 & n4))
                if (0 == (4294965248 & n4))
                  i4 += 2;
                else {
                  if (n4 >= 55296 && n4 <= 56319 && r4 < t5) {
                    var o4 = e5.charCodeAt(r4);
                    56320 == (64512 & o4) && (++r4, n4 = ((1023 & n4) << 10) + (1023 & o4) + 65536);
                  }
                  i4 += 0 == (4294901760 & n4) ? 3 : 4;
                }
              else
                i4++;
            }
            return i4;
          }
          var d3 = a3 ? new TextEncoder() : void 0, u3 = a3 ? "undefined" != typeof process ? 200 : 0 : i3, h3 = (null == d3 ? void 0 : d3.encodeInto) ? function(e5, t5, i4) {
            d3.encodeInto(e5, t5.subarray(i4));
          } : function(e5, t5, i4) {
            t5.set(d3.encode(e5), i4);
          };
          function A3(e5, t5, i4) {
            for (var r4 = t5, n4 = r4 + i4, a4 = [], c4 = ""; r4 < n4; ) {
              var d4 = e5[r4++];
              if (0 == (128 & d4))
                a4.push(d4);
              else if (192 == (224 & d4)) {
                var u4 = 63 & e5[r4++];
                a4.push((31 & d4) << 6 | u4);
              } else if (224 == (240 & d4)) {
                u4 = 63 & e5[r4++];
                var h4 = 63 & e5[r4++];
                a4.push((31 & d4) << 12 | u4 << 6 | h4);
              } else if (240 == (248 & d4)) {
                var A4 = (7 & d4) << 18 | (u4 = 63 & e5[r4++]) << 12 | (h4 = 63 & e5[r4++]) << 6 | 63 & e5[r4++];
                A4 > 65535 && (A4 -= 65536, a4.push(A4 >>> 10 & 1023 | 55296), A4 = 56320 | 1023 & A4), a4.push(A4);
              } else
                a4.push(d4);
              a4.length >= 4096 && (c4 += String.fromCharCode.apply(String, s3([], o3(a4))), a4.length = 0);
            }
            return a4.length > 0 && (c4 += String.fromCharCode.apply(String, s3([], o3(a4)))), c4;
          }
          var l3, p3 = a3 ? new TextDecoder() : null, g3 = a3 ? "undefined" != typeof process ? 200 : 0 : i3, E3 = function(e5, t5) {
            this.type = e5, this.data = t5;
          }, f3 = (l3 = function(e5, t5) {
            return (l3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e6, t6) {
              e6.__proto__ = t6;
            } || function(e6, t6) {
              for (var i4 in t6)
                Object.prototype.hasOwnProperty.call(t6, i4) && (e6[i4] = t6[i4]);
            })(e5, t5);
          }, function(e5, t5) {
            if ("function" != typeof t5 && null !== t5)
              throw new TypeError("Class extends value " + String(t5) + " is not a constructor or null");
            function i4() {
              this.constructor = e5;
            }
            l3(e5, t5), e5.prototype = null === t5 ? Object.create(t5) : (i4.prototype = t5.prototype, new i4());
          }), m3 = function(e5) {
            function t5(i4) {
              var r4 = e5.call(this, i4) || this, n4 = Object.create(t5.prototype);
              return Object.setPrototypeOf(r4, n4), Object.defineProperty(r4, "name", { configurable: true, enumerable: false, value: t5.name }), r4;
            }
            return f3(t5, e5), t5;
          }(Error), I3 = -1;
          function _3(e5) {
            var t5, i4 = e5.sec, n4 = e5.nsec;
            if (i4 >= 0 && n4 >= 0 && i4 <= 17179869183) {
              if (0 === n4 && i4 <= 4294967295) {
                var o4 = new Uint8Array(4);
                return (t5 = new DataView(o4.buffer)).setUint32(0, i4), o4;
              }
              var s4 = i4 / 4294967296, a4 = 4294967295 & i4;
              return o4 = new Uint8Array(8), (t5 = new DataView(o4.buffer)).setUint32(0, n4 << 2 | 3 & s4), t5.setUint32(4, a4), o4;
            }
            return o4 = new Uint8Array(12), (t5 = new DataView(o4.buffer)).setUint32(0, n4), r3(t5, 4, i4), o4;
          }
          function C3(e5) {
            var t5 = e5.getTime(), i4 = Math.floor(t5 / 1e3), r4 = 1e6 * (t5 - 1e3 * i4), n4 = Math.floor(r4 / 1e9);
            return { sec: i4 + n4, nsec: r4 - 1e9 * n4 };
          }
          function S3(e5) {
            return e5 instanceof Date ? _3(C3(e5)) : null;
          }
          function v3(e5) {
            var t5 = new DataView(e5.buffer, e5.byteOffset, e5.byteLength);
            switch (e5.byteLength) {
              case 4:
                return { sec: t5.getUint32(0), nsec: 0 };
              case 8:
                var i4 = t5.getUint32(0);
                return { sec: 4294967296 * (3 & i4) + t5.getUint32(4), nsec: i4 >>> 2 };
              case 12:
                return { sec: n3(t5, 4), nsec: t5.getUint32(0) };
              default:
                throw new m3("Unrecognized data size for timestamp (expected 4, 8, or 12): " + e5.length);
            }
          }
          function T3(e5) {
            var t5 = v3(e5);
            return new Date(1e3 * t5.sec + t5.nsec / 1e6);
          }
          var R3 = { type: I3, encode: S3, decode: T3 }, y3 = function() {
            function e5() {
              this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(R3);
            }
            return e5.prototype.register = function(e6) {
              var t5 = e6.type, i4 = e6.encode, r4 = e6.decode;
              if (t5 >= 0)
                this.encoders[t5] = i4, this.decoders[t5] = r4;
              else {
                var n4 = 1 + t5;
                this.builtInEncoders[n4] = i4, this.builtInDecoders[n4] = r4;
              }
            }, e5.prototype.tryToEncode = function(e6, t5) {
              for (var i4 = 0; i4 < this.builtInEncoders.length; i4++)
                if (null != (r4 = this.builtInEncoders[i4]) && null != (n4 = r4(e6, t5)))
                  return new E3(-1 - i4, n4);
              for (i4 = 0; i4 < this.encoders.length; i4++) {
                var r4, n4;
                if (null != (r4 = this.encoders[i4]) && null != (n4 = r4(e6, t5)))
                  return new E3(i4, n4);
              }
              return e6 instanceof E3 ? e6 : null;
            }, e5.prototype.decode = function(e6, t5, i4) {
              var r4 = t5 < 0 ? this.builtInDecoders[-1 - t5] : this.decoders[t5];
              return r4 ? r4(e6, t5, i4) : new E3(t5, e6);
            }, e5.defaultCodec = new e5(), e5;
          }();
          function w3(e5) {
            return e5 instanceof Uint8Array ? e5 : ArrayBuffer.isView(e5) ? new Uint8Array(e5.buffer, e5.byteOffset, e5.byteLength) : e5 instanceof ArrayBuffer ? new Uint8Array(e5) : Uint8Array.from(e5);
          }
          var b3 = function(e5) {
            var t5 = "function" == typeof Symbol && Symbol.iterator, i4 = t5 && e5[t5], r4 = 0;
            if (i4)
              return i4.call(e5);
            if (e5 && "number" == typeof e5.length)
              return { next: function() {
                return e5 && r4 >= e5.length && (e5 = void 0), { value: e5 && e5[r4++], done: !e5 };
              } };
            throw new TypeError(t5 ? "Object is not iterable." : "Symbol.iterator is not defined.");
          }, N3 = function() {
            function e5(e6, t5, i4, r4, n4, o4, s4, a4) {
              void 0 === e6 && (e6 = y3.defaultCodec), void 0 === t5 && (t5 = void 0), void 0 === i4 && (i4 = 100), void 0 === r4 && (r4 = 2048), void 0 === n4 && (n4 = false), void 0 === o4 && (o4 = false), void 0 === s4 && (s4 = false), void 0 === a4 && (a4 = false), this.extensionCodec = e6, this.context = t5, this.maxDepth = i4, this.initialBufferSize = r4, this.sortKeys = n4, this.forceFloat32 = o4, this.ignoreUndefined = s4, this.forceIntegerToFloat = a4, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
            }
            return e5.prototype.getUint8Array = function() {
              return this.bytes.subarray(0, this.pos);
            }, e5.prototype.reinitializeState = function() {
              this.pos = 0;
            }, e5.prototype.encode = function(e6) {
              return this.reinitializeState(), this.doEncode(e6, 1), this.getUint8Array();
            }, e5.prototype.doEncode = function(e6, t5) {
              if (t5 > this.maxDepth)
                throw new Error("Too deep objects in depth " + t5);
              null == e6 ? this.encodeNil() : "boolean" == typeof e6 ? this.encodeBoolean(e6) : "number" == typeof e6 ? this.encodeNumber(e6) : "string" == typeof e6 ? this.encodeString(e6) : this.encodeObject(e6, t5);
            }, e5.prototype.ensureBufferSizeToWrite = function(e6) {
              var t5 = this.pos + e6;
              this.view.byteLength < t5 && this.resizeBuffer(2 * t5);
            }, e5.prototype.resizeBuffer = function(e6) {
              var t5 = new ArrayBuffer(e6), i4 = new Uint8Array(t5), r4 = new DataView(t5);
              i4.set(this.bytes), this.view = r4, this.bytes = i4;
            }, e5.prototype.encodeNil = function() {
              this.writeU8(192);
            }, e5.prototype.encodeBoolean = function(e6) {
              false === e6 ? this.writeU8(194) : this.writeU8(195);
            }, e5.prototype.encodeNumber = function(e6) {
              Number.isSafeInteger(e6) && !this.forceIntegerToFloat ? e6 >= 0 ? e6 < 128 ? this.writeU8(e6) : e6 < 256 ? (this.writeU8(204), this.writeU8(e6)) : e6 < 65536 ? (this.writeU8(205), this.writeU16(e6)) : e6 < 4294967296 ? (this.writeU8(206), this.writeU32(e6)) : (this.writeU8(207), this.writeU64(e6)) : e6 >= -32 ? this.writeU8(224 | e6 + 32) : e6 >= -128 ? (this.writeU8(208), this.writeI8(e6)) : e6 >= -32768 ? (this.writeU8(209), this.writeI16(e6)) : e6 >= -2147483648 ? (this.writeU8(210), this.writeI32(e6)) : (this.writeU8(211), this.writeI64(e6)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(e6)) : (this.writeU8(203), this.writeF64(e6));
            }, e5.prototype.writeStringHeader = function(e6) {
              if (e6 < 32)
                this.writeU8(160 + e6);
              else if (e6 < 256)
                this.writeU8(217), this.writeU8(e6);
              else if (e6 < 65536)
                this.writeU8(218), this.writeU16(e6);
              else {
                if (!(e6 < 4294967296))
                  throw new Error("Too long string: " + e6 + " bytes in UTF-8");
                this.writeU8(219), this.writeU32(e6);
              }
            }, e5.prototype.encodeString = function(e6) {
              if (e6.length > u3) {
                var t5 = c3(e6);
                this.ensureBufferSizeToWrite(5 + t5), this.writeStringHeader(t5), h3(e6, this.bytes, this.pos), this.pos += t5;
              } else
                t5 = c3(e6), this.ensureBufferSizeToWrite(5 + t5), this.writeStringHeader(t5), function(e7, t6, i4) {
                  for (var r4 = e7.length, n4 = i4, o4 = 0; o4 < r4; ) {
                    var s4 = e7.charCodeAt(o4++);
                    if (0 != (4294967168 & s4)) {
                      if (0 == (4294965248 & s4))
                        t6[n4++] = s4 >> 6 & 31 | 192;
                      else {
                        if (s4 >= 55296 && s4 <= 56319 && o4 < r4) {
                          var a4 = e7.charCodeAt(o4);
                          56320 == (64512 & a4) && (++o4, s4 = ((1023 & s4) << 10) + (1023 & a4) + 65536);
                        }
                        0 == (4294901760 & s4) ? (t6[n4++] = s4 >> 12 & 15 | 224, t6[n4++] = s4 >> 6 & 63 | 128) : (t6[n4++] = s4 >> 18 & 7 | 240, t6[n4++] = s4 >> 12 & 63 | 128, t6[n4++] = s4 >> 6 & 63 | 128);
                      }
                      t6[n4++] = 63 & s4 | 128;
                    } else
                      t6[n4++] = s4;
                  }
                }(e6, this.bytes, this.pos), this.pos += t5;
            }, e5.prototype.encodeObject = function(e6, t5) {
              var i4 = this.extensionCodec.tryToEncode(e6, this.context);
              if (null != i4)
                this.encodeExtension(i4);
              else if (Array.isArray(e6))
                this.encodeArray(e6, t5);
              else if (ArrayBuffer.isView(e6))
                this.encodeBinary(e6);
              else {
                if ("object" != typeof e6)
                  throw new Error("Unrecognized object: " + Object.prototype.toString.apply(e6));
                this.encodeMap(e6, t5);
              }
            }, e5.prototype.encodeBinary = function(e6) {
              var t5 = e6.byteLength;
              if (t5 < 256)
                this.writeU8(196), this.writeU8(t5);
              else if (t5 < 65536)
                this.writeU8(197), this.writeU16(t5);
              else {
                if (!(t5 < 4294967296))
                  throw new Error("Too large binary: " + t5);
                this.writeU8(198), this.writeU32(t5);
              }
              var i4 = w3(e6);
              this.writeU8a(i4);
            }, e5.prototype.encodeArray = function(e6, t5) {
              var i4, r4, n4 = e6.length;
              if (n4 < 16)
                this.writeU8(144 + n4);
              else if (n4 < 65536)
                this.writeU8(220), this.writeU16(n4);
              else {
                if (!(n4 < 4294967296))
                  throw new Error("Too large array: " + n4);
                this.writeU8(221), this.writeU32(n4);
              }
              try {
                for (var o4 = b3(e6), s4 = o4.next(); !s4.done; s4 = o4.next()) {
                  var a4 = s4.value;
                  this.doEncode(a4, t5 + 1);
                }
              } catch (e7) {
                i4 = { error: e7 };
              } finally {
                try {
                  s4 && !s4.done && (r4 = o4.return) && r4.call(o4);
                } finally {
                  if (i4)
                    throw i4.error;
                }
              }
            }, e5.prototype.countWithoutUndefined = function(e6, t5) {
              var i4, r4, n4 = 0;
              try {
                for (var o4 = b3(t5), s4 = o4.next(); !s4.done; s4 = o4.next())
                  void 0 !== e6[s4.value] && n4++;
              } catch (e7) {
                i4 = { error: e7 };
              } finally {
                try {
                  s4 && !s4.done && (r4 = o4.return) && r4.call(o4);
                } finally {
                  if (i4)
                    throw i4.error;
                }
              }
              return n4;
            }, e5.prototype.encodeMap = function(e6, t5) {
              var i4, r4, n4 = Object.keys(e6);
              this.sortKeys && n4.sort();
              var o4 = this.ignoreUndefined ? this.countWithoutUndefined(e6, n4) : n4.length;
              if (o4 < 16)
                this.writeU8(128 + o4);
              else if (o4 < 65536)
                this.writeU8(222), this.writeU16(o4);
              else {
                if (!(o4 < 4294967296))
                  throw new Error("Too large map object: " + o4);
                this.writeU8(223), this.writeU32(o4);
              }
              try {
                for (var s4 = b3(n4), a4 = s4.next(); !a4.done; a4 = s4.next()) {
                  var c4 = a4.value, d4 = e6[c4];
                  this.ignoreUndefined && void 0 === d4 || (this.encodeString(c4), this.doEncode(d4, t5 + 1));
                }
              } catch (e7) {
                i4 = { error: e7 };
              } finally {
                try {
                  a4 && !a4.done && (r4 = s4.return) && r4.call(s4);
                } finally {
                  if (i4)
                    throw i4.error;
                }
              }
            }, e5.prototype.encodeExtension = function(e6) {
              var t5 = e6.data.length;
              if (1 === t5)
                this.writeU8(212);
              else if (2 === t5)
                this.writeU8(213);
              else if (4 === t5)
                this.writeU8(214);
              else if (8 === t5)
                this.writeU8(215);
              else if (16 === t5)
                this.writeU8(216);
              else if (t5 < 256)
                this.writeU8(199), this.writeU8(t5);
              else if (t5 < 65536)
                this.writeU8(200), this.writeU16(t5);
              else {
                if (!(t5 < 4294967296))
                  throw new Error("Too large extension object: " + t5);
                this.writeU8(201), this.writeU32(t5);
              }
              this.writeI8(e6.type), this.writeU8a(e6.data);
            }, e5.prototype.writeU8 = function(e6) {
              this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, e6), this.pos++;
            }, e5.prototype.writeU8a = function(e6) {
              var t5 = e6.length;
              this.ensureBufferSizeToWrite(t5), this.bytes.set(e6, this.pos), this.pos += t5;
            }, e5.prototype.writeI8 = function(e6) {
              this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, e6), this.pos++;
            }, e5.prototype.writeU16 = function(e6) {
              this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, e6), this.pos += 2;
            }, e5.prototype.writeI16 = function(e6) {
              this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, e6), this.pos += 2;
            }, e5.prototype.writeU32 = function(e6) {
              this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, e6), this.pos += 4;
            }, e5.prototype.writeI32 = function(e6) {
              this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, e6), this.pos += 4;
            }, e5.prototype.writeF32 = function(e6) {
              this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, e6), this.pos += 4;
            }, e5.prototype.writeF64 = function(e6) {
              this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, e6), this.pos += 8;
            }, e5.prototype.writeU64 = function(e6) {
              this.ensureBufferSizeToWrite(8), function(e7, t5, i4) {
                var r4 = i4 / 4294967296, n4 = i4;
                e7.setUint32(t5, r4), e7.setUint32(t5 + 4, n4);
              }(this.view, this.pos, e6), this.pos += 8;
            }, e5.prototype.writeI64 = function(e6) {
              this.ensureBufferSizeToWrite(8), r3(this.view, this.pos, e6), this.pos += 8;
            }, e5;
          }(), O3 = {};
          function D3(e5, t5) {
            return void 0 === t5 && (t5 = O3), new N3(t5.extensionCodec, t5.context, t5.maxDepth, t5.initialBufferSize, t5.sortKeys, t5.forceFloat32, t5.ignoreUndefined, t5.forceIntegerToFloat).encode(e5);
          }
          function P3(e5) {
            return (e5 < 0 ? "-" : "") + "0x" + Math.abs(e5).toString(16).padStart(2, "0");
          }
          var L3 = function() {
            function e5(e6, t5) {
              void 0 === e6 && (e6 = 16), void 0 === t5 && (t5 = 16), this.maxKeyLength = e6, this.maxLengthPerKey = t5, this.hit = 0, this.miss = 0, this.caches = [];
              for (var i4 = 0; i4 < this.maxKeyLength; i4++)
                this.caches.push([]);
            }
            return e5.prototype.canBeCached = function(e6) {
              return e6 > 0 && e6 <= this.maxKeyLength;
            }, e5.prototype.find = function(e6, t5, i4) {
              var r4, n4, o4 = this.caches[i4 - 1];
              try {
                e:
                  for (var s4 = function(e7) {
                    var t6 = "function" == typeof Symbol && Symbol.iterator, i5 = t6 && e7[t6], r5 = 0;
                    if (i5)
                      return i5.call(e7);
                    if (e7 && "number" == typeof e7.length)
                      return { next: function() {
                        return e7 && r5 >= e7.length && (e7 = void 0), { value: e7 && e7[r5++], done: !e7 };
                      } };
                    throw new TypeError(t6 ? "Object is not iterable." : "Symbol.iterator is not defined.");
                  }(o4), a4 = s4.next(); !a4.done; a4 = s4.next()) {
                    for (var c4 = a4.value, d4 = c4.bytes, u4 = 0; u4 < i4; u4++)
                      if (d4[u4] !== e6[t5 + u4])
                        continue e;
                    return c4.str;
                  }
              } catch (e7) {
                r4 = { error: e7 };
              } finally {
                try {
                  a4 && !a4.done && (n4 = s4.return) && n4.call(s4);
                } finally {
                  if (r4)
                    throw r4.error;
                }
              }
              return null;
            }, e5.prototype.store = function(e6, t5) {
              var i4 = this.caches[e6.length - 1], r4 = { bytes: e6, str: t5 };
              i4.length >= this.maxLengthPerKey ? i4[Math.random() * i4.length | 0] = r4 : i4.push(r4);
            }, e5.prototype.decode = function(e6, t5, i4) {
              var r4 = this.find(e6, t5, i4);
              if (null != r4)
                return this.hit++, r4;
              this.miss++;
              var n4 = A3(e6, t5, i4), o4 = Uint8Array.prototype.slice.call(e6, t5, t5 + i4);
              return this.store(o4, n4), n4;
            }, e5;
          }(), k3 = function(e5, t5) {
            var i4, r4, n4, o4, s4 = { label: 0, sent: function() {
              if (1 & n4[0])
                throw n4[1];
              return n4[1];
            }, trys: [], ops: [] };
            return o4 = { next: a4(0), throw: a4(1), return: a4(2) }, "function" == typeof Symbol && (o4[Symbol.iterator] = function() {
              return this;
            }), o4;
            function a4(o5) {
              return function(a5) {
                return function(o6) {
                  if (i4)
                    throw new TypeError("Generator is already executing.");
                  for (; s4; )
                    try {
                      if (i4 = 1, r4 && (n4 = 2 & o6[0] ? r4.return : o6[0] ? r4.throw || ((n4 = r4.return) && n4.call(r4), 0) : r4.next) && !(n4 = n4.call(r4, o6[1])).done)
                        return n4;
                      switch (r4 = 0, n4 && (o6 = [2 & o6[0], n4.value]), o6[0]) {
                        case 0:
                        case 1:
                          n4 = o6;
                          break;
                        case 4:
                          return s4.label++, { value: o6[1], done: false };
                        case 5:
                          s4.label++, r4 = o6[1], o6 = [0];
                          continue;
                        case 7:
                          o6 = s4.ops.pop(), s4.trys.pop();
                          continue;
                        default:
                          if (!((n4 = (n4 = s4.trys).length > 0 && n4[n4.length - 1]) || 6 !== o6[0] && 2 !== o6[0])) {
                            s4 = 0;
                            continue;
                          }
                          if (3 === o6[0] && (!n4 || o6[1] > n4[0] && o6[1] < n4[3])) {
                            s4.label = o6[1];
                            break;
                          }
                          if (6 === o6[0] && s4.label < n4[1]) {
                            s4.label = n4[1], n4 = o6;
                            break;
                          }
                          if (n4 && s4.label < n4[2]) {
                            s4.label = n4[2], s4.ops.push(o6);
                            break;
                          }
                          n4[2] && s4.ops.pop(), s4.trys.pop();
                          continue;
                      }
                      o6 = t5.call(e5, s4);
                    } catch (e6) {
                      o6 = [6, e6], r4 = 0;
                    } finally {
                      i4 = n4 = 0;
                    }
                  if (5 & o6[0])
                    throw o6[1];
                  return { value: o6[0] ? o6[1] : void 0, done: true };
                }([o5, a5]);
              };
            }
          }, B3 = function(e5) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var t5, i4 = e5[Symbol.asyncIterator];
            return i4 ? i4.call(e5) : (e5 = "function" == typeof __values ? __values(e5) : e5[Symbol.iterator](), t5 = {}, r4("next"), r4("throw"), r4("return"), t5[Symbol.asyncIterator] = function() {
              return this;
            }, t5);
            function r4(i5) {
              t5[i5] = e5[i5] && function(t6) {
                return new Promise(function(r5, n4) {
                  !function(e6, t7, i6, r6) {
                    Promise.resolve(r6).then(function(t8) {
                      e6({ value: t8, done: i6 });
                    }, t7);
                  }(r5, n4, (t6 = e5[i5](t6)).done, t6.value);
                });
              };
            }
          }, M3 = function(e5) {
            return this instanceof M3 ? (this.v = e5, this) : new M3(e5);
          }, U3 = function(e5, t5, i4) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var r4, n4 = i4.apply(e5, t5 || []), o4 = [];
            return r4 = {}, s4("next"), s4("throw"), s4("return"), r4[Symbol.asyncIterator] = function() {
              return this;
            }, r4;
            function s4(e6) {
              n4[e6] && (r4[e6] = function(t6) {
                return new Promise(function(i5, r5) {
                  o4.push([e6, t6, i5, r5]) > 1 || a4(e6, t6);
                });
              });
            }
            function a4(e6, t6) {
              try {
                (i5 = n4[e6](t6)).value instanceof M3 ? Promise.resolve(i5.value.v).then(c4, d4) : u4(o4[0][2], i5);
              } catch (e7) {
                u4(o4[0][3], e7);
              }
              var i5;
            }
            function c4(e6) {
              a4("next", e6);
            }
            function d4(e6) {
              a4("throw", e6);
            }
            function u4(e6, t6) {
              e6(t6), o4.shift(), o4.length && a4(o4[0][0], o4[0][1]);
            }
          }, x3 = new DataView(new ArrayBuffer(0)), Q3 = new Uint8Array(x3.buffer), F3 = function() {
            try {
              x3.getInt8(0);
            } catch (e5) {
              return e5.constructor;
            }
            throw new Error("never reached");
          }(), V3 = new F3("Insufficient data"), j3 = new L3(), G3 = function() {
            function e5(e6, t5, r4, n4, o4, s4, a4, c4) {
              void 0 === e6 && (e6 = y3.defaultCodec), void 0 === t5 && (t5 = void 0), void 0 === r4 && (r4 = i3), void 0 === n4 && (n4 = i3), void 0 === o4 && (o4 = i3), void 0 === s4 && (s4 = i3), void 0 === a4 && (a4 = i3), void 0 === c4 && (c4 = j3), this.extensionCodec = e6, this.context = t5, this.maxStrLength = r4, this.maxBinLength = n4, this.maxArrayLength = o4, this.maxMapLength = s4, this.maxExtLength = a4, this.keyDecoder = c4, this.totalPos = 0, this.pos = 0, this.view = x3, this.bytes = Q3, this.headByte = -1, this.stack = [];
            }
            return e5.prototype.reinitializeState = function() {
              this.totalPos = 0, this.headByte = -1, this.stack.length = 0;
            }, e5.prototype.setBuffer = function(e6) {
              this.bytes = w3(e6), this.view = function(e7) {
                if (e7 instanceof ArrayBuffer)
                  return new DataView(e7);
                var t5 = w3(e7);
                return new DataView(t5.buffer, t5.byteOffset, t5.byteLength);
              }(this.bytes), this.pos = 0;
            }, e5.prototype.appendBuffer = function(e6) {
              if (-1 !== this.headByte || this.hasRemaining(1)) {
                var t5 = this.bytes.subarray(this.pos), i4 = w3(e6), r4 = new Uint8Array(t5.length + i4.length);
                r4.set(t5), r4.set(i4, t5.length), this.setBuffer(r4);
              } else
                this.setBuffer(e6);
            }, e5.prototype.hasRemaining = function(e6) {
              return this.view.byteLength - this.pos >= e6;
            }, e5.prototype.createExtraByteError = function(e6) {
              var t5 = this.view, i4 = this.pos;
              return new RangeError("Extra " + (t5.byteLength - i4) + " of " + t5.byteLength + " byte(s) found at buffer[" + e6 + "]");
            }, e5.prototype.decode = function(e6) {
              this.reinitializeState(), this.setBuffer(e6);
              var t5 = this.doDecodeSync();
              if (this.hasRemaining(1))
                throw this.createExtraByteError(this.pos);
              return t5;
            }, e5.prototype.decodeMulti = function(e6) {
              return k3(this, function(t5) {
                switch (t5.label) {
                  case 0:
                    this.reinitializeState(), this.setBuffer(e6), t5.label = 1;
                  case 1:
                    return this.hasRemaining(1) ? [4, this.doDecodeSync()] : [3, 3];
                  case 2:
                    return t5.sent(), [3, 1];
                  case 3:
                    return [2];
                }
              });
            }, e5.prototype.decodeAsync = function(e6) {
              var t5, i4, r4, n4, o4, s4, a4, c4;
              return o4 = this, s4 = void 0, c4 = function() {
                var o5, s5, a5, c5, d4, u4, h4, A4;
                return k3(this, function(l4) {
                  switch (l4.label) {
                    case 0:
                      o5 = false, l4.label = 1;
                    case 1:
                      l4.trys.push([1, 6, 7, 12]), t5 = B3(e6), l4.label = 2;
                    case 2:
                      return [4, t5.next()];
                    case 3:
                      if ((i4 = l4.sent()).done)
                        return [3, 5];
                      if (a5 = i4.value, o5)
                        throw this.createExtraByteError(this.totalPos);
                      this.appendBuffer(a5);
                      try {
                        s5 = this.doDecodeSync(), o5 = true;
                      } catch (e7) {
                        if (!(e7 instanceof F3))
                          throw e7;
                      }
                      this.totalPos += this.pos, l4.label = 4;
                    case 4:
                      return [3, 2];
                    case 5:
                      return [3, 12];
                    case 6:
                      return c5 = l4.sent(), r4 = { error: c5 }, [3, 12];
                    case 7:
                      return l4.trys.push([7, , 10, 11]), i4 && !i4.done && (n4 = t5.return) ? [4, n4.call(t5)] : [3, 9];
                    case 8:
                      l4.sent(), l4.label = 9;
                    case 9:
                      return [3, 11];
                    case 10:
                      if (r4)
                        throw r4.error;
                      return [7];
                    case 11:
                      return [7];
                    case 12:
                      if (o5) {
                        if (this.hasRemaining(1))
                          throw this.createExtraByteError(this.totalPos);
                        return [2, s5];
                      }
                      throw u4 = (d4 = this).headByte, h4 = d4.pos, A4 = d4.totalPos, new RangeError("Insufficient data in parsing " + P3(u4) + " at " + A4 + " (" + h4 + " in the current buffer)");
                  }
                });
              }, new ((a4 = void 0) || (a4 = Promise))(function(e7, t6) {
                function i5(e8) {
                  try {
                    n5(c4.next(e8));
                  } catch (e9) {
                    t6(e9);
                  }
                }
                function r5(e8) {
                  try {
                    n5(c4.throw(e8));
                  } catch (e9) {
                    t6(e9);
                  }
                }
                function n5(t7) {
                  var n6;
                  t7.done ? e7(t7.value) : (n6 = t7.value, n6 instanceof a4 ? n6 : new a4(function(e8) {
                    e8(n6);
                  })).then(i5, r5);
                }
                n5((c4 = c4.apply(o4, s4 || [])).next());
              });
            }, e5.prototype.decodeArrayStream = function(e6) {
              return this.decodeMultiAsync(e6, true);
            }, e5.prototype.decodeStream = function(e6) {
              return this.decodeMultiAsync(e6, false);
            }, e5.prototype.decodeMultiAsync = function(e6, t5) {
              return U3(this, arguments, function() {
                var i4, r4, n4, o4, s4, a4, c4, d4, u4;
                return k3(this, function(h4) {
                  switch (h4.label) {
                    case 0:
                      i4 = t5, r4 = -1, h4.label = 1;
                    case 1:
                      h4.trys.push([1, 13, 14, 19]), n4 = B3(e6), h4.label = 2;
                    case 2:
                      return [4, M3(n4.next())];
                    case 3:
                      if ((o4 = h4.sent()).done)
                        return [3, 12];
                      if (s4 = o4.value, t5 && 0 === r4)
                        throw this.createExtraByteError(this.totalPos);
                      this.appendBuffer(s4), i4 && (r4 = this.readArraySize(), i4 = false, this.complete()), h4.label = 4;
                    case 4:
                      h4.trys.push([4, 9, , 10]), h4.label = 5;
                    case 5:
                      return [4, M3(this.doDecodeSync())];
                    case 6:
                      return [4, h4.sent()];
                    case 7:
                      return h4.sent(), 0 == --r4 ? [3, 8] : [3, 5];
                    case 8:
                      return [3, 10];
                    case 9:
                      if (!((a4 = h4.sent()) instanceof F3))
                        throw a4;
                      return [3, 10];
                    case 10:
                      this.totalPos += this.pos, h4.label = 11;
                    case 11:
                      return [3, 2];
                    case 12:
                      return [3, 19];
                    case 13:
                      return c4 = h4.sent(), d4 = { error: c4 }, [3, 19];
                    case 14:
                      return h4.trys.push([14, , 17, 18]), o4 && !o4.done && (u4 = n4.return) ? [4, M3(u4.call(n4))] : [3, 16];
                    case 15:
                      h4.sent(), h4.label = 16;
                    case 16:
                      return [3, 18];
                    case 17:
                      if (d4)
                        throw d4.error;
                      return [7];
                    case 18:
                      return [7];
                    case 19:
                      return [2];
                  }
                });
              });
            }, e5.prototype.doDecodeSync = function() {
              e:
                for (; ; ) {
                  var e6 = this.readHeadByte(), t5 = void 0;
                  if (e6 >= 224)
                    t5 = e6 - 256;
                  else if (e6 < 192)
                    if (e6 < 128)
                      t5 = e6;
                    else if (e6 < 144) {
                      if (0 != (r4 = e6 - 128)) {
                        this.pushMapState(r4), this.complete();
                        continue e;
                      }
                      t5 = {};
                    } else if (e6 < 160) {
                      if (0 != (r4 = e6 - 144)) {
                        this.pushArrayState(r4), this.complete();
                        continue e;
                      }
                      t5 = [];
                    } else {
                      var i4 = e6 - 160;
                      t5 = this.decodeUtf8String(i4, 0);
                    }
                  else if (192 === e6)
                    t5 = null;
                  else if (194 === e6)
                    t5 = false;
                  else if (195 === e6)
                    t5 = true;
                  else if (202 === e6)
                    t5 = this.readF32();
                  else if (203 === e6)
                    t5 = this.readF64();
                  else if (204 === e6)
                    t5 = this.readU8();
                  else if (205 === e6)
                    t5 = this.readU16();
                  else if (206 === e6)
                    t5 = this.readU32();
                  else if (207 === e6)
                    t5 = this.readU64();
                  else if (208 === e6)
                    t5 = this.readI8();
                  else if (209 === e6)
                    t5 = this.readI16();
                  else if (210 === e6)
                    t5 = this.readI32();
                  else if (211 === e6)
                    t5 = this.readI64();
                  else if (217 === e6)
                    i4 = this.lookU8(), t5 = this.decodeUtf8String(i4, 1);
                  else if (218 === e6)
                    i4 = this.lookU16(), t5 = this.decodeUtf8String(i4, 2);
                  else if (219 === e6)
                    i4 = this.lookU32(), t5 = this.decodeUtf8String(i4, 4);
                  else if (220 === e6) {
                    if (0 !== (r4 = this.readU16())) {
                      this.pushArrayState(r4), this.complete();
                      continue e;
                    }
                    t5 = [];
                  } else if (221 === e6) {
                    if (0 !== (r4 = this.readU32())) {
                      this.pushArrayState(r4), this.complete();
                      continue e;
                    }
                    t5 = [];
                  } else if (222 === e6) {
                    if (0 !== (r4 = this.readU16())) {
                      this.pushMapState(r4), this.complete();
                      continue e;
                    }
                    t5 = {};
                  } else if (223 === e6) {
                    if (0 !== (r4 = this.readU32())) {
                      this.pushMapState(r4), this.complete();
                      continue e;
                    }
                    t5 = {};
                  } else if (196 === e6) {
                    var r4 = this.lookU8();
                    t5 = this.decodeBinary(r4, 1);
                  } else if (197 === e6)
                    r4 = this.lookU16(), t5 = this.decodeBinary(r4, 2);
                  else if (198 === e6)
                    r4 = this.lookU32(), t5 = this.decodeBinary(r4, 4);
                  else if (212 === e6)
                    t5 = this.decodeExtension(1, 0);
                  else if (213 === e6)
                    t5 = this.decodeExtension(2, 0);
                  else if (214 === e6)
                    t5 = this.decodeExtension(4, 0);
                  else if (215 === e6)
                    t5 = this.decodeExtension(8, 0);
                  else if (216 === e6)
                    t5 = this.decodeExtension(16, 0);
                  else if (199 === e6)
                    r4 = this.lookU8(), t5 = this.decodeExtension(r4, 1);
                  else if (200 === e6)
                    r4 = this.lookU16(), t5 = this.decodeExtension(r4, 2);
                  else {
                    if (201 !== e6)
                      throw new m3("Unrecognized type byte: " + P3(e6));
                    r4 = this.lookU32(), t5 = this.decodeExtension(r4, 4);
                  }
                  this.complete();
                  for (var n4 = this.stack; n4.length > 0; ) {
                    var o4 = n4[n4.length - 1];
                    if (0 === o4.type) {
                      if (o4.array[o4.position] = t5, o4.position++, o4.position !== o4.size)
                        continue e;
                      n4.pop(), t5 = o4.array;
                    } else {
                      if (1 === o4.type) {
                        if ("string" != (s4 = typeof t5) && "number" !== s4)
                          throw new m3("The type of key must be string or number but " + typeof t5);
                        if ("__proto__" === t5)
                          throw new m3("The key __proto__ is not allowed");
                        o4.key = t5, o4.type = 2;
                        continue e;
                      }
                      if (o4.map[o4.key] = t5, o4.readCount++, o4.readCount !== o4.size) {
                        o4.key = null, o4.type = 1;
                        continue e;
                      }
                      n4.pop(), t5 = o4.map;
                    }
                  }
                  return t5;
                }
              var s4;
            }, e5.prototype.readHeadByte = function() {
              return -1 === this.headByte && (this.headByte = this.readU8()), this.headByte;
            }, e5.prototype.complete = function() {
              this.headByte = -1;
            }, e5.prototype.readArraySize = function() {
              var e6 = this.readHeadByte();
              switch (e6) {
                case 220:
                  return this.readU16();
                case 221:
                  return this.readU32();
                default:
                  if (e6 < 160)
                    return e6 - 144;
                  throw new m3("Unrecognized array type byte: " + P3(e6));
              }
            }, e5.prototype.pushMapState = function(e6) {
              if (e6 > this.maxMapLength)
                throw new m3("Max length exceeded: map length (" + e6 + ") > maxMapLengthLength (" + this.maxMapLength + ")");
              this.stack.push({ type: 1, size: e6, key: null, readCount: 0, map: {} });
            }, e5.prototype.pushArrayState = function(e6) {
              if (e6 > this.maxArrayLength)
                throw new m3("Max length exceeded: array length (" + e6 + ") > maxArrayLength (" + this.maxArrayLength + ")");
              this.stack.push({ type: 0, size: e6, array: new Array(e6), position: 0 });
            }, e5.prototype.decodeUtf8String = function(e6, t5) {
              var i4;
              if (e6 > this.maxStrLength)
                throw new m3("Max length exceeded: UTF-8 byte length (" + e6 + ") > maxStrLength (" + this.maxStrLength + ")");
              if (this.bytes.byteLength < this.pos + t5 + e6)
                throw V3;
              var r4, n4 = this.pos + t5;
              return r4 = this.stateIsMapKey() && (null === (i4 = this.keyDecoder) || void 0 === i4 ? void 0 : i4.canBeCached(e6)) ? this.keyDecoder.decode(this.bytes, n4, e6) : e6 > g3 ? function(e7, t6, i5) {
                var r5 = e7.subarray(t6, t6 + i5);
                return p3.decode(r5);
              }(this.bytes, n4, e6) : A3(this.bytes, n4, e6), this.pos += t5 + e6, r4;
            }, e5.prototype.stateIsMapKey = function() {
              return this.stack.length > 0 && 1 === this.stack[this.stack.length - 1].type;
            }, e5.prototype.decodeBinary = function(e6, t5) {
              if (e6 > this.maxBinLength)
                throw new m3("Max length exceeded: bin length (" + e6 + ") > maxBinLength (" + this.maxBinLength + ")");
              if (!this.hasRemaining(e6 + t5))
                throw V3;
              var i4 = this.pos + t5, r4 = this.bytes.subarray(i4, i4 + e6);
              return this.pos += t5 + e6, r4;
            }, e5.prototype.decodeExtension = function(e6, t5) {
              if (e6 > this.maxExtLength)
                throw new m3("Max length exceeded: ext length (" + e6 + ") > maxExtLength (" + this.maxExtLength + ")");
              var i4 = this.view.getInt8(this.pos + t5), r4 = this.decodeBinary(e6, t5 + 1);
              return this.extensionCodec.decode(r4, i4, this.context);
            }, e5.prototype.lookU8 = function() {
              return this.view.getUint8(this.pos);
            }, e5.prototype.lookU16 = function() {
              return this.view.getUint16(this.pos);
            }, e5.prototype.lookU32 = function() {
              return this.view.getUint32(this.pos);
            }, e5.prototype.readU8 = function() {
              var e6 = this.view.getUint8(this.pos);
              return this.pos++, e6;
            }, e5.prototype.readI8 = function() {
              var e6 = this.view.getInt8(this.pos);
              return this.pos++, e6;
            }, e5.prototype.readU16 = function() {
              var e6 = this.view.getUint16(this.pos);
              return this.pos += 2, e6;
            }, e5.prototype.readI16 = function() {
              var e6 = this.view.getInt16(this.pos);
              return this.pos += 2, e6;
            }, e5.prototype.readU32 = function() {
              var e6 = this.view.getUint32(this.pos);
              return this.pos += 4, e6;
            }, e5.prototype.readI32 = function() {
              var e6 = this.view.getInt32(this.pos);
              return this.pos += 4, e6;
            }, e5.prototype.readU64 = function() {
              var e6, t5, i4 = (e6 = this.view, t5 = this.pos, 4294967296 * e6.getUint32(t5) + e6.getUint32(t5 + 4));
              return this.pos += 8, i4;
            }, e5.prototype.readI64 = function() {
              var e6 = n3(this.view, this.pos);
              return this.pos += 8, e6;
            }, e5.prototype.readF32 = function() {
              var e6 = this.view.getFloat32(this.pos);
              return this.pos += 4, e6;
            }, e5.prototype.readF64 = function() {
              var e6 = this.view.getFloat64(this.pos);
              return this.pos += 8, e6;
            }, e5;
          }(), K3 = {};
          function H3(e5, t5) {
            return void 0 === t5 && (t5 = K3), new G3(t5.extensionCodec, t5.context, t5.maxStrLength, t5.maxBinLength, t5.maxArrayLength, t5.maxMapLength, t5.maxExtLength).decode(e5);
          }
          function W3(e5, t5) {
            return void 0 === t5 && (t5 = K3), new G3(t5.extensionCodec, t5.context, t5.maxStrLength, t5.maxBinLength, t5.maxArrayLength, t5.maxMapLength, t5.maxExtLength).decodeMulti(e5);
          }
          var Y3 = function(e5, t5) {
            var i4, r4, n4, o4, s4 = { label: 0, sent: function() {
              if (1 & n4[0])
                throw n4[1];
              return n4[1];
            }, trys: [], ops: [] };
            return o4 = { next: a4(0), throw: a4(1), return: a4(2) }, "function" == typeof Symbol && (o4[Symbol.iterator] = function() {
              return this;
            }), o4;
            function a4(o5) {
              return function(a5) {
                return function(o6) {
                  if (i4)
                    throw new TypeError("Generator is already executing.");
                  for (; s4; )
                    try {
                      if (i4 = 1, r4 && (n4 = 2 & o6[0] ? r4.return : o6[0] ? r4.throw || ((n4 = r4.return) && n4.call(r4), 0) : r4.next) && !(n4 = n4.call(r4, o6[1])).done)
                        return n4;
                      switch (r4 = 0, n4 && (o6 = [2 & o6[0], n4.value]), o6[0]) {
                        case 0:
                        case 1:
                          n4 = o6;
                          break;
                        case 4:
                          return s4.label++, { value: o6[1], done: false };
                        case 5:
                          s4.label++, r4 = o6[1], o6 = [0];
                          continue;
                        case 7:
                          o6 = s4.ops.pop(), s4.trys.pop();
                          continue;
                        default:
                          if (!((n4 = (n4 = s4.trys).length > 0 && n4[n4.length - 1]) || 6 !== o6[0] && 2 !== o6[0])) {
                            s4 = 0;
                            continue;
                          }
                          if (3 === o6[0] && (!n4 || o6[1] > n4[0] && o6[1] < n4[3])) {
                            s4.label = o6[1];
                            break;
                          }
                          if (6 === o6[0] && s4.label < n4[1]) {
                            s4.label = n4[1], n4 = o6;
                            break;
                          }
                          if (n4 && s4.label < n4[2]) {
                            s4.label = n4[2], s4.ops.push(o6);
                            break;
                          }
                          n4[2] && s4.ops.pop(), s4.trys.pop();
                          continue;
                      }
                      o6 = t5.call(e5, s4);
                    } catch (e6) {
                      o6 = [6, e6], r4 = 0;
                    } finally {
                      i4 = n4 = 0;
                    }
                  if (5 & o6[0])
                    throw o6[1];
                  return { value: o6[0] ? o6[1] : void 0, done: true };
                }([o5, a5]);
              };
            }
          }, J3 = function(e5) {
            return this instanceof J3 ? (this.v = e5, this) : new J3(e5);
          }, q3 = function(e5, t5, i4) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var r4, n4 = i4.apply(e5, t5 || []), o4 = [];
            return r4 = {}, s4("next"), s4("throw"), s4("return"), r4[Symbol.asyncIterator] = function() {
              return this;
            }, r4;
            function s4(e6) {
              n4[e6] && (r4[e6] = function(t6) {
                return new Promise(function(i5, r5) {
                  o4.push([e6, t6, i5, r5]) > 1 || a4(e6, t6);
                });
              });
            }
            function a4(e6, t6) {
              try {
                (i5 = n4[e6](t6)).value instanceof J3 ? Promise.resolve(i5.value.v).then(c4, d4) : u4(o4[0][2], i5);
              } catch (e7) {
                u4(o4[0][3], e7);
              }
              var i5;
            }
            function c4(e6) {
              a4("next", e6);
            }
            function d4(e6) {
              a4("throw", e6);
            }
            function u4(e6, t6) {
              e6(t6), o4.shift(), o4.length && a4(o4[0][0], o4[0][1]);
            }
          };
          function X3(e5) {
            if (null == e5)
              throw new Error("Assertion Failure: value must not be null nor undefined");
          }
          function z3(e5) {
            return null != e5[Symbol.asyncIterator] ? e5 : function(e6) {
              return q3(this, arguments, function() {
                var t5, i4, r4, n4;
                return Y3(this, function(o4) {
                  switch (o4.label) {
                    case 0:
                      t5 = e6.getReader(), o4.label = 1;
                    case 1:
                      o4.trys.push([1, , 9, 10]), o4.label = 2;
                    case 2:
                      return [4, J3(t5.read())];
                    case 3:
                      return i4 = o4.sent(), r4 = i4.done, n4 = i4.value, r4 ? [4, J3(void 0)] : [3, 5];
                    case 4:
                      return [2, o4.sent()];
                    case 5:
                      return X3(n4), [4, J3(n4)];
                    case 6:
                      return [4, o4.sent()];
                    case 7:
                      return o4.sent(), [3, 2];
                    case 8:
                      return [3, 10];
                    case 9:
                      return t5.releaseLock(), [7];
                    case 10:
                      return [2];
                  }
                });
              });
            }(e5);
          }
          function Z2(e5, t5) {
            return void 0 === t5 && (t5 = K3), i4 = this, r4 = void 0, o4 = function() {
              var i5;
              return function(e6, t6) {
                var i6, r5, n5, o5, s4 = { label: 0, sent: function() {
                  if (1 & n5[0])
                    throw n5[1];
                  return n5[1];
                }, trys: [], ops: [] };
                return o5 = { next: a4(0), throw: a4(1), return: a4(2) }, "function" == typeof Symbol && (o5[Symbol.iterator] = function() {
                  return this;
                }), o5;
                function a4(o6) {
                  return function(a5) {
                    return function(o7) {
                      if (i6)
                        throw new TypeError("Generator is already executing.");
                      for (; s4; )
                        try {
                          if (i6 = 1, r5 && (n5 = 2 & o7[0] ? r5.return : o7[0] ? r5.throw || ((n5 = r5.return) && n5.call(r5), 0) : r5.next) && !(n5 = n5.call(r5, o7[1])).done)
                            return n5;
                          switch (r5 = 0, n5 && (o7 = [2 & o7[0], n5.value]), o7[0]) {
                            case 0:
                            case 1:
                              n5 = o7;
                              break;
                            case 4:
                              return s4.label++, { value: o7[1], done: false };
                            case 5:
                              s4.label++, r5 = o7[1], o7 = [0];
                              continue;
                            case 7:
                              o7 = s4.ops.pop(), s4.trys.pop();
                              continue;
                            default:
                              if (!((n5 = (n5 = s4.trys).length > 0 && n5[n5.length - 1]) || 6 !== o7[0] && 2 !== o7[0])) {
                                s4 = 0;
                                continue;
                              }
                              if (3 === o7[0] && (!n5 || o7[1] > n5[0] && o7[1] < n5[3])) {
                                s4.label = o7[1];
                                break;
                              }
                              if (6 === o7[0] && s4.label < n5[1]) {
                                s4.label = n5[1], n5 = o7;
                                break;
                              }
                              if (n5 && s4.label < n5[2]) {
                                s4.label = n5[2], s4.ops.push(o7);
                                break;
                              }
                              n5[2] && s4.ops.pop(), s4.trys.pop();
                              continue;
                          }
                          o7 = t6.call(e6, s4);
                        } catch (e7) {
                          o7 = [6, e7], r5 = 0;
                        } finally {
                          i6 = n5 = 0;
                        }
                      if (5 & o7[0])
                        throw o7[1];
                      return { value: o7[0] ? o7[1] : void 0, done: true };
                    }([o6, a5]);
                  };
                }
              }(this, function(r5) {
                return i5 = z3(e5), [2, new G3(t5.extensionCodec, t5.context, t5.maxStrLength, t5.maxBinLength, t5.maxArrayLength, t5.maxMapLength, t5.maxExtLength).decodeAsync(i5)];
              });
            }, new ((n4 = void 0) || (n4 = Promise))(function(e6, t6) {
              function s4(e7) {
                try {
                  c4(o4.next(e7));
                } catch (e8) {
                  t6(e8);
                }
              }
              function a4(e7) {
                try {
                  c4(o4.throw(e7));
                } catch (e8) {
                  t6(e8);
                }
              }
              function c4(t7) {
                var i5;
                t7.done ? e6(t7.value) : (i5 = t7.value, i5 instanceof n4 ? i5 : new n4(function(e7) {
                  e7(i5);
                })).then(s4, a4);
              }
              c4((o4 = o4.apply(i4, r4 || [])).next());
            });
            var i4, r4, n4, o4;
          }
          function $2(e5, t5) {
            void 0 === t5 && (t5 = K3);
            var i4 = z3(e5);
            return new G3(t5.extensionCodec, t5.context, t5.maxStrLength, t5.maxBinLength, t5.maxArrayLength, t5.maxMapLength, t5.maxExtLength).decodeArrayStream(i4);
          }
          function ee2(e5, t5) {
            void 0 === t5 && (t5 = K3);
            var i4 = z3(e5);
            return new G3(t5.extensionCodec, t5.context, t5.maxStrLength, t5.maxBinLength, t5.maxArrayLength, t5.maxMapLength, t5.maxExtLength).decodeStream(i4);
          }
          function te2(e5, t5) {
            return void 0 === t5 && (t5 = K3), ee2(e5, t5);
          }
          return t4;
        }();
      }(kJ), (0, gU.exports)("Int8", function(e3) {
        return function(t3, i3, r3) {
          return e3(this, t3, i3, r3);
        };
      }), (0, gU.exports)("Int16", function(e3) {
        return function(t3, i3, r3) {
          return e3(this, t3, i3, r3);
        };
      }), (0, gU.exports)("Int32", function(e3) {
        return function(t3, i3, r3) {
          return e3(this, t3, i3, r3);
        };
      }), (0, gU.exports)("Uint16", function(e3) {
        return function(t3, i3, r3) {
          return e3(this, t3, i3, r3);
        };
      }), (0, gU.exports)("Uint32", function(e3) {
        return function(t3, i3, r3) {
          return e3(this, t3, i3, r3);
        };
      }), (0, gU.exports)("Float64", function(e3) {
        return function(t3, i3, r3) {
          return e3(this, t3, i3, r3);
        };
      });
      const BJ = () => function(e3) {
        const t3 = window.atob(e3).split("").map((e4) => e4.charCodeAt(0));
        return new Uint8Array(t3, 0, t3.length / Uint8Array.BYTES_PER_ELEMENT);
      }("AGFzbQEAAAABMAlgA39/fwF/YAF/AGACf38AYAF/AX9gAn9/AX9gA39/fwBgBH9/f38AYAABf2AAAAI6AgNlbnYWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAADA2VudhVlbXNjcmlwdGVuX21lbWNweV9iaWcAAAMjIggAAAAAAQEDAQEEBAQEAQEGAQYCBQUAAgAHAwEDAAIHAQMEBQFwAQYGBQYBAYACgAIGCQF/AUHQ48ACCweUAQoGbWVtb3J5AgARX193YXNtX2NhbGxfY3RvcnMAAhlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQAGbWFsbG9jABwEZnJlZQAdEF9fZXJybm9fbG9jYXRpb24AGwx6bGliQ29tcHJlc3MAGglzdGFja1NhdmUAIQxzdGFja1Jlc3RvcmUAIgpzdGFja0FsbG9jACMJCwEAQQELBRgZDA0PCq6FAiIDAAELpQcBBH8gAEH//wNxIQMgAEEQdiEEQQEhACACQQFGBEAgAyABLQAAaiIAQfH/A2sgACAAQfD/A0sbIgAgBGoiA0EQdCIEQYCAPGogBCADQfD/A0sbIAByDwsgAQR/IAJBEE8EQAJAAkACQCACQa8rSwRAA0AgAkGwK2shAkHbAiEFIAEhAANAIAMgAC0AAGoiAyAEaiADIAAtAAFqIgNqIAMgAC0AAmoiA2ogAyAALQADaiIDaiADIAAtAARqIgNqIAMgAC0ABWoiA2ogAyAALQAGaiIDaiADIAAtAAdqIgNqIAMgAC0ACGoiA2ogAyAALQAJaiIDaiADIAAtAApqIgNqIAMgAC0AC2oiA2ogAyAALQAMaiIDaiADIAAtAA1qIgNqIAMgAC0ADmoiA2ogAyAALQAPaiIDaiEEIABBEGohACAFQQFrIgUNAAsgBEHx/wNwIQQgA0Hx/wNwIQMgAUGwK2ohASACQa8rSw0ACyACRQ0DIAJBEEkNAQsDQCADIAEtAABqIgAgBGogACABLQABaiIAaiAAIAEtAAJqIgBqIAAgAS0AA2oiAGogACABLQAEaiIAaiAAIAEtAAVqIgBqIAAgAS0ABmoiAGogACABLQAHaiIAaiAAIAEtAAhqIgBqIAAgAS0ACWoiAGogACABLQAKaiIAaiAAIAEtAAtqIgBqIAAgAS0ADGoiAGogACABLQANaiIAaiAAIAEtAA5qIgBqIAAgAS0AD2oiA2ohBCABQRBqIQEgAkEQayICQQ9LDQALIAJFDQELIAJBAWshBiACQQNxIgUEQCABIQADQCACQQFrIQIgAyAALQAAaiIDIARqIQQgAEEBaiIBIQAgBUEBayIFDQALCyAGQQNJDQADQCADIAEtAABqIgAgAS0AAWoiBSABLQACaiIGIAEtAANqIgMgBiAFIAAgBGpqamohBCABQQRqIQEgAkEEayICDQALCyAEQfH/A3AhBCADQfH/A3AhAwsgBEEQdCADcg8LAkAgAkUNACACQQFrIQYgAkEDcSIFBEAgASEAA0AgAkEBayECIAMgAC0AAGoiAyAEaiEEIABBAWoiASEAIAVBAWsiBQ0ACwsgBkEDSQ0AA0AgAyABLQAAaiIAIAEtAAFqIgUgAS0AAmoiBiABLQADaiIDIAYgBSAAIARqampqIQQgAUEEaiEBIAJBBGsiAg0ACwsgBEHx/wNwQRB0IANB8f8DayADIANB8P8DSxtyBSAACwsKACAAIAEgAhADC4UJAQJ/IAFFBEBBAA8LIABBf3MhAAJAIAJFDQAgAUEDcUUNACABLQAAIABB/wFxc0ECdEGACGooAgAgAEEIdnMhACACQQFrIgRBACABQQFqIgNBA3EbRQRAIAMhASAEIQIMAQsgAS0AASAAQf8BcXNBAnRBgAhqKAIAIABBCHZzIQAgAUECaiEDAkAgAkECayIERQ0AIANBA3FFDQAgAS0AAiAAQf8BcXNBAnRBgAhqKAIAIABBCHZzIQAgAUEDaiEDAkAgAkEDayIERQ0AIANBA3FFDQAgAS0AAyAAQf8BcXNBAnRBgAhqKAIAIABBCHZzIQAgAkEEayECIAFBBGohAQwCCyADIQEgBCECDAELIAMhASAEIQILIAJBH0sEQANAIAEoAhwgASgCGCABKAIUIAEoAhAgASgCDCABKAIIIAEoAgQgASgCACAAcyIAQQZ2QfwHcUGAGGooAgAgAEH/AXFBAnRBgCBqKAIAcyAAQQ52QfwHcUGAEGooAgBzIABBFnZB/AdxQYAIaigCAHNzIgBBBnZB/AdxQYAYaigCACAAQf8BcUECdEGAIGooAgBzIABBDnZB/AdxQYAQaigCAHMgAEEWdkH8B3FBgAhqKAIAc3MiAEEGdkH8B3FBgBhqKAIAIABB/wFxQQJ0QYAgaigCAHMgAEEOdkH8B3FBgBBqKAIAcyAAQRZ2QfwHcUGACGooAgBzcyIAQQZ2QfwHcUGAGGooAgAgAEH/AXFBAnRBgCBqKAIAcyAAQQ52QfwHcUGAEGooAgBzIABBFnZB/AdxQYAIaigCAHNzIgBBBnZB/AdxQYAYaigCACAAQf8BcUECdEGAIGooAgBzIABBDnZB/AdxQYAQaigCAHMgAEEWdkH8B3FBgAhqKAIAc3MiAEEGdkH8B3FBgBhqKAIAIABB/wFxQQJ0QYAgaigCAHMgAEEOdkH8B3FBgBBqKAIAcyAAQRZ2QfwHcUGACGooAgBzcyIAQQZ2QfwHcUGAGGooAgAgAEH/AXFBAnRBgCBqKAIAcyAAQQ52QfwHcUGAEGooAgBzIABBFnZB/AdxQYAIaigCAHNzIgBBBnZB/AdxQYAYaigCACAAQf8BcUECdEGAIGooAgBzIABBDnZB/AdxQYAQaigCAHMgAEEWdkH8B3FBgAhqKAIAcyEAIAFBIGohASACQSBrIgJBH0sNAAsLIAJBA0sEQANAIAEoAgAgAHMiAEEGdkH8B3FBgBhqKAIAIABB/wFxQQJ0QYAgaigCAHMgAEEOdkH8B3FBgBBqKAIAcyAAQRZ2QfwHcUGACGooAgBzIQAgAUEEaiEBIAJBBGsiAkEDSw0ACwsCQCACRQ0AIAJBAXEEfyABLQAAIABB/wFxc0ECdEGACGooAgAgAEEIdnMhACABQQFqIQEgAkEBawUgAgshAyACQQFGDQADQCABLQABIAEtAAAgAEH/AXFzQQJ0QYAIaigCACAAQQh2cyIAQf8BcXNBAnRBgAhqKAIAIABBCHZzIQAgAUECaiEBIANBAmsiAw0ACwsgAEF/cwsKACAAIAEgAhAFC9wEAQN/AkBByN8ALQAAQTFHDQAgAEUNACAAQQA2AhggACgCICIBRQRAIABBADYCKCAAQQE2AiBBASEBCyAAKAIkRQRAIABBAjYCJAsgACgCKEEBQcQtIAERAAAiAUUNACAAIAE2AhwgAUEPNgIwIAFBADYCHCABQQA2AhggAUEqNgIEIAEgADYCACABQQs2AlAgAUGAgAI2AiwgAUH//wE2AjQgAUGAEDYCTCABQQQ2AlggAUH/DzYCVCABIAAoAihBgIACQQIgACgCIBEAADYCOCABIAAoAiggASgCLEECIAAoAiARAAA2AkAgACgCKCABKAJMQQIgACgCIBEAACECIAFBADYCwC0gASACNgJEIAFBgAg2ApwtIAEgACgCKEGACEEEIAAoAiARAAAiAjYCCCABIAEoApwtIgNBAnQ2AgwCQAJAIAEoAjhFDQAgASgCQEUNACACRQ0AIAEoAkQNAQsgAUGaBTYCBCAAQbjfACgCADYCGCAAEAgPCyABQQA2AogBIAFBCTYChAEgAUEIOgAkIAEgAiADQQNsajYCmC0gASACIANBfnFqNgKkLSAAEAkNACAAKAIcIgAgACgCLEEBdDYCPCAAKAJEIgEgACgCTEEBdEECayIDakEAOwEAIAEgAxAgIABBADYCtC0gAEKAgICAIDcCdCAAQgA3AmggAEKAgICAIDcCXCAAQQA2AkggACAAKAKEAUEMbCIBQYTIAGovAQA2ApABIAAgAUGAyABqLwEANgKMASAAIAFBgsgAai8BADYCgAEgACABQYbIAGovAQA2AnwLC6kCAQN/AkAgAEUNACAAKAIgRQ0AIAAoAiQiA0UNACAAKAIcIgFFDQAgASgCACAARw0AAkACQCABKAIEIgJBOWsOOQECAgICAgICAgICAgECAgIBAgICAgICAgICAgICAgICAgIBAgICAgICAgICAgIBAgICAgICAgICAQALIAJBmgVGDQAgAkEqRw0BCwJ/An8CfyABKAIIIgIEQCAAKAIoIAIgAxECACAAKAIcIQELIAEoAkQiAgsEQCAAKAIoIAIgACgCJBECACAAKAIcIQELIAEoAkAiAgsEQCAAKAIoIAIgACgCJBECACAAKAIcIQELIAEoAjgiAgsEQCAAKAIoIAIgACgCJBECACAAKAIcIQELIAAoAiggASAAKAIkEQIAIABBADYCHAsLlgIBA39BfiECAkAgAEUNACAAKAIgRQ0AIAAoAiRFDQAgACgCHCIBRQ0AIAEoAgAgAEcNAAJAAkAgASgCBCIDQTlrDjkBAgICAgICAgICAgIBAgICAQICAgICAgICAgICAgICAgICAQICAgICAgICAgICAQICAgICAgICAgEACyADQZoFRg0AIANBKkcNAQsgAEECNgIsIABBADYCCCAAQgA3AhQgAUEANgIUIAEgASgCCDYCECABKAIYIgJBf0wEQCABQQAgAmsiAjYCGAsgAUE5QSpB8QAgAhsgAkECRhs2AgQgAAJ/IAJBAkYEQEEAQQBBABAGDAELQQBBAEEAEAQLNgIwQQAhAiABQQA2AiggARAQCyACC9wIAQt/IAAoAiwiB0GGAmshCyAAKAJ0IQUgByEBA0AgACgCPCAFayAAKAJsIghrIQYgASALaiAITQRAIAAoAjgiASABIAdqIAcgBmsQHxogACAAKAJwIAdrNgJwIAAgACgCbCAHayIINgJsIAAgACgCXCAHazYCXCAAKAJMIgRBAWshCiAAKAJEIARBAXRqIQMgACgCLCEBIARBA3EiAgRAA0AgA0ECayIDQQAgAy8BACIFIAFrIgkgBSAJSRs7AQAgBEEBayEEIAJBAWsiAg0ACwsgCkEDTwRAA0AgA0ECayICQQAgAi8BACICIAFrIgUgAiAFSRs7AQAgA0EEayICQQAgAi8BACICIAFrIgUgAiAFSRs7AQAgA0EGayICQQAgAi8BACICIAFrIgUgAiAFSRs7AQAgA0EIayIDQQAgAy8BACICIAFrIgUgAiAFSRs7AQAgBEEEayIEDQALCyABQQFrIQogACgCQCABQQF0aiEDIAEhBCABQQNxIgIEQANAIANBAmsiA0EAIAMvAQAiBSABayIJIAUgCUkbOwEAIARBAWshBCACQQFrIgINAAsLIApBA08EQANAIANBAmsiAkEAIAIvAQAiAiABayIFIAIgBUkbOwEAIANBBGsiAkEAIAIvAQAiAiABayIFIAIgBUkbOwEAIANBBmsiAkEAIAIvAQAiAiABayIFIAIgBUkbOwEAIANBCGsiA0EAIAMvAQAiAiABayIFIAIgBUkbOwEAIARBBGsiBA0ACwsgBiAHaiEGCwJAIAAoAgAiASgCBCIERQ0AIAAoAnQhAiAGIAQgBCAGSxsiAwRAIAAoAjghBSABIAQgA2s2AgQgBSAIaiACaiABKAIAIAMQHyEEAkACQAJAIAEoAhwoAhhBAWsOAgABAgsgASABKAIwIAQgAxAENgIwDAELIAEgASgCMCAEIAMQBjYCMAsgASABKAIAIANqNgIAIAEgASgCCCADajYCCCAAKAJ0IQILIAAgAiADaiIFNgJ0AkAgACgCtC0iAyAFakEDSQ0AIAAgACgCOCIJIAAoAmwgA2siAWoiBC0AACICNgJIIAAgACgCVCIIIAQtAAEgAiAAKAJYIgZ0c3EiBDYCSANAIANFDQEgACABIAlqLQACIAQgBnRzIAhxIgQ2AkggACgCQCAAKAI0IAFxQQF0aiAAKAJEIARBAXRqIgIvAQA7AQAgAiABOwEAIAAgA0EBayIDNgK0LSABQQFqIQEgAyAFakECSw0ACwsgBUGFAksNACAAKAIAKAIERQ0AIAAoAiwhAQwBCwsCQCAAKAI8IgQgACgCwC0iAU0NACAAKAJ0IAAoAmxqIgMgAUsEQCAAKAI4IANqIAQgA2siAUGCAiABQYICSRsiARAgIAAgASADajYCwC0PCyADQYICaiIDIAFNDQAgACgCOCABaiAEIAFrIgQgAyABayIBIAEgBEsbIgEQICAAIAAoAsAtIAFqNgLALQsLsSwBCn8CQCAARQ0AIAAoAiBFDQAgACgCJEUNACAAKAIcIgFFDQAgASgCACAARw0AAkACQCABKAIEIgNBOWsOOQECAgICAgICAgICAgECAgIBAgICAgICAgICAgICAgICAgIBAgICAgICAgICAgIBAgICAgICAgICAQALIANBmgVGDQAgA0EqRw0BCwJAAkAgACgCDEUNACAAKAIEIgIEQCAAKAIARQ0BCyADQZoFRw0BCyAAQbDfACgCADYCGA8LIAAoAhBFBEAgAEG83wAoAgA2AhgPCyABKAIoIQUgAUEDNgIoAkAgASgCFARAIAEQEwJAIAAoAhAiAyABKAIUIgQgAyAESRsiAkUNACAAKAIMIAEoAhAgAhAfGiAAIAAoAgwgAmo2AgwgASABKAIQIAJqNgIQIAAgACgCFCACajYCFCAAIAAoAhAgAmsiAzYCECABIAEoAhQgAmsiBDYCFCAEDQAgASABKAIINgIQQQAhBAsgAwRAIAEoAgQhAwwCCyABQX82AigPCyACDQAgBUEBdEF3QQAgBUEEShtqQQZIDQAgAEG83wAoAgA2AhgPCwJAAkACQAJAAn8CQAJAAkACQAJAAkAgA0EqRwRAIANBmgVHDQEgACgCBEUNAiAAQbzfACgCADYCGA8LIAEoAjBBDHRBgPABayEDQQAhAgJAIAEoAogBQQFKDQAgASgChAEiBUECSA0AQcAAIQIgBUEGSA0AQYABQcABIAVBBkYbIQILIAEgBEEBajYCFCABKAIIIARqIAIgA3IiAkEgciACIAEoAmwbIgJBCHY6AAAgASABKAIUIgNBAWo2AhQgAyABKAIIaiACQR9wIAJyQR9zOgAAIAEoAmwEQCAAKAIwIQIgASABKAIUIgNBAWo2AhQgAyABKAIIaiACQRh2OgAAIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAkEQdjoAACAAKAIwIQIgASABKAIUIgNBAWo2AhQgAyABKAIIaiACQQh2OgAAIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAjoAAAsgAEEAQQBBABAENgIwIAFB8QA2AgQgACgCHCICEBMCQCAAKAIQIgMgAigCFCIEIAMgBEkbIgNFDQAgACgCDCACKAIQIAMQHxogACAAKAIMIANqNgIMIAIgAigCECADajYCECAAIAAoAhQgA2o2AhQgACAAKAIQIANrNgIQIAIgAigCFCADayIDNgIUIAMNACACIAIoAgg2AhALIAEoAhQNBCABKAIEIQMLAkACQAJAAkACQAJAAkAgA0E5RgR/IABBAEEAQQAQBjYCMCABIAEoAhQiAkEBajYCFCACIAEoAghqQR86AAAgASABKAIUIgJBAWo2AhQgAiABKAIIakGLAToAACABIAEoAhQiAkEBajYCFCACIAEoAghqQQg6AAAgASgCHCICDQIgASABKAIUIgJBAWo2AhQgAiABKAIIakEAOgAAIAEgASgCFCICQQFqNgIUIAIgASgCCGpBADoAACABIAEoAhQiAkEBajYCFCACIAEoAghqQQA6AAAgASABKAIUIgJBAWo2AhQgAiABKAIIakEAOgAAIAEgASgCFCICQQFqNgIUIAIgASgCCGpBADoAAEECIQIgASgChAEiA0EJRwRAQQQgASgCiAFBAUpBAnQgA0ECSBshAgsgASABKAIUIgNBAWo2AhQgAyABKAIIaiACOgAAIAEgASgCFCICQQFqNgIUIAIgASgCCGpBAzoAACABQfEANgIEIAAoAhwiAhATAkAgACgCECIDIAIoAhQiBCADIARJGyIDRQ0AIAAoAgwgAigCECADEB8aIAAgACgCDCADajYCDCACIAIoAhAgA2o2AhAgACAAKAIUIANqNgIUIAAgACgCECADazYCECACIAIoAhQgA2siAzYCFCADDQAgAiACKAIINgIQCyABKAIUDQEgASgCBAUgAwtBxQBrDiMCBgYGAwYGBgYGBgYGBgYGBgYGBgYGBAYGBgYGBgYGBgYGBQYLIAFBfzYCKA8LIAIoAiQhAyACKAIcIQQgAigCECEFIAIoAiwhBiACKAIAIQggASABKAIUIgdBAWo2AhRBAiECIAcgASgCCGogBkEAR0EBdCAIQQBHciAFQQBHQQJ0ciAEQQBHQQN0ciADQQBHQQR0cjoAACABKAIcKAIEIQMgASABKAIUIgRBAWo2AhQgBCABKAIIaiADOgAAIAEoAhwoAgQhAyABIAEoAhQiBEEBajYCFCAEIAEoAghqIANBCHY6AAAgASgCHC8BBiEDIAEgASgCFCIEQQFqNgIUIAQgASgCCGogAzoAACABKAIcLQAHIQMgASABKAIUIgRBAWo2AhQgBCABKAIIaiADOgAAIAEoAoQBIgNBCUcEQEEEIAEoAogBQQFKQQJ0IANBAkgbIQILIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAjoAACABKAIcKAIMIQIgASABKAIUIgNBAWo2AhQgAyABKAIIaiACOgAAIAEoAhwiAigCEAR/IAIoAhQhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAI6AAAgASgCHCgCFCECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAkEIdjoAACABKAIcBSACCygCLARAIAAgACgCMCABKAIIIAEoAhQQBjYCMAsgAUHFADYCBCABQQA2AiALIAEoAhwiBCgCECIDBEAgASgCFCICIAQvARQgASgCICIGayIFaiABKAIMIgRLBEADQCABKAIIIAJqIAMgBmogBCACayIEEB8aIAEgASgCDCIDNgIUAkAgAiADTw0AIAEoAhwoAixFDQAgACAAKAIwIAEoAgggAmogAyACaxAGNgIwCyABIAEoAiAgBGo2AiAgACgCHCICEBMCQCAAKAIQIgMgAigCFCIGIAMgBkkbIgNFDQAgACgCDCACKAIQIAMQHxogACAAKAIMIANqNgIMIAIgAigCECADajYCECAAIAAoAhQgA2o2AhQgACAAKAIQIANrNgIQIAIgAigCFCADayIDNgIUIAMNACACIAIoAgg2AhALIAEoAhQEQCABQX82AigPCyABKAIgIQYgASgCHCgCECEDQQAhAiAFIARrIgUgASgCDCIESw0ACwsgASgCCCACaiADIAZqIAUQHxogASABKAIUIAVqIgM2AhQCQCACIANPDQAgASgCHCgCLEUNACAAIAAoAjAgASgCCCACaiADIAJrEAY2AjALIAFBADYCIAsgAUHJADYCBAsgASgCHCgCHARAIAEoAhQiAiEFA0ACQCACIAEoAgxHDQACQCACIAVNDQAgASgCHCgCLEUNACAAIAAoAjAgASgCCCAFaiACIAVrEAY2AjALIAAoAhwiAhATAkAgACgCECIDIAIoAhQiBCADIARJGyIDRQ0AIAAoAgwgAigCECADEB8aIAAgACgCDCADajYCDCACIAIoAhAgA2o2AhAgACAAKAIUIANqNgIUIAAgACgCECADazYCECACIAIoAhQgA2siAzYCFCADDQAgAiACKAIINgIQC0EAIQJBACEFIAEoAhRFDQAgAUF/NgIoDwsgASgCHCgCHCEDIAEgASgCICIEQQFqNgIgIAMgBGotAAAhAyABIAJBAWo2AhQgASgCCCACaiADOgAAIAMEQCABKAIUIQIMAQsLAkAgASgCHCgCLEUNACABKAIUIgIgBU0NACAAIAAoAjAgASgCCCAFaiACIAVrEAY2AjALIAFBADYCIAsgAUHbADYCBAsCQCABKAIcKAIkRQ0AIAEoAhQiAiEFA0ACQCACIAEoAgxHDQACQCACIAVNDQAgASgCHCgCLEUNACAAIAAoAjAgASgCCCAFaiACIAVrEAY2AjALIAAoAhwiAhATAkAgACgCECIDIAIoAhQiBCADIARJGyIDRQ0AIAAoAgwgAigCECADEB8aIAAgACgCDCADajYCDCACIAIoAhAgA2o2AhAgACAAKAIUIANqNgIUIAAgACgCECADazYCECACIAIoAhQgA2siAzYCFCADDQAgAiACKAIINgIQC0EAIQJBACEFIAEoAhRFDQAgAUF/NgIoDwsgASgCHCgCJCEDIAEgASgCICIEQQFqNgIgIAMgBGotAAAhAyABIAJBAWo2AhQgASgCCCACaiADOgAAIAMEQCABKAIUIQIMAQsLIAEoAhwoAixFDQAgASgCFCICIAVNDQAgACAAKAIwIAEoAgggBWogAiAFaxAGNgIwCyABQecANgIECyABKAIcKAIsBEAgASgCDCABKAIUIgJBAmpJBEAgACgCHCICEBMCQCAAKAIQIgMgAigCFCIEIAMgBEkbIgNFDQAgACgCDCACKAIQIAMQHxogACAAKAIMIANqNgIMIAIgAigCECADajYCECAAIAAoAhQgA2o2AhQgACAAKAIQIANrNgIQIAIgAigCFCADayIDNgIUIAMNACACIAIoAgg2AhALIAEoAhQNBUEAIQILIAAoAjAhAyABIAJBAWo2AhQgASgCCCACaiADOgAAIAAoAjAhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAJBCHY6AAAgAEEAQQBBABAGNgIwCyABQfEANgIEIAAoAhwiAhATAkAgACgCECIDIAIoAhQiBCADIARJGyIDRQ0AIAAoAgwgAigCECADEB8aIAAgACgCDCADajYCDCACIAIoAhAgA2o2AhAgACAAKAIUIANqNgIUIAAgACgCECADazYCECACIAIoAhQgA2siAzYCFCADDQAgAiACKAIINgIQCyABKAIURQ0AIAFBfzYCKA8LIAAoAgQNAQsgASgCdA0AIAEoAgRBmgVGDQgLIAEoAoQBIgJFBEAgAUEDEAwMBAsCQAJAIAEoAogBQQJrDgIAAQQLA0ACQAJAIAEoAnQNACABEAogASgCdA0AIAFBADYCtC0MAQsgAUEANgJgIAEoAjggASgCbGotAAAhAiABKAKkLSABKAKgLSIDQQF0akEAOwEAIAEgA0EBajYCoC0gAyABKAKYLWogAjoAACABIAJBAnRqQZQBaiICIAIvAQBBAWo7AQAgASABKAJ0QQFrNgJ0IAEgASgCbEEBaiICNgJsIAEoAqAtIAEoApwtQQFrRw0BIAEgASgCXCIEQQBOBH8gASgCOCAEagVBAAsgAiAEa0EAEBQgASABKAJsNgJcIAEoAgAiAigCHCIDEBMCQCACKAIQIgQgAygCFCIFIAQgBUkbIgRFDQAgAigCDCADKAIQIAQQHxogAiACKAIMIARqNgIMIAMgAygCECAEajYCECACIAIoAhQgBGo2AhQgAiACKAIQIARrNgIQIAMgAygCFCAEayICNgIUIAINACADIAMoAgg2AhALIAEoAgAoAhANAQwHCwsgASgCoC1FDQcgASABKAJcIgNBAE4EfyABKAI4IANqBUEACyABKAJsIANrQQAQFCABIAEoAmw2AlwgASgCACICKAIcIgMQEwJAIAIoAhAiBCADKAIUIgUgBCAFSRsiBEUNACACKAIMIAMoAhAgBBAfGiACIAIoAgwgBGo2AgwgAyADKAIQIARqNgIQIAIgAigCFCAEajYCFCACIAIoAhAgBGs2AhAgAyADKAIUIARrIgI2AhQgAg0AIAMgAygCCDYCEAsgASgCACgCEEUNBQwHCwNAAkACQAJAIAEoAnQiAkGDAk8EQCABQQA2AmAMAQsgARAKIAEoAnQiAgRAIAFBADYCYCACQQJLDQEgASgCbCEDDAILIAFBADYCtC0gASgCoC1FDQogASABKAJcIgNBAE4EfyABKAI4IANqBUEACyABKAJsIANrQQAQFCABIAEoAmw2AlwgASgCACICKAIcIgMQEwJAIAIoAhAiBCADKAIUIgUgBCAFSRsiBEUNACACKAIMIAMoAhAgBBAfGiACIAIoAgwgBGo2AgwgAyADKAIQIARqNgIQIAIgAigCFCAEajYCFCACIAIoAhAgBGs2AhAgAyADKAIUIARrIgI2AhQgAg0AIAMgAygCCDYCEAsgASgCACgCEEUNCAwKCyABKAJsIgNFBEBBACEDDAELIAEoAjggA2oiBkEBayIFLQAAIgQgBi0AAEcNACAEIAUtAAJHDQAgBCAFLQADRw0AIAZBggJqIQlBfyEIAkACQAJAAkACQAJAA0AgBiAIaiIFLQAEIARGBEAgBCAFLQAFRw0CIAQgBS0ABkcNAyAEIAUtAAdHDQQgBCAGIAhBCGoiCmoiBy0AAEcNByAEIAUtAAlHDQUgBCAFLQAKRw0GIAVBC2ohByAIQfYBSg0HIAohCCAEIActAABGDQEMBwsLIAVBBGohBwwFCyAFQQVqIQcMBAsgBUEGaiEHDAMLIAVBB2ohBwwCCyAFQQlqIQcMAQsgBUEKaiEHCyABIAIgByAJa0GCAmoiBCACIARJGyICNgJgIAJBA0kNACABKAKkLSABKAKgLSIDQQF0akEBOwEAIAEgA0EBajYCoC0gAyABKAKYLWogAkEDayICOgAAIAJB/wFxQYDNAGotAABBAnQgAWpBmAlqIgIgAi8BAEEBajsBACABQYDJAC0AAEECdGpBiBNqIgIgAi8BAEEBajsBACABKAJgIQIgAUEANgJgIAEgASgCdCACazYCdCABIAIgASgCbGoiAjYCbCABKAKgLSABKAKcLUEBa0cNAgwBCyABKAI4IANqLQAAIQIgASgCpC0gASgCoC0iA0EBdGpBADsBACABIANBAWo2AqAtIAMgASgCmC1qIAI6AAAgASACQQJ0akGUAWoiAiACLwEAQQFqOwEAIAEgASgCdEEBazYCdCABIAEoAmxBAWoiAjYCbCABKAKgLSABKAKcLUEBa0cNAQsgASABKAJcIgRBAE4EfyABKAI4IARqBUEACyACIARrQQAQFCABIAEoAmw2AlwgASgCACICKAIcIgMQEwJAIAIoAhAiBCADKAIUIgUgBCAFSRsiBEUNACACKAIMIAMoAhAgBBAfGiACIAIoAgwgBGo2AgwgAyADKAIQIARqNgIQIAIgAigCFCAEajYCFCACIAIoAhAgBGs2AhAgAyADKAIUIARrIgI2AhQgAg0AIAMgAygCCDYCEAsgASgCACgCEA0ACwwECyABQX82AigPCyABQX82AigPCyABQQMgAkEMbEGIyABqKAIAEQQACyICQX5xQQJGBEAgAUGaBTYCBAsgAkF9cQ0BCyAAKAIQDQMgAUF/NgIoDwsgAkEBRw0BCyABQQBBAEEAEBIgASgCRCICIAEoAkxBAXRBAmsiA2pBADsBACACIAMQICABKAJ0RQRAIAFBADYCtC0gAUEANgJcIAFBADYCbAsgACgCHCICEBMCQCAAKAIQIgQgAigCFCIDIAMgBEsbIgNFDQAgACgCDCACKAIQIAMQHxogACAAKAIMIANqNgIMIAIgAigCECADajYCECAAIAAoAhQgA2o2AhQgACAAKAIQIANrIgQ2AhAgAiACKAIUIANrIgM2AhQgAw0AIAIgAigCCDYCEAsgBA0AIAFBfzYCKAsLC7YNAQt/IAAoAgAiBCgCBCEJQQEhCAJAIAQoAhAiAyAAKAK8LUEqakEDdSICSQ0AIAAoAiwiBSAAKAIMQQVrIgYgBSAGSRshCiABQQRHIQsDQCAKIAMgAmsiAyAAKAJsIAAoAlxrIgYgBCgCBGoiAkH//wMgAkH//wNJGyIFIAMgBUkbIgNLBEAgAiADRw0CIAFFDQIgCyADRXENAgsgAEEAQQAgAUEERiACIANGcSIHEBIgACgCFCAAKAIIakEEayADOgAAIAAoAhQgACgCCGpBA2sgA0EIdjoAACAAKAIUIAAoAghqQQJrIANBf3MiAjoAACAAKAIUIAAoAghqQQFrIAJBCHY6AAAgACgCACICKAIcIgQQEwJAIAIoAhAiBSAEKAIUIgwgBSAMSRsiBUUNACACKAIMIAQoAhAgBRAfGiACIAIoAgwgBWo2AgwgBCAEKAIQIAVqNgIQIAIgAigCFCAFajYCFCACIAIoAhAgBWs2AhAgBCAEKAIUIAVrIgI2AhQgAg0AIAQgBCgCCDYCEAsCfyAGBEAgACgCACgCDCAAKAI4IAAoAlxqIAMgBiADIAZJGyICEB8aIAAoAgAiBCAEKAIMIAJqNgIMIAQgBCgCECACazYCECAEIAQoAhQgAmo2AhQgACAAKAJcIAJqNgJcIAMgAmshAwsgAwsEQCAAKAIAIgIoAgwhBSADIAIoAgQiBiADIAZJGyIEBEAgAiAGIARrNgIEIAUgAigCACAEEB8hBQJAAkACQCACKAIcKAIYQQFrDgIAAQILIAIgAigCMCAFIAQQBDYCMAwBCyACIAIoAjAgBSAEEAY2AjALIAIgAigCACAEajYCACACIAIoAgggBGo2AgggACgCACICKAIMIQULIAIgAyAFajYCDCACIAIoAhAgA2s2AhAgAiACKAIUIANqNgIUCyAAKAIAIQQgBwRAQQAhCAwCCyAEKAIQIgMgACgCvC1BKmpBA3UiAk8NAAsLAkAgCSAEKAIEayIDRQRAIAAoAmwhAgwBCwJAIAAoAiwiAiADTQRAIABBAjYCsC0gACgCOCAEKAIAIAJrIAIQHxogACAAKAIsIgQ2AmwgBCECDAELAkAgACgCPCAAKAJsIgRrIANLDQAgACAEIAJrIgQ2AmwgACgCOCIFIAIgBWogBBAfGiAAKAKwLSICQQFLDQAgACACQQFqNgKwLQsgACgCOCAAKAJsaiAAKAIAKAIAIANrIAMQHxogACAAKAJsIANqIgI2AmwgACgCLCEECyAAIAI2AlwgACAEIAAoArQtIgVrIgQgAyADIARLGyAFajYCtC0LIAIgACgCwC1LBEAgACACNgLALQtBAyEDAkAgCEUNACAAKAIAIgQoAgQhAwJAAkAgAUF7cUUNACADDQBBASEDIAIgACgCXEYNAiAAKAI8IAJBf3NqIQVBACEDDAELIAMgACgCPCACQX9zaiIFTQ0AIAAoAlwiByAAKAIsIgZIDQAgACACIAZrIgM2AmwgACAHIAZrNgJcIAAoAjgiAiACIAZqIAMQHxogACgCsC0iA0EBTQRAIAAgA0EBajYCsC0LIAAoAiwgBWohBSAAKAIAIgQoAgQhAwsCQCADIAUgAyAFSRsiAkUEQCAAKAJsIQMMAQsgACgCbCEFIAAoAjghBiAEIAMgAms2AgQgBSAGaiAEKAIAIAIQHyEDAkACQAJAIAQoAhwoAhhBAWsOAgABAgsgBCAEKAIwIAMgAhAENgIwDAELIAQgBCgCMCADIAIQBjYCMAsgBCAEKAIAIAJqNgIAIAQgBCgCCCACajYCCCAAIAAoAmwgAmoiAzYCbAsgAyAAKALALUsEQCAAIAM2AsAtCyADIAAoAlwiBmsiBCAAKAIsIgMgACgCDCAAKAK8LUEqakEDdWsiAkH//wMgAkH//wNJGyICIAIgA0sbSQRAQQAhAyABRQ0BIAFBBEYgBEEAR3JFDQEgAiAESQ0BIAAoAgAoAgQNAQtBACEFIAAgACgCOCAGaiACIAQgAiAESRsiAwJ/IAFBBEYEQCAAKAIAKAIERSACIARPcSEFCyAFCxASIAAgACgCXCADajYCXCAAKAIAIgAoAhwiAxATAkAgACgCECICIAMoAhQiBCACIARJGyICRQ0AIAAoAgwgAygCECACEB8aIAAgACgCDCACajYCDCADIAMoAhAgAmo2AhAgACAAKAIUIAJqNgIUIAAgACgCECACazYCECADIAMoAhQgAmsiADYCFCAADQAgAyADKAIINgIQC0ECQQAgBRshAwsgAwu5CwENfwJAA0ACQAJAIAAoAnRBhQJNBEAgABAKIAAoAnQhAgJAIAENACACQYYCTw0AQQAPCyACRQ0EIAJBA0kNAQsgACAAKAJUIAAoAmwiAiAAKAI4ai0AAiAAKAJIIAAoAlh0c3EiAzYCSCAAKAJAIAIgACgCNHFBAXRqIAAoAkQgA0EBdGoiBC8BACIDOwEAIAQgAjsBACADRQ0AIAAoAixBhgJrIAIgA2tJDQAgACAAIAMQDiICNgJgDAELIAAoAmAhAgsCQCACQQNPBEAgACgCpC0gACgCoC0iA0EBdGogACgCbCAAKAJwayIEOwEAIAAgA0EBajYCoC0gAyAAKAKYLWogAkEDayICOgAAIAJB/wFxQYDNAGotAABBAnQgAGpBmAlqIgIgAi8BAEEBajsBACAAIARBAWtB//8DcSICIAJBB3ZBgAJqIAJBgAJJG0GAyQBqLQAAQQJ0akGIE2oiAiACLwEAQQFqOwEAIAAgACgCdCAAKAJgIgJrIgM2AnQgACgCnC1BAWshBiAAKAKgLSEHAkAgA0EDSQ0AIAIgACgCgAFLDQAgACACQQFrIgM2AmAgACgCSCEEIAAoAmwhAiAAKAI0IQggACgCQCEJIAAoAkQhCiAAKAJUIQsgACgCOCEMIAAoAlghDQNAIAAgAiIFQQFqIgI2AmwgACAFIAxqLQADIAQgDXRzIAtxIgQ2AkggCSACIAhxQQF0aiAKIARBAXRqIg4vAQA7AQAgDiACOwEAIAAgA0EBayIDNgJgIAMNAAsgACAFQQJqIgI2AmwgBiAHRw0DDAILIABBADYCYCAAIAAoAmwgAmoiAjYCbCAAIAAoAjggAmoiAy0AACIENgJIIAAgACgCVCADLQABIAQgACgCWHRzcTYCSCAGIAdHDQIMAQsgACgCOCAAKAJsai0AACECIAAoAqQtIAAoAqAtIgNBAXRqQQA7AQAgACADQQFqNgKgLSADIAAoApgtaiACOgAAIAAgAkECdGpBlAFqIgIgAi8BAEEBajsBACAAIAAoAnRBAWs2AnQgACAAKAJsQQFqIgI2AmwgACgCoC0gACgCnC1BAWtHDQELQQAhAyAAIAAoAlwiBEEATgR/IAAoAjggBGoFIAMLIAIgBGtBABAUIAAgACgCbDYCXCAAKAIAIgIoAhwiAxATAkAgAigCECIEIAMoAhQiBSAEIAVJGyIERQ0AIAIoAgwgAygCECAEEB8aIAIgAigCDCAEajYCDCADIAMoAhAgBGo2AhAgAiACKAIUIARqNgIUIAIgAigCECAEazYCECADIAMoAhQgBGsiAjYCFCACDQAgAyADKAIINgIQCyAAKAIAKAIQDQALQQAPCyAAIAAoAmwiAkECIAJBAkkbNgK0LSABQQRGBEBBACEDIAAgACgCXCIEQQBOBH8gACgCOCAEagUgAwsgAiAEa0EBEBQgACAAKAJsNgJcIAAoAgAiAigCHCIDEBMCQCACKAIQIgQgAygCFCIFIAQgBUkbIgRFDQAgAigCDCADKAIQIAQQHxogAiACKAIMIARqNgIMIAMgAygCECAEajYCECACIAIoAhQgBGo2AhQgAiACKAIQIARrNgIQIAMgAygCFCAEayICNgIUIAINACADIAMoAgg2AhALQQNBAiAAKAIAKAIQGw8LAkAgACgCoC1FDQBBACEDIAAgACgCXCIEQQBOBH8gACgCOCAEagUgAwsgAiAEa0EAEBQgACAAKAJsNgJcIAAoAgAiAigCHCIDEBMCQCACKAIQIgQgAygCFCIFIAQgBUkbIgRFDQAgAigCDCADKAIQIAQQHxogAiACKAIMIARqNgIMIAMgAygCECAEajYCECACIAIoAhQgBGo2AhQgAiACKAIQIARrNgIQIAMgAygCFCAEayICNgIUIAINACADIAMoAgg2AhALIAAoAgAoAhANAEEADwtBAQukBAEQfyAAKAJ8IgMgA0ECdiAAKAJ4IgQgACgCjAFJGyEJQQAgACgCbCIDIAAoAixrQYYCaiICIAIgA0sbIQwgACgCdCIHIAAoApABIgIgAiAHSxshDSAAKAI4Ig4gA2oiBUGCAmohDyAEIAVqIgMtAAAhCiADQQFrLQAAIQsgACgCNCEQIAAoAkAhEQNAAkACQCABIA5qIgMgBGoiAi0AACAKRw0AIAJBAWstAAAgC0cNACADLQAAIAUtAABHDQBBAiEGIAMtAAEgBS0AAUcNAAJAAkACQAJAAkACQAJAA0AgBSAGaiICLQABIAMtAANHDQYgAi0AAiADLQAERw0FIAItAAMgAy0ABUcNBCACLQAEIAMtAAZHDQMgAi0ABSADLQAHRw0CIAItAAYgAy0ACEcNASACLQAHIAMtAAlGBEAgBkH5AUshCCAFIAZBCGoiBmohAiAIDQggAy0ACiEIIANBCGohAyACLQAAIAhGDQEMCAsLIAJBB2ohAgwGCyACQQZqIQIMBQsgAkEFaiECDAQLIAJBBGohAgwDCyACQQNqIQIMAgsgAkECaiECDAELIAJBAWohAgsgAiAPayICQYICaiIDIARMDQAgACABNgJwIAMgDU4EQCADIQQMAgsgAyAFai0AACEKIAIgBWotAIECIQsgAyEECyAJQQFrIglFDQAgDCARIAEgEHFBAXRqLwEAIgFJDQELCyAHIAQgBCAHSxsL3Q4BB38DQAJAAkACQCAAKAJ0QYUCSw0AIAAQCiAAKAJ0IQICQCABDQAgAkGGAk8NAEEADwsgAkUNAiACQQJLDQAgACAAKAJgIgI2AnggACAAKAJwNgJkQQIhAyAAQQI2AmAMAQtBAiEDIAAgACgCVCAAKAJsIgIgACgCOGotAAIgACgCSCAAKAJYdHNxIgQ2AkggACgCQCACIAAoAjRxQQF0aiAAKAJEIARBAXRqIgUvAQAiBDsBACAFIAI7AQAgACAAKAJgIgI2AnggACAAKAJwNgJkIABBAjYCYCAERQ0AAkAgAiAAKAKAAU8NACAAKAIsQYYCayAAKAJsIARrSQ0AIAAgACAEEA4iAzYCYCADQQVLDQAgACgCiAFBAUcEQCADQQNHDQFBAyEDIAAoAmwgACgCcGtBgSBJDQELQQIhAyAAQQI2AmALIAAoAnghAgsCQCACQQNJDQAgAiADSQ0AIAAoAnQhBCAAKAKkLSAAKAKgLSIDQQF0aiAAKAJsIgUgACgCZEF/c2oiBjsBACAAIANBAWo2AqAtIAMgACgCmC1qIAJBA2siAjoAACACQf8BcUGAzQBqLQAAQQJ0IABqQZgJaiICIAIvAQBBAWo7AQAgACAGQQFrQf//A3EiAiACQQd2QYACaiACQYACSRtBgMkAai0AAEECdGpBiBNqIgIgAi8BAEEBajsBACAAIAAoAngiAkECayIDNgJ4IAAgACgCdCACa0EBajYCdCAEIAVqQQNrIQUgACgCnC1BAWshByAAKAJsIQIgACgCoC0hCANAIAAgAiIEQQFqIgI2AmwgAiAFTQRAIAAgACgCVCAEIAAoAjhqLQADIAAoAkggACgCWHRzcSIGNgJIIAAoAkAgACgCNCACcUEBdGogACgCRCAGQQF0aiIGLwEAOwEAIAYgAjsBAAsgACADQQFrIgM2AnggAw0ACyAAQQI2AmAgAEEANgJoIAAgBEECaiICNgJsIAcgCEcNAkEAIQMgACAAKAJcIgRBAE4EfyAAKAI4IARqBSADCyACIARrQQAQFCAAIAAoAmw2AlwgACgCACICKAIcIgMQEwJAIAIoAhAiBCADKAIUIgUgBCAFSRsiBEUNACACKAIMIAMoAhAgBBAfGiACIAIoAgwgBGo2AgwgAyADKAIQIARqNgIQIAIgAigCFCAEajYCFCACIAIoAhAgBGs2AhAgAyADKAIUIARrIgI2AhQgAg0AIAMgAygCCDYCEAsgACgCACgCEA0CQQAPCyAAKAJoBEAgACgCbCAAKAI4akEBay0AACECIAAoAqQtIAAoAqAtIgNBAXRqQQA7AQAgACADQQFqNgKgLSADIAAoApgtaiACOgAAIAAgAkECdGpBlAFqIgIgAi8BAEEBajsBAAJAIAAoAqAtIAAoApwtQQFrRw0AQQAhAyAAIAAoAlwiAkEATgR/IAAoAjggAmoFIAMLIAAoAmwgAmtBABAUIAAgACgCbDYCXCAAKAIAIgIoAhwiAxATIAIoAhAiBCADKAIUIgUgBCAFSRsiBEUNACACKAIMIAMoAhAgBBAfGiACIAIoAgwgBGo2AgwgAyADKAIQIARqNgIQIAIgAigCFCAEajYCFCACIAIoAhAgBGs2AhAgAyADKAIUIARrIgI2AhQgAg0AIAMgAygCCDYCEAsgACAAKAJsQQFqNgJsIAAgACgCdEEBazYCdCAAKAIAKAIQDQJBAA8FIABBATYCaCAAIAAoAmxBAWo2AmwgACAAKAJ0QQFrNgJ0DAILAAsLIAAoAmgEQCAAKAJsIAAoAjhqQQFrLQAAIQIgACgCpC0gACgCoC0iA0EBdGpBADsBACAAIANBAWo2AqAtIAMgACgCmC1qIAI6AAAgACACQQJ0akGUAWoiAiACLwEAQQFqOwEAIABBADYCaAsgACAAKAJsIgJBAiACQQJJGzYCtC0gAUEERgRAQQAhAyAAIAAoAlwiBEEATgR/IAAoAjggBGoFIAMLIAIgBGtBARAUIAAgACgCbDYCXCAAKAIAIgIoAhwiAxATAkAgAigCECIEIAMoAhQiBSAEIAVJGyIERQ0AIAIoAgwgAygCECAEEB8aIAIgAigCDCAEajYCDCADIAMoAhAgBGo2AhAgAiACKAIUIARqNgIUIAIgAigCECAEazYCECADIAMoAhQgBGsiAjYCFCACDQAgAyADKAIINgIQC0EDQQIgACgCACgCEBsPCwJAIAAoAqAtRQ0AQQAhAyAAIAAoAlwiBEEATgR/IAAoAjggBGoFIAMLIAIgBGtBABAUIAAgACgCbDYCXCAAKAIAIgIoAhwiAxATAkAgAigCECIEIAMoAhQiBSAEIAVJGyIERQ0AIAIoAgwgAygCECAEEB8aIAIgAigCDCAEajYCDCADIAMoAhAgBGo2AhAgAiACKAIUIARqNgIUIAIgAigCECAEazYCECADIAMoAhQgBGsiAjYCFCACDQAgAyADKAIINgIQCyAAKAIAKAIQDQBBAA8LQQELYQAgAEEANgK8LSAAQQA7AbgtIABBuBZqQajPADYCACAAIABB/BRqNgKwFiAAQawWakGUzwA2AgAgACAAQYgTajYCpBYgAEGgFmpBgM8ANgIAIAAgAEGUAWo2ApgWIAAQEQvwBAEDfyAAQZQBaiECA0AgAiABQQJ0IgNqQQA7AQAgAiADQQRyakEAOwEAIAFBAmoiAUGeAkcNAAsgAEEAOwH8FCAAQQA7AYgTIABBxBVqQQA7AQAgAEHAFWpBADsBACAAQbwVakEAOwEAIABBuBVqQQA7AQAgAEG0FWpBADsBACAAQbAVakEAOwEAIABBrBVqQQA7AQAgAEGoFWpBADsBACAAQaQVakEAOwEAIABBoBVqQQA7AQAgAEGcFWpBADsBACAAQZgVakEAOwEAIABBlBVqQQA7AQAgAEGQFWpBADsBACAAQYwVakEAOwEAIABBiBVqQQA7AQAgAEGEFWpBADsBACAAQYAVakEAOwEAIABB/BNqQQA7AQAgAEH4E2pBADsBACAAQfQTakEAOwEAIABB8BNqQQA7AQAgAEHsE2pBADsBACAAQegTakEAOwEAIABB5BNqQQA7AQAgAEHgE2pBADsBACAAQdwTakEAOwEAIABB2BNqQQA7AQAgAEHUE2pBADsBACAAQdATakEAOwEAIABBzBNqQQA7AQAgAEHIE2pBADsBACAAQcQTakEAOwEAIABBwBNqQQA7AQAgAEG8E2pBADsBACAAQbgTakEAOwEAIABBtBNqQQA7AQAgAEGwE2pBADsBACAAQawTakEAOwEAIABBqBNqQQA7AQAgAEGkE2pBADsBACAAQaATakEAOwEAIABBnBNqQQA7AQAgAEGYE2pBADsBACAAQZQTakEAOwEAIABBkBNqQQA7AQAgAEGME2pBADsBACAAQgA3AqwtIABBlAlqQQE7AQAgAEEANgKoLSAAQQA2AqAtC7IDAQJ/IAAgAC8BuC0gA0H//wNxIgUgACgCvC0iBHRyIgM7AbgtAkACQAJ/IARBDk4EQCAAIAAoAhQiBEEBajYCFCAEIAAoAghqIAM6AAAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAAQbktai0AADoAACAAIAVBECAAKAK8LSIEa3YiAzsBuC0gBEENawwBCyAEQQNqCyIEQQlOBEAgACAAKAIUIgRBAWo2AhQgBCAAKAIIaiADOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGohBCAAQbktai0AACEDDAELIARBAUgNASAAIAAoAhQiBEEBajYCFCAEIAAoAghqIQQLIAQgAzoAAAsgAEEANgK8LSAAQQA7AbgtIAAgACgCFCIDQQFqNgIUIAMgACgCCGogAjoAACAAIAAoAhQiA0EBajYCFCADIAAoAghqIAJBCHY6AAAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiACQX9zIgM6AAAgACAAKAIUIgRBAWo2AhQgBCAAKAIIaiADQQh2OgAAIAAoAgggACgCFGogASACEB8aIAAgACgCFCACajYCFAusAQEBfwJAIAACfyAAKAK8LSIBQRBGBEAgACAAKAIUIgFBAWo2AhQgASAAKAIIaiAALQC4LToAACAAIAAoAhQiAUEBajYCFCABIAAoAghqIABBuS1qLQAAOgAAIABBADsBuC1BAAwBCyABQQhIDQEgACAAKAIUIgFBAWo2AhQgASAAKAIIaiAALQC4LToAACAAIABBuS1qLQAAOwG4LSAAKAK8LUEIaws2ArwtCwuhEwENfwJ/AkACQAJAIAAoAoQBQQFOBEAgACgCACIGKAIsQQJHDQNB/4D/n38hBANAAkAgBEEBcUUNACAAIAVBAnRqLwGUAUUNAEEAIQQMBAsCQCAEQQJxRQ0AIAAgBUECdEEEcmovAZQBRQ0AQQAhBAwECyAEQQJ2IQQgBUECaiIFQSBHDQALDAELIAJBBWoiBQwDCwJAIAAvAbgBDQAgAC8BvAENACAALwHIAQ0AQSAhBQNAIAAgBUECdCIEai8BlAENASAAIARBBHJqLwGUAQ0BIAAgBEEIcmovAZQBDQEgACAEQQxyai8BlAENAUEAIQQgBUEEaiIFQYACRw0ACwwBC0EBIQQLIAYgBDYCLAsgACAAQZgWahAVIAAgAEGkFmoQFSAALwGWASEEIAAgAEGcFmooAgAiCkECdGpB//8DOwGaASAKQQBOBEBBB0GKASAEGyEJQQRBAyAEGyELIABBwBVqIQ4gAEHEFWohDyAAQbwVaiEQQX8hDANAIAQhBSAAIAgiDUEBaiIIQQJ0ai8BlgEhBAJAAkAgB0EBaiIGIAlODQAgBCAFRw0AIAYhBwwBCwJ/IAYgC0gEQCAAIAVBAnRqQfwUaiIHLwEAIAZqDAELIAUEQCAFIAxHBEAgACAFQQJ0akH8FGoiBiAGLwEAQQFqOwEACyAQIgcvAQBBAWoMAQsgB0EJTARAIA4iBy8BAEEBagwBCyAPIgcvAQBBAWoLIQYgByAGOwEAQQAhBwJ/IARFBEBBAyELQYoBDAELQQNBBCAEIAVGIgYbIQtBBkEHIAYbCyEJIAUhDAsgCiANRw0ACwsgAEGKE2ovAQAhBCAAIABBqBZqKAIAIgpBAnRqQY4TakH//wM7AQBBACEHIApBAE4EQEEHQYoBIAQbIQlBBEEDIAQbIQsgAEHAFWohDiAAQcQVaiEPIABBvBVqIRBBfyEMQQAhCANAIAQhBSAAIAgiDUEBaiIIQQJ0akGKE2ovAQAhBAJAAkAgB0EBaiIGIAlODQAgBCAFRw0AIAYhBwwBCwJ/IAYgC0gEQCAAIAVBAnRqQfwUaiIHLwEAIAZqDAELIAUEQCAFIAxHBEAgACAFQQJ0akH8FGoiBiAGLwEAQQFqOwEACyAQIgcvAQBBAWoMAQsgB0EJTARAIA4iBy8BAEEBagwBCyAPIgcvAQBBAWoLIQYgByAGOwEAQQAhBwJ/IARFBEBBAyELQYoBDAELQQNBBCAEIAVGIgYbIQtBBkEHIAYbCyEJIAUhDAsgCiANRw0ACwsgACAAQbAWahAVIAAgACgCqC0Cf0ESIABBuhVqLwEADQAaQREgAEGCFWovAQANABpBECAAQbYVai8BAA0AGkEPIABBhhVqLwEADQAaQQ4gAEGyFWovAQANABpBDSAAQYoVai8BAA0AGkEMIABBrhVqLwEADQAaQQsgAEGOFWovAQANABpBCiAAQaoVai8BAA0AGkEJIABBkhVqLwEADQAaQQggAEGmFWovAQANABpBByAAQZYVai8BAA0AGkEGIABBohVqLwEADQAaQQUgAEGaFWovAQANABpBBCAAQZ4Vai8BAA0AGkEDQQIgAEH+FGovAQAbCyIIQQNsaiIEQRFqNgKoLSAEQRtqQQN2IgQgACgCrC1BCmpBA3YiBSAEIAVJGwshBAJAAkAgAUUNACACQQRqIARLDQAgACABIAIgAxASDAELIAAoArwtIQYCQCAEIAVHBEAgACgCiAFBBEcNAQsgACAALwG4LSADQQJqQf//A3EiBCAGdHIiBTsBuC0gAAJ/IAZBDk4EQCAAIAAoAhQiBkEBajYCFCAGIAAoAghqIAU6AAAgACAAKAIUIgVBAWo2AhQgBSAAKAIIaiAAQbktai0AADoAACAAIARBECAAKAK8LSIFa3Y7AbgtIAVBDWsMAQsgBkEDags2ArwtIABBwM8AQcDYABAWDAELIAAvAbgtIANBBGpB//8DcSIHIAZ0ciEFAkAgBkEOTgRAIAAgBTsBuC0gACAAKAIUIgRBAWo2AhQgBCAAKAIIaiAFOgAAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogAEG5LWotAAA6AAAgACgCvC0iBUENayEEIAdBECAFa3YhBQwBCyAGQQNqIQQLIAAgBDYCvC0gAEGcFmooAgAiCkGA/gNqQf//A3EiByAEdCEGIABBqBZqKAIAIQkCfyAEQQxOBEAgACAFIAZyIgQ7AbgtIAAgACgCFCIFQQFqNgIUIAUgACgCCGogBDoAACAAIAAoAhQiBEEBajYCFCAEIAAoAghqIABBuS1qLQAAOgAAIAAoArwtIgVBC2shBCAHQRAgBWt2DAELIARBBWohBCAFIAZyCyEFIAAgBDYCvC0gCUH//wNxIgcgBHQhBgJ/IARBDE4EQCAAIAUgBnIiBDsBuC0gACAAKAIUIgVBAWo2AhQgBSAAKAIIaiAEOgAAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogAEG5LWotAAA6AAAgACgCvC0iBUELayEEIAdBECAFa3YMAQsgBEEFaiEEIAUgBnILIQUgACAENgK8LSAIQf3/A2pB//8DcSIHIAR0IQYCfyAEQQ1OBEAgACAFIAZyIgQ7AbgtIAAgACgCFCIFQQFqNgIUIAUgACgCCGogBDoAACAAIAAoAhQiBEEBajYCFCAEIAAoAghqIABBuS1qLQAAOgAAIAAoArwtIgVBDGshBCAHQRAgBWt2DAELIARBBGohBCAFIAZyCyEGIAAgBDYCvC1BACEFIABBuS1qIQ0DQCAAIAYgACAFQZDcAGotAABBAnRqQf4Uai8BACIHIAR0ciIGOwG4LSAAAn8gBEEOTgRAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogBjoAACAAIAAoAhQiBEEBajYCFCAEIAAoAghqIA0tAAA6AAAgACAHQRAgACgCvC0iBGt2IgY7AbgtIARBDWsMAQsgBEEDagsiBDYCvC0gBSAIRyEHIAVBAWohBSAHDQALIAAgAEGUAWoiBCAKEBcgACAAQYgTaiIFIAkQFyAAIAQgBRAWCyAAEBEgAwRAAkACfyAAKAK8LSIEQQlOBEAgACAAKAIUIgRBAWo2AhQgBCAAKAIIaiAALQC4LToAACAAIAAoAhQiBEEBajYCFCAEIAAoAghqIQQgAEG5LWotAAAMAQsgBEEBSA0BIAAgACgCFCIEQQFqNgIUIAQgACgCCGohBCAALQC4LQshBSAEIAU6AAALIABBADYCvC0gAEEAOwG4LQsLsRUBFX8jAEEgayEKIAEoAgAhCSABKAIIIgIoAgAhBSACKAIMIQ0gAEKAgICA0McANwLQKEF/IRACQCANQQBKBEBBACECA0ACQCAJIAJBAnRqIgMvAQAEQCAAIAAoAtAoQQFqIgM2AtAoIAAgA0ECdGpB3BZqIAI2AgAgACACakHYKGpBADoAACACIRAMAQsgA0EAOwECCyACQQFqIgIgDUcNAAsgACgC0CgiBEEBSg0BCwNAIAAgBEEBaiICNgLQKCAAIAJBAnRqQdwWaiAQQQFqIgNBACAQQQJIIgQbIgI2AgAgCSACQQJ0IgdqQQE7AQAgACACakHYKGpBADoAACAAIAAoAqgtQQFrNgKoLSAFBEAgACAAKAKsLSAFIAdqLwECazYCrC0LIAMgECAEGyEQIAAoAtAoIgRBAkgNAAsLIAEgEDYCBCAEQQF2IQgDQCAAIAhBAnRqQdwWaigCACELAkAgCCICQQF0IgMgBEoNACAAIAtqQdgoaiEPIAkgC0ECdGohBiAIIQUDQAJAIAMgBE4EQCADIQIMAQsgCSAAQdwWaiICIANBAXIiBEECdGooAgAiDkECdGovAQAiByAJIAIgA0ECdGooAgAiDEECdGovAQAiAk8EQCACIAdHBEAgAyECDAILIAMhAiAAQdgoaiIDIA5qLQAAIAMgDGotAABLDQELIAQhAgsgBi8BACIEIAkgACACQQJ0akHcFmooAgAiA0ECdGovAQAiB0kEQCAFIQIMAgsCQCAEIAdHDQAgDy0AACAAIANqQdgoai0AAEsNACAFIQIMAgsgACAFQQJ0akHcFmogAzYCACACIQUgAkEBdCIDIAAoAtAoIgRMDQALCyAAIAJBAnRqQdwWaiALNgIAIAhBAk4EQCAIQQFrIQggACgC0CghBAwBCwsgACgC0CghAwNAIA0hCCAAIANBAWsiBDYC0CggACgC4BYhCyAAIAAgA0ECdGpB3BZqKAIAIg02AuAWQQEhAgJAIANBA0gNACAAIA1qQdgoaiEPQQIhAyAJIA1BAnRqIQZBASEFA0ACQCADIAROBEAgAyECDAELIAkgAEHcFmoiAiADQQFyIgRBAnRqKAIAIg5BAnRqLwEAIgcgCSACIANBAnRqKAIAIgxBAnRqLwEAIgJPBEAgAiAHRwRAIAMhAgwCCyADIQIgAEHYKGoiAyAOai0AACADIAxqLQAASw0BCyAEIQILIAYvAQAiBCAJIAAgAkECdGpB3BZqKAIAIgNBAnRqLwEAIgdJBEAgBSECDAILAkAgBCAHRw0AIA8tAAAgACADakHYKGotAABLDQAgBSECDAILIAAgBUECdGpB3BZqIAM2AgAgAiEFIAJBAXQiAyAAKALQKCIETA0ACwtBAiEDIABB3BZqIgYgAkECdGogDTYCACAAIAAoAtQoQQFrIgQ2AtQoIAAoAuAWIQIgBiAEQQJ0aiALNgIAIAAgACgC1ChBAWsiBDYC1CggBiAEQQJ0aiACNgIAIAkgCEECdGoiDiAJIAJBAnRqIgQvAQAgCSALQQJ0aiIFLwEAajsBACAAQdgoaiIMIAhqIg8gAiAMai0AACICIAsgDGotAAAiByACIAdLG0EBajoAACAEIAg7AQIgBSAIOwECIAAgCDYC4BZBASEFQQEhAgJAIAAoAtAoIgRBAkgNAANAAn8gAyADIARODQAaIAkgBiADQQFyIgRBAnRqKAIAIgtBAnRqLwEAIgIgCSAGIANBAnRqKAIAIg1BAnRqLwEAIgdPBEAgAyACIAdHDQEaIAMgCyAMai0AACAMIA1qLQAASw0BGgsgBAshAiAOLwEAIgQgCSAAIAJBAnRqQdwWaigCACIDQQJ0ai8BACIHSQRAIAUhAgwCCwJAIAQgB0cNACAPLQAAIAAgA2pB2ChqLQAASw0AIAUhAgwCCyAAIAVBAnRqQdwWaiADNgIAIAIhBSACQQF0IgMgACgC0CgiBEwNAAsLIAhBAWohDSAAIAJBAnRqQdwWaiAINgIAIAAoAtAoIgNBAUoNAAsgACAAKALUKEEBayICNgLUKCAAQdwWaiIDIAJBAnRqIAAoAuAWNgIAIAEoAgQhByABKAIIIgIoAhAhBiACKAIIIREgAigCBCETIAIoAgAhEiABKAIAIQwgAEHUFmoiAUIANwEAIABBzBZqIhRCADcBACAAQcQWaiIVQgA3AQAgAEG8FmoiFkIANwEAQQAhCCAMIAMgACgC1ChBAnRqKAIAQQJ0akEAOwECAkAgACgC1CgiAkG7BEoNACACQQFqIQJBACEOA0AgDCAAIAJBAnRqQdwWaigCACIEQQJ0Ig1qIgUgDCAFLwECQQJ0ai8BAiIDQQFqIAYgAyAGSBsiDzsBAiADIAZOIQMCQCAEIAdKDQAgACAPQQF0akG8FmoiCyALLwEAQQFqOwEAQQAhCyAEIBFOBEAgEyAEIBFrQQJ0aigCACELCyAAIAAoAqgtIAUvAQAiBCALIA9qbGo2AqgtIBJFDQAgACAAKAKsLSALIA0gEmovAQJqIARsajYCrC0LIAMgDmohDiACQQFqIgJBvQRHDQALIA5FDQAgACAGQQF0akG8FmohDwNAIAYhAgNAIAAgAiIDQQFrIgJBAXRqQbwWaiIELwEAIgVFDQALIAQgBUEBazsBACAAIANBAXRqQbwWaiICIAIvAQBBAmo7AQAgDyAPLwEAQQFrIgI7AQAgDkECSiEDIA5BAmshDiADDQALIAZFDQBBvQQhBQNAIAJB//8DcSEDIAUhAgNAIAMEQCAAIAJBAWsiAkECdGpB3BZqKAIAIgQgB0oNASAMIARBAnRqIgQvAQIiBSAGRwRAIAAgACgCqC0gBC8BACAGIAVrbGo2AqgtIAQgBjsBAgsgA0EBayEDIAIhBQwBCwsgBkEBayIGRQ0BIAAgBkEBdGpBvBZqLwEAIQIMAAsACyAKIBYvAQBBAXQiAjsBAiAKIAIgAEG+FmovAQBqQQF0IgI7AQQgCiACIABBwBZqLwEAakEBdCICOwEGIAogAiAAQcIWai8BAGpBAXQiAjsBCCAKIAIgFS8BAGpBAXQiAjsBCiAKIAIgAEHGFmovAQBqQQF0IgI7AQwgCiACIABByBZqLwEAakEBdCICOwEOIAogAiAAQcoWai8BAGpBAXQiAjsBECAKIAIgFC8BAGpBAXQiAjsBEiAKIAIgAEHOFmovAQBqQQF0IgI7ARQgCiACIABB0BZqLwEAakEBdCICOwEWIAogAiAAQdIWai8BAGpBAXQiAjsBGCAKIAEvAQAgAmpBAXQiAjsBGiAKIABB1hZqLwEAIAJqQQF0IgI7ARwgCiACIABB2BZqLwEAakEBdDsBHiAQQQBOBEADQCAJIAhBAnRqIgcvAQIiBARAIAogBEEBdGoiACAALwEAIgBBAWo7AQAgBEEDcSEDQQAhAiAEQQFrQQNPBEAgBEH8/wNxIQUDQCAAQQN2QQFxIABBAnZBAXEgAEECcSACIABBAXFyQQJ0cnJBAXRyIgRBAXQhAiAAQQR2IQAgBUEEayIFDQALCyADBEADQCACIABBAXFyIgRBAXQhAiAAQQF2IQAgA0EBayIDDQALCyAHIAQ7AQALIAggEEchACAIQQFqIQggAA0ACwsL2QgBCn8CQCAAKAKgLUUEQCAAKAK8LSEDDAELIABBuS1qIQgDQCAEQQFqIQogACgCmC0gBGotAAAhBQJAIAACfyAAKAKkLSAEQQF0ai8BACIHRQRAIAEgBUECdGoiAy8BAiEEIAAgAC8BuC0gAy8BACIFIAAoArwtIgN0ciIHOwG4LUEQIARrIANIBEAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAHOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogCC0AADoAACAAIAVBECAAKAK8LSIDa3Y7AbgtIAMgBGpBEGsMAgsgAyAEagwBCyAFQYDNAGotAAAiC0ECdCIJQYAIciABaiIDLwEGIQQgACAALwG4LSADLwEEIgwgACgCvC0iBnRyIgM7AbgtIAACf0EQIARrIAZIBEAgACAAKAIUIgZBAWo2AhQgBiAAKAIIaiADOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogCC0AADoAACAAIAxBECAAKAK8LSIGa3YiAzsBuC0gBCAGakEQawwBCyAEIAZqCyIENgK8LSALQQhrQRNNBEAgACADIAUgCUGw3ABqKAIAa0H//wNxIgYgBHRyIgM7AbgtIAACf0EQIAlBwNkAaigCACIFayAESARAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogAzoAACAAIAAoAhQiBEEBajYCFCAEIAAoAghqIAgtAAA6AAAgACAGQRAgACgCvC0iBGt2IgM7AbgtIAQgBWpBEGsMAQsgBCAFagsiBDYCvC0LIAIgB0EBayIFIAVBB3ZBgAJqIAVBgAJJG0GAyQBqLQAAIgtBAnQiCWoiBi8BAiEHIAAgAyAGLwEAIgwgBHRyIgY7AbgtIAACf0EQIAdrIARIBEAgACAAKAIUIgRBAWo2AhQgBCAAKAIIaiAGOgAAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogCC0AADoAACAAIAxBECAAKAK8LSIEa3YiBjsBuC0gBCAHakEQawwBCyAEIAdqCyIDNgK8LSALQQRJDQEgACAGIAUgCUGw3QBqKAIAa0H//wNxIgUgA3RyIgc7AbgtQRAgCUHA2gBqKAIAIgRrIANIBEAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAHOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogCC0AADoAACAAIAVBECAAKAK8LSIDa3Y7AbgtIAMgBGpBEGsMAQsgAyAEagsiAzYCvC0LIAoiBCAAKAKgLUkNAAsLIAFBgghqLwEAIQQgACAALwG4LSABLwGACCIKIAN0ciIFOwG4LUEQIARrIANIBEAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAFOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogAEG5LWotAAA6AAAgACAKQRAgACgCvC0iA2t2OwG4LSAAIAMgBGpBEGs2ArwtDwsgACADIARqNgK8LQuXCwEMfyACQQBOBEBBBEEDIAEvAQIiChshBkEHQYoBIAobIQMgAEG5LWohCEF/IQcDQCAKIQkgASALIgxBAWoiC0ECdGovAQIhCgJAAkAgBUEBaiIEIANODQAgCSAKRw0AIAQhBQwBCwJAIAQgBkgEQCAAIAlBAnRqIgVB/BRqIQ0gBUH+FGohDiAAKAK8LSEFA0AgDi8BACEDIAAgAC8BuC0gDS8BACIGIAV0ciIHOwG4LSAAAn9BECADayAFSARAIAAgACgCFCIFQQFqNgIUIAUgACgCCGogBzoAACAAIAAoAhQiBUEBajYCFCAFIAAoAghqIAgtAAA6AAAgACAGQRAgACgCvC0iBWt2OwG4LSADIAVqQRBrDAELIAMgBWoLIgU2ArwtIARBAWsiBA0ACwwBCyAAAn8gCQRAAkAgByAJRgRAIAAoArwtIQMgBCEFDAELIAAgCUECdGoiBEH+FGovAQAhAyAAIAAvAbgtIARB/BRqLwEAIgYgACgCvC0iBHRyIgc7AbgtIAACf0EQIANrIARIBEAgACAAKAIUIgRBAWo2AhQgBCAAKAIIaiAHOgAAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogCC0AADoAACAAIAZBECAAKAK8LSIEa3Y7AbgtIAMgBGpBEGsMAQsgAyAEagsiAzYCvC0LIAAvAbgtIAAvAbwVIgcgA3RyIQQCQEEQIAAvAb4VIgZrIANIBEAgACAEOwG4LSAAIAAoAhQiA0EBajYCFCADIAAoAghqIAQ6AAAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAILQAAOgAAIAYgACgCvC0iBGpBEGshAyAHQRAgBGt2IQQMAQsgAyAGaiEDCyAAIAM2ArwtIAAgBCAFQf3/A2pB//8DcSIFIAN0ciIEOwG4LSADQQ9OBEAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAEOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogCC0AADoAACAAIAVBECAAKAK8LSIDa3Y7AbgtIANBDmsMAgsgA0ECagwBCyAFQQlMBEAgAC8BuC0gAC8BwBUiByAAKAK8LSIDdHIhBAJAQRAgAC8BwhUiBmsgA0gEQCAAIAQ7AbgtIAAgACgCFCIDQQFqNgIUIAMgACgCCGogBDoAACAAIAAoAhQiA0EBajYCFCADIAAoAghqIAgtAAA6AAAgBiAAKAK8LSIEakEQayEDIAdBECAEa3YhBAwBCyADIAZqIQMLIAAgAzYCvC0gACAEIAVB/v8DakH//wNxIgUgA3RyIgQ7AbgtIANBDk4EQCAAIAAoAhQiA0EBajYCFCADIAAoAghqIAQ6AAAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAILQAAOgAAIAAgBUEQIAAoArwtIgNrdjsBuC0gA0ENawwCCyADQQNqDAELIAAvAbgtIAAvAcQVIgcgACgCvC0iA3RyIQQCQEEQIAAvAcYVIgZrIANIBEAgACAEOwG4LSAAIAAoAhQiA0EBajYCFCADIAAoAghqIAQ6AAAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAILQAAOgAAIAYgACgCvC0iBGpBEGshAyAHQRAgBGt2IQQMAQsgAyAGaiEDCyAAIAM2ArwtIAAgBCAFQfb/A2pB//8DcSIFIAN0ciIEOwG4LSADQQpOBEAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAEOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogCC0AADoAACAAIAVBECAAKAK8LSIDa3Y7AbgtIANBCWsMAQsgA0EHags2ArwtC0EAIQUCfyAKRQRAQYoBIQNBAwwBC0EGQQcgCSAKRiIEGyEDQQNBBCAEGwshBiAJIQcLIAIgDEcNAAsLCwkAIAEgAmwQHAsGACABEB0LXwEBfyMAQUBqIgMkACADQQA2AjAgA0IANwMoIAMgADYCCCADIAI2AhQgAyABNgIMIAMgAUEDbDYCGCADQQhqEAcgA0EIahALIANBCGoQCCADKAIcIQEgA0FAayQAIAELBgBB1N8AC6QuAQx/IwBBEGsiDCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBB2N8AKAIAIgZBECAAQQtqQXhxIABBC0kbIgRBA3YiAXYiAEEDcQRAIABBf3NBAXEgAWoiAkEDdCIDQYjgAGooAgAiAUEIaiEAAkAgASgCCCIEIANBgOAAaiIDRgRAQdjfACAGQX4gAndxNgIADAELIAQgAzYCDCADIAQ2AggLIAEgAkEDdCICQQNyNgIEIAEgAmoiASABKAIEQQFyNgIEDA0LIARB4N8AKAIAIghNDQEgAARAAkAgACABdEECIAF0IgBBACAAa3JxIgBBACAAa3FBAWsiACAAQQx2QRBxIgB2IgFBBXZBCHEiAiAAciABIAJ2IgBBAnZBBHEiAXIgACABdiIAQQF2QQJxIgFyIAAgAXYiAEEBdkEBcSIBciAAIAF2aiICQQN0IgNBiOAAaigCACIBKAIIIgAgA0GA4ABqIgNGBEBB2N8AIAZBfiACd3EiBjYCAAwBCyAAIAM2AgwgAyAANgIICyABQQhqIQAgASAEQQNyNgIEIAEgBGoiAyACQQN0IgUgBGsiAkEBcjYCBCABIAVqIAI2AgAgCARAIAhBA3YiBUEDdEGA4ABqIQRB7N8AKAIAIQECfyAGQQEgBXQiBXFFBEBB2N8AIAUgBnI2AgAgBAwBCyAEKAIICyEFIAQgATYCCCAFIAE2AgwgASAENgIMIAEgBTYCCAtB7N8AIAM2AgBB4N8AIAI2AgAMDQtB3N8AKAIAIglFDQEgCUEAIAlrcUEBayIAIABBDHZBEHEiAHYiAUEFdkEIcSICIAByIAEgAnYiAEECdkEEcSIBciAAIAF2IgBBAXZBAnEiAXIgACABdiIAQQF2QQFxIgFyIAAgAXZqQQJ0QYjiAGooAgAiAygCBEF4cSAEayEBIAMhAgNAAkAgAigCECIARQRAIAIoAhQiAEUNAQsgACgCBEF4cSAEayICIAEgASACSyICGyEBIAAgAyACGyEDIAAhAgwBCwsgAyAEaiILIANNDQIgAygCGCEKIAMgAygCDCIFRwRAIAMoAggiAEHo3wAoAgBJGiAAIAU2AgwgBSAANgIIDAwLIANBFGoiAigCACIARQRAIAMoAhAiAEUNBCADQRBqIQILA0AgAiEHIAAiBUEUaiICKAIAIgANACAFQRBqIQIgBSgCECIADQALIAdBADYCAAwLC0F/IQQgAEG/f0sNACAAQQtqIgBBeHEhBEHc3wAoAgAiCEUNAEEfIQcgBEH///8HTQRAIABBCHYiACAAQYD+P2pBEHZBCHEiAHQiASABQYDgH2pBEHZBBHEiAXQiAiACQYCAD2pBEHZBAnEiAnRBD3YgACABciACcmsiAEEBdCAEIABBFWp2QQFxckEcaiEHC0EAIARrIQECQAJAAkAgB0ECdEGI4gBqKAIAIgJFBEBBACEADAELQQAhACAEQQBBGSAHQQF2ayAHQR9GG3QhAwNAAkAgAigCBEF4cSAEayIGIAFPDQAgAiEFIAYiAQ0AQQAhASACIQAMAwsgACACKAIUIgYgBiACIANBHXZBBHFqKAIQIgJGGyAAIAYbIQAgA0EBdCEDIAINAAsLIAAgBXJFBEBBAiAHdCIAQQAgAGtyIAhxIgBFDQMgAEEAIABrcUEBayIAIABBDHZBEHEiAHYiAkEFdkEIcSIDIAByIAIgA3YiAEECdkEEcSICciAAIAJ2IgBBAXZBAnEiAnIgACACdiIAQQF2QQFxIgJyIAAgAnZqQQJ0QYjiAGooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIARrIgYgAUkhAyAGIAEgAxshASAAIAUgAxshBSAAKAIQIgIEfyACBSAAKAIUCyIADQALCyAFRQ0AIAFB4N8AKAIAIARrTw0AIAQgBWoiByAFTQ0BIAUoAhghCSAFIAUoAgwiA0cEQCAFKAIIIgBB6N8AKAIASRogACADNgIMIAMgADYCCAwKCyAFQRRqIgIoAgAiAEUEQCAFKAIQIgBFDQQgBUEQaiECCwNAIAIhBiAAIgNBFGoiAigCACIADQAgA0EQaiECIAMoAhAiAA0ACyAGQQA2AgAMCQsgBEHg3wAoAgAiAE0EQEHs3wAoAgAhAQJAIAAgBGsiAkEQTwRAQeDfACACNgIAQezfACABIARqIgM2AgAgAyACQQFyNgIEIAAgAWogAjYCACABIARBA3I2AgQMAQtB7N8AQQA2AgBB4N8AQQA2AgAgASAAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIECyABQQhqIQAMCwsgBEHk3wAoAgAiA0kEQEHk3wAgAyAEayIBNgIAQfDfAEHw3wAoAgAiACAEaiICNgIAIAIgAUEBcjYCBCAAIARBA3I2AgQgAEEIaiEADAsLQQAhACAEQS9qIggCf0Gw4wAoAgAEQEG44wAoAgAMAQtBvOMAQn83AgBBtOMAQoCggICAgAQ3AgBBsOMAIAxBDGpBcHFB2KrVqgVzNgIAQcTjAEEANgIAQZTjAEEANgIAQYAgCyIBaiIGQQAgAWsiB3EiBSAETQ0KQZDjACgCACIBBEBBiOMAKAIAIgIgBWoiCSACTQ0LIAEgCUkNCwtBlOMALQAAQQRxDQUCQAJAQfDfACgCACIBBEBBmOMAIQADQCABIAAoAgAiAk8EQCACIAAoAgRqIAFLDQMLIAAoAggiAA0ACwtBABAeIgNBf0YNBiAFIQZBtOMAKAIAIgBBAWsiASADcQRAIAUgA2sgASADakEAIABrcWohBgsgBCAGTw0GIAZB/v///wdLDQZBkOMAKAIAIgAEQEGI4wAoAgAiASAGaiICIAFNDQcgACACSQ0HCyAGEB4iACADRw0BDAgLIAYgA2sgB3EiBkH+////B0sNBSAGEB4iAyAAKAIAIAAoAgRqRg0EIAMhAAsCQCAEQTBqIAZNDQAgAEF/Rg0AQbjjACgCACIBIAggBmtqQQAgAWtxIgFB/v///wdLBEAgACEDDAgLIAEQHkF/RwRAIAEgBmohBiAAIQMMCAtBACAGaxAeGgwFCyAAIQMgAEF/Rw0GDAQLAAtBACEFDAcLQQAhAwwFCyADQX9HDQILQZTjAEGU4wAoAgBBBHI2AgALIAVB/v///wdLDQEgBRAeIgNBABAeIgBPDQEgA0F/Rg0BIABBf0YNASAAIANrIgYgBEEoak0NAQtBiOMAQYjjACgCACAGaiIANgIAQYzjACgCACAASQRAQYzjACAANgIACwJAAkACQEHw3wAoAgAiAQRAQZjjACEAA0AgAyAAKAIAIgIgACgCBCIFakYNAiAAKAIIIgANAAsMAgtB6N8AKAIAIgBBACAAIANNG0UEQEHo3wAgAzYCAAtBACEAQZzjACAGNgIAQZjjACADNgIAQfjfAEF/NgIAQfzfAEGw4wAoAgA2AgBBpOMAQQA2AgADQCAAQQN0IgFBiOAAaiABQYDgAGoiAjYCACABQYzgAGogAjYCACAAQQFqIgBBIEcNAAtB5N8AIAZBKGsiAEF4IANrQQdxQQAgA0EIakEHcRsiAWsiAjYCAEHw3wAgASADaiIBNgIAIAEgAkEBcjYCBCAAIANqQSg2AgRB9N8AQcDjACgCADYCAAwCCyABIANPDQAgASACSQ0AIAAoAgxBCHENACAAIAUgBmo2AgRB8N8AIAFBeCABa0EHcUEAIAFBCGpBB3EbIgBqIgI2AgBB5N8AQeTfACgCACAGaiIDIABrIgA2AgAgAiAAQQFyNgIEIAEgA2pBKDYCBEH03wBBwOMAKAIANgIADAELQejfACgCACADSwRAQejfACADNgIACyADIAZqIQJBmOMAIQACQAJAAkACQAJAAkADQCACIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQZjjACEAA0AgASAAKAIAIgJPBEAgAiAAKAIEaiICIAFLDQMLIAAoAgghAAwACwALIAAgAzYCACAAIAAoAgQgBmo2AgQgA0F4IANrQQdxQQAgA0EIakEHcRtqIgcgBEEDcjYCBCACQXggAmtBB3FBACACQQhqQQdxG2oiBiAHayAEayECIAQgB2ohBCABIAZGBEBB8N8AIAQ2AgBB5N8AQeTfACgCACACaiIANgIAIAQgAEEBcjYCBAwDCyAGQezfACgCAEYEQEHs3wAgBDYCAEHg3wBB4N8AKAIAIAJqIgA2AgAgBCAAQQFyNgIEIAAgBGogADYCAAwDCyAGKAIEIgBBA3FBAUYEQCAAQXhxIQgCQCAAQf8BTQRAIAYoAggiASAAQQN2IgVBA3RBgOAAakYaIAEgBigCDCIARgRAQdjfAEHY3wAoAgBBfiAFd3E2AgAMAgsgASAANgIMIAAgATYCCAwBCyAGKAIYIQkCQCAGIAYoAgwiA0cEQCAGKAIIIgAgAzYCDCADIAA2AggMAQsCQCAGQRRqIgAoAgAiAQ0AIAZBEGoiACgCACIBDQBBACEDDAELA0AgACEFIAEiA0EUaiIAKAIAIgENACADQRBqIQAgAygCECIBDQALIAVBADYCAAsgCUUNAAJAIAYgBigCHCIBQQJ0QYjiAGoiACgCAEYEQCAAIAM2AgAgAw0BQdzfAEHc3wAoAgBBfiABd3E2AgAMAgsgCUEQQRQgCSgCECAGRhtqIAM2AgAgA0UNAQsgAyAJNgIYIAYoAhAiAARAIAMgADYCECAAIAM2AhgLIAYoAhQiAEUNACADIAA2AhQgACADNgIYCyAGIAhqIQYgAiAIaiECCyAGIAYoAgRBfnE2AgQgBCACQQFyNgIEIAIgBGogAjYCACACQf8BTQRAIAJBA3YiAUEDdEGA4ABqIQACf0HY3wAoAgAiAkEBIAF0IgFxRQRAQdjfACABIAJyNgIAIAAMAQsgACgCCAshASAAIAQ2AgggASAENgIMIAQgADYCDCAEIAE2AggMAwtBHyEAIAJB////B00EQCACQQh2IgAgAEGA/j9qQRB2QQhxIgB0IgEgAUGA4B9qQRB2QQRxIgF0IgMgA0GAgA9qQRB2QQJxIgN0QQ92IAAgAXIgA3JrIgBBAXQgAiAAQRVqdkEBcXJBHGohAAsgBCAANgIcIARCADcCECAAQQJ0QYjiAGohAQJAQdzfACgCACIDQQEgAHQiBXFFBEBB3N8AIAMgBXI2AgAgASAENgIAIAQgATYCGAwBCyACQQBBGSAAQQF2ayAAQR9GG3QhACABKAIAIQMDQCADIgEoAgRBeHEgAkYNAyAAQR12IQMgAEEBdCEAIAEgA0EEcWpBEGoiBSgCACIDDQALIAUgBDYCACAEIAE2AhgLIAQgBDYCDCAEIAQ2AggMAgtB5N8AIAZBKGsiAEF4IANrQQdxQQAgA0EIakEHcRsiBWsiBzYCAEHw3wAgAyAFaiIFNgIAIAUgB0EBcjYCBCAAIANqQSg2AgRB9N8AQcDjACgCADYCACABIAJBJyACa0EHcUEAIAJBJ2tBB3EbakEvayIAIAAgAUEQakkbIgVBGzYCBCAFQaDjACkCADcCECAFQZjjACkCADcCCEGg4wAgBUEIajYCAEGc4wAgBjYCAEGY4wAgAzYCAEGk4wBBADYCACAFQRhqIQADQCAAQQc2AgQgAEEIaiEDIABBBGohACACIANLDQALIAEgBUYNAyAFIAUoAgRBfnE2AgQgASAFIAFrIgZBAXI2AgQgBSAGNgIAIAZB/wFNBEAgBkEDdiICQQN0QYDgAGohAAJ/QdjfACgCACIDQQEgAnQiAnFFBEBB2N8AIAIgA3I2AgAgAAwBCyAAKAIICyECIAAgATYCCCACIAE2AgwgASAANgIMIAEgAjYCCAwEC0EfIQAgAUIANwIQIAZB////B00EQCAGQQh2IgAgAEGA/j9qQRB2QQhxIgB0IgIgAkGA4B9qQRB2QQRxIgJ0IgMgA0GAgA9qQRB2QQJxIgN0QQ92IAAgAnIgA3JrIgBBAXQgBiAAQRVqdkEBcXJBHGohAAsgASAANgIcIABBAnRBiOIAaiECAkBB3N8AKAIAIgNBASAAdCIFcUUEQEHc3wAgAyAFcjYCACACIAE2AgAgASACNgIYDAELIAZBAEEZIABBAXZrIABBH0YbdCEAIAIoAgAhAwNAIAMiAigCBEF4cSAGRg0EIABBHXYhAyAAQQF0IQAgAiADQQRxakEQaiIFKAIAIgMNAAsgBSABNgIAIAEgAjYCGAsgASABNgIMIAEgATYCCAwDCyABKAIIIgAgBDYCDCABIAQ2AgggBEEANgIYIAQgATYCDCAEIAA2AggLIAdBCGohAAwFCyACKAIIIgAgATYCDCACIAE2AgggAUEANgIYIAEgAjYCDCABIAA2AggLQeTfACgCACIAIARNDQBB5N8AIAAgBGsiATYCAEHw3wBB8N8AKAIAIgAgBGoiAjYCACACIAFBAXI2AgQgACAEQQNyNgIEIABBCGohAAwDC0HU3wBBMDYCAEEAIQAMAgsCQCAJRQ0AAkAgBSgCHCICQQJ0QYjiAGoiACgCACAFRgRAIAAgAzYCACADDQFB3N8AIAhBfiACd3EiCDYCAAwCCyAJQRBBFCAJKAIQIAVGG2ogAzYCACADRQ0BCyADIAk2AhggBSgCECIABEAgAyAANgIQIAAgAzYCGAsgBSgCFCIARQ0AIAMgADYCFCAAIAM2AhgLAkAgAUEPTQRAIAUgASAEaiIAQQNyNgIEIAAgBWoiACAAKAIEQQFyNgIEDAELIAUgBEEDcjYCBCAHIAFBAXI2AgQgASAHaiABNgIAIAFB/wFNBEAgAUEDdiIBQQN0QYDgAGohAAJ/QdjfACgCACICQQEgAXQiAXFFBEBB2N8AIAEgAnI2AgAgAAwBCyAAKAIICyEBIAAgBzYCCCABIAc2AgwgByAANgIMIAcgATYCCAwBC0EfIQAgAUH///8HTQRAIAFBCHYiACAAQYD+P2pBEHZBCHEiAHQiAiACQYDgH2pBEHZBBHEiAnQiBCAEQYCAD2pBEHZBAnEiBHRBD3YgACACciAEcmsiAEEBdCABIABBFWp2QQFxckEcaiEACyAHIAA2AhwgB0IANwIQIABBAnRBiOIAaiECAkACQCAIQQEgAHQiBHFFBEBB3N8AIAQgCHI2AgAgAiAHNgIAIAcgAjYCGAwBCyABQQBBGSAAQQF2ayAAQR9GG3QhACACKAIAIQQDQCAEIgIoAgRBeHEgAUYNAiAAQR12IQQgAEEBdCEAIAIgBEEEcWpBEGoiAygCACIEDQALIAMgBzYCACAHIAI2AhgLIAcgBzYCDCAHIAc2AggMAQsgAigCCCIAIAc2AgwgAiAHNgIIIAdBADYCGCAHIAI2AgwgByAANgIICyAFQQhqIQAMAQsCQCAKRQ0AAkAgAygCHCICQQJ0QYjiAGoiACgCACADRgRAIAAgBTYCACAFDQFB3N8AIAlBfiACd3E2AgAMAgsgCkEQQRQgCigCECADRhtqIAU2AgAgBUUNAQsgBSAKNgIYIAMoAhAiAARAIAUgADYCECAAIAU2AhgLIAMoAhQiAEUNACAFIAA2AhQgACAFNgIYCwJAIAFBD00EQCADIAEgBGoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAwBCyADIARBA3I2AgQgCyABQQFyNgIEIAEgC2ogATYCACAIBEAgCEEDdiIEQQN0QYDgAGohAkHs3wAoAgAhAAJ/QQEgBHQiBCAGcUUEQEHY3wAgBCAGcjYCACACDAELIAIoAggLIQQgAiAANgIIIAQgADYCDCAAIAI2AgwgACAENgIIC0Hs3wAgCzYCAEHg3wAgATYCAAsgA0EIaiEACyAMQRBqJAAgAAvMDAEHfwJAIABFDQAgAEEIayICIABBBGsoAgAiAUF4cSIAaiEFAkAgAUEBcQ0AIAFBA3FFDQEgAiACKAIAIgFrIgJB6N8AKAIASQ0BIAAgAWohACACQezfACgCAEcEQCABQf8BTQRAIAIoAggiBCABQQN2IgdBA3RBgOAAakYaIAQgAigCDCIBRgRAQdjfAEHY3wAoAgBBfiAHd3E2AgAMAwsgBCABNgIMIAEgBDYCCAwCCyACKAIYIQYCQCACIAIoAgwiA0cEQCACKAIIIgEgAzYCDCADIAE2AggMAQsCQCACQRRqIgEoAgAiBA0AIAJBEGoiASgCACIEDQBBACEDDAELA0AgASEHIAQiA0EUaiIBKAIAIgQNACADQRBqIQEgAygCECIEDQALIAdBADYCAAsgBkUNAQJAIAIgAigCHCIEQQJ0QYjiAGoiASgCAEYEQCABIAM2AgAgAw0BQdzfAEHc3wAoAgBBfiAEd3E2AgAMAwsgBkEQQRQgBigCECACRhtqIAM2AgAgA0UNAgsgAyAGNgIYIAIoAhAiAQRAIAMgATYCECABIAM2AhgLIAIoAhQiAUUNASADIAE2AhQgASADNgIYDAELIAUoAgQiAUEDcUEDRw0AQeDfACAANgIAIAUgAUF+cTYCBCACIABBAXI2AgQgACACaiAANgIADwsgAiAFTw0AIAUoAgQiAUEBcUUNAAJAIAFBAnFFBEAgBUHw3wAoAgBGBEBB8N8AIAI2AgBB5N8AQeTfACgCACAAaiIANgIAIAIgAEEBcjYCBCACQezfACgCAEcNA0Hg3wBBADYCAEHs3wBBADYCAA8LIAVB7N8AKAIARgRAQezfACACNgIAQeDfAEHg3wAoAgAgAGoiADYCACACIABBAXI2AgQgACACaiAANgIADwsgAUF4cSAAaiEAAkAgAUH/AU0EQCAFKAIIIgQgAUEDdiIHQQN0QYDgAGpGGiAEIAUoAgwiAUYEQEHY3wBB2N8AKAIAQX4gB3dxNgIADAILIAQgATYCDCABIAQ2AggMAQsgBSgCGCEGAkAgBSAFKAIMIgNHBEAgBSgCCCIBQejfACgCAEkaIAEgAzYCDCADIAE2AggMAQsCQCAFQRRqIgEoAgAiBA0AIAVBEGoiASgCACIEDQBBACEDDAELA0AgASEHIAQiA0EUaiIBKAIAIgQNACADQRBqIQEgAygCECIEDQALIAdBADYCAAsgBkUNAAJAIAUgBSgCHCIEQQJ0QYjiAGoiASgCAEYEQCABIAM2AgAgAw0BQdzfAEHc3wAoAgBBfiAEd3E2AgAMAgsgBkEQQRQgBigCECAFRhtqIAM2AgAgA0UNAQsgAyAGNgIYIAUoAhAiAQRAIAMgATYCECABIAM2AhgLIAUoAhQiAUUNACADIAE2AhQgASADNgIYCyACIABBAXI2AgQgACACaiAANgIAIAJB7N8AKAIARw0BQeDfACAANgIADwsgBSABQX5xNgIEIAIgAEEBcjYCBCAAIAJqIAA2AgALIABB/wFNBEAgAEEDdiIBQQN0QYDgAGohAAJ/QdjfACgCACIEQQEgAXQiAXFFBEBB2N8AIAEgBHI2AgAgAAwBCyAAKAIICyEBIAAgAjYCCCABIAI2AgwgAiAANgIMIAIgATYCCA8LQR8hASACQgA3AhAgAEH///8HTQRAIABBCHYiASABQYD+P2pBEHZBCHEiAXQiBCAEQYDgH2pBEHZBBHEiBHQiAyADQYCAD2pBEHZBAnEiA3RBD3YgASAEciADcmsiAUEBdCAAIAFBFWp2QQFxckEcaiEBCyACIAE2AhwgAUECdEGI4gBqIQQCQAJAAkBB3N8AKAIAIgNBASABdCIFcUUEQEHc3wAgAyAFcjYCACAEIAI2AgAgAiAENgIYDAELIABBAEEZIAFBAXZrIAFBH0YbdCEBIAQoAgAhAwNAIAMiBCgCBEF4cSAARg0CIAFBHXYhAyABQQF0IQEgBCADQQRxakEQaiIFKAIAIgMNAAsgBSACNgIAIAIgBDYCGAsgAiACNgIMIAIgAjYCCAwBCyAEKAIIIgAgAjYCDCAEIAI2AgggAkEANgIYIAIgBDYCDCACIAA2AggLQfjfAEH43wAoAgBBAWsiAkF/IAIbNgIACwtVAQJ/QdDfACgCACIBIABBA2pBfHEiAmohAAJAIAJBAU5BACAAIAFNGw0APwBBEHQgAEkEQCAAEABFDQELQdDfACAANgIAIAEPC0HU3wBBMDYCAEF/C4IEAQN/IAJBgARPBEAgACABIAIQARogAA8LIAAgAmohAwJAIAAgAXNBA3FFBEACQCACQQFIBEAgACECDAELIABBA3FFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANPDQEgAkEDcQ0ACwsCQCADQXxxIgRBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyAAIANBBGsiBEsEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCyAAC9YCAQJ/AkAgAUUNACAAIAFqIgJBAWtBADoAACAAQQA6AAAgAUEDSQ0AIAJBAmtBADoAACAAQQA6AAEgAkEDa0EAOgAAIABBADoAAiABQQdJDQAgAkEEa0EAOgAAIABBADoAAyABQQlJDQAgAEEAIABrQQNxIgNqIgJBADYCACACIAEgA2tBfHEiA2oiAUEEa0EANgIAIANBCUkNACACQQA2AgggAkEANgIEIAFBCGtBADYCACABQQxrQQA2AgAgA0EZSQ0AIAJBADYCGCACQQA2AhQgAkEANgIQIAJBADYCDCABQRBrQQA2AgAgAUEUa0EANgIAIAFBGGtBADYCACABQRxrQQA2AgAgAyACQQRxQRhyIgNrIgFBIEkNACACIANqIQIDQCACQgA3AxggAkIANwMQIAJCADcDCCACQgA3AwAgAkEgaiECIAFBIGsiAUEfSw0ACwsLBAAjAAsGACAAJAALEAAjACAAa0FwcSIAJAAgAAsLvVYIAEGECAvxQJYwB3csYQ7uulEJmRnEbQeP9GpwNaVj6aOVZJ4yiNsOpLjceR7p1eCI2dKXK0y2Cb18sX4HLbjnkR2/kGQQtx3yILBqSHG5895BvoR91Noa6+TdbVG11PTHhdODVphsE8Coa2R6+WL97Mllik9cARTZbAZjYz0P+vUNCI3IIG47XhBpTORBYNVycWei0eQDPEfUBEv9hQ3Sa7UKpfqotTVsmLJC1sm720D5vKzjbNgydVzfRc8N1txZPdGrrDDZJjoA3lGAUdfIFmHQv7X0tCEjxLNWmZW6zw+lvbieuAIoCIgFX7LZDMYk6Quxh3xvLxFMaFirHWHBPS1mtpBB3HYGcdsBvCDSmCoQ1e+JhbFxH7W2BqXkv58z1LjooskHeDT5AA+OqAmWGJgO4bsNan8tPW0Il2xkkQFcY+b0UWtrYmFsHNgwZYVOAGLy7ZUGbHulARvB9AiCV8QP9cbZsGVQ6bcS6ri+i3yIufzfHd1iSS3aFfN804xlTNT7WGGyTc5RtTp0ALyj4jC71EGl30rXldg9bcTRpPv01tNq6WlD/NluNEaIZ63QuGDacy0EROUdAzNfTAqqyXwN3TxxBVCqQQInEBALvoYgDMkltWhXs4VvIAnUZrmf5GHODvneXpjJ2SkimNCwtKjXxxc9s1mBDbQuO1y9t61susAgg7jttrO/mgzitgOa0rF0OUfV6q930p0VJtsEgxbccxILY+OEO2SUPmptDahaanoLzw7knf8JkyeuAAqxngd9RJMP8NKjCIdo8gEe/sIGaV1XYvfLZ2WAcTZsGecGa252G9T+4CvTiVp62hDMSt1nb9+5+fnvvo5DvrcX1Y6wYOij1tZ+k9GhxMLYOFLy30/xZ7vRZ1e8pt0GtT9LNrJI2isN2EwbCq/2SgM2YHoEQcPvYN9V32eo745uMXm+aUaMs2HLGoNmvKDSbyU24mhSlXcMzANHC7u5FgIiLyYFVb47usUoC72yklq0KwRqs1yn/9fCMc/QtYue2Swdrt5bsMJkmybyY+yco2p1CpNtAqkGCZw/Ng7rhWcHchNXAAWCSr+VFHq44q4rsXs4G7YMm47Skg2+1eW379x8Id/bC9TS04ZC4tTx+LPdaG6D2h/NFr6BWya59uF3sG93R7cY5loIiHBqD//KOwZmXAsBEf+eZY9prmL40/9rYUXPbBZ44gqg7tIN11SDBE7CswM5YSZnp/cWYNBNR2lJ23duPkpq0a7cWtbZZgvfQPA72DdTrrypxZ673n/Pskfp/7UwHPK9vYrCusowk7NTpqO0JAU20LqTBtfNKVfeVL9n2SMuemazuEphxAIbaF2UK28qN74LtKGODMMb3wVaje8CLQAAAABBMRsZgmI2MsNTLSsExWxkRfR3fYanWlbHlkFPCIrZyEm7wtGK6O/6y9n04wxPtaxNfq61ji2Dns8cmIdREsJKECPZU9Nw9HiSQe9hVdeuLhTmtTfXtZgcloSDBVmYG4IYqQCb2/otsJrLNqldXXfmHGxs/98/QdSeDlrNoiSEleMVn4wgRrKnYXepvqbh6PHn0PPoJIPew2Wyxdqqrl1d659GRCjMa29p/XB2rmsxOe9aKiAsCQcLbTgcEvM2Rt+yB13GcVRw7TBla/T38yq7tsIxonWRHIk0oAeQ+7yfF7qNhA553qklOO+yPP9583O+SOhqfRvFQTwq3lgFT3nwRH5i6YctT8LGHFTbAYoVlEC7Do2D6COmwtk4vw3FoDhM9Lshj6eWCs6WjRMJAMxcSDHXRYti+m7KU+F3VF27uhVsoKPWP42Ilw6WkVCY194RqczH0vrh7JPL+vVc12JyHeZ5a961VECfhE9ZWBIOFhkjFQ/acDgkm0EjPadr/WXmWuZ8JQnLV2Q40E6jrpEB4p+KGCHMpzNg/bwqr+Ekre7QP7QtgxKfbLIJhqskSMnqFVPQKUZ++2h3ZeL2eT8vt0gkNnQbCR01KhIE8rxTS7ONSFJw3mV5Me9+YP7z5ue/wv3+fJHQ1T2gy8z6NoqDuweRmnhUvLE5ZaeoS5iDOwqpmCLJ+rUJiMuuEE9d718ObPRGzT/ZbYwOwnRDElrzAiNB6sFwbMGAQXfYR9c2lwbmLY7FtQClhIQbvBqKQXFbu1pomOh3Q9nZbFoeTy0VX342DJwtGyfdHAA+EgCYuVMxg6CQYq6L0VO1khbF9N1X9O/ElKfC79WW2fbpvAeuqI0ct2veMZwq7yqF7XlryqxIcNNvG134LipG4eE23magB8V/Y1ToVCJl803l87ICpMKpG2eRhDAmoJ8puK7F5Pmf3v06zPPWe/3oz7xrqYD9WrKZPgmfsn84hKuwJBws8RUHNTJGKh5zdzEHtOFwSPXQa1E2g0Z6d7JdY07X+ssP5uHSzLXM+Y2E1+BKEpavCyONtshwoJ2JQbuERl0jAwdsOBrEPxUxhQ4OKEKYT2cDqVR+wPp5VYHLYkwfxTiBXvQjmJ2nDrPclhWqGwBU5VoxT/yZYmLX2FN5zhdP4UlWfvpQlS3Xe9QczGITio0tUruWNJHoux/Q2aAG7PN+Xq3CZUdukUhsL6BTdeg2EjqpBwkjalQkCCtlPxHkeaeWpUi8j2YbkaQnKoq94LzL8qGN0Oti3v3AI+/m2b3hvBT80KcNP4OKJn6ykT+5JNBw+BXLaTtG5kJ6d/1btWtl3PRafsU3CVPudjhI97GuCbjwnxKhM8w/inL9JJMAAAAAN2rCAW7UhANZvkYC3KgJB+vCywayfI0EhRZPBbhREw6PO9EP1oWXDeHvVQxk+RoJU5PYCAotngo9R1wLcKMmHEfJ5B0ed6IfKR1gHqwLLxubYe0awt+rGPW1aRnI8jUS/5j3E6YmsRGRTHMQFFo8FSMw/hR6jrgWTeR6F+BGTTjXLI85jpLJO7n4Czo87kQ/C4SGPlI6wDxlUAI9WBdeNm99nDc2w9o1AakYNIS/VzGz1ZUw6mvTMt0BETOQ5Wskp4+pJf4x7yfJWy0mTE1iI3snoCIimeYgFfMkISi0eCof3rorRmD8KXEKPij0HHEtw3azLJrI9S6tojcvwI2acPfnWHGuWR5zmTPcchwlk3crT1F2cvEXdEWb1XV43Il+T7ZLfxYIDX0hYs98pHSAeZMeQnjKoAR6/crGe7AuvGyHRH5t3vo4b+mQ+m5shrVrW+x3agJSMWg1OPNpCH+vYj8VbWNmqythUcHpYNTXpmXjvWRkugMiZo1p4Gcgy9dIF6EVSU4fU0t5dZFK/GPeT8sJHE6St1pMpd2YTZiaxEav8AZH9k5ARcEkgkREMs1Bc1gPQCrmSUIdjItDUGjxVGcCM1U+vHVXCda3VozA+FO7qjpS4hR8UNV+vlHoOeJa31MgW4btZlmxh6RYNJHrXQP7KVxaRW9ebS+tX4AbNeG3cffg7s+x4tmlc+Ncszzma9n+5zJnuOUFDXrkOEom7w8g5O5WnqLsYfRg7eTiL+jTiO3pijar671caerwuBP9x9LR/J5sl/6pBlX/LBAa+ht62PtCxJ75da5c+EjpAPN/g8LyJj2E8BFXRvGUQQn0oyvL9fqVjffN/0/2YF142Vc3utgOifzaOeM+27z1cd6Ln7Pf0iH13eVLN9zYDGvX72ap1rbY79SBsi3VBKRi0DPOoNFqcObTXRok0hD+XsUnlJzEfiraxklAGMfMVlfC+zyVw6KC08GV6BHAqK9Ny5/Fj8rGe8nI8RELyXQHRMxDbYbNGtPAzy25As5Alq+Rd/xtkC5CK5IZKOmTnD6mlqtUZJfy6iKVxYDglPjHvJ/PrX6elhM4nKF5+p0kb7WYEwV3mUq7MZt90fOaMDWJjQdfS4xe4Q2OaYvPj+ydgIrb90KLgkkEibUjxoiIZJqDvw5YguawHoDR2tyBVMyThGOmUYU6GBeHDXLVhqDQ4qmXuiCozgRmqvlupKt8eOuuSxIprxKsb60lxq2sGIHxpy/rM6Z2VXWkQT+3pcQp+KDzQzqhqv18o52XvqLQc8S15xkGtL6nQLaJzYK3DNvNsjuxD7NiD0mxVWWLsGgi17tfSBW6BvZTuDGckbm0it68g+AcvdpeWr/tNJi+AAAAAGVnvLiLyAmq7q+1EleXYo8y8N433F9rJbk4153vKLTFik8IfWTgvW8BhwHXuL/WSt3YavIzd9/gVhBjWJ9XGVD6MKXoFJ8Q+nH4rELIwHvfrafHZ0MIcnUmb87NcH+tlRUYES37t6Q/ntAYhyfozxpCj3OirCDGsMlHegg+rzKgW8iOGLVnOwrQAIeyaThQLwxf7Jfi8FmFh5flPdGHhmW04DrdWk+Pzz8oM3eGEOTq43dYUg3Y7UBov1H4ofgr8MSfl0gqMCJaT1ee4vZvSX+TCPXHfadA1RjA/G1O0J81K7cjjcUYlp+gfyonGUf9unwgQQKSj/QQ9+hIqD1YFJtYP6gjtpAdMdP3oYlqz3YUD6jKrOEHf76EYMMG0nCgXrcXHOZZuKn0PN8VTIXnwtHggH5pDi/Le2tId8OiDw3Lx2ixcynHBGFMoLjZ9ZhvRJD/0/x+UGbuGzfaVk0nuQ4oQAW2xu+wpKOIDBwasNuBf9dnOZF40iv0H26TA/cmO2aQmoOIPy+R7ViTKVRgRLQxB/gM36hNHrrP8abs35L+ibguRmcXm1QCcCfsu0jwcd4vTMkwgPnbVedFY5ygP2v5x4PTF2g2wXIPinnLN13krlDhXED/VE4lmOj2c4iLrhbvNxb4QIIEnSc+vCQf6SFBeFWZr9fgi8qwXDM7tlntXtHlVbB+UEfVGez/bCE7YglGh9rn6TLIgo6OcNSe7Six+VGQX1bkgjoxWDqDCY+n5m4zHwjBhg1tpjq1pOFAvcGG/AUvKUkXSk71r/N2IjKWEZ6KeL4rmB3ZlyBLyfR4Lq5IwMAB/dKlZkFqHF6W93k5Kk+Xlp9d8vEj5QUZa01gftf1jtFi5+u23l9SjgnCN+m1etlGAGi8IbzQ6jHfiI9WYzBh+dYiBJ5qmr2mvQfYwQG/Nm60rVMJCBWaTnId/ynOpRGGe7d04ccPzdkQkqi+rCpGERk4I3algHVmxtgQAXpg/q7PcpvJc8oi8aRXR5YY76k5rf3MXhFFBu5NdmOJ8c6NJkTc6EH4ZFF5L/k0HpNB2rEmU7/WmuvpxvmzjKFFC2IO8BkHaUyhvlGbPNs2J4Q1mZKWUP4uLpm5VCb83uieEnFdjHcW4TTOLjapq0mKEUXmPwMggYO7dpHg4xP2XFv9WelJmD5V8SEGgmxEYT7Uqs6Lxs+pN344QX/WXSbDbrOJdnzW7srEb9YdWQqxoeHkHhTzgXmoS9dpyxOyDnerXKHCuTnGfgGA/qmc5ZkVJAs2oDZuURyOpxZmhsJx2j4s3m8sSbnTlPCBBAmV5rixe0kNox4usRtIPtJDLVlu+8P22+mmkWdRH6mwzHrODHSUYblm8QYF3gAAAAB3BzCW7g5hLJkJUboHbcQZcGr0j+ljpTWeZJWjDtuIMnncuKTg1ekel9LZiAm2TCt+sXy957gtB5C/HZEdtxBkarAg8vO5cUiEvkHeGtrUfW3d5Ov01LVRg9OFxxNsmFZka6jA/WL5eoplyewUAVxPYwZs2foPPWONCA31O24gyExpEF7VYEHkomdxcjwD5NFLBNRH0g2F/aUKtWs1taj6QrKYbNu7ydasvPlAMths40XfXHXc1g3Pq9E9WSbZMKxR3gA6yNdRgL/QYRYhtPS1VrPEI8+6lZm4vaUPKAK4nl8FiAjGDNmysQvpJC9vfIdYaEwRwWEdq7ZmLT123EGQAdtxBpjSILzv1RAqcbGFiQa2tR+fv+Sl6LjUM3gHyaIPAPk0lgmojuEOmBh/ag27CG09LZFkbJfmY1wBa2tR9BxsYWKFZTDY8mIATmwGle0bAaV7ggj0wfUPxFdlsNnGErfpUIu+uOr8uYh8Yt0d3xXaLUmM03zz+9RMZU2yYVg6tVHOo7wAdNS7MOJK36VBPdiV16TRxG3T1vT7Q2npajRu2fytZ4hG2mC40EQELXMzAx3lqgpMX90NfMlQBXE8JwJBqr4LEBDJDCCGV2i1JSBvhbO5ZtQJzmHkn17e+Q4p2cmYsNCYIsfXqLRZsz0XLrQNgbe9XDvAumyt7biDIJq/s7YDtuIMdLHSmurVRzmd0nevBNsmFXPcFoPjYwsSlGQ7hA1taj56alqo5A7PC5MJ/50KAK4nfQeesfAPk0SHCKPSHgHyaGkGwv73YlddgGVnyxlsNnFuawbn/tQbdonTK+AQ2npaZ91KzPm532+Ovu/5F7e+Q2CwjtXW1qPoodGTfjjYwsRP3/JS0btn8aa8V2c/tQbdSLI2S9gNK9qvChtMNgNK9kEEemDfYO/DqGffVTFuju9Gab55y2GzjLxmgxolb9KgUmjiNswMd5W7C0cDIgIWuVUFJi/Fuju+sr0LKCu0WpJcs2oEwtf/p7XQzzEs2Z6LW96uHZtkwrDsY/ImdWqjnAJtkwqcCQap6w42P3IHZ4UFAFcTlb9KguK4ehR7sSuuDLYbOJLSjpvl1b4NfNzvtwvb3yGG09LU8dTiQmjds/gf2oNugb4Wzfa5JltvsHfhGLdHd4gIWub/D2pwZgY7yhEBC1yPZZ7/+GKuaWFr/9MWbM9FoArieNcN0u5OBINUOQOzwqdnJmHQYBb3SWlHTT5ud9uu0WpK2dZa3EDfC2Y32DvwqbyuU967nsVHss9/MLX/6b298hzKusKKU7OTMCS0o6a60DYFzdcGk1TeVykj2We/s2Z6LsRhSrhdaBsCKm8rlLQLvjfDDI6hWgXfGy0C740AAAAAGRsxQTI2YoIrLVPDZGzFBH139EVWWqeGT0GWx8jZigjRwrtJ+u/oiuP02custU8Mta5+TZ6DLY6HmBzPSsISUVPZIxB49HDTYe9Bki6u11U3teYUHJi11wWDhJaCG5hZmwCpGLAt+tupNsua5nddXf9sbBzUQT/fzVoOnpWEJKKMnxXjp7JGIL6pd2Hx6OGm6PPQ58PegyTaxbJlXV2uqkRGn+tva8wodnD9aTkxa64gKlrvCwcJLBIcOG3fRjbzxl0Hsu1wVHH0a2Uwuyrz96IxwraJHJF1kAegNBefvPsOhI26JaneeTyy7zhz83n/auhIvkHFG31Y3io88HlPBelifkTCTy2H21QcxpQVigGNDrtApiPog7842cI4oMUNIbv0TAqWp48TjZbOXMwACUXXMUhu+mKLd+FTyrq7XVSjoGwViI0/1pGWDpfe15hQx8ypEezh+tL1+suTcmLXXGt55h1AVLXeWU+EnxYOElgPFSMZJDhw2j0jQZtl/WunfOZa5lfLCSVO0DhkAZGuoxiKn+Izp8whKrz9YK0k4a+0P9DunxKDLYYJsmzJSCSr0FMV6vt+RiniZXdoLz959jYkSLcdCRt0BBIqNUtTvPJSSI2zeWXecGB+7zHn5vP+/v3Cv9XQkXzMy6A9g4o2+pqRB7uxvFR4qKdlOTuDmEsimKkKCbX6yRCuy4hf711PRvRsDm3ZP810wg6M81oSQ+pBIwLBbHDB2HdBgJc210eOLeYGpQC1xbwbhIRxQYoaaFq7W0N36JhabNnZFS1PHgw2fl8nGy2cPgAc3bmYABKggzFTi65ikJK1U9Hd9MUWxO/0V+/Cp5T22ZbVrge86bccjaicMd5rhSrvKspree3TcEis+F0bb+FGKi5m3jbhf8UHoFToVGNN82UiArLz5RupwqQwhJFnKZ+gJuTFrrj93p/51vPMOs/o/XuAqWu8mbJa/bKfCT6rhDh/LBwksDUHFfEeKkYyBzF3c0hw4bRRa9D1ekaDNmNdsnfL+tdO0uHmD/nMtczg14SNr5YSSraNIwudoHDIhLtBiQMjXUYaOGwHMRU/xCgODoVnT5hCflSpA1V5+sBMYsuBgTjFH5gj9F6zDqedqhWW3OVUABv8TzFa12Jimc55U9hJ4U8XUPp+VnvXLZVizBzULY2KEzSWu1Ifu+iRBqDZ0F5+8+xHZcKtbEiRbnVToC86EjboIwkHqQgkVGoRP2Urlqd55I+8SKWkkRtmvYoqJ/LLvODr0I2hwP3eYtnm7yMUvOG9DafQ/CaKgz8/kbJ+cNAkuWnLFfhC5kY7W/13etxla7XFflr07lMJN/dIOHa4Ca6xoRKf8Io/zDOTJP1yAAAAAAHCajcDhNRuAka+WQcJqNwGy8LrBI18sgVPFoUOE1G4D9E7jw2XhdYMVe/hCRr5ZAjYk1MKni0KC1xHPRwmo3Ad5MlHH6J3Hh5gHSkbLwusGu1hmxir38IZabX1EjXyyBP3mP8RsSamEHNMkRU8WhQU/jAjFriOehd65E04TUbgOY8s1zvJko46C/i5P0TuPD6GhAs8wDpSPQJQZTZeF1g3nH1vNdrDNjQYqQExV7+EMJXVszLTa+ozEQHdJGvlkCWpj6cn7zH+Ji1bySNiTUwioCd7IOaZIiEk8xUqeLQoK7reHyn8YEYoPgpxLXEc9CyzdsMu9ciaLzeirXCajcBxWOf3cx5ZrnLcM5l3kyUcdlFPK3QX8XJ11ZtFfonceH9Ltk99DQgWfM9iIXmAdKR4Qh6TegSgynvGyv1svC6wbX5Eh284+t5u+pDpa7WGbGp37FtoMVICafM4NWKvfwhjbRU/YSurZmDpwVFlptfUZGS942YiA7pn4GmNSNfLIEkVoRdLUx9OSpF1eU/eY/xOHAnLTFq3kk2Y3aVGxJqYRwbwr0VATvZEgiTBQc0yREAPWHNCSeYqQ4uMHVTxaFBVMwJnV3W8Pla31glT+MCMUjqqu1B8FOJRvn7VWuI56FsgU99ZZu2GWKSHsV3rkTRcKfsDXm9FWl+tL23hNRuA4Pdxt+Kxz+7jc6XZ5jyzXOf+2WvluGcy5HoNBe8mSjju5CAP7KKeVu1g9GHoL+Lk6e2I0+urNorqaVy9/RO48PzR0sf+l2ye/1UGqfoaECz72Hob+Z7EQvhcrnXzAOlI8sKDf/CEPSbxRlcR9AlBlPXLK6P3jZX69k//zdl4XWDYujdX2vyJDts+4znecfW837Ofi931IdLcN0vl12sM2NapZu/U79i21S2ygdBipATRoM4z0+ZwatIkGl3FXv4QxJyUJ8baKn7HGEBJwldWzMOVPPvB04KiwBHolctNr6jKj8WfyMl7xskLEfHMRAd0zYZtQ8/A0xrOArktka+WQJBt/HeSK0Iuk+koGZamPpyXZFSrlSLq8pTggMWfvMf4nn6tz5w4E5ad+nmhmLVvJJl3BRObMbtKmvPRfY2JNTCMS18Hjg3hXo/Pi2mKgJ3si0L324kESYKIxiO1g5pkiIJYDr+AHrDmgdza0YSTzFSFUaZjhxcYOobVcg2p4tCgqCC6l6pmBM6rpG75rut4fK8pEkutb6wSrK3GJafxgRimM+svpHVVdqW3P0Gg+CnEoTpD86N8/aqivpedtcRz0LQGGee2QKe+t4LNibLN2wyzD7E7sUkPYrCLZVW71yJouhVIX7hT9ga5kZwxvN6KtL0c4IO/Wl7avpg07QAAAAC4vGdlqgnIixK1r+6PYpdXN97wMiVrX9yd1zi5xbQo730IT4pvveBk1wGHAUrWv7jyatjd4N93M1hjEFZQGVef6KUw+voQnxRCrPhx33vAyGfHp611cghDzc5vJpWtf3AtERgVP6S3+4cY0J4az+gnonOPQrDGIKwIekfJoDKvPhiOyFsKO2e1socA0C9QOGmX7F8MhVnw4j3ll4dlhofR3TrgtM+PT1p3Myg/6uQQhlJYd+NA7dgN+FG/aPAr+KFIl5/EWiIwKuKeV09/SW/2x/UIk9VAp31t/MAYNZ/QTo0jtyuflhjFJyp/oLr9RxkCQSB8EPSPkqhI6PebFFg9I6g/WDEdkLaJoffTFHbPaqzKqA++fwfhBsNghF6gcNLmHBe39Km4WUwV3zzRwueFaX6A4HvLLw7Dd0hryw0PonOxaMdhBMcp2bigTERvmPX80/+Q7mZQflbaNxsOuSdNtgVAKKSw78YcDIijgduwGjln138r0niRk24f9Dsm9wODmpBmkS8/iCmTWO20RGBUDPgHMR5NqN+m8c+6/pLf7EYuuIlUmxdn7CdwAnHwSLvJTC/e2/mAMGNF51VrP6Cc04PH+cE2aBd5ig9y5F03y1zhUK5OVP9A9uiYJa6LiHMWN+8WBIJA+Lw+J50h6R8kmVV4QYvg168zXLDK7Vm2O1Xl0V5HUH6w/+wZ1WI7IWzah0YJyDLp53COjoIo7Z7UkFH5sYLkVl86WDE6p48Jgx8zbuYNhsEItTqmbb1A4aQF/IbBF0kpL6/1TkoyInbzip4Rlpgrvnggl9kdePTJS8BIri7S/QHAakFmpfeWXhxPKjl5XZ+Wl+Uj8fJNaxkF9dd+YOdi0Y5f3rbrwgmOUnq16TdoAEbZ0LwhvIjfMeowY1aPItb5YZpqngQHvaa9vwHB2K20bjYVCAlTHXJOmqXOKf+3e4YRD8fhdJIQ2c0qrL6oOBkRRoCldiPYxmZ1YHoBEHLPrv7Kc8mbV6TxIu8Ylkf9rTmpRRFezHZN7gbO8Ylj3EQmjWT4Qej5L3lRQZMeNFMmsdrrmta/s/nG6QtFoYwZ8A5ioUxpBzybUb6EJzbblpKZNS4u/lAmVLmZnuje/IxdcRI04RZ3qTYuzhGKSasDP+ZFu4OBIOPgkXZbXPYTSelZ/fFVPphsggYh1D5hRMaLzqp+N6nP1n9BOG7DJl18domzxMru1lkd1m/hobEK8xQe5EuoeYETy2nXq3cOsrnCoVwBfsY5nKn+gCQVmeU2oDYLjhxRboZmFqc+2nHCLG/eLJTTuUkJBIHwsbjmlaMNSXsbsS4eQ9I+SPtuWS3p2/bDUWeRpsywqR90DM56ZrlhlN4FBvEAAAAAAAAAAAMAAAAEAAQACAAEAAQAAAAEAAUAEAAIAAQAAAAEAAYAIAAgAAQAAAAEAAQAEAAQAAUAAAAIABAAIAAgAAUAAAAIABAAgACAAAUAAAAIACAAgAAAAQUAAAAgAIAAAgEABAUAAAAgAAIBAgEAEAUAQYHJAAu2EAECAwQEBQUGBgYGBwcHBwgICAgICAgICQkJCQkJCQkKCgoKCgoKCgoKCgoKCgoKCwsLCwsLCwsLCwsLCwsLCwwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDwAAEBESEhMTFBQUFBUVFRUWFhYWFhYWFhcXFxcXFxcXGBgYGBgYGBgYGBgYGBgYGBkZGRkZGRkZGRkZGRkZGRkaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHB0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0AAQIDBAUGBwgICQkKCgsLDAwMDA0NDQ0ODg4ODw8PDxAQEBAQEBAQERERERERERESEhISEhISEhMTExMTExMTFBQUFBQUFBQUFBQUFBQUFBUVFRUVFRUVFRUVFRUVFRUWFhYWFhYWFhYWFhYWFhYWFxcXFxcXFxcXFxcXFxcXFxgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxscwCcAAMAsAAABAQAAHgEAAA8AAABALAAAQC0AAAAAAAAeAAAADwAAAAAAAADALQAAAAAAABMAAAAHAAAAAAAAAAwACACMAAgATAAIAMwACAAsAAgArAAIAGwACADsAAgAHAAIAJwACABcAAgA3AAIADwACAC8AAgAfAAIAPwACAACAAgAggAIAEIACADCAAgAIgAIAKIACABiAAgA4gAIABIACACSAAgAUgAIANIACAAyAAgAsgAIAHIACADyAAgACgAIAIoACABKAAgAygAIACoACACqAAgAagAIAOoACAAaAAgAmgAIAFoACADaAAgAOgAIALoACAB6AAgA+gAIAAYACACGAAgARgAIAMYACAAmAAgApgAIAGYACADmAAgAFgAIAJYACABWAAgA1gAIADYACAC2AAgAdgAIAPYACAAOAAgAjgAIAE4ACADOAAgALgAIAK4ACABuAAgA7gAIAB4ACACeAAgAXgAIAN4ACAA+AAgAvgAIAH4ACAD+AAgAAQAIAIEACABBAAgAwQAIACEACAChAAgAYQAIAOEACAARAAgAkQAIAFEACADRAAgAMQAIALEACABxAAgA8QAIAAkACACJAAgASQAIAMkACAApAAgAqQAIAGkACADpAAgAGQAIAJkACABZAAgA2QAIADkACAC5AAgAeQAIAPkACAAFAAgAhQAIAEUACADFAAgAJQAIAKUACABlAAgA5QAIABUACACVAAgAVQAIANUACAA1AAgAtQAIAHUACAD1AAgADQAIAI0ACABNAAgAzQAIAC0ACACtAAgAbQAIAO0ACAAdAAgAnQAIAF0ACADdAAgAPQAIAL0ACAB9AAgA/QAIABMACQATAQkAkwAJAJMBCQBTAAkAUwEJANMACQDTAQkAMwAJADMBCQCzAAkAswEJAHMACQBzAQkA8wAJAPMBCQALAAkACwEJAIsACQCLAQkASwAJAEsBCQDLAAkAywEJACsACQArAQkAqwAJAKsBCQBrAAkAawEJAOsACQDrAQkAGwAJABsBCQCbAAkAmwEJAFsACQBbAQkA2wAJANsBCQA7AAkAOwEJALsACQC7AQkAewAJAHsBCQD7AAkA+wEJAAcACQAHAQkAhwAJAIcBCQBHAAkARwEJAMcACQDHAQkAJwAJACcBCQCnAAkApwEJAGcACQBnAQkA5wAJAOcBCQAXAAkAFwEJAJcACQCXAQkAVwAJAFcBCQDXAAkA1wEJADcACQA3AQkAtwAJALcBCQB3AAkAdwEJAPcACQD3AQkADwAJAA8BCQCPAAkAjwEJAE8ACQBPAQkAzwAJAM8BCQAvAAkALwEJAK8ACQCvAQkAbwAJAG8BCQDvAAkA7wEJAB8ACQAfAQkAnwAJAJ8BCQBfAAkAXwEJAN8ACQDfAQkAPwAJAD8BCQC/AAkAvwEJAH8ACQB/AQkA/wAJAP8BCQAAAAcAQAAHACAABwBgAAcAEAAHAFAABwAwAAcAcAAHAAgABwBIAAcAKAAHAGgABwAYAAcAWAAHADgABwB4AAcABAAHAEQABwAkAAcAZAAHABQABwBUAAcANAAHAHQABwADAAgAgwAIAEMACADDAAgAIwAIAKMACABjAAgA4wAIAAAABQAQAAUACAAFABgABQAEAAUAFAAFAAwABQAcAAUAAgAFABIABQAKAAUAGgAFAAYABQAWAAUADgAFAB4ABQABAAUAEQAFAAkABQAZAAUABQAFABUABQANAAUAHQAFAAMABQATAAUACwAFABsABQAHAAUAFwAFAEHg2QALTQEAAAABAAAAAQAAAAEAAAACAAAAAgAAAAIAAAACAAAAAwAAAAMAAAADAAAAAwAAAAQAAAAEAAAABAAAAAQAAAAFAAAABQAAAAUAAAAFAEHQ2gALZQEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAUAAAAGAAAABgAAAAcAAAAHAAAACAAAAAgAAAAJAAAACQAAAAoAAAAKAAAACwAAAAsAAAAMAAAADAAAAA0AAAANAEGA3AALIwIAAAADAAAABwAAAAAAAAAQERIACAcJBgoFCwQMAw0CDgEPAEG03AALaQEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACgAAAAwAAAAOAAAAEAAAABQAAAAYAAAAHAAAACAAAAAoAAAAMAAAADgAAABAAAAAUAAAAGAAAABwAAAAgAAAAKAAAADAAAAA4ABBtN0AC5oCAQAAAAIAAAADAAAABAAAAAYAAAAIAAAADAAAABAAAAAYAAAAIAAAADAAAABAAAAAYAAAAIAAAADAAAAAAAEAAIABAAAAAgAAAAMAAAAEAAAABgAAAAgAAAAMAAAAEAAAABgAAAAgAAAAMAAAAEAAAABgAABuZWVkIGRpY3Rpb25hcnkAc3RyZWFtIGVuZAAAZmlsZSBlcnJvcgBzdHJlYW0gZXJyb3IAZGF0YSBlcnJvcgBpbnN1ZmZpY2llbnQgbWVtb3J5AGJ1ZmZlciBlcnJvcgBpbmNvbXBhdGlibGUgdmVyc2lvbgAAAAAoLwAAOC8AAEMvAABELwAATy8AAFwvAABnLwAAey8AAIgvAABDLwAAMS4yLjExAEHQ3wALA9AxUA==");
      let MJ, UJ;
      async function xJ() {
        if (MJ)
          return MJ;
        const e3 = {};
        let t3, i3 = {};
        for (t3 in e3)
          Object.prototype.hasOwnProperty.call(e3, t3) && (i3[t3] = e3[t3]);
        let r3 = false, n3 = false;
        r3 = "object" == typeof window, n3 = "function" == typeof importScripts, "object" == typeof process && "object" == typeof process.versions && process.versions.node;
        let o3 = "";
        (r3 || n3) && (n3 ? o3 = self.location.href : "undefined" != typeof document && document.currentScript && (o3 = document.currentScript.src), o3 = 0 !== o3.indexOf("blob:") ? o3.substr(0, o3.lastIndexOf("/") + 1) : ""), e3.print || console.log.bind(console);
        const s3 = e3.printErr || console.warn.bind(console);
        for (t3 in i3)
          Object.prototype.hasOwnProperty.call(i3, t3) && (e3[t3] = i3[t3]);
        let a3;
        i3 = null, e3.arguments, e3.thisProgram, e3.quit, e3.wasmBinary, e3.noExitRuntime, "object" != typeof WebAssembly && C3("no native wasm support detected");
        let c3 = false;
        function d3(t4) {
          const i4 = e3["_" + t4];
          var r4;
          return r4 = "Cannot call unknown function " + t4 + ", make sure it is exported", i4 || C3("Assertion failed: " + r4), i4;
        }
        function u3(e4, t4, i4, r4, n4) {
          const o4 = { string: function(e5) {
            let t5 = 0;
            if (null != e5 && 0 !== e5) {
              const i5 = 1 + (e5.length << 2);
              t5 = D3(i5), function(e6, t6, i6) {
                (function(e7, t7, i7, r5) {
                  if (!(r5 > 0))
                    return 0;
                  const n5 = i7, o5 = i7 + r5 - 1;
                  for (let r6 = 0; r6 < e7.length; ++r6) {
                    let n6 = e7.charCodeAt(r6);
                    if (n6 >= 55296 && n6 <= 57343) {
                      n6 = 65536 + ((1023 & n6) << 10) | 1023 & e7.charCodeAt(++r6);
                    }
                    if (n6 <= 127) {
                      if (i7 >= o5)
                        break;
                      t7[i7++] = n6;
                    } else if (n6 <= 2047) {
                      if (i7 + 1 >= o5)
                        break;
                      t7[i7++] = 192 | n6 >> 6, t7[i7++] = 128 | 63 & n6;
                    } else if (n6 <= 65535) {
                      if (i7 + 2 >= o5)
                        break;
                      t7[i7++] = 224 | n6 >> 12, t7[i7++] = 128 | n6 >> 6 & 63, t7[i7++] = 128 | 63 & n6;
                    } else {
                      if (i7 + 3 >= o5)
                        break;
                      t7[i7++] = 240 | n6 >> 18, t7[i7++] = 128 | n6 >> 12 & 63, t7[i7++] = 128 | n6 >> 6 & 63, t7[i7++] = 128 | 63 & n6;
                    }
                  }
                  t7[i7] = 0;
                })(e6, l3, t6, i6);
              }(e5, t5, i5);
            }
            return t5;
          }, array: function(e5) {
            const t5 = D3(e5.length);
            var i5, r5;
            return i5 = e5, r5 = t5, A3.set(i5, r5), t5;
          } };
          const s4 = d3(e4), a4 = [];
          let c4 = 0;
          if (r4)
            for (let e5 = 0; e5 < r4.length; e5++) {
              const t5 = o4[i4[e5]];
              t5 ? (0 === c4 && (c4 = N3()), a4[e5] = t5(r4[e5])) : a4[e5] = r4[e5];
            }
          let u4 = s4.apply(null, a4);
          return u4 = function(e5) {
            return "string" === t4 ? (i5 = e5) ? function(e6, t5, i6) {
              const r6 = t5 + i6;
              let n5 = t5, o5 = "";
              for (; e6[n5] && !(n5 >= r6); )
                ++n5;
              if (n5 - t5 > 16 && e6.subarray && h3)
                return h3.decode(e6.subarray(t5, n5));
              for (; t5 < n5; ) {
                let i7 = e6[t5++];
                if (!(128 & i7)) {
                  o5 += String.fromCharCode(i7);
                  continue;
                }
                const r7 = 63 & e6[t5++];
                if (192 == (224 & i7)) {
                  o5 += String.fromCharCode((31 & i7) << 6 | r7);
                  continue;
                }
                const n6 = 63 & e6[t5++];
                if (i7 = 224 == (240 & i7) ? (15 & i7) << 12 | r7 << 6 | n6 : (7 & i7) << 18 | r7 << 12 | n6 << 6 | 63 & e6[t5++], i7 < 65536)
                  o5 += String.fromCharCode(i7);
                else {
                  const e7 = i7 - 65536;
                  o5 += String.fromCharCode(55296 | e7 >> 10, 56320 | 1023 & e7);
                }
              }
              return o5;
            }(l3, i5, r5) : "" : "boolean" === t4 ? Boolean(e5) : e5;
            var i5, r5;
          }(u4), 0 !== c4 && O3(c4), u4;
        }
        const h3 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
        let A3, l3, p3;
        "undefined" != typeof TextDecoder && new TextDecoder("utf-16le"), e3.INITIAL_MEMORY;
        const g3 = [], E3 = [], f3 = [], m3 = [];
        E3.push({ func: function() {
          y3();
        } });
        let I3 = 0, _3 = null;
        function C3(t4) {
          e3.onAbort && e3.onAbort(t4), s3(t4 += ""), c3 = true, t4 = "abort(" + t4 + "). Build with -s ASSERTIONS=1 for more info.";
          throw new WebAssembly.RuntimeError(t4);
        }
        e3.preloadedImages = {}, e3.preloadedAudios = {};
        let S3 = "deflate.wasm";
        var v3;
        function T3(t4) {
          for (; t4.length > 0; ) {
            const i4 = t4.shift();
            if ("function" == typeof i4) {
              i4(e3);
              continue;
            }
            const r4 = i4.func;
            "number" == typeof r4 ? void 0 === i4.arg ? p3.get(r4)() : p3.get(r4)(i4.arg) : r4(void 0 === i4.arg ? null : i4.arg);
          }
        }
        v3 = "data:application/octet-stream;base64,", S3.startsWith(v3) || (S3 = function(t4) {
          return e3.locateFile ? e3.locateFile(t4, o3) : o3 + t4;
        }(S3));
        const R3 = { emscripten_memcpy_big: function(e4, t4, i4) {
          l3.copyWithin(e4, t4, t4 + i4);
        }, emscripten_resize_heap: function(e4) {
          C3("OOM");
        } };
        await async function() {
          const t4 = { env: R3, wasi_snapshot_preview1: R3 };
          function i4(t5, i5) {
            const r5 = t5.exports;
            var n5;
            e3.asm = r5, a3 = e3.asm.memory, n5 = a3.buffer, e3.HEAP8 = A3 = new Int8Array(n5), e3.HEAP16 = new Int16Array(n5), e3.HEAP32 = new Int32Array(n5), e3.HEAPU8 = l3 = new Uint8Array(n5), e3.HEAPU16 = new Uint16Array(n5), e3.HEAPU32 = new Uint32Array(n5), e3.HEAPF32 = new Float32Array(n5), e3.HEAPF64 = new Float64Array(n5), p3 = e3.asm.__indirect_function_table, function(t6) {
              if (I3--, e3.monitorRunDependencies && e3.monitorRunDependencies(I3), 0 == I3 && _3) {
                const e4 = _3;
                _3 = null, e4();
              }
            }();
          }
          function r4(e4) {
            i4(e4.instance);
          }
          function n4(e4) {
            return new l_((e5, t5) => {
              e5(BJ().buffer);
            }).then(function(e5) {
              return WebAssembly.instantiate(e5, t4);
            }).then(e4, function(e5) {
              s3("failed to asynchronously prepare wasm: " + e5), C3(e5);
            });
          }
          if (I3++, e3.monitorRunDependencies && e3.monitorRunDependencies(I3), e3.instantiateWasm)
            try {
              return e3.instantiateWasm(t4, i4);
            } catch (e4) {
              return s3("Module.instantiateWasm callback failed with error: " + e4), false;
            }
          return await n4(r4), {};
        }();
        let y3 = e3.___wasm_call_ctors = function() {
          return (y3 = e3.___wasm_call_ctors = e3.asm.__wasm_call_ctors).apply(null, arguments);
        }, w3 = e3._malloc = function() {
          return (w3 = e3._malloc = e3.asm.malloc).apply(null, arguments);
        };
        e3._free = function() {
          return (e3._free = e3.asm.free).apply(null, arguments);
        }, e3.___errno_location = function() {
          return (e3.___errno_location = e3.asm.__errno_location).apply(null, arguments);
        }, e3._zlibCompress = function() {
          return (e3._zlibCompress = e3.asm.zlibCompress).apply(null, arguments);
        };
        let b3, N3 = e3.stackSave = function() {
          return (N3 = e3.stackSave = e3.asm.stackSave).apply(null, arguments);
        }, O3 = e3.stackRestore = function() {
          return (O3 = e3.stackRestore = e3.asm.stackRestore).apply(null, arguments);
        }, D3 = e3.stackAlloc = function() {
          return (D3 = e3.stackAlloc = e3.asm.stackAlloc).apply(null, arguments);
        };
        function P3(t4) {
          function i4() {
            b3 || (b3 = true, e3.calledRun = true, c3 || (T3(E3), T3(f3), e3.onRuntimeInitialized && e3.onRuntimeInitialized(), function() {
              if (e3.postRun)
                for ("function" == typeof e3.postRun && (e3.postRun = [e3.postRun]); e3.postRun.length; )
                  t5 = e3.postRun.shift(), m3.unshift(t5);
              var t5;
              T3(m3);
            }()));
          }
          I3 > 0 || (!function() {
            if (e3.preRun)
              for ("function" == typeof e3.preRun && (e3.preRun = [e3.preRun]); e3.preRun.length; )
                t5 = e3.preRun.shift(), g3.unshift(t5);
            var t5;
            T3(g3);
          }(), I3 > 0 || (e3.setStatus ? (e3.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              e3.setStatus("");
            }, 1), i4();
          }, 1)) : i4()));
        }
        if (e3.ccall = u3, e3.cwrap = function(e4, t4, i4, r4) {
          const n4 = (i4 = i4 || []).every(function(e5) {
            return "number" === e5;
          });
          return "string" !== t4 && n4 && !r4 ? d3(e4) : function() {
            return u3(e4, t4, i4, arguments);
          };
        }, e3.allocate = function(e4, t4) {
          let i4;
          return i4 = 1 == t4 ? D3(e4.length) : w3(e4.length), e4.subarray || e4.slice ? l3.set(e4, i4) : l3.set(new Uint8Array(e4), i4), i4;
        }, _3 = function e4() {
          b3 || P3(), b3 || (_3 = e4);
        }, e3.run = P3, e3.preInit)
          for ("function" == typeof e3.preInit && (e3.preInit = [e3.preInit]); e3.preInit.length > 0; )
            e3.preInit.pop()();
        return P3(), MJ = e3, e3;
      }
      const QJ = Uint8Array.BYTES_PER_ELEMENT;
      const FJ = { bytesReceived: "br", frameDropped: "fd", frameReceived: "fr", googJitterReceived: "jr", isAudioMute: "am", isFreeze: "fz", mediaType: "mt", packetsLost: "pl", packetsReceived: "pr", peerId: "pid", id: "id", ssrc: "ssrc", timestamp: "ts", type: "tp", frameRateInput: "fi", frameRateSent: "fs", googRtt: "rt", isVideoMute: "vm" }, VJ = { stats: "sts", state: "st", stream_id: "stid", session_id: "seid", stream_type: "stt", app_id: "aid", channel_key: "ck", channel_name: "cn", sdk_version: "sv", browser: "b", process_id: "pcid", mode: "m", codec: "c", role: "r", has_changed_gateway: "hcg", ap_response: "ar", extends: "es", details: "d", features: "ft", p2p_id: "ppid", sdp: "sdp", audio: "a", video: "v", attributes: "at", hq: "h", lq: "l", stereo: "str", speech: "spe", extend: "e", pingpongElapse: "ppe" }, jJ = { _message: "m", _type: "t", _id: "id" }, GJ = { join_v2: "j2", publish: "pub", publish_related_stats: "prs", ping: "pi", traffic_stats: "ts", ping_back: "pib", publish_stats: "pubs" };
      let KJ;
      class HJ {
        constructor() {
          MN(this, "zlibCompress", void 0);
        }
        async init() {
          if (!KJ) {
            const e3 = await (async () => (UJ || (UJ = await xJ()), { zlibCompress: (e4) => {
              const t3 = new Uint8Array(e4), i3 = QJ * t3.byteLength, r3 = UJ._malloc(i3), n3 = UJ._malloc(3 * i3);
              for (let e5 = 0; e5 < i3; e5++)
                UJ.HEAP8[r3 / QJ + e5] = t3[e5];
              const o3 = UJ._zlibCompress(r3, i3, n3), s3 = new Uint8Array(UJ.HEAP8.slice(n3, n3 + o3));
              return UJ._free(r3), UJ._free(n3), s3;
            } }))();
            KJ = e3.zlibCompress;
          }
          this.zlibCompress = KJ;
        }
        msgPackCompress(e3) {
          return kJ.exports.encode(e3);
        }
        compress(e3) {
          const t3 = Date.now(), i3 = this.compressKeyAndValue(JSON.parse(JSON.stringify(e3))), r3 = this.msgPackCompress(i3), n3 = this.zlibCompress(r3), o3 = new Uint8Array([49, 49, 49, 50, ...Array.from(n3)]);
          return { origin: Object.assign({}, e3), originLength: JSON.stringify(e3).length, shortKeyAndValue: i3, msgpackSer: r3, compressed: o3, compressedLength: o3.length, time: Date.now() - t3 };
        }
        compressKeyAndValue(e3) {
          return this._ObjectKeyCompress(this._typeCompress(e3));
        }
        _typeCompress(e3) {
          const t3 = e3._type;
          if (!t3)
            return e3;
          const i3 = GJ[t3];
          return e3._type = i3 || t3, e3;
        }
        _ObjectKeyCompress(e3) {
          const t3 = e3._message;
          if (t3) {
            const i3 = t3.stats;
            i3 && (t3.stats = this._statsCompress(i3)), e3._message = this._messageCompress(t3);
          }
          return this._reportCompress(e3);
        }
        _statsCompress(e3) {
          return this._keyCompress(e3, FJ);
        }
        _messageCompress(e3) {
          return this._keyCompress(e3, VJ);
        }
        _reportCompress(e3) {
          return this._keyCompress(e3, jJ);
        }
        _keyCompress(e3, t3) {
          const i3 = {}, r3 = Object.keys(e3);
          return cc(r3).call(r3, (r4, n3) => {
            const o3 = e3[n3];
            return t3[n3] ? i3[t3[n3]] = o3 : i3[n3] = o3, i3;
          }, i3), i3;
        }
      }
      class WJ extends MD {
        get queue() {
          return [...this.highPriorityQueue, ...this.lowPriorityQueue];
        }
        constructor(e3) {
          super(), MN(this, "lowPriorityQueue", []), MN(this, "highPriorityQueue", []), MN(this, "AgoraWebSocketManager", void 0), this.AgoraWebSocketManager = e3;
        }
        reset() {
          this.lowPriorityQueue = [], this.highPriorityQueue = [];
        }
        pushMessage(e3) {
          arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? this.highPriorityQueue.push(e3) : this.lowPriorityQueue.push(e3), this.sendMessage();
        }
        sendMessage() {
          const e3 = this.queue.length;
          let t3 = 0;
          t3 = e3 < 5 ? 15 * e3 : 60 + 3 * (e3 - 4), setTimeout(() => {
            this._sendMessage();
          }, t3);
        }
        _sendMessage() {
          if (!this.queue.length)
            return;
          const e3 = this.AgoraWebSocketManager.getConnection();
          if (!e3 || 1 !== e3.readyState)
            return;
          const t3 = this.queue.shift();
          return this.lowPriorityQueue.includes(t3) ? this.lowPriorityQueue.shift() : this.highPriorityQueue.shift(), e3.send(t3.compressed), t3;
        }
      }
      var YJ;
      function JJ(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      let qJ = mP("AgoraWebSocketManager", "connectionID")(YJ = class extends MD {
        get url() {
          return this.websocket ? this.websocket.url : null;
        }
        get reconnectMode() {
          return this._reconnectMode;
        }
        set reconnectMode(e3) {
          ["tryNext", "recover"].includes(e3) && this.resetReconnectCount(e3), this._reconnectMode = e3;
        }
        get state() {
          return this._state;
        }
        set state(e3) {
          e3 !== this._state && (this._state = e3, "reconnecting" === this._state ? this.emit(Lk.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(Lk.CONNECTED) : "closed" === this._state ? this.emit(Lk.CLOSED) : "failed" === this._state && this.emit(Lk.FAILED));
        }
        resetReconnectCount(e3) {
          JD.debug("websocket reset reconnect count, reason: " + e3), gP("debug", this, "resetReconnectCount", e3, "websocket reset reconnect count, reason: " + e3), this.reconnectCount = 0;
        }
        constructor(e3, t3) {
          let i3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], n3 = arguments.length > 4 ? arguments[4] : void 0;
          super(), MN(this, "connectionID", 0), MN(this, "currentURLIndex", 0), MN(this, "urls", void 0), MN(this, "_reconnectMode", "tryNext"), MN(this, "reconnectReason", void 0), MN(this, "_initMutex", new fj("websocket")), MN(this, "name", void 0), MN(this, "_state", "closed"), MN(this, "reconnectInterrupter", void 0), MN(this, "websocket", void 0), MN(this, "retryConfig", void 0), MN(this, "reconnectCount", 0), MN(this, "forceCloseTimeout", 5e3), MN(this, "onlineReconnectListener", void 0), MN(this, "compressor", new HJ()), MN(this, "compressorInitStatus", "initializing"), MN(this, "compress", void 0), MN(this, "messageSender", void 0), MN(this, "useCompress", void 0), MN(this, "tryDoubleDomain", false), MN(this, "wsInflateLength", 0), MN(this, "wsDeflateLength", 0), MN(this, "closeEstablishingWs", () => {
          }), MN(this, "store", void 0), MN(this, "joinChannelServiceRecordIndex", void 0), this.store = n3, this.name = e3, this.retryConfig = function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var i4 = null != arguments[t4] ? arguments[t4] : {};
              t4 % 2 ? JJ(Object(i4), true).forEach(function(t5) {
                MN(e4, t5, i4[t5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i4)) : JJ(Object(i4)).forEach(function(t5) {
                Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(i4, t5));
              });
            }
            return e4;
          }({}, t3), this.useCompress = i3, this.tryDoubleDomain = r3;
          const { timeout: o3, timeoutFactor: s3 } = t3, a3 = Math.max(300, Math.floor(3 * o3 / 5)), c3 = Math.max(1.2, Math.floor(8 * s3) / 10);
          EB.ONLINE && (this.retryConfig.timeout = a3, this.retryConfig.timeoutFactor = c3), ij.on(fB.NETWORK_STATE_CHANGE, (e4, t4) => {
            e4 !== t4 && (this.resetReconnectCount("network state change: ".concat(t4, " -> ").concat(e4)), e4 === EB.ONLINE ? (this.retryConfig.timeout = a3, this.retryConfig.timeoutFactor = c3) : (this.retryConfig.timeout = o3, this.retryConfig.timeoutFactor = s3));
          });
          const d3 = Date.now();
          this.compressor.init().then(() => {
            this.compressorInitStatus = "initialized";
            const e4 = Date.now() - d3;
            JD.debug("websocket compressor initialized successfully in ".concat(e4, "ms")), gP("debug", this.compressor, "init", void 0, "websocket compressor initialized successfully in ".concat(e4, "ms")), pj.wsCompressorInit({ status: true, ec: null, eventElapse: e4 }), this.compress = this.compressor.compress.bind(this.compressor);
          }).catch((e4) => {
            this.compressorInitStatus = "failed";
            const t4 = e4 ? e4.message || e4.toString() : "Empty Error";
            JD.debug("websocket compressor failed to initialize because of ".concat(t4)), gP("debug", this.compressor, "init", void 0, "websocket compressor failed to initialize because of ".concat(t4)), pj.wsCompressorInit({ status: false, ec: t4, eventElapse: 1 });
          });
        }
        getConnection() {
          return this.websocket || void 0;
        }
        init(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          this.forceCloseTimeout = t3;
          const i3 = (t4, i4) => {
            this.urls = e3;
            const r3 = this.urls[this.currentURLIndex];
            this.state = "connecting", this.messageSender = new WJ(this), this.createWebSocketConnection(r3).then(t4).catch(i4), this.once(Lk.CLOSED, () => i4(new QD(xD.WS_DISCONNECT))), this.once(Lk.CONNECTED, () => t4());
          };
          return this._initMutex.lock().then((e4) => new l_((e5, t4) => {
            i3(e5, t4);
          }).then(() => {
            e4();
          }).catch(() => {
            e4();
          }));
        }
        close(e3, t3) {
          if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {
            this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;
            const e4 = this.websocket;
            t3 ? setTimeout(() => e4.close(), 500) : e4.close(), this.websocket = void 0;
          }
          this.state = e3 ? "failed" : "closed", this.closeEstablishingWs && this.closeEstablishingWs();
        }
        reconnect(e3, t3) {
          if (!this.websocket)
            return JD.warning("[".concat(this.name, "] can not reconnect, no websocket")), void gP("warning", this, "reconnect", "can not reconnect, no websocket");
          var i3;
          (void 0 !== e3 && (this.reconnectMode = e3), JD.debug("[".concat(this.name, "] reconnect is triggered initiative")), gP("debug", this, "reconnect"), "number" == typeof this.joinChannelServiceRecordIndex) && (null === (i3 = this.store) || void 0 === i3 || i3.recordJoinChannelService({ status: "error", errors: [new Error(t3)] }, this.joinChannelServiceRecordIndex));
          const r3 = this.websocket.onclose;
          this.websocket.onclose = null, this.websocket.close(), r3 && r3.bind(this.websocket)({ code: 9999, reason: t3 });
        }
        sendMessageWithJSON(e3) {
          const t3 = JSON.stringify(e3);
          return { compressed: t3, compressedLength: t3.length, origin: e3 };
        }
        sendMessageWithUint8Array(e3) {
          return { compressed: e3, compressedLength: e3.byteLength, origin: e3 };
        }
        sendMessage(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN)
            throw new QD(xD.WS_ABORT, "websocket is not ready");
          try {
            let r3 = null;
            if (i3)
              r3 = this.sendMessageWithUint8Array(e3);
            else if ("initialized" === this.compressorInitStatus && this.useCompress && LP("WEBSOCKET_COMPRESS"))
              try {
                r3 = this.compress(e3), this.setWsInflateData(r3);
              } catch (t4) {
                r3 = this.sendMessageWithJSON(e3);
              }
            else
              r3 = this.sendMessageWithJSON(e3);
            t3 ? this.websocket.send(r3.compressed) : this.messageSender.pushMessage(r3);
          } catch (e4) {
            throw new QD(xD.WS_ERR, "send websocket message error" + e4.toString());
          }
        }
        setWsInflateData(e3) {
          this.wsDeflateLength = this.wsDeflateLength + e3.originLength, this.wsInflateLength = this.wsInflateLength + e3.compressedLength;
        }
        getWsInflateData() {
          const e3 = this.wsInflateLength, t3 = this.wsDeflateLength;
          return this.clearWsInflateData(), { wsInflateLength: e3, wsDeflateLength: t3 };
        }
        clearWsInflateData() {
          this.wsInflateLength = 0, this.wsDeflateLength = 0;
        }
        async createWebSocketConnection(e3, t3) {
          return this.connectionID += 1, this.connectionID, this.joinChannelServiceRecordIndex = void 0, new l_((i3, r3) => {
            var n3;
            const o3 = () => {
              var t4;
              null === (t4 = this.store) || void 0 === t4 || t4.signalChannelOpen(), JD.debug("[".concat(this.name, "] websocket opened:"), e3), pP("debug", ["WebSocket", this.connectionID], "open", e3), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), i3();
            }, s3 = async (e4) => {
              if (JD.debug("[".concat(this.name, "] websocket close ").concat(this.websocket && this.websocket.url, ", code: ").concat(e4.code, ", reason: ").concat(e4.reason, ", current mode: ").concat(this.reconnectMode)), pP("debug", ["WebSocket", this.connectionID], "close", { code: e4.code, reason: e4.reason, url: this.websocket && this.websocket.url, reconnectMode: this.reconnectMode }), this.reconnectCount < this.retryConfig.maxRetryCount) {
                "connected" === this.state && (this.reconnectReason = e4.reason, this.state = "reconnecting");
                const t4 = RK(this, Lk.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode, n4 = await this.reconnectWithAction(t4);
                if ("closed" === this.state)
                  return JD.debug("[".concat(this.connectionID, "] ws is closed, no need to reconnect")), void hP("debug", this, "ws is closed, no need to reconnect");
                if (!n4)
                  return r3(new QD(xD.WS_DISCONNECT, "websocket reconnect failed: ".concat(e4.code))), void this.close(true);
                i3();
              } else
                r3(new QD(xD.WS_DISCONNECT, "websocket close: ".concat(e4.code))), this.close();
            }, a3 = (e4) => {
              this.emit(Lk.ON_MESSAGE, e4);
            };
            this.websocket && (this.websocket.onclose = null, this.websocket.close()), LP("GATEWAY_WSS_ADDRESS") && this.name.startsWith("gateway") && (e3 = LP("GATEWAY_WSS_ADDRESS")), JD.debug("[".concat(this.name, "] start connect, url: ").concat(e3)), hP("debug", this, "start connect, url: ".concat(e3));
            const c3 = null === (n3 = this.store) || void 0 === n3 ? void 0 : n3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" });
            this.chooseBestWebsocketConnection(e3, !!t3, c3).then((e4) => {
              var t4;
              this.websocket = e4, o3 && o3(), e4.onclose = s3, e4.onmessage = a3, null === (t4 = this.store) || void 0 === t4 || t4.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c3), this.joinChannelServiceRecordIndex = c3;
            }).catch((e4) => {
              var t4;
              if (null === (t4 = this.store) || void 0 === t4 || t4.recordJoinChannelService({ endTs: Date.now(), status: e4 instanceof QD && e4.code === xD.WS_ABORT ? "aborted" : "error", errors: [e4] }, c3), "closed" !== this.state) {
                if (e4 instanceof QD && e4.code === xD.WS_ERR) {
                  const t5 = new QD(xD.WS_ERR, "init websocket failed! Error: ".concat(e4.toString()));
                  return JD.error("[".concat(this.name, "]").concat(t5)), gP("error", this, "chooseBestWebsocketConnection", void 0, e4.toString()), void r3(t5);
                }
                s3 && s3(e4);
              } else
                r3(new QD(xD.WS_DISCONNECT, "websocket is closed: ".concat(e4.toString())));
            });
          });
        }
        async reconnectWithAction(e3) {
          let t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this.reconnectCount >= this.retryConfig.maxRetryCount)
            return false;
          if (!this.urls)
            return false;
          if ("closed" === this.state)
            return false;
          this.onlineReconnectListener || ij.networkState !== EB.OFFLINE || (this.onlineReconnectListener = ij.onlineWaiter && ij.onlineWaiter.then(() => {
            this.onlineReconnectListener = void 0;
          }));
          let i3 = true;
          if (this.reconnectInterrupter = () => {
            i3 = false;
          }, t3) {
            const t4 = VD(this.reconnectCount, this.retryConfig);
            JD.debug("[".concat(this.name, "] wait ").concat(t4, "ms to reconnect websocket, mode: ").concat(e3)), gP("debug", this, "reconnectWithAction", { timeout: t4, action: e3 }), await l_.race([EK(t4), this.onlineReconnectListener || new l_(() => {
            })]);
          }
          if ("closed" === this.state || !i3)
            return false;
          this.reconnectCount += 1;
          const r3 = async (e4, t4) => {
            this.emit(Lk.RECONNECT_CREATE_CONNECTION, t4), await this.createWebSocketConnection(e4);
          };
          try {
            if ("retry" === e3) {
              const t4 = this.urls[this.currentURLIndex];
              this.emit(Lk.RECONNECT_WAITTING_FINISH, e3), await r3(t4, e3);
            } else if ("tryNext" === e3) {
              if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length)
                return await this.reconnectWithAction("recover", false);
              JD.debug("[".concat(this.name, "] websocket url length: ").concat(this.urls.length, " current index: ").concat(this.currentURLIndex)), hP("debug", this, "websocket url length: ".concat(this.urls.length, " current index: ").concat(this.currentURLIndex));
              const t4 = this.urls[this.currentURLIndex];
              this.emit(Lk.RECONNECT_WAITTING_FINISH, e3), await r3(t4, e3);
            } else if ("recover" === e3) {
              JD.debug("[".concat(this.name, "] request new urls")), hP("debug", this, "request new urls"), this.resetReconnectCount("recover mode"), this.emit(Lk.RECONNECT_WAITTING_FINISH, e3), this.urls = await vK(this, Lk.REQUEST_NEW_URLS), this.currentURLIndex = 0;
              const t4 = this.urls[this.currentURLIndex];
              await r3(t4, e3);
            }
            return true;
          } catch (i4) {
            var n3;
            return JD.error("[".concat(this.name, "] reconnect failed"), i4.toString()), gP("error", this, "reconnectWithAction", void 0, i4.toString()), null != i4 && null !== (n3 = i4.data) && void 0 !== n3 && n3.desc && Array.isArray(i4.data.desc) && i4.data.desc.length && i4.data.desc.includes("dynamic key expired") ? (this.emit(Lk.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : await this.reconnectWithAction(e3, t3);
          }
        }
        async chooseBestWebsocketConnection(e3, t3, i3) {
          return new l_((r3, n3) => {
            let o3 = false;
            const s3 = [];
            this.closeEstablishingWs = () => {
              JD.debug("[choose-best-ws] close establishing websockets"), s3.forEach((e4) => {
                e4.onclose = null, e4.onopen = null, e4.onmessage = null, e4.close();
              }), n3(new QD(xD.WS_ABORT, "choose best websocket aborted"));
            };
            const a3 = LP("GATEWAY_DOMAINS");
            let c3;
            const d3 = e3.indexOf("?h="), u3 = a3.find((t4) => -1 !== d3 ? e3.includes(t4, d3) : e3.includes(t4));
            JD.debug("[choose-best-ws] currentDomain: ", u3, ", domains: ", a3), gP("debug", this, "chooseBestWebsocketConnection", { currentDomain: u3, domains: a3 });
            let h3 = !this.tryDoubleDomain || t3 || !u3;
            if (!h3 && u3) {
              var A3;
              const t4 = Date.now();
              try {
                a3.forEach((t5) => {
                  const i4 = -1 === d3 ? e3.replace(u3, t5) : e3.substr(0, d3) + e3.substr(d3).replace(u3, t5), r4 = new WebSocket(i4);
                  r4.binaryType = "arraybuffer", s3.push(r4), JD.debug("[choose-best-ws] ws is connecting:", r4.url), hP("debug", this, "ws is connecting: ".concat(r4.url));
                });
              } catch (e4) {
                for (JD.debug("[choose-best-ws] ws create failed, fallback to single url"), hP("debug", this, "ws create failed, fallback to single url"), s3.forEach((e5) => e5.close()); s3.length; )
                  s3.pop();
                h3 = true;
              }
              null === (A3 = this.store) || void 0 === A3 || A3.recordJoinChannelService({ urls: s3.map((e4) => e4.url), service: "gateway" }, i3), s3.forEach((e4) => {
                e4.onopen = () => {
                  if (o3)
                    return;
                  const i4 = Date.now() - t4;
                  JD.debug("[choose-best-ws] ws open cost ".concat(i4, "ms")), s3.filter((t5) => t5 !== e4).forEach((e5) => {
                    JD.debug("[choose-best-ws]close backup websocket: ".concat(e5.url)), hP("debug", this, "close backup websocket: ".concat(e5.url)), e5.close();
                  }), o3 = true, r3(e4);
                }, e4.onclose = (e5) => {
                  if (c3 = e5, o3)
                    return;
                  s3.find((e6) => !(e6.readyState === WebSocket.CLOSED || e6.readyState === WebSocket.CLOSING)) || (JD.debug("[choose-best-ws] all websocket is closed"), hP("debug", this, "all websocket is closed"), o3 = true, n3(c3));
                }, e4.onmessage = (t5) => {
                  JD.debug("[choose-best-ws]".concat(e4.url, " onmessage: ").concat(t5.data)), hP("debug", this, "".concat(e4.url, " onmessage: ").concat(t5.data));
                };
              }), EK(this.forceCloseTimeout).then(() => {
                s3.forEach((e4) => {
                  e4.readyState !== WebSocket.OPEN && e4.close();
                });
              });
            }
            if (h3) {
              var l3;
              let t4;
              JD.debug("[choose-best-ws] use single url: ", e3), hP("debug", this, "use single url: ".concat(e3)), null === (l3 = this.store) || void 0 === l3 || l3.recordJoinChannelService({ urls: [e3], service: "gateway" }, i3);
              try {
                t4 = new WebSocket(e3), s3.push(t4), t4.binaryType = "arraybuffer";
              } catch (e4) {
                const t5 = new QD(xD.WS_ERR, "init websocket failed! Error: ".concat(e4.toString()));
                return JD.error("[".concat(this.name, "]").concat(t5)), gP("error", this, "chooseBestWebsocketConnection", void 0, e4.toString()), void n3(t5);
              }
              t4.onopen = () => {
                r3(t4);
              }, t4.onclose = (e4) => {
                n3(e4);
              }, t4.onmessage = (e4) => {
                JD.debug("[choose-best-ws]".concat(t4.url, " onmessage: ").concat(e4.data)), hP("debug", this, "".concat(t4.url, " onmessage: ").concat(e4.data));
              }, EK(this.forceCloseTimeout).then(() => {
                t4 && t4.readyState !== WebSocket.OPEN && t4.close();
              });
            }
          }).then((e4) => (this.closeEstablishingWs = void 0, e4)).catch((e4) => {
            throw this.closeEstablishingWs = void 0, e4;
          });
        }
      }) || YJ;
      class XJ {
        constructor(e3) {
          MN(this, "input", []), MN(this, "size", void 0), this.size = e3;
        }
        add(e3) {
          this.input.push(e3), this.input.length > this.size && this.input.splice(0, 1);
        }
        mean() {
          var e3;
          return 0 === this.input.length ? 0 : cc(e3 = this.input).call(e3, (e4, t3) => e4 + t3) / this.input.length;
        }
      }
      var zJ;
      let ZJ, $J = mP("AgoraRTCSignal", "websocket.connectionID")(zJ = class extends MD {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e3) {
          e3 !== this._connectionState && (this._connectionState = e3, e3 === Ek.CONNECTED ? this.emit(fk.WS_CONNECTED) : e3 === Ek.RECONNECTING ? this.emit(fk.WS_RECONNECTING, this._websocketReconnectReason) : e3 === Ek.CLOSED && this.emit(fk.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket ? this.websocket.url : null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e3, t3) {
          super(), MN(this, "_disconnectedReason", void 0), MN(this, "_websocketReconnectReason", void 0), MN(this, "_connectionState", Ek.CLOSED), MN(this, "reconnectToken", void 0), MN(this, "websocket", void 0), MN(this, "openConnectionTime", void 0), MN(this, "clientId", void 0), MN(this, "lastMsgTime", Date.now()), MN(this, "uploadCache", []), MN(this, "uploadCacheInterval", void 0), MN(this, "rttRolling", new XJ(5)), MN(this, "pingpongTimer", void 0), MN(this, "wsInflateDataTimer", void 0), MN(this, "pingpongTimeoutCount", 0), MN(this, "joinResponse", void 0), MN(this, "multiIpOption", void 0), MN(this, "initError", void 0), MN(this, "spec", void 0), MN(this, "store", void 0), MN(this, "onWebsocketMessage", (e4) => {
            if (e4.data instanceof ArrayBuffer)
              return void this.emit(fk.ON_BINARY_DATA, e4.data);
            const t4 = JSON.parse(e4.data);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t4, "_id")) {
              const e5 = "res-@".concat(t4._id);
              this.emit(e5, t4._result, t4._message);
            } else if (Object.prototype.hasOwnProperty.call(t4, "_type")) {
              if (this.emit(t4._type, t4._message), t4._type === _k.ON_NOTIFICATION && this.handleNotification(t4._message), t4._type === _k.ON_USER_BANNED)
                switch (t4._message.error_code) {
                  case 14:
                    this.close(lk.UID_BANNED);
                    break;
                  case 15:
                    this.close(lk.IP_BANNED);
                    break;
                  case 16:
                    this.close(lk.CHANNEL_BANNED);
                }
              if (t4._type === _k.ON_USER_LICENSE_BANNED)
                switch (t4._message.error_code) {
                  case hk.ERR_LICENSE_MISSING:
                    this.close(lk.LICENSE_MISSING);
                    break;
                  case hk.ERR_LICENSE_EXPIRED:
                    this.close(lk.LICENSE_EXPIRED);
                    break;
                  case hk.ERR_LICENSE_MINUTES_EXCEEDED:
                    this.close(lk.LICENSE_MINUTES_EXCEEDED);
                    break;
                  case hk.ERR_LICENSE_PERIOD_INVALID:
                    this.close(lk.LICENSE_PERIOD_INVALID);
                    break;
                  case hk.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                    this.close(lk.LICENSE_MULTIPLE_SDK_SERVICE);
                    break;
                  case hk.ERR_LICENSE_ILLEGAL:
                    this.close(lk.LICENSE_ILLEGAL);
                    break;
                  default:
                    this.close();
                }
            }
          }), this.clientId = e3.clientId, this.spec = e3, this.store = t3, this.websocket = new qJ("gateway-".concat(this.clientId), this.spec.retryConfig, true, true, t3), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
            this.connectionState === Ek.CONNECTED && this.reconnect("retry", gk.OFFLINE);
          });
        }
        async request(e3, t3, i3, r3) {
          const n3 = mK(6, ""), o3 = { _id: n3, _type: e3, _message: t3 }, s3 = this.websocket.connectionID, a3 = () => new l_((t4, i4) => {
            if (this.connectionState === Ek.CONNECTED)
              return t4();
            const r4 = () => {
              this.off(fk.WS_CLOSED, n4), t4();
            }, n4 = () => {
              this.off(fk.WS_CONNECTED, r4), i4(new QD(xD.WS_ABORT));
            };
            this.once(fk.WS_CONNECTED, r4), this.once(fk.WS_CLOSED, n4), e3 !== mk.PUBLISH && e3 !== mk.SUBSCRIBE && e3 !== mk.UNSUBSCRIBE && e3 !== mk.UNPUBLISH && e3 !== mk.CONTROL && e3 !== mk.RESTART_ICE || this.once(fk.DISCONNECT_P2P, () => {
              i4(new QD(xD.DISCONNECT_P2P));
            }), e3 !== mk.PUBLISH && e3 !== mk.RESTART_ICE || this.once(fk.ABORT_P2P_EXECUTION, () => {
              i4(new QD(xD.DISCONNECT_P2P));
            });
          });
          if (this.connectionState !== Ek.CONNECTING && this.connectionState !== Ek.RECONNECTING || e3 === mk.JOIN || e3 === mk.REJOIN || await a3(), this.websocket.sendMessage(o3, true), r3)
            return;
          const c3 = new l_((i4, r4) => {
            let o4 = false;
            const a4 = (r5, n4) => {
              o4 = true, i4({ isSuccess: "success" === r5, message: n4 || {} }), this.off(fk.WS_CLOSED, c4), this.off(fk.WS_RECONNECTING, c4), this.emit(fk.REQUEST_SUCCESS, e3, t3);
            };
            this.once("res-@".concat(n3), a4);
            const c4 = () => {
              r4(new QD(xD.WS_ABORT, "type: ".concat(e3))), this.off(fk.WS_CLOSED, c4), this.off(fk.WS_RECONNECTING, c4), this.off("res-@".concat(n3), a4);
            };
            this.once(fk.WS_CLOSED, c4), this.once(fk.WS_RECONNECTING, c4), EK(LP("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              this.websocket.connectionID !== s3 || o4 || (JD.warning("ws request timeout, type: ".concat(e3)), hP("warning", this, "ws request timeout, type: ".concat(e3)), this.emit(fk.REQUEST_TIMEOUT, e3, t3));
            });
          });
          let d3 = null;
          try {
            d3 = await c3;
          } catch (r4) {
            if (this.connectionState === Ek.CLOSED || e3 === mk.LEAVE)
              throw new QD(xD.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i3 ? r4.throw() : e3 === mk.JOIN || e3 === mk.REJOIN ? null : (await a3(), await this.request(e3, t3));
          }
          if (d3.isSuccess)
            return d3.message;
          const u3 = Number(d3.message.error_code || d3.message.code), h3 = LJ(u3), A3 = new QD(xD.UNEXPECTED_RESPONSE, "".concat(h3.desc, ": ").concat(d3.message.error_str), { code: u3, data: d3.message });
          return "success" === h3.action ? d3.message : (JD.warning("[".concat(this.websocket.connectionID, "] unexpected response from type ").concat(e3, ", error_code: ").concat(u3, ", message: ").concat(h3.desc, ", action: ").concat(h3.action)), hP("warning", this, "unexpected response from type ".concat(e3, ", error_code: ").concat(u3, ", message: ").concat(h3.desc, ", action: ").concat(h3.action)), u3 === hk.ERR_TOO_MANY_BROADCASTERS ? e3 === mk.JOIN || e3 === mk.REJOIN ? (this.initError = A3, this.close(), A3.throw()) : A3.throw() : "failed" === h3.action ? A3.throw() : "quit" === h3.action ? (this.initError = A3, this.close(), A3.throw()) : (u3 === hk.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d3.message.option, JD.warning("[".concat(this.clientId, "] detect multi ip, recover")), hP("warning", this, "detect multi ip, recover"), this.reconnect("recover", gk.MULTI_IP)) : this.reconnect(h3.action, gk.SERVER_ERROR), e3 === mk.JOIN || e3 === mk.REJOIN ? null : await this.request(e3, t3)));
        }
        waitMessage(e3, t3) {
          return new l_((i3) => {
            const r3 = (n3) => {
              (!t3 || t3(n3)) && (this.off(e3, r3), i3(n3));
            };
            this.on(e3, r3);
          });
        }
        upload(e3, t3) {
          const i3 = { _type: e3, _message: t3 };
          try {
            this.websocket.sendMessage(i3);
          } catch (e4) {
            const t4 = LP("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i3), this.uploadCache.length > t4 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
              if (this.connectionState !== Ek.CONNECTED)
                return;
              const e5 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e5._type, e5._message);
            }, LP("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e3, t3) {
          const i3 = { _type: e3, _message: t3 };
          this.websocket.sendMessage(i3);
        }
        init(e3, t3) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new l_((i3, r3) => {
            this.once(fk.WS_CONNECTED, () => i3(this.joinResponse)), this.once(fk.WS_CLOSED, () => r3(this.initError || new QD(xD.WS_ABORT))), this.connectionState = Ek.CONNECTING, this.websocket.init(e3).catch(r3), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {
              this.handleWsInflateData();
            }, 2e4), setTimeout(() => {
              t3 && void 0 === this.openConnectionTime && (JD.debug("[".concat(this.clientId, "] init websocket timeout while join with fallback to proxy")), r3(new QD(xD.INIT_WEBSOCKET_TIMEOUT)));
            }, LP("JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION"));
          });
        }
        close(e3) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e3 || lk.LEAVE, this.connectionState = Ek.CLOSED, JD.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), e3 === lk.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new qJ("gateway-".concat(this.clientId), this.spec.retryConfig, true, true, this.store), this.handleWebsocketEvents());
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(fk.ABORT_P2P_EXECUTION);
            const e3 = await vK(this, fk.REQUEST_JOIN_INFO), t3 = await this.request(mk.JOIN, e3);
            if (!t3)
              return this.emit(fk.REPORT_JOIN_GATEWAY, xD.TIMEOUT, this.url || ""), false;
            this.joinResponse = t3, this.emit(fk.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = Ek.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        async rejoin() {
          if (!this.reconnectToken)
            throw new QD(xD.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
          const e3 = yK(this, fk.REQUEST_REJOIN_INFO);
          e3.token = this.reconnectToken;
          const t3 = await this.request(mk.REJOIN, e3);
          return !!t3 && (this.connectionState = Ek.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t3.peers && t3.peers.forEach((e4) => {
            this.emit(_k.ON_USER_ONLINE, { uid: e4.uid }), e4.audio && this.emit(_k.ON_ADD_AUDIO_STREAM, { uid: e4.uid, uint_id: e4.uint_id, audio: true, ssrcId: e4.audio_ssrc }), e4.video && this.emit(_k.ON_ADD_VIDEO_STREAM, { uid: e4.uid, uint_id: e4.uint_id, video: true, ssrcId: e4.video_ssrc }), e4.audio_mute ? this.emit(_k.MUTE_AUDIO, { uid: e4.uid }) : this.emit(_k.UNMUTE_AUDIO, { uid: e4.uid }), e4.video_mute ? this.emit(_k.MUTE_VIDEO, { uid: e4.uid }) : this.emit(_k.UNMUTE_VIDEO, { uid: e4.uid }), e4.audio_enable_local ? this.emit(_k.ENABLE_LOCAL_AUDIO, { uid: e4.uid }) : this.emit(_k.DISABLE_LOCAL_AUDIO, { uid: e4.uid }), e4.video_enable_local ? this.emit(_k.ENABLE_LOCAL_VIDEO, { uid: e4.uid }) : this.emit(_k.DISABLE_LOCAL_VIDEO, { uid: e4.uid }), e4.audio || e4.video || this.emit(_k.ON_REMOVE_STREAM, { uid: e4.uid, uint_id: e4.uint_id });
          }), true);
        }
        reconnect(e3, t3) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e3, t3);
        }
        handleNotification(e3) {
          JD.debug("[".concat(this.clientId, "] receive notification: "), e3), gP("debug", this, "handleNotification", e3);
          const t3 = LJ(e3.code);
          if ("success" !== t3.action)
            return "failed" === t3.action ? (JD.error("[".concat(this.clientId, "] ignore error: "), t3.desc), void hP("error", this, "ignore error: ".concat(t3.desc))) : "quit" === t3.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t3.desc && this.close(lk.UID_BANNED), void this.close()) : void this.reconnect(t3.action, gk.SERVER_ERROR);
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state)
            return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e3 = LP("PING_PONG_TIME_OUT"), t3 = Date.now();
          this.pingpongTimeoutCount >= e3 && (JD.warning("PINGPONG Timeout. Last Socket Message: ".concat(t3 - this.lastMsgTime, "ms")), hP("warning", this, "PINGPONG Timeout. Last Socket Message: ".concat(t3 - this.lastMsgTime, "ms")), t3 - this.lastMsgTime > LP("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", gk.TIMEOUT) : this.request(mk.PING, void 0, true).then(() => {
            this.pingpongTimeoutCount = 0;
            const e4 = Date.now() - t3;
            this.rttRolling.add(e4), LP("REPORT_STATS") && this.send(mk.PING_BACK, { pingpongElapse: e4 });
          }).catch((e4) => {
          });
        }
        handleWsInflateData() {
          const { wsInflateLength: e3, wsDeflateLength: t3 } = this.websocket.getWsInflateData();
          0 !== e3 && 0 !== t3 && this.upload(Ik.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t3, ws_inflate_length: e3 });
        }
        handleWebsocketEvents() {
          this.websocket.on(Lk.RECONNECT_WAITTING_FINISH, (e3) => {
            this.emit(fk.WS_RECONNECT_WAITTING_FINISH, e3);
          }), this.websocket.on(Lk.RECONNECT_CREATE_CONNECTION, (e3) => {
            this.emit(fk.WS_RECONNECT_CREATE_CONNECTION, e3);
          }), this.websocket.on(Lk.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(Lk.CLOSED, () => {
            this.connectionState = Ek.CLOSED;
          }), this.websocket.on(Lk.FAILED, () => {
            this._disconnectedReason = lk.NETWORK_ERROR, this.connectionState = Ek.CLOSED;
          }), this.websocket.on(Lk.RECONNECTING, (e3) => {
            this._websocketReconnectReason = e3, this.joinResponse = void 0, this.connectionState === Ek.CONNECTED ? this.connectionState = Ek.RECONNECTING : this.connectionState = Ek.CONNECTING;
          }), this.websocket.on(Lk.WILL_RECONNECT, (e3, t3) => {
            if (yK(this, fk.IS_P2P_DISCONNECTED) && "retry" === e3)
              return JD.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), hP("debug", this, "".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(fk.NEED_RENEW_SESSION), this.emit(fk.DISCONNECT_P2P), t3("tryNext");
            "retry" !== e3 && (JD.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e3)), hP("debug", this, "".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e3)), this.reconnectToken = void 0, this.emit(fk.NEED_RENEW_SESSION), this.emit(fk.DISCONNECT_P2P)), t3(e3);
          }), this.websocket.on(Lk.CONNECTED, () => {
            this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e3) => {
              JD.warning("[".concat(this.clientId, "] rejoin failed ").concat(e3)), gP("warning", this, "rejoin", void 0, e3.toString()), this.reconnect("tryNext", gk.SERVER_ERROR);
            }) : this.join().catch((e3) => {
              if (this.emit(fk.REPORT_JOIN_GATEWAY, e3.message || e3.code, this.url || ""), e3 instanceof QD && e3.code === xD.UNEXPECTED_RESPONSE && e3.data.code === hk.ERR_NO_AUTHORIZED)
                return JD.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), hP("warning", this, "reconnect no authorized, recover"), void this.reconnect("recover", gk.SERVER_ERROR);
              JD.error("[".concat(this.clientId, "] join gateway request failed"), e3.toString()), gP("error", this, "join", void 0, e3.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", gk.SERVER_ERROR) : (this.initError = e3, this.close());
            });
          }), this.websocket.on(Lk.REQUEST_NEW_URLS, (e3, t3) => {
            vK(this, fk.REQUEST_RECOVER, this.multiIpOption).then(e3).catch(t3);
          }), this.websocket.on(Lk.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            this.emit(_k.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          });
        }
      }) || zJ;
      function eq(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      class tq extends MD {
        get url() {
          return this._url ? this._url : null;
        }
        get reconnectMode() {
          return this._reconnectMode;
        }
        set reconnectMode(e3) {
          ["tryNext", "recover"].includes(e3) && this.resetReconnectCount(e3), this._reconnectMode = e3;
        }
        get state() {
          return this._state;
        }
        set state(e3) {
          e3 !== this._state && (this._state = e3, "reconnecting" === this._state ? this.emit(TB.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(TB.CONNECTED) : "closed" === this._state ? this.emit(TB.CLOSED) : "failed" === this._state && this.emit(TB.FAILED));
        }
        constructor(e3, t3, i3, r3) {
          super(), MN(this, "connectionID", 0), MN(this, "currentURLIndex", 0), MN(this, "reconnectReason", void 0), MN(this, "_reconnectMode", "tryNext"), MN(this, "_initMutex", void 0), MN(this, "_name", void 0), MN(this, "_state", "closed"), MN(this, "_reconnectInterrupter", void 0), MN(this, "_url", void 0), MN(this, "_retryConfig", void 0), MN(this, "_reconnectCount", 0), MN(this, "_forceCloseTimeout", 5e3), MN(this, "_onlineReconnectListener", void 0), MN(this, "_messageSender", void 0), MN(this, "_closeEstablishingTransmitter", () => {
          }), MN(this, "_store", void 0), MN(this, "_joinChannelServiceRecordIndex", void 0), MN(this, "_transmitter", void 0), MN(this, "_compressor", new HJ()), MN(this, "_compressorInitStatus", "initializing"), MN(this, "_compress", void 0), MN(this, "_useCompress", void 0), MN(this, "_inflateLength", 0), MN(this, "_deflateLength", 0), this._store = r3, this._name = e3, this._retryConfig = function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var i4 = null != arguments[t4] ? arguments[t4] : {};
              t4 % 2 ? eq(Object(i4), true).forEach(function(t5) {
                MN(e4, t5, i4[t5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i4)) : eq(Object(i4)).forEach(function(t5) {
                Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(i4, t5));
              });
            }
            return e4;
          }({}, t3), this._useCompress = i3;
        }
        resetReconnectCount(e3) {
          JD.debug("".concat(this._name, " reset reconnect count, reason: ").concat(e3)), gP("debug", this, "resetReconnectCount", e3, "".concat(this._name, " reset reconnect count, reason: ").concat(e3)), this._reconnectCount = 0;
        }
        close(e3, t3) {
          var i3;
          if (this.currentURLIndex = 0, this.resetReconnectCount("close"), null === (i3 = this._messageSender) || void 0 === i3 || i3.reset(), this._reconnectInterrupter && this._reconnectInterrupter(), this._transmitter) {
            this._transmitter.onclose = null, this._transmitter.onopen = null, this._transmitter.onmessage = null;
            const e4 = this._transmitter;
            t3 ? setTimeout(() => e4.close(), 500) : e4.close(), this._transmitter = void 0;
          }
          this.state = e3 ? "failed" : "closed", this._closeEstablishingTransmitter && this._closeEstablishingTransmitter();
        }
        reconnect(e3, t3) {
          if (!this._transmitter)
            return JD.warning("[".concat(this._name, "] can not reconnect, no websocket")), void gP("warning", this, "reconnect", "can not reconnect, no websocket");
          var i3;
          (void 0 !== e3 && (this.reconnectMode = e3), JD.debug("[".concat(this._name, "] reconnect is triggered initiative")), gP("debug", this, "reconnect"), "number" == typeof this._joinChannelServiceRecordIndex) && (null === (i3 = this._store) || void 0 === i3 || i3.recordJoinChannelService({ status: "error", errors: [new Error(t3)] }, this._joinChannelServiceRecordIndex));
          const r3 = this._transmitter.onclose;
          this._transmitter.onclose = null, this._transmitter.close(), r3 && r3.bind(this._transmitter)({ code: 9999, reason: t3 });
        }
        getInflateData() {
          const e3 = this._inflateLength, t3 = this._deflateLength;
          return this.clearInflateData(), { inflateLength: e3, deflateLength: t3 };
        }
        setInflateData(e3) {
          this._deflateLength = this._deflateLength + e3.originLength, this._inflateLength = this._inflateLength + e3.compressedLength;
        }
        clearInflateData() {
          this._inflateLength = 0, this._deflateLength = 0;
        }
      }
      function iq(e3, t3, i3) {
        if ("getBigUint64" in DataView.prototype)
          return e3.getBigUint64(t3, i3);
        const r3 = e3.getUint32(t3, i3), n3 = e3.getUint32(t3 + 4, i3), o3 = Number(!!i3), s3 = Number(!i3);
        return BigInt(r3 * s3 + n3 * o3) << BigInt(32) | BigInt(r3 * o3 + n3 * s3);
      }
      function rq(e3, t3, i3, r3) {
        if ("setBigUint64" in DataView.prototype)
          return e3.setBigUint64(t3, i3, r3);
        const n3 = Number(i3 >> BigInt(32)), o3 = Number(i3 & BigInt(4294967295));
        r3 ? (e3.setUint32(t3 + 4, n3, r3), e3.setUint32(t3, o3, r3)) : (e3.setUint32(t3, n3, r3), e3.setUint32(t3 + 4, o3, r3));
      }
      !function(e3) {
        e3[e3.Default = 0] = "Default", e3[e3.Ack = 1] = "Ack";
      }(ZJ || (ZJ = {}));
      class nq {
        constructor(e3, t3, i3) {
          MN(this, "version", 1), MN(this, "initialRTO", void 0), MN(this, "maxBatchAckCount", void 0), MN(this, "maxRTO", void 0), MN(this, "initialRTT", void 0), MN(this, "ID", void 0), MN(this, "rtt", void 0), MN(this, "packetNumber", 1), MN(this, "rtoRatioMap", /* @__PURE__ */ new Map()), MN(this, "timeoutMap", /* @__PURE__ */ new Map()), MN(this, "unorderedPacketQueue", []), MN(this, "batchAckPacketQueue", []), MN(this, "lastOrderedPacketNumber", 0), MN(this, "batchAckTimer", void 0), MN(this, "sendImpl", void 0), MN(this, "receiveImpl", void 0), this.sendImpl = e3, this.receiveImpl = t3, this.ID = mK(7, "transmitter-"), this.initialRTO = void 0 !== (null == i3 ? void 0 : i3.initialRTO) ? i3.initialRTO : LP("TRANSMITTER_INITIAL_RTO"), this.initialRTT = void 0 !== (null == i3 ? void 0 : i3.initialRTT) ? i3.initialRTT : LP("TRANSMITTER_INITIAL_RTT"), this.rtt = void 0 !== (null == i3 ? void 0 : i3.initialRTT) ? i3.initialRTT : LP("TRANSMITTER_INITIAL_RTT"), this.maxBatchAckCount = void 0 !== (null == i3 ? void 0 : i3.maxBatchAckCount) ? i3.maxBatchAckCount : LP("TRANSMITTER_MAX_BATCH_ACK_COUNT"), this.maxRTO = void 0 !== (null == i3 ? void 0 : i3.maxRTO) ? i3.maxRTO : LP("TRANSMITTER_MAX_RTO");
        }
        packetize(e3, t3) {
          return { type: ZJ.Default, version: this.version, packetNumber: t3, payload: e3 };
        }
        serialize(e3) {
          switch (e3.type) {
            case ZJ.Default: {
              let t3;
              if ("string" == typeof e3.payload) {
                t3 = new TextEncoder().encode(e3.payload);
              } else
                t3 = e3.payload;
              const i3 = new ArrayBuffer(t3.length + 15), r3 = new DataView(i3);
              r3.setUint16(0, e3.version), r3.setUint8(2, e3.type), r3.setUint32(3, e3.packetNumber), rq(r3, 7, BigInt(e3.sendTs));
              return new Uint8Array(r3.buffer).set(t3, 15), i3;
            }
            case ZJ.Ack: {
              const t3 = new ArrayBuffer(16), i3 = new DataView(t3);
              return i3.setUint16(0, e3.version), i3.setUint8(2, e3.type), i3.setUint32(3, e3.maxAckPacketNumber), i3.setUint8(7, e3.shift), rq(i3, 8, BigInt(e3.ackSendTs)), t3;
            }
          }
        }
        deserialize(e3) {
          const t3 = new DataView(e3), i3 = t3.getUint16(0), r3 = t3.getUint8(2);
          switch (r3) {
            case ZJ.Default: {
              const n3 = t3.getUint32(3), o3 = iq(t3, 7), s3 = e3.slice(15), a3 = new TextDecoder().decode(s3);
              return { version: i3, type: r3, packetNumber: n3, sendTs: Number(o3), payload: a3 };
            }
            case ZJ.Ack: {
              const e4 = t3.getUint32(3), n3 = t3.getUint8(7), o3 = iq(t3, 8);
              return { version: i3, type: r3, maxAckPacketNumber: e4, shift: n3, ackSendTs: Number(o3) };
            }
            default:
              throw JD.error("[".concat(this.ID, "] Unrecognized packet type ").concat(r3)), new Error("Unrecognized packet type ".concat(r3));
          }
        }
        sendMessage(e3) {
          const t3 = this.packetize(e3, this.packetNumber);
          this.packetNumber = 4294967295 === this.packetNumber ? 1 : this.packetNumber + 1;
          const i3 = this.calculateRTO(t3), r3 = window.setTimeout(() => {
            this.resendMessage(t3);
          }, i3);
          this.timeoutMap.set(t3.packetNumber, r3), this.sendPacket(t3);
        }
        onData(e3) {
          const t3 = this.deserialize(e3);
          t3.type === ZJ.Default ? this.ack(t3) : t3.type === ZJ.Ack && (this.updateRTT(t3, Math.round(performance.now())), this.clearRTO(t3));
        }
        close() {
          this.rtt = this.initialRTT, this.packetNumber = 1, Array.from(this.timeoutMap.entries()).forEach((e3) => {
            let [t3, i3] = e3;
            window.clearTimeout(i3);
          }), this.timeoutMap = /* @__PURE__ */ new Map(), this.rtoRatioMap = /* @__PURE__ */ new Map(), this.unorderedPacketQueue = [], this.batchAckPacketQueue = [], this.lastOrderedPacketNumber = 0, void 0 !== this.batchAckTimer && window.clearTimeout(this.batchAckTimer);
        }
        resendMessage(e3) {
          const t3 = this.calculateRTO(e3), i3 = window.setTimeout(() => {
            this.resendMessage(e3);
          }, t3);
          this.timeoutMap.set(e3.packetNumber, i3), this.sendPacket(e3);
        }
        calculateRTO(e3) {
          const t3 = this.rtoRatioMap.get(e3.packetNumber);
          if (void 0 === t3)
            return this.rtoRatioMap.set(e3.packetNumber, 1), this.initialRTO;
          {
            const i3 = 9 * this.rtt / 8 * t3;
            return this.rtoRatioMap.set(e3.packetNumber, t3 + 1), i3 > this.maxRTO ? this.maxRTO : i3;
          }
        }
        updateRTT(e3, t3) {
          const i3 = e3.ackSendTs;
          this.rtt = this.rtt * (7 / 8) + (t3 - i3 - this.rtt) / 8;
        }
        ack(e3) {
          if (e3.packetNumber === this.lastOrderedPacketNumber + 1)
            for (this.batchAckPacketQueue.length >= this.maxBatchAckCount && this.batchAck(), this.batchAckTimer ? this.batchAckPacketQueue.push(e3) : (this.batchAckPacketQueue.push(e3), this.batchAckTimer = window.setTimeout(() => {
              this.batchAck();
            }, this.rtt / 8)), this.lastOrderedPacketNumber += 1, this.receiveImpl(e3.payload); ; ) {
              const e4 = this.unorderedPacketQueue[0];
              if (!e4) {
                this.unorderedPacketQueue.shift();
                break;
              }
              this.batchAckTimer && this.batchAck(), this.receiveImpl(e4.payload), this.unorderedPacketQueue.shift(), this.lastOrderedPacketNumber += 1;
            }
          else if (e3.packetNumber <= this.lastOrderedPacketNumber) {
            const t3 = { ackSendTs: e3.sendTs, maxAckPacketNumber: e3.packetNumber, shift: 0, type: ZJ.Ack, version: this.version };
            this.sendPacket(t3);
          } else if (e3.packetNumber > this.lastOrderedPacketNumber) {
            this.unorderedPacketQueue[e3.packetNumber - this.lastOrderedPacketNumber - 2] = e3;
            const t3 = { ackSendTs: e3.sendTs, maxAckPacketNumber: e3.packetNumber, shift: 0, type: ZJ.Ack, version: this.version };
            this.sendPacket(t3);
          }
        }
        batchAck() {
          window.clearTimeout(this.batchAckTimer), this.batchAckTimer = void 0;
          const e3 = { ackSendTs: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].sendTs, maxAckPacketNumber: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].packetNumber, shift: this.batchAckPacketQueue.length - 1, type: ZJ.Ack, version: this.version };
          this.sendPacket(e3), this.batchAckPacketQueue = [];
        }
        sendPacket(e3) {
          e3.type === ZJ.Default && (e3.sendTs = Math.round(performance.now()));
          const t3 = this.serialize(e3);
          this.sendImpl(t3);
        }
        clearRTO(e3) {
          for (let t3 = e3.maxAckPacketNumber - e3.shift; t3 <= e3.maxAckPacketNumber; t3++) {
            const e4 = this.timeoutMap.get(t3);
            void 0 !== e4 && window.clearTimeout(e4), this.timeoutMap.delete(t3), this.rtoRatioMap.delete(t3);
          }
        }
      }
      class oq extends MD {
        get queue() {
          return [...this.highPriorityQueue, ...this.lowPriorityQueue];
        }
        constructor(e3) {
          super(), MN(this, "lowPriorityQueue", []), MN(this, "highPriorityQueue", []), MN(this, "AgoraTransmissionManager", void 0), this.AgoraTransmissionManager = e3;
        }
        reset() {
          this.lowPriorityQueue = [], this.highPriorityQueue = [];
        }
        pushMessage(e3) {
          arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? this.highPriorityQueue.push(e3) : this.lowPriorityQueue.push(e3), this.sendMessage();
        }
        sendMessage() {
          const e3 = this.queue.length;
          let t3 = 0;
          t3 = e3 < 5 ? 15 * e3 : 60 + 3 * (e3 - 4), setTimeout(() => {
            this._sendMessage();
          }, t3);
        }
        _sendMessage() {
          if (!this.queue.length)
            return;
          const e3 = this.AgoraTransmissionManager.getConnection();
          if (!e3)
            return;
          const t3 = this.queue.shift();
          return this.lowPriorityQueue.includes(t3) ? this.lowPriorityQueue.shift() : this.highPriorityQueue.shift(), e3.sendMessage(t3.compressed), t3;
        }
      }
      var sq;
      let aq = mP("AgoraDatachannelManager", "connectionID")(sq = class extends tq {
        constructor(e3, t3) {
          super(e3, t3, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0), MN(this, "_initMutex", void 0), MN(this, "_reconnectInterrupter", void 0), MN(this, "_url", void 0), MN(this, "_transmitter", void 0), MN(this, "_addresses", void 0), MN(this, "_reliableTransmission", void 0), this._initMutex = new fj("datachannel");
          const { timeout: i3, timeoutFactor: r3 } = t3, n3 = Math.max(300, Math.floor(3 * i3 / 5)), o3 = Math.max(1.2, Math.floor(8 * r3) / 10);
          EB.ONLINE && (this._retryConfig.timeout = n3, this._retryConfig.timeoutFactor = o3), ij.on(fB.NETWORK_STATE_CHANGE, (e4, t4) => {
            e4 !== t4 && (this.resetReconnectCount("network state change: ".concat(t4, " -> ").concat(e4)), e4 === EB.ONLINE ? (this._retryConfig.timeout = n3, this._retryConfig.timeoutFactor = o3) : (this._retryConfig.timeout = i3, this._retryConfig.timeoutFactor = r3));
          });
          const s3 = Date.now();
          this._compressor.init().then(() => {
            this._compressorInitStatus = "initialized";
            const e4 = Date.now() - s3;
            JD.debug("datachannel compressor initialized successfully in ".concat(e4, "ms")), gP("debug", this._compressor, "init", void 0, "datachannel compressor initialized successfully in ".concat(e4, "ms")), pj.wsCompressorInit({ status: true, ec: null, eventElapse: e4 }), this._compress = this._compressor.compress.bind(this._compressor);
          }).catch((e4) => {
            this._compressorInitStatus = "failed";
            const t4 = e4 ? e4.message || e4.toString() : "Empty Error";
            JD.debug("datachannel compressor failed to initialize because of ".concat(t4)), gP("debug", this._compressor, "init", void 0, "datachannel compressor failed to initialize because of ".concat(t4)), pj.wsCompressorInit({ status: false, ec: t4, eventElapse: 1 });
          });
        }
        getConnection() {
          if (this._reliableTransmission)
            return this._reliableTransmission;
        }
        async init(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          this._forceCloseTimeout = t3;
          const i3 = (t4, i4) => {
            this._addresses = e3, this.currentURLIndex = this._addresses.findIndex((e4) => e4.fingerprint || LP("FINGERPRINT"));
            const r3 = this._addresses[this.currentURLIndex];
            this.state = "connecting", this._messageSender = new oq(this), this.createTransmitterConnection(r3).then(t4).catch(i4), this.once(TB.CLOSED, () => i4(new QD(xD.WS_DISCONNECT))), this.once(TB.CONNECTED, () => t4());
          };
          return this._initMutex.lock().then((e4) => new l_((e5, t4) => {
            i3(e5, t4);
          }).then(() => {
            e4();
          }).catch(() => {
            e4();
          }));
        }
        sendMessage(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!this._transmitter || !this._reliableTransmission)
            throw new QD(xD.WS_ABORT, "datachannel is not ready");
          try {
            let r3 = null;
            if (i3)
              r3 = this.sendMessageWithUint8Array(e3);
            else if ("initialized" === this._compressorInitStatus && this._useCompress && LP("DATACHANNEL_COMPRESS"))
              try {
                r3 = this._compress(e3), this.setInflateData(r3);
              } catch (t4) {
                r3 = this.sendMessageWithJSON(e3);
              }
            else
              r3 = this.sendMessageWithJSON(e3);
            t3 ? this._reliableTransmission.sendMessage(r3.compressed) : this._messageSender.pushMessage(r3);
          } catch (e4) {
            throw new QD(xD.WS_ERR, "send datachannel signal message error" + e4.toString());
          }
        }
        unbindDcCloseEventListener() {
          this._transmitter && (this._transmitter.onclose = null);
        }
        sendMessageWithJSON(e3) {
          const t3 = JSON.stringify(e3);
          return { compressed: t3, compressedLength: t3.length, origin: e3 };
        }
        sendMessageWithUint8Array(e3) {
          return { compressed: e3, compressedLength: e3.byteLength, origin: e3 };
        }
        createTransmitterConnection(e3) {
          return this.connectionID += 1, this._joinChannelServiceRecordIndex = void 0, this._url = "dc://".concat(e3.ip, ":").concat(e3.port), new l_((t3, i3) => {
            var r3;
            const n3 = () => {
              JD.debug("[".concat(this._name, "] datachannel opened:"), this._url), pP("debug", ["DataChannel", this.connectionID], "open", this._url), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), t3();
            }, o3 = async (r4) => {
              var n4;
              if (null === (n4 = this._closeEstablishingTransmitter) || void 0 === n4 || n4.call(this), JD.debug("[".concat(this._name, "] datachannel close ").concat(this._url, ", code: ").concat(r4.code, ", reason: ").concat(r4.reason, ", current mode: ").concat(this.reconnectMode)), pP("debug", ["DataChannel", this.connectionID], "close", { code: r4.code, reason: r4.reason, address: e3, reconnectMode: this.reconnectMode }), this._reconnectCount < this._retryConfig.maxRetryCount) {
                "connected" === this.state && (this.reconnectReason = r4.reason, this.state = "reconnecting");
                const e4 = RK(this, TB.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode, n5 = await this.reconnectWithAction(e4);
                if ("closed" === this.state)
                  return JD.debug("[".concat(this.connectionID, "] dc is closed, no need to reconnect")), void hP("debug", this, "dc is closed, no need to reconnect");
                if (!n5)
                  return i3(new QD(xD.WS_DISCONNECT, "datachannel reconnect failed: ".concat(r4.code))), void this.close(true);
                t3();
              } else
                i3(new QD(xD.WS_DISCONNECT, "datachannel close: ".concat(r4.code))), this.close();
            }, s3 = (e4) => {
              var t4;
              null === (t4 = this._reliableTransmission) || void 0 === t4 || t4.onData(e4.data);
            };
            this._transmitter && (this._transmitter.onclose = null, this._transmitter.close()), this._reliableTransmission && (this._reliableTransmission.close(), this._reliableTransmission = void 0), JD.debug("[".concat(this._name, "] start connect, address: ").concat(JSON.stringify(e3))), hP("debug", this, "start connect, address: ".concat(JSON.stringify(e3)));
            const a3 = null === (r3 = this._store) || void 0 === r3 ? void 0 : r3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" }), c3 = Date.now();
            vK(this, TB.TO_CONNECT_DATACHANNEL, e3).then((e4) => {
              var t4, i4;
              if (!e4)
                throw new Error("transmissonInfo not exist yet");
              const { transmitter: r4, close: d3 } = e4;
              this._transmitter = r4, null === (t4 = this._store) || void 0 === t4 || t4.signalChannelOpen();
              const u3 = Date.now() - c3;
              JD.debug("[choose dc] dc open cost ".concat(u3, "ms"));
              this._reliableTransmission = new nq((e5) => {
                var t5;
                this._transmitter && "open" === this._transmitter.readyState && (null === (t5 = this._transmitter) || void 0 === t5 || t5.send(e5));
              }, (e5) => {
                "string" == typeof e5 && this.emit(TB.ON_MESSAGE, e5);
              }), this._closeEstablishingTransmitter = () => {
                var e5;
                null === (e5 = this._reliableTransmission) || void 0 === e5 || e5.close(), this._reliableTransmission = void 0, d3();
              }, n3 && n3(), r4.onclose = o3, r4.onmessage = s3, null === (i4 = this._store) || void 0 === i4 || i4.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a3), this._joinChannelServiceRecordIndex = a3;
            }).catch((e4) => {
              var t4;
              if (null === (t4 = this._store) || void 0 === t4 || t4.recordJoinChannelService({ endTs: Date.now(), status: e4 instanceof QD && e4.code === xD.WS_ABORT ? "aborted" : "error", errors: [e4] }, a3), "closed" !== this.state) {
                if (e4 instanceof QD && e4.code === xD.WS_ERR) {
                  const t5 = new QD(xD.WS_ERR, "init datachannel failed! Error: ".concat(e4.toString()));
                  return JD.error("[".concat(this._name, "]").concat(t5)), gP("error", this, "chooseBestDataChannelConnection", void 0, e4.toString()), void i3(t5);
                }
                o3 && o3(e4);
              } else
                i3(new QD(xD.WS_DISCONNECT, "datachannel is closed: ".concat(e4.toString())));
            });
          });
        }
        async reconnectWithAction(e3) {
          let t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this._reconnectCount >= this._retryConfig.maxRetryCount)
            return false;
          if (!this._addresses)
            return false;
          if ("closed" === this.state)
            return false;
          this._onlineReconnectListener || ij.networkState !== EB.OFFLINE || (this._onlineReconnectListener = ij.onlineWaiter && ij.onlineWaiter.then(() => {
            this._onlineReconnectListener = void 0;
          }));
          let i3 = true;
          if (this._reconnectInterrupter = () => {
            i3 = false;
          }, t3) {
            const t4 = VD(this._reconnectCount, this._retryConfig);
            JD.debug("[".concat(this._name, "] wait ").concat(t4, "ms to reconnect datachannel, mode: ").concat(e3)), gP("debug", this, "reconnectWithAction", { timeout: t4, action: e3 }), await l_.race([EK(t4), this._onlineReconnectListener || new l_(() => {
            })]);
          }
          if ("closed" === this.state || !i3)
            return false;
          this._reconnectCount += 1;
          const r3 = async (e4, t4) => {
            this.emit(TB.RECONNECT_CREATE_CONNECTION, t4), await this.createTransmitterConnection(e4);
          };
          try {
            if ("retry" === e3) {
              const t4 = this._addresses[this.currentURLIndex];
              this.emit(TB.RECONNECT_WAITTING_FINISH, e3), await r3(t4, e3);
            } else if ("tryNext" === e3) {
              this.currentURLIndex += 1;
              for (let e4 = this.currentURLIndex; e4 < this._addresses.length; e4++) {
                if (this._addresses[e4].fingerprint || LP("FINGERPRINT")) {
                  this.currentURLIndex = e4;
                  break;
                }
                this.currentURLIndex += 1;
              }
              if (this.currentURLIndex >= this._addresses.length)
                return JD.debug("[".concat(this._name, "] the available addresses are exhausted, change to recover")), await this.reconnectWithAction("recover", false);
              JD.debug("[".concat(this._name, "] datachannel url length: ").concat(this._addresses.length, " current index: ").concat(this.currentURLIndex)), hP("debug", this, "datachannel url length: ".concat(this._addresses.length, " current index: ").concat(this.currentURLIndex));
              const t4 = this._addresses[this.currentURLIndex];
              this.emit(TB.RECONNECT_WAITTING_FINISH, e3), await r3(t4, e3);
            } else
              "recover" === e3 && (JD.debug("[".concat(this._name, "] start to failback to websocket")), hP("debug", this, "start to failback to websocket"), this.resetReconnectCount("recover mode"), this.emit(TB.RECONNECT_WAITTING_FINISH, e3), this.emit(TB.FAILBACK));
            return true;
          } catch (i4) {
            var n3;
            return JD.error("[".concat(this._name, "] reconnect failed"), i4.toString()), gP("error", this, "reconnectWithAction", void 0, i4.toString()), null != i4 && null !== (n3 = i4.data) && void 0 !== n3 && n3.desc && Array.isArray(i4.data.desc) && i4.data.desc.length && i4.data.desc.includes("dynamic key expired") ? (this.emit(TB.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : await this.reconnectWithAction(e3, t3);
          }
        }
      }) || sq;
      var cq;
      let dq = mP("AgoraDataChannelSignal", "websocket.connectionID")(cq = class extends MD {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e3) {
          e3 !== this._connectionState && (this._connectionState = e3, e3 === Ek.CONNECTED ? this.emit(fk.WS_CONNECTED) : e3 === Ek.RECONNECTING ? this.emit(fk.WS_RECONNECTING, this._websocketReconnectReason) : e3 === Ek.CLOSED && this.emit(fk.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket ? this.websocket.url : null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e3, t3) {
          super(), MN(this, "_disconnectedReason", void 0), MN(this, "_websocketReconnectReason", void 0), MN(this, "_connectionState", Ek.CLOSED), MN(this, "reconnectToken", void 0), MN(this, "websocket", void 0), MN(this, "openConnectionTime", void 0), MN(this, "clientId", void 0), MN(this, "lastMsgTime", Date.now()), MN(this, "uploadCache", []), MN(this, "uploadCacheInterval", void 0), MN(this, "rttRolling", new XJ(5)), MN(this, "pingpongTimer", void 0), MN(this, "inflateDataTimer", void 0), MN(this, "pingpongTimeoutCount", 0), MN(this, "joinResponse", void 0), MN(this, "multiIpOption", void 0), MN(this, "initError", void 0), MN(this, "spec", void 0), MN(this, "store", void 0), MN(this, "onWebsocketMessage", (e4) => {
            if (e4 instanceof ArrayBuffer)
              return void this.emit(fk.ON_BINARY_DATA, e4);
            const t4 = JSON.parse(e4);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t4, "_id")) {
              const e5 = "res-@".concat(t4._id);
              this.emit(e5, t4._result, t4._message);
            } else if (Object.prototype.hasOwnProperty.call(t4, "_type") && (this.emit(t4._type, t4._message), t4._type === _k.ON_NOTIFICATION && this.handleNotification(t4._message), t4._type === _k.ON_USER_BANNED))
              switch (t4._message.error_code) {
                case 14:
                  this.close(lk.UID_BANNED);
                  break;
                case 15:
                  this.close(lk.IP_BANNED);
                  break;
                case 16:
                  this.close(lk.CHANNEL_BANNED);
              }
          }), this.clientId = e3.clientId, this.spec = e3, this.store = t3, this.websocket = new aq("gateway-".concat(this.clientId), this.spec.retryConfig, true, t3), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
            this.connectionState === Ek.CONNECTED && this.reconnect("retry", vB.OFFLINE);
          });
        }
        async request(e3, t3, i3, r3) {
          const n3 = mK(6, ""), o3 = { _id: n3, _type: e3, _message: t3 }, s3 = this.websocket.connectionID, a3 = () => new l_((t4, i4) => {
            if (this.connectionState === Ek.CONNECTED)
              return t4();
            const r4 = () => {
              this.off(fk.WS_CLOSED, n4), t4();
            }, n4 = () => {
              this.off(fk.WS_CONNECTED, r4), i4(new QD(xD.WS_ABORT));
            };
            this.once(fk.WS_CONNECTED, r4), this.once(fk.WS_CLOSED, n4), e3 !== mk.PUBLISH && e3 !== mk.SUBSCRIBE && e3 !== mk.UNSUBSCRIBE && e3 !== mk.UNPUBLISH && e3 !== mk.CONTROL && e3 !== mk.RESTART_ICE || this.once(fk.DISCONNECT_P2P, () => {
              i4(new QD(xD.DISCONNECT_P2P));
            }), e3 !== mk.PUBLISH && e3 !== mk.RESTART_ICE || this.once(fk.ABORT_P2P_EXECUTION, () => {
              i4(new QD(xD.DISCONNECT_P2P));
            });
          });
          if (this.connectionState !== Ek.CONNECTING && this.connectionState !== Ek.RECONNECTING || e3 === mk.JOIN || e3 === mk.REJOIN || await a3(), e3 === mk.LEAVE && (this.websocket.unbindDcCloseEventListener(), r3 = true), this.websocket.sendMessage(o3, true, false), r3)
            return;
          const c3 = new l_((i4, r4) => {
            let o4 = false;
            const a4 = (r5, n4) => {
              o4 = true, i4({ isSuccess: "success" === r5, message: n4 || {} }), this.off(fk.WS_CLOSED, c4), this.off(fk.WS_RECONNECTING, c4), this.emit(fk.REQUEST_SUCCESS, e3, t3);
            };
            this.once("res-@".concat(n3), a4);
            const c4 = () => {
              r4(new QD(xD.WS_ABORT, "type: ".concat(e3))), this.off(fk.WS_CLOSED, c4), this.off(fk.WS_RECONNECTING, c4), this.off("res-@".concat(n3), a4);
            };
            this.once(fk.WS_CLOSED, c4), this.once(fk.WS_RECONNECTING, c4), EK(LP("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              this.websocket.connectionID !== s3 || o4 || (JD.warning("dc request timeout, type: ".concat(e3)), hP("warning", this, "dc request timeout, type: ".concat(e3)), this.emit(fk.REQUEST_TIMEOUT, e3, t3));
            });
          });
          let d3 = null;
          try {
            d3 = await c3;
          } catch (r4) {
            if (this.connectionState === Ek.CLOSED || e3 === mk.LEAVE)
              throw new QD(xD.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i3 ? r4.throw() : e3 === mk.JOIN || e3 === mk.REJOIN ? null : (await a3(), await this.request(e3, t3));
          }
          if (d3.isSuccess)
            return d3.message;
          const u3 = Number(d3.message.error_code || d3.message.code), h3 = LJ(u3), A3 = new QD(xD.UNEXPECTED_RESPONSE, "".concat(h3.desc, ": ").concat(d3.message.error_str), { code: u3, data: d3.message });
          return "success" === h3.action ? d3.message : (JD.warning("[".concat(this.websocket.connectionID, "] unexpected response from type ").concat(e3, ", error_code: ").concat(u3, ", message: ").concat(h3.desc, ", action: ").concat(h3.action)), hP("warning", this, "unexpected response from type ".concat(e3, ", error_code: ").concat(u3, ", message: ").concat(h3.desc, ", action: ").concat(h3.action)), u3 === hk.ERR_TOO_MANY_BROADCASTERS ? e3 === mk.JOIN || e3 === mk.REJOIN ? (this.initError = A3, this.close(), A3.throw()) : A3.throw() : "failed" === h3.action ? A3.throw() : "quit" === h3.action ? (this.initError = A3, this.close(), A3.throw()) : (u3 === hk.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d3.message.option, JD.warning("[".concat(this.clientId, "] detect multi ip, recover")), hP("warning", this, "detect multi ip, recover"), this.reconnect("recover", vB.MULTI_IP)) : this.reconnect(h3.action, vB.SERVER_ERROR), e3 === mk.JOIN || e3 === mk.REJOIN ? null : await this.request(e3, t3)));
        }
        waitMessage(e3, t3) {
          return new l_((i3) => {
            const r3 = (n3) => {
              (!t3 || t3(n3)) && (this.off(e3, r3), i3(n3));
            };
            this.on(e3, r3);
          });
        }
        upload(e3, t3) {
          const i3 = { _type: e3, _message: t3 };
          try {
            this.websocket.sendMessage(i3);
          } catch (e4) {
            const t4 = LP("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i3), this.uploadCache.length > t4 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
              if (this.connectionState !== Ek.CONNECTED)
                return;
              const e5 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e5._type, e5._message);
            }, LP("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e3, t3) {
          const i3 = { _type: e3, _message: t3 };
          this.websocket.sendMessage(i3);
        }
        init(e3, t3) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new l_((i3, r3) => {
            this.once(fk.WS_CONNECTED, () => i3(this.joinResponse)), this.once(fk.WS_CLOSED, () => r3(this.initError || new QD(xD.WS_ABORT))), this.connectionState = Ek.CONNECTING, this.websocket.init(e3).catch(r3), this.websocket.once(TB.FAILBACK, () => {
              void 0 === this.openConnectionTime && r3(new QD(xD.INIT_DATACHANNEL_TIMEOUT));
            }), this.inflateDataTimer && window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = window.setInterval(() => {
              this.handleInflateData();
            }, 2e4), setTimeout(() => {
              t3 && void 0 === this.openConnectionTime && (JD.debug("[".concat(this.clientId, "] init datachannel timeout while join with failback to websocket")), r3(new QD(xD.INIT_DATACHANNEL_TIMEOUT)));
            }, LP("DC_JOIN_WITH_FAILBACK"));
          });
        }
        close(e3) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.inflateDataTimer && (this.handleInflateData(), window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e3 || lk.LEAVE, this.connectionState = Ek.CLOSED, JD.debug("[".concat(this.clientId, "] ") + "will close datachannel in signal"), this.websocket.close(), e3 === lk.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new aq("gateway-".concat(this.clientId), this.spec.retryConfig, true, this.store), this.handleWebsocketEvents());
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(fk.ABORT_P2P_EXECUTION);
            const e3 = await vK(this, fk.DATACHANNEL_CONNECTING), t3 = await this.request(mk.JOIN, e3);
            if (!t3)
              return this.emit(fk.REPORT_JOIN_GATEWAY, xD.TIMEOUT, this.url || ""), false;
            this.joinResponse = t3, this.emit(fk.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = Ek.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        async rejoin() {
          if (!this.reconnectToken)
            throw new QD(xD.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
          const e3 = yK(this, fk.REQUEST_REJOIN_INFO);
          e3.token = this.reconnectToken;
          const t3 = await this.request(mk.REJOIN, e3);
          return !!t3 && (this.connectionState = Ek.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t3.peers && t3.peers.forEach((e4) => {
            this.emit(_k.ON_USER_ONLINE, { uid: e4.uid }), e4.audio && this.emit(_k.ON_ADD_AUDIO_STREAM, { uid: e4.uid, uint_id: e4.uint_id, audio: true, ssrcId: e4.audio_ssrc }), e4.video && this.emit(_k.ON_ADD_VIDEO_STREAM, { uid: e4.uid, uint_id: e4.uint_id, video: true, ssrcId: e4.video_ssrc }), e4.audio_mute ? this.emit(_k.MUTE_AUDIO, { uid: e4.uid }) : this.emit(_k.UNMUTE_AUDIO, { uid: e4.uid }), e4.video_mute ? this.emit(_k.MUTE_VIDEO, { uid: e4.uid }) : this.emit(_k.UNMUTE_VIDEO, { uid: e4.uid }), e4.audio_enable_local ? this.emit(_k.ENABLE_LOCAL_AUDIO, { uid: e4.uid }) : this.emit(_k.DISABLE_LOCAL_AUDIO, { uid: e4.uid }), e4.video_enable_local ? this.emit(_k.ENABLE_LOCAL_VIDEO, { uid: e4.uid }) : this.emit(_k.DISABLE_LOCAL_VIDEO, { uid: e4.uid }), e4.audio || e4.video || this.emit(_k.ON_REMOVE_STREAM, { uid: e4.uid, uint_id: e4.uint_id });
          }), true);
        }
        reconnect(e3, t3) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e3, t3);
        }
        handleNotification(e3) {
          JD.debug("[".concat(this.clientId, "] receive notification: "), e3), gP("debug", this, "handleNotification", e3);
          const t3 = LJ(e3.code);
          if ("success" !== t3.action)
            return "failed" === t3.action ? (JD.error("[".concat(this.clientId, "] ignore error: "), t3.desc), void hP("error", this, "ignore error: ".concat(t3.desc))) : "quit" === t3.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t3.desc && this.close(lk.UID_BANNED), void this.close()) : void this.reconnect(t3.action, vB.SERVER_ERROR);
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state)
            return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e3 = LP("PING_PONG_TIME_OUT"), t3 = Date.now();
          this.pingpongTimeoutCount >= e3 && (JD.warning("PINGPONG Timeout. Last Socket Message: ".concat(t3 - this.lastMsgTime, "ms")), hP("warning", this, "PINGPONG Timeout. Last Socket Message: ".concat(t3 - this.lastMsgTime, "ms")), t3 - this.lastMsgTime > LP("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", vB.TIMEOUT) : this.request(mk.PING, void 0, true).then(() => {
            this.pingpongTimeoutCount = 0;
            const e4 = Date.now() - t3;
            this.rttRolling.add(e4), LP("REPORT_STATS") && this.send(mk.PING_BACK, { pingpongElapse: e4 });
          }).catch((e4) => {
          });
        }
        handleInflateData() {
          const { inflateLength: e3, deflateLength: t3 } = this.websocket.getInflateData();
          0 !== e3 && 0 !== t3 && this.upload(Ik.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t3, ws_inflate_length: e3 });
        }
        handleWebsocketEvents() {
          this.websocket.on(TB.RECONNECT_WAITTING_FINISH, (e3) => {
            this.emit(fk.WS_RECONNECT_WAITTING_FINISH, e3);
          }), this.websocket.on(TB.RECONNECT_CREATE_CONNECTION, (e3) => {
            this.emit(fk.WS_RECONNECT_CREATE_CONNECTION, e3);
          }), this.websocket.on(TB.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(TB.CLOSED, () => {
            this.connectionState = Ek.CLOSED;
          }), this.websocket.on(TB.FAILED, () => {
            this._disconnectedReason = lk.NETWORK_ERROR, this.connectionState = Ek.CLOSED;
          }), this.websocket.on(TB.RECONNECTING, (e3) => {
            this._websocketReconnectReason = e3, this.joinResponse = void 0, this.connectionState === Ek.CONNECTED ? this.connectionState = Ek.RECONNECTING : this.connectionState = Ek.CONNECTING;
          }), this.websocket.on(TB.WILL_RECONNECT, (e3, t3) => {
            if (yK(this, fk.IS_P2P_DISCONNECTED) && "retry" === e3)
              return JD.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), hP("debug", this, "".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(fk.NEED_RENEW_SESSION), this.emit(fk.DISCONNECT_P2P), t3("tryNext");
            "retry" !== e3 && (JD.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e3)), hP("debug", this, "".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e3)), this.reconnectToken = void 0, this.emit(fk.NEED_RENEW_SESSION), this.emit(fk.DISCONNECT_P2P)), t3(e3);
          }), this.websocket.on(TB.CONNECTED, () => {
            this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e3) => {
              JD.warning("[".concat(this.clientId, "] rejoin failed ").concat(e3)), gP("warning", this, "rejoin", void 0, e3.toString()), this.reconnect("tryNext", vB.SERVER_ERROR);
            }) : this.join().catch((e3) => {
              if (this.emit(fk.REPORT_JOIN_GATEWAY, e3.message || e3.code, this.url || ""), e3 instanceof QD && e3.code === xD.UNEXPECTED_RESPONSE && e3.data.code === hk.ERR_NO_AUTHORIZED)
                return JD.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), hP("warning", this, "reconnect no authorized, recover"), void this.reconnect("recover", vB.SERVER_ERROR);
              JD.error("[".concat(this.clientId, "] join gateway request failed"), e3.toString()), gP("error", this, "join", void 0, e3.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", vB.SERVER_ERROR) : (this.initError = e3, this.close());
            });
          }), this.websocket.on(TB.REQUEST_NEW_URLS, (e3, t3) => {
            vK(this, fk.REQUEST_RECOVER, this.multiIpOption).then(e3).catch(t3);
          }), this.websocket.on(TB.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            this.emit(_k.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          }), this.websocket.on(TB.TO_CONNECT_DATACHANNEL, async (e3, t3, i3) => vK(this, fk.DATACHANNEL_PRECONNECT, e3).then(t3).catch(i3)), this.websocket.on(TB.FAILBACK, () => {
            void 0 !== this.openConnectionTime && this.emit(fk.DATACHANNEL_FAILBACK);
          });
        }
      }) || cq;
      var uq;
      function hq(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function Aq(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? hq(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : hq(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      const lq = /* @__PURE__ */ new Map();
      let pq = mP("AgoraRTCGateway", "store.clientId")(uq = class extends MD {
        get state() {
          return this._state;
        }
        set state(e3) {
          if (e3 === this._state)
            return;
          const t3 = this._state;
          this._state = e3, "DISCONNECTED" === e3 && this._disconnectedReason ? this.emit(Xk.CONNECTION_STATE_CHANGE, e3, t3, this._disconnectedReason) : this.emit(Xk.CONNECTION_STATE_CHANGE, e3, t3);
        }
        get joinGatewayStartTime() {
          return this._joinGatewayStartTime;
        }
        set joinGatewayStartTime(e3) {
          JD.debug("[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e3)), gP("debug", this, "joinGatewayStartTime", e3, "[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e3)), this._joinGatewayStartTime = e3;
        }
        constructor(e3, t3) {
          super(), MN(this, "store", void 0), MN(this, "joinInfo", void 0), MN(this, "key", void 0), MN(this, "signal", void 0), MN(this, "role", void 0), MN(this, "inChannelInfo", { joinAt: null, duration: 0 }), MN(this, "spec", void 0), MN(this, "_state", "DISCONNECTED"), MN(this, "_statsCollector", void 0), MN(this, "_disconnectedReason", void 0), MN(this, "isSignalRecover", false), MN(this, "hasChangeBGPAddress", false), MN(this, "trafficStatsInterval", void 0), MN(this, "networkQualityInterval", void 0), MN(this, "_joinGatewayStartTime", 0), MN(this, "_signalTimeout", false), MN(this, "_clientRoleOptions", void 0), MN(this, "_isProactiveJoin", false), this.store = e3, this.spec = t3;
          const i3 = wB().supportDataChannel && LP("SIGNAL_CHANNEL");
          this.signal = i3 ? new dq(Aq(Aq({}, t3), {}, { retryConfig: t3.websocketRetryConfig }), e3) : new $J(Aq(Aq({}, t3), {}, { retryConfig: t3.websocketRetryConfig }), e3), this._statsCollector = t3.statsCollector, this.role = t3.role || "audience", this._clientRoleOptions = t3.clientRoleOptions, this.handleSignalEvents();
        }
        async join(e3, t3, i3) {
          if (this.signal instanceof dq) {
            let t4 = false;
            "disabled" !== e3.cloudProxyServer ? (JD.debug("[".concat(this.store.clientId, "] Dc is not supported, because cloudProxyServer are not supported (").concat(e3.cloudProxyServer, ")")), t4 = true) : "".concat(e3.apResponse.cid, "_").concat(e3.apResponse.cert).length > 255 || "".concat(e3.apResponse.cid, "_").concat(e3.apResponse.cert).length < 22 ? (JD.debug("[".concat(this.store.clientId, "] Dc is not supported, because ticket length is incorrect, it has to be between 22 and 255")), t4 = true) : e3.apResponse.addresses.some((e4) => e4.fingerprint) || LP("FINGERPRINT") || (JD.debug("[".concat(this.store.clientId, "] Dc is not supported, because fingerprint does not exist")), t4 = true), t4 && this.resetSignal();
          }
          this.store.joinGatewayStart(), "disabled" !== e3.cloudProxyServer && (this.hasChangeBGPAddress = true);
          const r3 = Date.now();
          let n3 = lq.get(e3.cname);
          if (n3 || (n3 = /* @__PURE__ */ new Map(), lq.set(e3.cname, n3)), this._isProactiveJoin = true, n3.has(e3.uid)) {
            const t4 = new QD(xD.UID_CONFLICT);
            throw pj.joinGateway(e3.sid, { lts: r3, succ: false, ec: t4.message, addr: null, uid: e3.uid, cid: e3.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!e3.proxyServer, signalChannel: this.signal instanceof dq ? "1" : "0" }), this._isProactiveJoin = false, t4;
          }
          n3.set(e3.uid, true), this.joinInfo = e3, this.key = t3;
          let o3 = 0;
          this.joinGatewayStartTime = r3;
          const s3 = e3.proxyServer;
          try {
            let t4;
            if (JD.debug("[".concat(this.store.clientId, "] use ").concat(this.signal instanceof dq ? "datachannel" : "websocket", " join uid ").concat(o3)), this.signal instanceof dq)
              t4 = await this.signal.init(e3.apResponse.addresses, i3);
            else {
              const r4 = e3.proxyServer, n4 = r4 ? e3.gatewayAddrs.map((e4) => {
                const t5 = e4.address.split(":");
                return "wss://".concat(r4, "/ws/?h=").concat(t5[0], "&p=").concat(t5[1]);
              }) : e3.gatewayAddrs.map((e4) => "wss://".concat(e4.address));
              t4 = await this.signal.init(n4, i3);
            }
            o3 = t4.uid, JD.debug("[".concat(this.store.clientId, "] ").concat(this.signal instanceof dq ? "datachannel" : "websocket", " join uid ").concat(o3, " cost ").concat(Date.now() - this.joinGatewayStartTime));
          } catch (t4) {
            if (t4 && t4.code === xD.INIT_WEBSOCKET_TIMEOUT)
              throw JD.warning("[".concat(this.store.clientId, "] User join failed"), t4.toString()), t4;
            if (t4 && t4.code === xD.INIT_DATACHANNEL_TIMEOUT)
              throw JD.warning("[".concat(this.store.clientId, "] User join datachannel failed"), t4.toString()), this.resetSignal(), t4;
            throw JD.error("[".concat(this.store.clientId, "] User join failed"), t4.toString()), gP("error", this, "join", void 0, t4.toString()), pj.joinGateway(e3.sid, { lts: r3, succ: false, ec: t4.message, addr: this.signal.url, uid: e3.uid, cid: e3.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!s3, signalChannel: this.signal instanceof dq ? "1" : "0" }), this._isProactiveJoin = false, n3.delete(e3.uid), this.signal.close(), t4;
          }
          return this.state = "CONNECTED", this.inChannelInfo.joinAt = Date.now(), JD.debug("[".concat(this.store.clientId, "] Connected to gateway server")), gP("debug", this, "join", void 0, "success"), this.trafficStatsInterval = window.setInterval(() => {
            this.updateTrafficStats().catch((e4) => {
              JD.warning("[".concat(this.store.clientId, "] get traffic stats error"), e4.toString()), gP("warning", this, "trafficStatsInterval", void 0, e4.toString());
            });
          }, 3e3), this.networkQualityInterval = window.setInterval(() => {
            navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit(Xk.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 }) : this._signalTimeout ? this.emit(Xk.NETWORK_QUALITY, { downlinkNetworkQuality: 5, uplinkNetworkQuality: 5 }) : "CONNECTED" === this.state && this._statsCollector.trafficStats ? this.emit(Xk.NETWORK_QUALITY, { uplinkNetworkQuality: cK(this._statsCollector.trafficStats.B_unq), downlinkNetworkQuality: cK(this._statsCollector.trafficStats.B_dnq) }) : this.emit(Xk.NETWORK_QUALITY, { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 });
          }, 2e3), this.store.joinGatewayEnd(), o3;
        }
        async leave() {
          let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t3 = arguments.length > 1 ? arguments[1] : void 0;
          if ("DISCONNECTED" !== this.state) {
            t3 !== lk.FALLBACK && (this.state = "DISCONNECTING");
            try {
              e3 || this.signal.connectionState !== Ek.CONNECTED || await function(e4, t4) {
                return t4 === 1 / 0 ? e4 : l_.race([e4, fK(t4)]);
              }(this.signal.request(mk.LEAVE, void 0, true), 3e3);
            } catch (e4) {
              JD.warning("[".concat(this.store.clientId, "] leave request failed, ignore"), e4), hP("warning", this, "leave request failed, ignore, ".concat(e4.toString()));
            }
            this.signal.close(t3), t3 !== lk.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          }
        }
        async publish(e3, t3, i3) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
            throw new QD(xD.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
          const r3 = { state: "offer", p2p_id: this.store.p2pId, ortc: t3, mode: this.spec.mode, extend: LP("PUB_EXTEND") };
          try {
            return (await this.signal.request(mk.PUBLISH, r3, true))._message;
          } catch (r4) {
            if (i3 && r4.data && r4.data.code === hk.ERR_PUBLISH_REQUEST_INVALID)
              return JD.warning("[".concat(this.store.clientId, "] receive publish error code, retry"), r4.toString()), hP("warning", this, "receive publish error code, retry, ".concat(r4.toString())), await this.tryUnpubBeforeRepub(e3, t3), this.publish(e3, t3, false);
            throw r4;
          }
        }
        async unpublish(e3, t3) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
              throw new QD(xD.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await this.signal.request(mk.UNPUBLISH, { stream_id: t3, ortc: e3 }, true);
          } catch (e4) {
            JD.warning("unpublish warning: ", e4), gP("warning", this, "unpublish", void 0, e4.toString());
          }
        }
        async subscribe(e3, t3, i3) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
            throw new QD(xD.INVALID_OPERATION, "can not subscribe when connection state is ".concat(this.state));
          const r3 = { stream_id: e3, stream_type: t3.stream_type, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, tcc: !!LP("SUBSCRIBE_TCC"), extend: LP("SUB_EXTEND"), ssrcId: t3.ssrcId };
          try {
            return (await this.signal.request(mk.SUBSCRIBE, r3, true))._message;
          } catch (r4) {
            if (i3 && r4.data && r4.data.code === hk.ERR_SUBSCRIBE_REQUEST_INVALID)
              return JD.warning("[".concat(this.store.clientId, "] receiver subscribe error code, retry"), r4.toString()), hP("warning", this, "receiver subscribe error code, retry"), await this.tryUnsubBeforeResub(e3, t3), await this.subscribe(e3, t3, false);
            throw r4;
          }
        }
        async subscribeAll(e3, t3) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
            throw new QD(xD.INVALID_OPERATION, "can not massSubscribe when connection state is ".concat(this.state));
          const i3 = { p2p_id: this.store.p2pId, users: e3, dtx: false };
          try {
            return await this.signal.request(mk.SUBSCRIBE_STREAMS, i3, true);
          } catch (i4) {
            if (t3 && i4.data && i4.data.code === hk.ERR_SUBSCRIBE_REQUEST_INVALID)
              return JD.warning("[".concat(this.store.clientId, "] receiver massSubscribe error code, retry"), i4.toString()), hP("warning", this, "receiver massSubscribe error code, retry"), await this.tryMassUnsubBeforeResub(e3), await this.subscribeAll(e3, false);
            throw i4;
          }
        }
        async setVideoProfile(e3) {
          const t3 = function(e4) {
            if (!(e4.bitrateMax && e4.bitrateMin && e4.frameRate && e4.height && e4.width))
              return;
            let t4 = e4.frameRate, i3 = e4.width, r3 = e4.height, n3 = true;
            return "number" != typeof t4 && (t4 = t4.exact || t4.ideal || t4.max || t4.min || 0, t4 || (n3 = false)), "number" != typeof i3 && (i3 = i3.exact || i3.ideal || i3.max || i3.min || 0, i3 || (n3 = false)), "number" != typeof r3 && (r3 = r3.exact || r3.ideal || r3.max || r3.min || 0, t4 || (n3 = false)), n3 ? { stream_type: 0, width: i3, height: r3, fps: t4, start_bps: 1e3 * e4.bitrateMax, min_bps: 1e3 * e4.bitrateMin, target_bps: 1e3 * e4.bitrateMax } : void 0;
          }(e3);
          return t3 ? this.signal.request(mk.SET_VIDEO_PROFILE, t3) : (JD.debug("[".concat(this.store.clientId, "] encoder config is not complete, do not report to gateway")), void hP("debug", this, "encoder config is not complete, do not report to gateway"));
        }
        async unsubscribe(e3, t3) {
          try {
            await this.signal.request(mk.UNSUBSCRIBE, { p2p_id: this.store.p2pId, ortc: e3, stream_id: t3 }, true);
          } catch (e4) {
            JD.warning("unsubscribe warning: ", e4), gP("warning", this, "unsubscribe", void 0, e4.toString());
          }
        }
        async massUnsubscribe(e3) {
          try {
            await this.signal.request(mk.UNSUBSCRIBE_STREAMS, e3, true);
          } catch (e4) {
            JD.warning("unsubscribeAll warning: ", e4), gP("warning", this, "unsubscribeAll", void 0, e4.toString());
          }
        }
        async reconnectPC(e3) {
          const { iceParameters: t3, dtlsParameters: i3, rtpCapabilities: r3 } = e3;
          return { gatewayEstablishParams: await this.signal.request(mk.CONNECT_PC, { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: { iceParameters: t3, dtlsParameters: i3, rtpCapabilities: r3 } }, true), gatewayAddress: this.getCurrentGatewayAddress() };
        }
        getGatewayInfo() {
          return this.signal.request(mk.GATEWAY_INFO);
        }
        renewToken(e3) {
          return this.signal.request(mk.RENEW_TOKEN, e3);
        }
        async setClientRole(e3, t3) {
          if (t3 && (this._clientRoleOptions = Object.assign({}, t3)), "CONNECTED" !== this.state)
            return void (this.role = e3);
          let i3 = void 0;
          i3 = "audience" === e3 ? this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : 0, await this.signal.request(mk.SET_CLIENT_ROLE, { role: e3, level: i3, client_ts: Date.now() }), this.role = e3;
        }
        async setRemoteVideoStreamType(e3, t3) {
          await this.signal.request(mk.SWITCH_VIDEO_STREAM, { stream_id: e3, stream_type: t3 });
        }
        async setDefaultRemoteVideoStreamType(e3) {
          await this.signal.request(mk.DEFAULT_VIDEO_STREAM, { stream_type: e3 });
        }
        async setStreamFallbackOption(e3, t3) {
          await this.signal.request(mk.SET_FALLBACK_OPTION, { stream_id: e3, fallback_type: t3 });
        }
        async pickSVCLayer(e3, t3) {
          await this.signal.request(mk.PICK_SVC_LAYER, { stream_id: e3, spatial_layer: t3.spatialLayer, temporal_layer: t3.temporalLayer });
        }
        getInChannelInfo() {
          return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), Aq({}, this.inChannelInfo);
        }
        async getGatewayVersion() {
          return (await this.signal.request(mk.GATEWAY_INFO)).version;
        }
        reset() {
          if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {
            const e3 = lq.get(this.joinInfo.cname);
            e3 && e3.delete(this.joinInfo.uid);
          }
          this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0);
        }
        updateTurnConfigFromSignal() {
          if (!this.joinInfo)
            return;
          const e3 = function(e4) {
            let t3;
            return t3 = e4.startsWith("dc") ? e4.match(/(dc\:\/\/)?([^:]+):(\d+)/) : e4.match(/(wss\:\/\/)?([^:]+):(\d+)/), t3 ? { username: vP.username, password: vP.password, turnServerURL: t3[2], tcpport: parseInt(t3[3]) + 30, udpport: parseInt(t3[3]) + 30, forceturn: false } : null;
          }(("disabled" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || "");
          this.joinInfo.turnServer.serversFromGateway = [], e3 && "off" !== this.joinInfo.turnServer.mode && "disabled" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(Aq(Aq({}, vP), {}, { turnServerURL: e3.turnServerURL, tcpport: e3.tcpport, udpport: e3.udpport, username: this.joinInfo.uid.toString(), password: this.joinInfo.token }));
        }
        async updateTrafficStats() {
          if ("CONNECTED" !== this.state)
            return;
          const e3 = await this.signal.request(mk.TRAFFIC_STATS, void 0, true);
          e3.timestamp = Date.now(), e3.peer_delay.forEach((e4) => {
            const t3 = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find((t4) => t4.peer_uid === e4.peer_uid);
            t3 && t3.B_st !== e4.B_st && NK(() => {
              this.emit(Xk.STREAM_TYPE_CHANGE, e4.peer_uid, e4.B_st);
            });
          }), this._statsCollector.updateTrafficStats(e3);
        }
        getJoinMessage(e3) {
          if (!this.joinInfo || !this.key)
            throw new QD(xD.UNEXPECTED_ERROR, "can not generate join message, no join info");
          const t3 = Object.assign({}, this.joinInfo.apResponse);
          let i3 = LP("REPORT_APP_SCENARIO");
          if ("string" != typeof i3)
            try {
              i3 = JSON.stringify(i3);
            } catch (e4) {
              i3 = void 0;
            }
          i3 && i3.length > 128 && (i3 = void 0);
          const r3 = Aq({ license: this.joinInfo.license, p2p_id: this.store.p2pId, session_id: this.joinInfo.sid, app_id: this.joinInfo.appId, channel_key: this.key, channel_name: this.joinInfo.cname, sdk_version: CP, browser: navigator.userAgent, process_id: LP("PROCESS_ID"), mode: this.spec.mode, codec: this.spec.codec, role: this.role, has_changed_gateway: this.hasChangeBGPAddress, ap_response: t3, extend: LP("JOIN_EXTEND"), details: { 6: this.joinInfo.stringUid, cservice_map: "proxy3" === this.joinInfo.cloudProxyServer ? "1" : "proxy5" === this.joinInfo.cloudProxyServer ? "2" : void 0 }, features: { rejoin: true }, optionalInfo: this.joinInfo.optionalInfo, appScenario: i3, attributes: { userAttributes: { enablePublishedUserList: LP("ENABLE_PUBLISHED_USER_LIST"), maxSubscription: LP("MAX_SUBSCRIPTION"), subscribeAudioFilterTopN: "number" == typeof LP("SUBSCRIBE_AUDIO_FILTER_TOPN") ? LP("SUBSCRIBE_AUDIO_FILTER_TOPN") : void 0, enablePublishAudioFilter: "boolean" == typeof LP("ENABLE_PUBLISH_AUDIO_FILTER") ? LP("ENABLE_PUBLISH_AUDIO_FILTER") : void 0, enableUserLicenseCheck: "boolean" == typeof LP("ENABLE_USER_LICENSE_CHECK") ? LP("ENABLE_USER_LICENSE_CHECK") : void 0 } }, join_ts: this.joinGatewayStartTime }, e3);
          return this.joinInfo.stringUid && (r3.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (r3.aes_mode = this.joinInfo.aesmode, LP("ENCRYPT_AES") ? (r3.aes_secret = this.joinInfo.aespassword, r3.aes_encrypt = true) : r3.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (r3.aes_salt = this.joinInfo.aessalt)), t3.addresses[this.signal.websocket.currentURLIndex] && (r3.ap_response.ticket = t3.addresses[this.signal.websocket.currentURLIndex].ticket, delete t3.addresses), void 0 !== this.joinInfo.defaultVideoStream && (r3.default_video_stream = this.joinInfo.defaultVideoStream), r3;
        }
        getRejoinMessage() {
          if (!this.joinInfo)
            throw new QD(xD.UNEXPECTED_ERROR, "can not generate rejoin message, no join info");
          return { session_id: this.joinInfo.sid, channel_name: this.joinInfo.cname, cid: this.joinInfo.cid, uid: this.joinInfo.uid, vid: Number(this.joinInfo.vid) };
        }
        handleSignalEvents() {
          this.signal.on(fk.WS_RECONNECT_WAITTING_FINISH, (e3) => {
            ["tryNext", "recover"].includes(e3) && this.joinInfo && pj.adjustSessionStartTime(this.joinInfo.sid);
          }), this.signal.on(fk.WS_RECONNECT_CREATE_CONNECTION, (e3) => {
            this.joinGatewayStartTime = Date.now();
          }), this.signal.on(fk.WS_RECONNECTING, (e3) => {
            this.joinInfo && pj.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: e3 || gk.NETWORK_ERROR }), this.joinInfo && (this.state = "RECONNECTING", pj.sessionInit(this.joinInfo.sid, { lts: new Date().getTime(), extend: this.isSignalRecover ? { recover: true } : { rejoin: true }, cname: this.joinInfo.cname, appid: this.joinInfo.appId, mode: this.spec.mode }), this.isSignalRecover = false, this.joinGatewayStartTime = Date.now());
          }), this.signal.on(fk.WS_CLOSED, (e3) => {
            let t3;
            switch (e3) {
              case lk.LEAVE:
                t3 = gk.LEAVE;
                break;
              case lk.UID_BANNED:
              case lk.IP_BANNED:
              case lk.CHANNEL_BANNED:
              case lk.SERVER_ERROR:
                t3 = gk.SERVER_ERROR;
                break;
              case lk.FALLBACK:
                t3 = gk.FALLBACK;
                break;
              case lk.LICENSE_MISSING:
              case lk.LICENSE_EXPIRED:
              case lk.LICENSE_MINUTES_EXCEEDED:
              case lk.LICENSE_PERIOD_INVALID:
              case lk.LICENSE_MULTIPLE_SDK_SERVICE:
              case lk.LICENSE_ILLEGAL:
                t3 = e3;
                break;
              default:
                t3 = gk.NETWORK_ERROR;
            }
            JD.debug("[signal] websocket closed, reason: ".concat(t3 || "undefined -> " + gk.NETWORK_ERROR)), AP("debug", this, "ws_closed", "reason: ".concat(e3)), this.joinInfo && pj.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: e3 === lk.LEAVE ? 1 : -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: t3 }), this._disconnectedReason = e3, e3 !== lk.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          }), this.signal.on(fk.WS_CONNECTED, () => {
            if (this.updateTurnConfigFromSignal(), this.state = "CONNECTED", this.joinInfo && ("audience" === this.role && this._clientRoleOptions && this._clientRoleOptions.level && (JD.debug("[".concat(this.store.clientId, "] patch to send set client role, role: ").concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(this._clientRoleOptions && this._clientRoleOptions.level)), hP("debug", this, "patch to send set client role, role: ".concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(this._clientRoleOptions && this._clientRoleOptions.level)), this.setClientRole(this.role, this._clientRoleOptions)), pj.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: true, ec: null, vid: this.joinInfo.vid, addr: this.signal.url, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: this.signal instanceof dq ? "1" : "0" }), this._isProactiveJoin = false, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion)) {
              const e3 = this.signal.url && this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);
              if (!e3)
                return JD.error("[".concat(this.store.clientId, "] set local access point after joined failed: ").concat(e3)), void hP("error", this, "set local access point after joined failed: ".concat(e3));
              PP("EVENT_REPORT_DOMAIN", e3[1]), PP("EVENT_REPORT_BACKUP_DOMAIN", e3[1]), PP("LOG_UPLOAD_SERVER", "".concat(e3[1], ":6444"));
            }
          }), this.signal.on(_k.ON_UPLINK_STATS, (e3) => {
            this._statsCollector.updateUplinkStats(e3);
          }), this.signal.on(fk.REQUEST_RECOVER, (e3, t3, i3) => {
            if (!this.joinInfo)
              return i3(new QD(xD.UNEXPECTED_ERROR, "gateway: can not recover, no join info"));
            e3 && (this.joinInfo.multiIP = e3, this.hasChangeBGPAddress = true), this.isSignalRecover = true, vK(this, Xk.REQUEST_NEW_GATEWAY_LIST).then(t3).catch(i3);
          }), this.signal.on(fk.REQUEST_JOIN_INFO, async (e3) => {
            var t3;
            this.updateTurnConfigFromSignal();
            const { iceParameters: i3, dtlsParameters: r3, rtpCapabilities: n3 } = await vK(this, Xk.REQUEST_P2P_CONNECTION_PARAMS, { turnServer: null === (t3 = this.joinInfo) || void 0 === t3 ? void 0 : t3.turnServer });
            e3(this.getJoinMessage({ ortc: { iceParameters: i3, dtlsParameters: r3, rtpCapabilities: n3, version: "2" } }));
          }), this.signal.on(fk.REQUEST_REJOIN_INFO, (e3) => {
            e3(this.getRejoinMessage());
          }), this.signal.on(fk.REPORT_JOIN_GATEWAY, (e3, t3) => {
            this.joinInfo && (pj.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: false, ec: e3, addr: t3, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: this.signal instanceof dq ? "1" : "0" }), this._isProactiveJoin = false);
          }), this.signal.on(fk.IS_P2P_DISCONNECTED, (e3) => {
            e3(yK(this, Xk.IS_P2P_DISCONNECTED));
          }), this.signal.on(fk.DISCONNECT_P2P, () => {
            this.emit(Xk.DISCONNECT_P2P);
          }), this.signal.on(fk.NEED_RENEW_SESSION, () => {
            this.emit(Xk.NEED_RENEW_SESSION);
          }), this.signal.on(fk.REQUEST_SUCCESS, () => {
            this._signalTimeout = false;
          }), this.signal.on(fk.REQUEST_TIMEOUT, () => {
            this._signalTimeout = true;
          }), this.signal.on(fk.JOIN_RESPONSE, (e3) => {
            const t3 = this.getCurrentGatewayAddress();
            this.emit(Xk.JOIN_RESPONSE, e3, t3);
          }), this.signal.on(fk.DATACHANNEL_PRECONNECT, async (e3, t3, i3) => {
            this.updateTurnConfigFromSignal();
            const r3 = this.getCurrentGatewayAddress();
            return vK(this, Xk.DATACHANNEL_PRECONNECT, e3, r3).then(t3).catch(i3);
          }), this.signal.on(fk.DATACHANNEL_CONNECTING, async (e3) => {
            const { iceParameters: t3, dtlsParameters: i3, rtpCapabilities: r3 } = await vK(this, Xk.REQUEST_DC_CONNECTION_PARAMS);
            e3(this.getJoinMessage({ ortc: { iceParameters: t3, dtlsParameters: i3, rtpCapabilities: r3, version: "2" } }));
          }), this.signal.on(fk.DATACHANNEL_FAILBACK, () => {
            JD.warning("[".concat(this.store.clientId, "] User join datachannel failed")), this.reset(), this.resetSignal(), this.emit(Xk.DATACHANNEL_FAILBACK);
          });
        }
        async tryUnsubBeforeResub(e3, t3) {
          try {
            await this.signal.request(mk.UNSUBSCRIBE, { p2p_id: this.store.p2pId, stream_id: e3, ortc: [t3] }, true);
          } catch (t4) {
            throw JD.warning("unsubscribe warning", t4), gP("warning", this, "tryUnsubBeforeResub", e3, t4.toString()), t4;
          }
        }
        async tryUnpubBeforeRepub(e3, t3) {
          try {
            await this.signal.request(mk.UNPUBLISH, { stream_id: e3, ortc: t3 }, true);
          } catch (t4) {
            throw JD.warning("unpublish warning: ", t4), gP("warning", this, "tryUnpubBeforeRepub", e3, t4.toString()), t4;
          }
        }
        async tryMassUnsubBeforeResub(e3) {
          const t3 = { users: e3.map((e4) => ({ stream_id: e4.stream_id, stream_type: e4.stream_type })) };
          try {
            await this.signal.request(mk.UNSUBSCRIBE_STREAMS, t3, true);
          } catch (t4) {
            throw JD.warning("massUnsubscribe warning", t4), gP("warning", this, "tryUnsubAllBeforeResub", e3.map((e4) => e4.stream_id), t4.toString()), t4;
          }
        }
        async muteLocal(e3, t3) {
          const i3 = { action: e3.find((e4) => e4.stream_type === qk.Audio) ? "mute_local_audio" : "mute_local_video", p2p_id: this.store.p2pId, ortc: e3, stream_id: t3 };
          try {
            await this.signal.request(mk.CONTROL, i3, true, true);
          } catch (e4) {
            throw JD.warning("gateway unmuteLocal warning: ", e4), gP("warning", this, "muteLocal", t3, e4.toString()), e4;
          }
        }
        async unmuteLocal(e3, t3) {
          const i3 = { action: e3.find((e4) => e4.stream_type === qk.Audio) ? "unmute_local_audio" : "unmute_local_video", p2p_id: this.store.p2pId, ortc: e3, stream_id: t3 };
          try {
            await this.signal.request(mk.CONTROL, i3, true, true);
          } catch (e4) {
            throw JD.warning("gateway muteLocal warning: ", e4), gP("warning", this, "unmuteLocal", t3, e4.toString()), e4;
          }
        }
        uploadStats(e3, t3) {
          this.signal.upload(e3, t3);
        }
        getSignalRTT() {
          return this.signal.rtt;
        }
        async restartICE(e3) {
          const t3 = { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: e3 };
          try {
            return await this.signal.request(mk.RESTART_ICE, t3, true);
          } catch (e4) {
            throw JD.warning("P2PChannel.restartICE warning: ", e4), gP("warning", this, "restartICE", void 0, e4.toString()), e4;
          }
        }
        reconnect() {
          "CONNECTED" === this.state && this.signal.reconnect(void 0, gk.P2P_FAILED);
        }
        getCurrentGatewayAddress() {
          var e3;
          if (!LP("GATEWAY_WSS_ADDRESS"))
            return null !== (e3 = this.joinInfo) && void 0 !== e3 && e3.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0;
        }
        async setPublishAudioFilterEnabled(e3) {
          await this.signal.request(mk.SET_PARAMETER, { enablePublishAudioFilter: e3 });
        }
        resetSignal() {
          this.signal && (this.signal.removeAllListeners(), this.signal.close(lk.FALLBACK)), this.signal = new $J(Aq(Aq({}, this.spec), {}, { retryConfig: this.spec.websocketRetryConfig }), this.store), this.handleSignalEvents(), this.emit(Xk.RESET_CONNECTION_EVENTS);
        }
      }) || uq;
      function gq(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function Eq(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? gq(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : gq(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      !function() {
        var t3;
        function i3(e3) {
          var t4 = 0;
          return function() {
            return t4 < e3.length ? { done: false, value: e3[t4++] } : { done: true };
          };
        }
        var r3 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(e3, t4, i4) {
          return e3 == Array.prototype || e3 == Object.prototype || (e3[t4] = i4.value), e3;
        };
        var n3, o3 = function(t4) {
          t4 = ["object" == typeof globalThis && globalThis, t4, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof e && e];
          for (var i4 = 0; i4 < t4.length; ++i4) {
            var r4 = t4[i4];
            if (r4 && r4.Math == Math)
              return r4;
          }
          throw Error("Cannot find global object");
        }(this);
        function s3(e3, t4) {
          if (t4)
            e: {
              var i4 = o3;
              e3 = e3.split(".");
              for (var n4 = 0; n4 < e3.length - 1; n4++) {
                var s4 = e3[n4];
                if (!(s4 in i4))
                  break e;
                i4 = i4[s4];
              }
              (t4 = t4(n4 = i4[e3 = e3[e3.length - 1]])) != n4 && null != t4 && r3(i4, e3, { configurable: true, writable: true, value: t4 });
            }
        }
        function a3(e3) {
          return (e3 = { next: e3 })[Symbol.iterator] = function() {
            return this;
          }, e3;
        }
        function c3(e3) {
          var t4 = "undefined" != typeof Symbol && Symbol.iterator && e3[Symbol.iterator];
          return t4 ? t4.call(e3) : { next: i3(e3) };
        }
        if (s3("Symbol", function(e3) {
          function t4(e4, t5) {
            this.A = e4, r3(this, "description", { configurable: true, writable: true, value: t5 });
          }
          if (e3)
            return e3;
          t4.prototype.toString = function() {
            return this.A;
          };
          var i4 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", n4 = 0;
          return function e4(r4) {
            if (this instanceof e4)
              throw new TypeError("Symbol is not a constructor");
            return new t4(i4 + (r4 || "") + "_" + n4++, r4);
          };
        }), s3("Symbol.iterator", function(e3) {
          if (e3)
            return e3;
          e3 = Symbol("Symbol.iterator");
          for (var t4 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), n4 = 0; n4 < t4.length; n4++) {
            var s4 = o3[t4[n4]];
            "function" == typeof s4 && "function" != typeof s4.prototype[e3] && r3(s4.prototype, e3, { configurable: true, writable: true, value: function() {
              return a3(i3(this));
            } });
          }
          return e3;
        }), "function" == typeof Object.setPrototypeOf)
          n3 = Object.setPrototypeOf;
        else {
          var d3;
          e: {
            var u3 = {};
            try {
              u3.__proto__ = { a: true }, d3 = u3.a;
              break e;
            } catch (e3) {
            }
            d3 = false;
          }
          n3 = d3 ? function(e3, t4) {
            if (e3.__proto__ = t4, e3.__proto__ !== t4)
              throw new TypeError(e3 + " is not extensible");
            return e3;
          } : null;
        }
        var h3 = n3;
        function A3() {
          this.m = false, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;
        }
        function l3(e3) {
          if (e3.m)
            throw new TypeError("Generator is already running");
          e3.m = true;
        }
        function p3(e3, t4) {
          return e3.h = 3, { value: t4 };
        }
        function g3(e3) {
          this.g = new A3(), this.G = e3;
        }
        function E3(e3, t4, i4, r4) {
          try {
            var n4 = t4.call(e3.g.j, i4);
            if (!(n4 instanceof Object))
              throw new TypeError("Iterator result " + n4 + " is not an object");
            if (!n4.done)
              return e3.g.m = false, n4;
            var o4 = n4.value;
          } catch (t5) {
            return e3.g.j = null, e3.g.s(t5), f3(e3);
          }
          return e3.g.j = null, r4.call(e3.g, o4), f3(e3);
        }
        function f3(e3) {
          for (; e3.g.h; )
            try {
              var t4 = e3.G(e3.g);
              if (t4)
                return e3.g.m = false, { value: t4.value, done: false };
            } catch (t5) {
              e3.g.v = void 0, e3.g.s(t5);
            }
          if (e3.g.m = false, e3.g.l) {
            if (t4 = e3.g.l, e3.g.l = null, t4.F)
              throw t4.D;
            return { value: t4.return, done: true };
          }
          return { value: void 0, done: true };
        }
        function m3(e3) {
          this.next = function(t4) {
            return e3.o(t4);
          }, this.throw = function(t4) {
            return e3.s(t4);
          }, this.return = function(t4) {
            return function(e4, t5) {
              l3(e4.g);
              var i4 = e4.g.j;
              return i4 ? E3(e4, "return" in i4 ? i4.return : function(e5) {
                return { value: e5, done: true };
              }, t5, e4.g.return) : (e4.g.return(t5), f3(e4));
            }(e3, t4);
          }, this[Symbol.iterator] = function() {
            return this;
          };
        }
        function I3(e3, t4) {
          return t4 = new m3(new g3(t4)), h3 && e3.prototype && h3(t4, e3.prototype), t4;
        }
        if (A3.prototype.o = function(e3) {
          this.v = e3;
        }, A3.prototype.s = function(e3) {
          this.l = { D: e3, F: true }, this.h = this.C || this.u;
        }, A3.prototype.return = function(e3) {
          this.l = { return: e3 }, this.h = this.u;
        }, g3.prototype.o = function(e3) {
          return l3(this.g), this.g.j ? E3(this, this.g.j.next, e3, this.g.o) : (this.g.o(e3), f3(this));
        }, g3.prototype.s = function(e3) {
          return l3(this.g), this.g.j ? E3(this, this.g.j.throw, e3, this.g.o) : (this.g.s(e3), f3(this));
        }, s3("Array.prototype.entries", function(e3) {
          return e3 || function() {
            return function(e4, t4) {
              e4 instanceof String && (e4 += "");
              var i4 = 0, r4 = false, n4 = { next: function() {
                if (!r4 && i4 < e4.length) {
                  var n5 = i4++;
                  return { value: t4(n5, e4[n5]), done: false };
                }
                return r4 = true, { done: true, value: void 0 };
              } };
              return n4[Symbol.iterator] = function() {
                return n4;
              }, n4;
            }(this, function(e4, t4) {
              return [e4, t4];
            });
          };
        }), "undefined" != typeof Blob && ("undefined" == typeof FormData || !FormData.prototype.keys)) {
          var _3 = function(e3, t4) {
            for (var i4 = 0; i4 < e3.length; i4++)
              t4(e3[i4]);
          }, C3 = function(e3) {
            return e3.replace(/\r?\n|\r/g, "\r\n");
          }, S3 = function(e3, t4, i4) {
            return t4 instanceof Blob ? (i4 = void 0 !== i4 ? String(i4 + "") : "string" == typeof t4.name ? t4.name : "blob", t4.name === i4 && "[object Blob]" !== Object.prototype.toString.call(t4) || (t4 = new File([t4], i4)), [String(e3), t4]) : [String(e3), String(t4)];
          }, v3 = function(e3, t4) {
            if (e3.length < t4)
              throw new TypeError(t4 + " argument required, but only " + e3.length + " present.");
          }, T3 = "object" == typeof globalThis ? globalThis : "object" == typeof window ? window : "object" == typeof self ? self : this, R3 = T3.FormData, y3 = T3.XMLHttpRequest && T3.XMLHttpRequest.prototype.send, w3 = T3.Request && T3.fetch, b3 = T3.navigator && T3.navigator.sendBeacon, N3 = T3.Element && T3.Element.prototype, O3 = T3.Symbol && Symbol.toStringTag;
          O3 && (Blob.prototype[O3] || (Blob.prototype[O3] = "Blob"), "File" in T3 && !File.prototype[O3] && (File.prototype[O3] = "File"));
          try {
            new File([], "");
          } catch (e3) {
            T3.File = function(e4, t4, i4) {
              return e4 = new Blob(e4, i4 || {}), Object.defineProperties(e4, { name: { value: t4 }, lastModified: { value: +(i4 && void 0 !== i4.lastModified ? new Date(i4.lastModified) : new Date()) }, toString: { value: function() {
                return "[object File]";
              } } }), O3 && Object.defineProperty(e4, O3, { value: "File" }), e4;
            };
          }
          var D3 = function(e3) {
            return e3.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
          }, P3 = function(e3) {
            this.i = [];
            var t4 = this;
            e3 && _3(e3.elements, function(e4) {
              if (e4.name && !e4.disabled && "submit" !== e4.type && "button" !== e4.type && !e4.matches("form fieldset[disabled] *"))
                if ("file" === e4.type) {
                  var i4 = e4.files && e4.files.length ? e4.files : [new File([], "", { type: "application/octet-stream" })];
                  _3(i4, function(i5) {
                    t4.append(e4.name, i5);
                  });
                } else
                  "select-multiple" === e4.type || "select-one" === e4.type ? _3(e4.options, function(i5) {
                    !i5.disabled && i5.selected && t4.append(e4.name, i5.value);
                  }) : "checkbox" === e4.type || "radio" === e4.type ? e4.checked && t4.append(e4.name, e4.value) : (i4 = "textarea" === e4.type ? C3(e4.value) : e4.value, t4.append(e4.name, i4));
            });
          };
          if ((t3 = P3.prototype).append = function(e3, t4, i4) {
            v3(arguments, 2), this.i.push(S3(e3, t4, i4));
          }, t3.delete = function(e3) {
            v3(arguments, 1);
            var t4 = [];
            e3 = String(e3), _3(this.i, function(i4) {
              i4[0] !== e3 && t4.push(i4);
            }), this.i = t4;
          }, t3.entries = function e3() {
            var t4, i4 = this;
            return I3(e3, function(e4) {
              if (1 == e4.h && (t4 = 0), 3 != e4.h)
                return t4 < i4.i.length ? e4 = p3(e4, i4.i[t4]) : (e4.h = 0, e4 = void 0), e4;
              t4++, e4.h = 2;
            });
          }, t3.forEach = function(e3, t4) {
            v3(arguments, 1);
            for (var i4 = c3(this), r4 = i4.next(); !r4.done; r4 = i4.next()) {
              var n4 = c3(r4.value);
              r4 = n4.next().value, n4 = n4.next().value, e3.call(t4, n4, r4, this);
            }
          }, t3.get = function(e3) {
            v3(arguments, 1);
            var t4 = this.i;
            e3 = String(e3);
            for (var i4 = 0; i4 < t4.length; i4++)
              if (t4[i4][0] === e3)
                return t4[i4][1];
            return null;
          }, t3.getAll = function(e3) {
            v3(arguments, 1);
            var t4 = [];
            return e3 = String(e3), _3(this.i, function(i4) {
              i4[0] === e3 && t4.push(i4[1]);
            }), t4;
          }, t3.has = function(e3) {
            v3(arguments, 1), e3 = String(e3);
            for (var t4 = 0; t4 < this.i.length; t4++)
              if (this.i[t4][0] === e3)
                return true;
            return false;
          }, t3.keys = function e3() {
            var t4, i4, r4, n4, o4 = this;
            return I3(e3, function(e4) {
              if (1 == e4.h && (t4 = c3(o4), i4 = t4.next()), 3 != e4.h)
                return i4.done ? void (e4.h = 0) : (r4 = i4.value, n4 = c3(r4), p3(e4, n4.next().value));
              i4 = t4.next(), e4.h = 2;
            });
          }, t3.set = function(e3, t4, i4) {
            v3(arguments, 2), e3 = String(e3);
            var r4 = [], n4 = S3(e3, t4, i4), o4 = true;
            _3(this.i, function(t5) {
              t5[0] === e3 ? o4 && (o4 = !r4.push(n4)) : r4.push(t5);
            }), o4 && r4.push(n4), this.i = r4;
          }, t3.values = function e3() {
            var t4, i4, r4, n4, o4 = this;
            return I3(e3, function(e4) {
              if (1 == e4.h && (t4 = c3(o4), i4 = t4.next()), 3 != e4.h)
                return i4.done ? void (e4.h = 0) : (r4 = i4.value, (n4 = c3(r4)).next(), p3(e4, n4.next().value));
              i4 = t4.next(), e4.h = 2;
            });
          }, P3.prototype._asNative = function() {
            for (var e3 = new R3(), t4 = c3(this), i4 = t4.next(); !i4.done; i4 = t4.next()) {
              var r4 = c3(i4.value);
              i4 = r4.next().value, r4 = r4.next().value, e3.append(i4, r4);
            }
            return e3;
          }, P3.prototype._blob = function() {
            var e3 = "----formdata-polyfill-" + Math.random(), t4 = [], i4 = "--" + e3 + '\r\nContent-Disposition: form-data; name="';
            return this.forEach(function(e4, r4) {
              return "string" == typeof e4 ? t4.push(i4 + D3(C3(r4)) + '"\r\n\r\n' + C3(e4) + "\r\n") : t4.push(i4 + D3(C3(r4)) + '"; filename="' + D3(e4.name) + '"\r\nContent-Type: ' + (e4.type || "application/octet-stream") + "\r\n\r\n", e4, "\r\n");
            }), t4.push("--" + e3 + "--"), new Blob(t4, { type: "multipart/form-data; boundary=" + e3 });
          }, P3.prototype[Symbol.iterator] = function() {
            return this.entries();
          }, P3.prototype.toString = function() {
            return "[object FormData]";
          }, N3 && !N3.matches && (N3.matches = N3.matchesSelector || N3.mozMatchesSelector || N3.msMatchesSelector || N3.oMatchesSelector || N3.webkitMatchesSelector || function(e3) {
            for (var t4 = (e3 = (this.document || this.ownerDocument).querySelectorAll(e3)).length; 0 <= --t4 && e3.item(t4) !== this; )
              ;
            return -1 < t4;
          }), O3 && (P3.prototype[O3] = "FormData"), y3) {
            var L3 = T3.XMLHttpRequest.prototype.setRequestHeader;
            T3.XMLHttpRequest.prototype.setRequestHeader = function(e3, t4) {
              L3.call(this, e3, t4), "content-type" === e3.toLowerCase() && (this.B = true);
            }, T3.XMLHttpRequest.prototype.send = function(e3) {
              e3 instanceof P3 ? (e3 = e3._blob(), this.B || this.setRequestHeader("Content-Type", e3.type), y3.call(this, e3)) : y3.call(this, e3);
            };
          }
          w3 && (T3.fetch = function(e3, t4) {
            return t4 && t4.body && t4.body instanceof P3 && (t4.body = t4.body._blob()), w3.call(this, e3, t4);
          }), b3 && (T3.navigator.sendBeacon = function(e3, t4) {
            return t4 instanceof P3 && (t4 = t4._asNative()), b3.call(this, e3, t4);
          }), T3.FormData = P3;
        }
      }();
      let fq = 1;
      function mq(e3, t3, i3, r3, n3) {
        fq += 1;
        const o3 = { sid: i3.sid, command: "convergeAllocateEdge", uid: "666", appId: i3.appId, ts: Math.floor(Date.now() / 1e3), seq: fq, requestId: fq, version: CP, cname: i3.cname }, s3 = { service_name: t3, json_body: JSON.stringify(o3) };
        let a3, c3, d3 = e3[0];
        return jD(async () => {
          a3 = Date.now();
          const e4 = await ej(d3, { data: s3, cancelToken: r3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" } });
          if (c3 = Date.now() - a3, 0 !== e4.code) {
            const t4 = new QD(xD.UNEXPECTED_RESPONSE, "live streaming ap error, code" + e4.code, { retry: true, responseTime: c3 });
            throw JD.error(t4.toString()), gP("error", ["AjaxAPI"], "requestLiveStreamingWorkerManager", void 0, t4.toString()), t4;
          }
          const i4 = JSON.parse(e4.json_body);
          if (200 !== i4.code) {
            const e5 = new QD(xD.UNEXPECTED_RESPONSE, "live streaming app center error, code: ".concat(i4.code, ", reason: ").concat(i4.reason), { code: i4.code, responseTime: c3 });
            throw JD.error(e5.toString()), gP("error", ["AjaxAPI"], "requestLiveStreamingWorkerManager", void 0, e5.toString()), e5;
          }
          if (!i4.servers || 0 === i4.servers.length) {
            const e5 = new QD(xD.UNEXPECTED_RESPONSE, "live streaming app center empty server", { code: i4.code, responseTime: c3 });
            throw JD.error(e5.toString()), gP("error", ["AjaxAPI"], "requestLiveStreamingWorkerManager", void 0, e5.toString()), e5;
          }
          const n4 = function(e5, t4) {
            return { addressList: e5.servers.map((e6) => "wss://".concat(e6.address.replace(/\./g, "-"), ".").concat(LP("WORKER_DOMAIN"), ":").concat(e6.wss, "?serviceName=").concat(encodeURIComponent(t4))), workerToken: e5.workerToken, vid: e5.vid };
          }(i4, t3);
          return LP("LIVE_STREAMING_ADDRESS") && (n4.addressList = LP("LIVE_STREAMING_ADDRESS") instanceof Array ? LP("LIVE_STREAMING_ADDRESS") : [LP("LIVE_STREAMING_ADDRESS")]), Eq(Eq({}, n4), {}, { responseTime: c3 });
        }, (r4, n4) => (pj.apworkerEvent(i3.sid, { success: true, sc: 200, serviceName: t3, responseDetail: JSON.stringify(r4.addressList), firstSuccess: 0 === n4, responseTime: c3, serverIp: e3[n4 % e3.length] }), false), (r4, n4) => (pj.apworkerEvent(i3.sid, { success: false, sc: r4.data && r4.data.code || 200, serviceName: t3, responseTime: c3, serverIp: e3[n4 % e3.length] }), !!(r4.code !== xD.OPERATION_ABORTED && r4.code !== xD.UNEXPECTED_RESPONSE || r4.data && r4.data.retry) && (d3 = e3[(n4 + 1) % e3.length], true)), n3);
      }
      let Iq = 1;
      function _q(e3, t3, i3, r3) {
        let { url: n3, areaCode: o3 } = e3;
        gP("debug", ["AjaxAPI", t3.clientId], "requestChooseServer", { url: n3, areaCode: o3 });
        const s3 = Date.now();
        let a3;
        const [c3, d3] = Rq(t3, o3, [NF.CHOOSE_SERVER]);
        let u3 = ij.networkState;
        return jD(async () => {
          u3 && ij.networkState === EB.OFFLINE && ij.onlineWaiter && await l_.race([ij.onlineWaiter, EK(r3 && r3.maxRetryTimeout || FD.maxRetryTimeout)]), u3 = ij.networkState;
          const { data: e4, headers: o4 } = await ej(n3, { data: c3, cancelToken: i3, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
          a3 = "1" === o4.http3 ? 1 : -1, pj.reportResourceTiming(n3, t3.sid), Sq(e4, n3, t3, s3, [NF.CHOOSE_SERVER], a3);
          const d4 = dK(e4, NF.CHOOSE_SERVER);
          return vq(d4), nK(d4, n3);
        }, (e4) => (e4 && pj.joinChooseServer(t3.sid, { lts: s3, succ: true, csAddr: n3, opid: d3, serverList: e4.gatewayAddrs.map((e5) => e5.address), ec: null, cid: e4.cid.toString(), uid: e4.uid.toString(), csIp: e4.csIp, unilbsServerIds: [NF.CHOOSE_SERVER].toString(), isHttp3: a3 }), false), (e4) => e4.code !== xD.OPERATION_ABORTED && (e4.code === xD.CAN_NOT_GET_GATEWAY_SERVER ? e4.data.retry : (pj.joinChooseServer(t3.sid, { lts: s3, succ: false, csAddr: n3, serverList: null, opid: d3, ec: e4.code, csIp: e4.data && e4.data.csIp, unilbsServerIds: [NF.CHOOSE_SERVER].toString(), extend: JSON.stringify({ networkState: u3 }), isHttp3: a3 }), JD.warning("[".concat(t3.clientId, "] Choose server network error, retry"), e4), hP("warning", ["AjaxAPI", t3.clientId], "Choose server network error, retry, ".concat(e4)), true)), r3);
      }
      function Cq(e3, t3, i3, r3) {
        let n3, { url: o3, areaCode: s3, serviceIds: a3 } = e3;
        gP("debug", ["AjaxAPI", t3.clientId], "requestMultiUnilbs", { url: o3, areaCode: s3, serviceIds: a3 });
        const c3 = Date.now(), [d3, u3] = Rq(t3, s3, a3);
        let h3 = void 0;
        return jD(async () => {
          h3 && ij.networkState === EB.OFFLINE && ij.onlineWaiter && await l_.race([ij.onlineWaiter, EK(r3 && r3.maxRetryTimeout || FD.maxRetryTimeout)]), h3 = ij.networkState;
          const { data: e4, headers: s4 } = await ej(o3, { data: d3, cancelToken: i3, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
          n3 = "1" === s4.http3 ? 1 : -1, pj.reportResourceTiming(o3, t3.sid), Sq(e4, o3, t3, c3, a3, n3);
          const u4 = dK(e4, NF.CHOOSE_SERVER), A3 = dK(e4, "proxy5" === t3.cloudProxyServer ? NF.CLOUD_PROXY_5 : "proxy3" === t3.cloudProxyServer || "proxy4" === t3.cloudProxyServer ? NF.CLOUD_PROXY : NF.CLOUD_PROXY_FALLBACK);
          return vq(u4), { gatewayInfo: nK(u4, o3), proxyInfo: A3, url: o3 };
        }, (e4) => (e4.gatewayInfo && pj.joinChooseServer(t3.sid, { lts: c3, succ: true, csAddr: o3, serverList: e4.gatewayInfo.gatewayAddrs.map((e5) => e5.address), ec: null, opid: u3, cid: e4.gatewayInfo.cid.toString(), uid: e4.gatewayInfo.uid.toString(), csIp: e4.gatewayInfo.csIp, unilbsServerIds: a3.toString(), isHttp3: n3 }), e4.proxyInfo && pj.joinWebProxyAP(t3.sid, { lts: c3, sucess: 1, apServerAddr: o3, turnServerAddrList: e4.proxyInfo.addresses.map((e5) => e5.ip).join(","), errorCode: null, eventType: t3.cloudProxyServer, unilbsServerIds: a3.toString() }), false), (e4) => e4.code !== xD.OPERATION_ABORTED && (e4.code === xD.CAN_NOT_GET_GATEWAY_SERVER ? e4.data.retry : (pj.joinWebProxyAP(t3.sid, { lts: c3, sucess: 0, apServerAddr: o3, turnServerAddrList: null, errorCode: e4.code, eventType: t3.cloudProxyServer, unilbsServerIds: a3.toString(), extend: JSON.stringify({ networkState: h3 }) }), JD.warning("[".concat(t3.clientId, "] multi unilbs network error, retry"), e4), hP("warning", ["AjaxAPI", t3.clientId], "multi unilbs network error, retry, ".concat(e4)), true)), r3);
      }
      const Sq = (e3, t3, i3, r3, n3, o3) => {
        const s3 = [], a3 = (s4) => {
          4096 === s4.flag ? pj.joinChooseServer(i3.sid, { lts: r3, succ: false, csAddr: t3, opid: e3.opid, serverList: null, ec: s4.error.message, csIp: s4.error.data && s4.error.data.csIp, unilbsServerIds: n3.toString(), isHttp3: o3 }) : 1048576 !== s4.flag && 4194304 !== s4.flag && 4194310 !== s4.flag || pj.joinWebProxyAP(i3.sid, { lts: r3, sucess: 0, apServerAddr: t3, turnServerAddrList: null, errorCode: s4.error.code, eventType: i3.cloudProxyServer, unilbsServerIds: n3.toString() });
        };
        if (e3.response_body.forEach((t4) => {
          const i4 = t4.buffer.code;
          if (23 === t4.uri && 0 === i4 && !t4.buffer.edges_services)
            if (4194310 === t4.buffer.flag)
              JD.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"), t4.buffer.edges_services = [];
            else {
              const i5 = { error: new QD(xD.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: e3.detail[502] }), flag: t4.buffer.flag };
              s3.push(i5), a3(i5);
            }
          if (0 !== i4) {
            const r4 = DJ(i4), n4 = { error: new QD(xD.CAN_NOT_GET_GATEWAY_SERVER, r4.desc, { desc: r4.desc, retry: r4.retry, csIp: e3.detail[502] }), flag: t4.buffer.flag };
            4194310 === t4.buffer.flag ? JD.warning(n4.error.toString()) : s3.push(n4), a3(n4);
          }
        }), s3.length)
          throw JD.warning("[".concat(i3.clientId, "] multi unilbs ").concat(t3, " failed, ").concat(s3.map((e4) => "flag: ".concat(e4.flag, ", message: ").concat(e4.error.message, ", retry: ").concat(e4.error.data.retry)).join(" | "))), gP("warning", ["AjaxAPI", i3.clientId], "checkMultiUnilbsResponseValid", { url: t3 }, s3.map((e4) => ({ flag: e4.flag, message: e4.error.message, retry: e4.error.data.retry }))), new QD(xD.CAN_NOT_GET_GATEWAY_SERVER, s3.map((e4) => "flag: ".concat(e4.flag, ", message: ").concat(e4.error.message)).join(" | "), { retry: !!s3.find((e4) => e4.error.data.retry), csIp: e3.detail[502], desc: [...new Set(s3.map((e4) => {
            var t4, i4;
            return null == e4 || null === (t4 = e4.error) || void 0 === t4 || null === (i4 = t4.data) || void 0 === i4 ? void 0 : i4.desc;
          }).filter((e4) => !!e4))] });
      }, vq = (e3) => {
        var t3, i3;
        if (e3.addresses && 0 === e3.addresses.length && 0 === e3.code)
          throw new QD(xD.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", { retry: true, csIp: e3.detail && e3.detail[502] });
        if (null !== (t3 = e3.detail) && void 0 !== t3 && t3[19] && "string" == typeof (null === (i3 = e3.detail) || void 0 === i3 ? void 0 : i3[19])) {
          const t4 = e3.detail[19], i4 = null == t4 ? void 0 : t4.split(";");
          for (let t5 = 0; t5 < i4.length; t5++) {
            var r3;
            const n3 = Gb(r3 = i4[t5]).call(r3);
            e3.addresses[t5] && i4 && (e3.addresses[t5].fingerprint = n3);
          }
        }
        if (LP("GATEWAY_ADDRESS") && LP("GATEWAY_ADDRESS").length > 0) {
          JD.debug("assign gateway address to", LP("GATEWAY_ADDRESS")), hP("debug", ["AjaxAPI"], "assign gateway address to ".concat(JSON.stringify(LP("GATEWAY_ADDRESS"))));
          const t4 = LP("GATEWAY_ADDRESS").map((t5) => {
            var i4, r4;
            const n3 = null !== (i4 = null === (r4 = e3.addresses.find((e4) => e4.ip === t5.ip && e4.port === t5.port)) || void 0 === r4 ? void 0 : r4.fingerprint) && void 0 !== i4 ? i4 : "";
            return { ip: t5.ip, port: t5.port, ticket: e3.addresses[0] && e3.addresses[0].ticket, fingerprint: n3 };
          });
          e3.addresses = t4;
        }
      }, Tq = (e3, t3) => {
        if (e3.response_body && e3.response_body.length) {
          const t4 = e3.response_body[0];
          if (0 !== t4.buffer.code) {
            const e4 = DJ(t4.buffer.code);
            throw new QD(xD.UPDATE_TICKET_FAILED, "[".concat(t4.buffer.code, "]: ").concat(e4.desc), { retry: e4.retry });
          }
          return t4.buffer.ticket;
        }
        throw JD.debug("update ticket request received ap response without response body:", t3), hP("debug", ["AjaxAPI"], "update ticket request received ap response without response body: ".concat(t3)), new QD(xD.UPDATE_TICKET_FAILED, "cannot find response body from ap response", { retry: false });
      }, Rq = (e3, t3, i3) => {
        const r3 = Math.floor(Math.random() * 10 ** 12), n3 = { appid: e3.appId, client_ts: Date.now(), opid: r3, sid: e3.sid, request_bodies: [{ uri: 22, buffer: { cname: e3.cname, detail: { 6: e3.stringUid, 11: t3, 12: LP("USE_NEW_TOKEN") ? "1" : void 0 }, key: e3.token, service_ids: i3, uid: e3.uid || 0 } }] };
        n3.request_bodies.forEach((t4) => {
          e3.multiIP && e3.multiIP.gateway_ip && (t4.buffer.detail[5] = JSON.stringify({ vocs_ip: [e3.multiIP.uni_lbs_ip], vos_ip: [e3.multiIP.gateway_ip] }));
        });
        const o3 = new FormData();
        return o3.append("request", JSON.stringify(n3)), [o3, r3];
      }, yq = (e3, t3) => {
        const i3 = Math.floor(Math.random() * 10 ** 12), r3 = { appid: e3.appId, client_ts: Date.now(), opid: i3, sid: e3.sid, request_bodies: [{ uri: 28, buffer: { cname: e3.cname, detail: { 1: "", 6: e3.stringUid, 12: "1" }, token: e3.token, service_ids: t3, uid: e3.uid || 0, edges_services: e3.apResponse.addresses.map((e4) => ({ ip: e4.ip, port: e4.port })) } }] }, n3 = new FormData();
        return n3.append("request", JSON.stringify(r3)), [n3, i3];
      };
      let wq = 0;
      const bq = () => {
        const e3 = LP("AREAS");
        0 === e3.length && e3.push(nB.GLOBAL);
        return cc(e3).call(e3, (e4, t3, i3) => {
          const r3 = Nq(t3);
          return r3 ? 0 === i3 ? r3 : "".concat(e4, ",").concat(r3) : e4;
        }, "");
      }, Nq = (e3) => e3 === nB.OVERSEA ? "".concat(cB.ASIA, ",").concat(cB.EUROPE, ",").concat(cB.AFRICA, ",").concat(cB.NORTH_AMERICA, ",").concat(cB.SOUTH_AMERICA, ",").concat(cB.OCEANIA) : cB[e3], Oq = { GLOBAL: { ASIA: [nB.CHINA, nB.JAPAN, nB.INDIA, nB.KOREA, nB.HKMC], EUROPE: [], NORTH_AMERICA: [nB.US], SOUTH_AMERICA: [], OCEANIA: [], AFRICA: [] } }, Dq = Object.keys(Oq[nB.GLOBAL]), Pq = [nB.CHINA, nB.NORTH_AMERICA, nB.EUROPE, nB.ASIA, nB.JAPAN, nB.INDIA, nB.OCEANIA, nB.SOUTH_AMERICA, nB.AFRICA, nB.KOREA, nB.HKMC, nB.US], Lq = function(e3, t3) {
        let i3 = [];
        if (e3.includes(nB.GLOBAL)) {
          const o3 = [nB.GLOBAL, nB.OVERSEA], s3 = Object.keys(dB);
          if (t3 === nB.GLOBAL)
            throw new QD(xD.INVALID_PARAMS, "GLOBAL is an invalid excludedArea value");
          if (t3 === nB.CHINA)
            i3 = [nB.OVERSEA];
          else if (n3 = t3, Dq.includes(n3)) {
            const e4 = (r3 = t3, Oq[nB.GLOBAL][r3] || []), n4 = [...o3, t3, ...e4];
            i3 = s3.filter((e5) => !n4.includes(e5));
          } else if (function(e4) {
            let t4 = false;
            return Dq.forEach((i4) => {
              Oq[nB.GLOBAL][i4].includes(e4) && (t4 = true);
            }), t4;
          }(t3)) {
            const e4 = function(e5) {
              let t4;
              return Dq.forEach((i4) => {
                Oq[nB.GLOBAL][i4].includes(e5) && (t4 = i4);
              }), t4;
            }(t3), r4 = [...o3, e4, t3];
            i3 = s3.filter((e5) => !r4.includes(e5));
          } else
            i3 = e3;
          i3 = function(e4) {
            const t4 = [];
            return Pq.forEach((i4) => {
              e4.includes(i4) && t4.push(i4);
            }), t4.concat(e4.filter((e5) => !Pq.includes(e5)));
          }(i3);
        } else
          i3 = e3;
        var r3, n3;
        return i3;
      };
      async function kq(e3, t3, i3, r3) {
        const n3 = async function(e4, t4, i4, r4) {
          let n4 = null;
          const o3 = [], s3 = async () => {
            const n5 = LP("WEBCS_DOMAIN").slice(0, LP("AJAX_REQUEST_CONCURRENT")).map((t5) => ({ url: e4.proxyServer ? "https://".concat(e4.proxyServer, "/ap/?url=").concat(t5 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t5, "/api/v2/transpond/webrtc?v=2"), areaCode: bq() })), s4 = r4.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: n5.map((e5) => e5.url) }), a4 = await UK({ fragementLength: LP("FRAGEMENT_LENGTH"), referenceList: n5, asyncMapHandler: (r5) => (JD.debug("[".concat(e4.clientId, "] Connect to choose_server:"), r5.url), _q(r5, e4, t4, i4)), allFailedhandler: (e5) => {
              throw r4.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e5 }, s4), e5[0];
            }, promisesCollector: o3 });
            return r4.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s4), a4;
          }, a3 = async () => {
            if (await EK(1e3), null !== n4)
              return n4;
            const s4 = LP("WEBCS_DOMAIN_BACKUP_LIST").map((t5) => ({ url: e4.proxyServer ? "https://".concat(e4.proxyServer, "/ap/?url=").concat(t5 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t5, "/api/v2/transpond/webrtc?v=2"), areaCode: bq() })), a4 = r4.recordJoinChannelService({ endTs: void 0, startTs: Date.now(), status: "pending", service: "chooseServer", urls: s4.map((e5) => e5.url) }), c3 = await UK({ fragementLength: LP("FRAGEMENT_LENGTH"), referenceList: s4, asyncMapHandler: (r5) => (JD.debug("[".concat(e4.clientId, "] Connect to backup choose_server:"), r5.url), _q(r5, e4, t4, i4)), allFailedhandler: (e5) => {
              throw r4.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e5 }, a4), e5[0];
            }, promisesCollector: o3 });
            return r4.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a4), c3;
          };
          try {
            return n4 = await SK([s3(), a3()]), o3.length && o3.forEach((e5) => e5.cancel && "function" == typeof e5.cancel && e5.cancel()), n4;
          } catch (e5) {
            throw e5[0];
          }
        }(e3, t3, i3, r3);
        return { gatewayInfo: await n3 };
      }
      async function Bq(e3, t3, i3, r3, n3) {
        const o3 = e3.cloudProxyServer;
        if ("disabled" === o3) {
          if (!r3)
            return;
          if (e3.useLocalAccessPoint)
            return await kq(e3, t3, i3, n3);
          if (LP("JOIN_WITH_FALLBACK_MEDIA_PROXY")) {
            const { gatewayInfo: r4, proxyInfo: o4 } = await xq(e3, t3, i3, n3);
            return e3.turnServer && "auto" !== e3.turnServer.mode ? (hP("debug", ["Server", e3.clientId], "do not set fallback turn because of already having turnserver"), { gatewayInfo: r4 }) : (e3.turnServer = { mode: "manual", servers: o4.map((e4) => ({ turnServerURL: e4.address, tcpport: e4.tcpport || vP.tcpport, udpport: e4.udpport || vP.udpport, username: e4.username || vP.username, password: e4.password || vP.password, forceturn: LP("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE"), security: true })) }, { gatewayInfo: r4 });
          }
          return await kq(e3, t3, i3, n3);
        }
        const { proxyInfo: s3, gatewayInfo: a3 } = await xq(e3, t3, i3, n3), c3 = { gatewayInfo: a3 };
        return e3.turnServer = { mode: "manual", servers: s3.map((e4) => ({ turnServerURL: e4.address, tcpport: "proxy3" === o3 ? void 0 : e4.tcpport ? e4.tcpport : vP.tcpport, udpport: "proxy4" === o3 ? void 0 : e4.udpport ? e4.udpport : vP.udpport, username: e4.username || vP.username, password: e4.password || vP.password, forceturn: "proxy4" !== o3, security: "proxy5" === o3 })) }, JD.debug("[".concat(e3.clientId, "] set proxy server: ").concat(e3.proxyServer, ", mode: ").concat(o3)), gP("debug", ["Server", e3.clientId], "setCloudProxyServerAndGetServerInfo", { proxyServer: e3.proxyServer, mode: e3.cloudProxyServer }), c3;
      }
      async function Mq(e3, t3, i3, r3, n3) {
        const o3 = LP("ACCOUNT_REGISTER").slice(0, LP("AJAX_REQUEST_CONCURRENT"));
        let s3 = [];
        s3 = t3.proxyServer ? o3.map((e4) => "https://".concat(t3.proxyServer, "/ap/?url=").concat(e4 + "/api/v1")) : o3.map((e4) => "https://".concat(e4, "/api/v1"));
        const a3 = null == n3 ? void 0 : n3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "stringUID", urls: s3 });
        try {
          const o4 = await async function(e4, t4, i4, r4, n4) {
            const o5 = Date.now(), s4 = { sid: i4.sid, opid: 10, appid: i4.appId, string_uid: t4 };
            let a4 = e4[0];
            const c3 = await jD(() => ej(a4 + "".concat(-1 === a4.indexOf("?") ? "?" : "&", "action=stringuid"), { data: s4, cancelToken: r4, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } }), (i5, r5) => {
              if (0 === i5.code) {
                if (i5.uid <= 0 || i5.uid >= Math.pow(2, 32))
                  throw JD.error("Invalid Uint Uid ".concat(t4, " => ").concat(i5.uid), i5), gP("error", ["AjaxAPI"], "requestUserAccount", "Invalid Uint Uid ".concat(t4, " => ").concat(i5.uid, ", ").concat(i5)), pj.reqUserAccount(s4.sid, { lts: o5, success: false, serverAddr: a4, stringUid: s4.string_uid, uid: i5.uid, errorCode: xD.INVALID_UINT_UID_FROM_STRING_UID, extend: s4 }), new QD(xD.INVALID_UINT_UID_FROM_STRING_UID);
                return pj.reqUserAccount(s4.sid, { lts: o5, success: true, serverAddr: a4, stringUid: s4.string_uid, uid: i5.uid, errorCode: null, extend: s4 }), false;
              }
              const n5 = DJ(i5.code);
              return n5.retry && (a4 = e4[(r5 + 1) % e4.length]), pj.reqUserAccount(s4.sid, { lts: o5, success: false, serverAddr: a4, stringUid: s4.string_uid, uid: i5.uid, errorCode: n5.desc, extend: s4 }), n5.retry;
            }, (t5, i5) => t5.code !== xD.OPERATION_ABORTED && (pj.reqUserAccount(s4.sid, { lts: o5, success: false, serverAddr: a4, stringUid: s4.string_uid, uid: null, errorCode: t5.code, extend: s4 }), a4 = e4[(i5 + 1) % e4.length], true), n4);
            if (0 !== c3.code) {
              const e5 = DJ(c3.code);
              throw new QD(xD.UNEXPECTED_RESPONSE, e5.desc);
            }
            return c3;
          }(s3, e3, t3, i3, r3);
          return null == n3 || n3.recordJoinChannelService({ status: "success", endTs: Date.now() }, a3), o4.uid;
        } catch (e4) {
          throw null == n3 || n3.recordJoinChannelService({ status: "error", endTs: Date.now(), errors: [e4] }, a3), e4;
        }
      }
      async function Uq(e3, t3, i3) {
        const r3 = LP("CDS_AP").slice(0, LP("AJAX_REQUEST_CONCURRENT")).map((t4) => e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v1") : "https://".concat(t4, "/api/v1?action=config")).map((r4) => function(e4, t4, i4, r5) {
          const n4 = oN(), o4 = { flag: 64, cipher_method: 0, features: { device: n4.name, system: n4.os, system_general: navigator.userAgent, vendor: t4.appId, version: CP, cname: t4.cname, sid: t4.sid, session_id: t4.sid, detail: "", proxyServer: t4.proxyServer } };
          return jD(() => ej(e4, { data: o4, timeout: 1e3, cancelToken: i4, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 54 } }), void 0, (e5) => e5.code !== xD.OPERATION_ABORTED, r5);
        }(r4, e3, t3, i3));
        let n3 = null, o3 = null, s3 = {};
        try {
          n3 = await SK(r3);
        } catch (e4) {
          if (e4.code === xD.OPERATION_ABORTED)
            throw e4;
          o3 = e4;
        }
        r3.forEach((e4) => e4.cancel());
        if (pj.reportApiInvoke(e3.sid, { name: rk.REQUEST_CONFIG_DISTRIBUTE, options: { error: o3, res: n3 } }).onSuccess(), n3 && n3.test_tags)
          try {
            s3 = function(e4) {
              if (!e4.test_tags)
                return {};
              const t4 = e4.test_tags, i4 = Object.keys(t4), r4 = {};
              return i4.forEach((e5) => {
                var i5;
                const n4 = Gb(i5 = e5.slice(4)).call(i5), o4 = JSON.parse(t4[e5])[1];
                r4[n4] = o4;
              }), r4;
            }(n3);
          } catch (e4) {
          }
        return s3;
      }
      async function xq(e3, t3, i3, r3) {
        const n3 = LP("PROXY_SERVER_TYPE3"), o3 = (e4, t4, i4) => {
          let r4 = i4 || n3;
          return Array.isArray(r4) && (r4 = t4 % 2 == 0 ? n3[1] : n3[0]), "https://".concat(r4, "/ap/?url=").concat(e4);
        };
        let s3 = null;
        const a3 = [], c3 = async () => {
          const n4 = LP("WEBCS_DOMAIN").slice(0, LP("AJAX_REQUEST_CONCURRENT")).map((t4, i4) => {
            let r4;
            return r4 = "disabled" === e3.cloudProxyServer && e3.proxyServer ? o3("".concat(t4, "/api/v2/transpond/webrtc?v=2"), i4, e3.proxyServer) : "disabled" === e3.cloudProxyServer || "fallback" === e3.cloudProxyServer ? "https://".concat(t4, "/api/v2/transpond/webrtc?v=2") : o3("".concat(t4, "/api/v2/transpond/webrtc?v=2"), i4), { url: r4, areaCode: bq(), serviceIds: [NF.CHOOSE_SERVER, "proxy5" === e3.cloudProxyServer ? NF.CLOUD_PROXY_5 : "proxy3" === e3.cloudProxyServer || "proxy4" === e3.cloudProxyServer ? NF.CLOUD_PROXY : NF.CLOUD_PROXY_FALLBACK] };
          }), s4 = r3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: n4.map((e4) => e4.url) }), c4 = await UK({ fragementLength: LP("FRAGEMENT_LENGTH"), referenceList: n4, asyncMapHandler: (r4) => (JD.debug("[".concat(e3.clientId, "] Connect to choose_server:"), r4.url), Cq(r4, e3, t3, i3)), allFailedhandler: (e4) => {
            throw r3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, s4), e4[0];
          }, promisesCollector: a3 });
          return r3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s4), c4;
        }, d3 = async () => {
          if (await EK(1e3), null !== s3)
            return s3;
          const n4 = LP("WEBCS_DOMAIN_BACKUP_LIST").map((t4, i4) => {
            let r4;
            return r4 = "disabled" === e3.cloudProxyServer && e3.proxyServer ? o3("".concat(t4, "/api/v2/transpond/webrtc?v=2"), i4, e3.proxyServer) : "disabled" === e3.cloudProxyServer || "fallback" === e3.cloudProxyServer ? "https://".concat(t4, "/api/v2/transpond/webrtc?v=2") : o3("".concat(t4, "/api/v2/transpond/webrtc?v=2"), i4), { url: r4, areaCode: bq(), serviceIds: [NF.CHOOSE_SERVER, "proxy5" === e3.cloudProxyServer ? NF.CLOUD_PROXY_5 : "proxy3" === e3.cloudProxyServer || "proxy4" === e3.cloudProxyServer ? NF.CLOUD_PROXY : NF.CLOUD_PROXY_FALLBACK] };
          }), c4 = r3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: n4.map((e4) => e4.url) }), d4 = await UK({ fragementLength: LP("FRAGEMENT_LENGTH"), referenceList: n4, asyncMapHandler: (r4) => (JD.debug("[".concat(e3.clientId, "] Connect to backup choose_server:"), r4.url), Cq(r4, e3, t3, i3)), allFailedhandler: (e4) => {
            throw r3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, c4), e4[0];
          }, promisesCollector: a3 });
          return r3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c4), d4;
        };
        let u3, h3, A3;
        try {
          ({ gatewayInfo: u3, proxyInfo: h3, url: A3 } = await SK([c3(), d3()]));
        } catch (e4) {
          throw e4[0];
        }
        if (a3.length && a3.forEach((e4) => e4.cancel && "function" == typeof e4.cancel && e4.cancel()), !u3 || !h3)
          throw new QD(xD.UNEXPECTED_ERROR, "missing gateway or proxy response").print();
        if (e3.apUrl = A3, "disabled" !== e3.cloudProxyServer && Array.isArray(n3) && A3) {
          const t4 = new NJ(A3).host;
          n3.includes(t4) && (e3.proxyServer = t4, JD.setProxyServer(t4), pj.setProxyServer(t4), uP(t4));
        }
        return s3 = { gatewayInfo: u3, proxyInfo: await uK(h3, u3.uid) }, s3;
      }
      async function Qq(e3, t3, i3, r3) {
        const n3 = LP("UAP_AP").slice(0, LP("AJAX_REQUEST_CONCURRENT")).map((e4) => t3.proxyServer ? "https://".concat(t3.proxyServer, "/ap/?url=").concat(e4 + "/api/v1?action=uap") : "https://".concat(e4, "/api/v1?action=uap"));
        return await mq(n3, e3, t3, i3, r3);
      }
      async function Fq(e3, t3, i3) {
        const r3 = LP("UAP_AP").slice(0, LP("AJAX_REQUEST_CONCURRENT")).map((t4) => e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v1?action=uap") : "https://".concat(t4, "/api/v1?action=uap")).map((r4) => function(e4, t4, i4, r5) {
          const n3 = { command: "convergeAllocateEdge", sid: t4.sid, appId: t4.appId, token: t4.token, ts: Date.now(), version: CP, cname: t4.cname, uid: t4.uid.toString(), requestId: Iq, seq: Iq };
          Iq += 1;
          const o3 = { service_name: "tele_channel", json_body: JSON.stringify(n3) };
          return jD(async () => {
            const t5 = await ej(e4, { data: o3, cancelToken: i4, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 61 } });
            if (0 !== t5.code) {
              const e5 = new QD(xD.UNEXPECTED_RESPONSE, "cross channel ap error, code" + t5.code, { retry: true });
              throw JD.error(e5.toString()), gP("error", ["AjaxAPI"], "requestChannelMediaRelayWorkerManager", void 0, e5.toString()), e5;
            }
            const r6 = JSON.parse(t5.json_body);
            if (200 !== r6.code) {
              const e5 = new QD(xD.UNEXPECTED_RESPONSE, "cross channel app center error, code: ".concat(r6.code, ", reason: ").concat(r6.reason));
              throw JD.error(e5.toString()), gP("error", ["AjaxAPI"], "requestChannelMediaRelayWorkerManager", void 0, e5.toString()), e5;
            }
            if (!r6.servers || 0 === r6.servers.length) {
              const e5 = new QD(xD.UNEXPECTED_RESPONSE, "cross channel app center empty server");
              throw JD.error(e5.toString()), gP("error", ["AjaxAPI"], "requestChannelMediaRelayWorkerManager", void 0, e5.toString()), e5;
            }
            return { vid: r6.vid, workerToken: r6.workerToken, addressList: r6.servers.map((e5) => "wss://".concat(e5.address.replace(/\./g, "-"), ".").concat(LP("WORKER_DOMAIN"), ":").concat(e5.wss)) };
          }, void 0, (e5) => !!(e5.code !== xD.OPERATION_ABORTED && e5.code !== xD.UNEXPECTED_RESPONSE || e5.data && e5.data.retry), r5);
        }(r4, e3, t3, i3));
        try {
          const e4 = await SK(r3);
          return r3.forEach((e5) => e5.cancel()), e4;
        } catch (e4) {
          throw e4[0];
        }
      }
      async function Vq(e3, t3, i3) {
        let r3 = null;
        const n3 = [], o3 = async (o4) => {
          const s3 = LP(o4 ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map((t4) => e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"));
          return o4 && (await EK(1e3), null !== r3) ? r3 : await UK({ fragementLength: LP("FRAGEMENT_LENGTH"), referenceList: s3, asyncMapHandler: (r4) => (JD.debug("[".concat(e3.clientId, "] update ticket, Connect to ").concat(o4 ? "backup" : "", " choose_server:"), r4), function(e4, t4, i4, r5) {
            const [n4] = yq(t4, [NF.CHOOSE_SERVER]);
            let o5 = ij.networkState;
            return jD(async () => {
              o5 && ij.networkState === EB.OFFLINE && ij.onlineWaiter && await l_.race([ij.onlineWaiter, EK(r5 && r5.maxRetryTimeout || FD.maxRetryTimeout)]), o5 = ij.networkState;
              const t5 = await ej(e4, { data: n4, cancelToken: i4, headers: { "Content-Type": "multipart/form-data;" } }, true);
              return Tq(t5, e4);
            }, () => false, (e5) => e5.code !== xD.OPERATION_ABORTED && (e5.code === xD.UPDATE_TICKET_FAILED ? e5.data.retry : (JD.warning("[".concat(t4.clientId, "] update ticket network error, retry"), e5), hP("warning", ["AjaxAPI", t4.clientId], "update ticket network error, retry, ".concat(e5)), true)), r5);
          }(r4, e3, t3, i3)), allFailedhandler: (e4) => {
            throw e4[0];
          }, promisesCollector: n3 });
        };
        try {
          return r3 = await SK([o3(false), o3(true)]), n3.length && n3.forEach((e4) => e4.cancel && "function" == typeof e4.cancel && e4.cancel()), r3;
        } catch (e4) {
          throw e4[0];
        }
      }
      var jq;
      function Gq(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function Kq(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? Gq(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : Gq(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      let Hq = mP("ConfigDistributeManager")(jq = class extends MD {
        constructor() {
          super(), MN(this, "configs", void 0), MN(this, "joinInfo", void 0), MN(this, "cancelToken", void 0), MN(this, "retryConfig", { timeout: 3e3, timeoutFactor: 1.5, maxRetryCount: 1, maxRetryTimeout: 1e4 }), MN(this, "interval", void 0), MN(this, "mutex", new fj("config-distribute")), MN(this, "mutableParamsRead", false);
        }
        startGetConfigDistribute(e3, t3) {
          this.joinInfo = e3, this.cancelToken = t3, this.interval && this.stopGetConfigDistribute(), LP("ENABLE_CONFIG_DISTRIBUTE") && (this.updateConfigDistribute(), this.interval = window.setInterval(() => {
            this.updateConfigDistribute();
          }, LP("CONFIG_DISTRIBUTE_INTERVAL")));
        }
        stopGetConfigDistribute() {
          this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0;
        }
        async awaitConfigDistributeComplete() {
          if (!this.mutex.isLocked)
            return;
          (await this.mutex.lock())();
        }
        async updateConfigDistribute() {
          if (!this.mutableParamsRead) {
            this.mutableParamsRead = true;
            pj.reportApiInvoke(null, { options: void 0, name: rk.LOAD_CONFIG_FROM_LOCALSTORAGE, tag: nk.TRACER }).onSuccess(JSON.stringify(BP));
          }
          if (!this.joinInfo || !this.cancelToken || !this.retryConfig)
            return JD.debug("[config-distribute] get config distribute interrupted have no joininfo"), void gP("debug", this, "updateConfigDistribute", void 0, "get config distribute interrupted have no joininfo");
          let e3;
          const t3 = await this.mutex.lock();
          try {
            e3 = await Uq(this.joinInfo, this.cancelToken, this.retryConfig), JD.debug("[config-distribute] get config distribute", JSON.stringify(e3)), gP("debug", this, "updateConfigDistribute", e3), e3.limit_bitrate && this.handleBitrateLimit(e3.limit_bitrate), this.cacheGlobalParameterConfig(e3), this.configs = e3;
          } catch (e4) {
            const t4 = new QD(xD.NETWORK_RESPONSE_ERROR, e4);
            JD.warning("[config-distribute] ".concat(t4.toString())), gP("warning", this, "updateConfigDistribute", void 0, e4.toString());
          } finally {
            t3();
          }
        }
        getBitrateLimit() {
          return this.configs ? this.configs.limit_bitrate : void 0;
        }
        handleBitrateLimit(e3) {
          var t3;
          (t3 = e3) && t3.uplink && t3.id && void 0 !== t3.uplink.max_bitrate && void 0 !== t3.uplink.min_bitrate && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== e3.id && this.emit(uB.UPDATE_BITRATE_LIMIT, e3) : this.emit(uB.UPDATE_BITRATE_LIMIT, e3));
        }
        getLowStreamConfigDistribute() {
          return this.configs && this.configs.limit_bitrate && Kq({}, this.configs.limit_bitrate.low_stream_uplink);
        }
        cacheGlobalParameterConfig(e3) {
          var t3;
          const i3 = kL(t3 = Object.keys(e3).filter((e4) => /^webrtc_ng_global_parameter/.test(e4))).call(t3);
          for (let t4 = 0; t4 < i3.length; t4++)
            for (let r4 = i3.length - 1; r4 > t4; r4--) {
              const t5 = i3[r4];
              if ("number" == typeof e3[t5].__priority) {
                const n3 = e3[t5].__priority, o3 = i3[r4 - 1];
                if ("number" == typeof e3[o3].__priority) {
                  if (!(n3 > e3[o3].__priority))
                    continue;
                  {
                    const e4 = t5;
                    i3[r4] = i3[r4 - 1], i3[r4 - 1] = e4;
                  }
                } else {
                  const e4 = t5;
                  i3[r4] = i3[r4 - 1], i3[r4 - 1] = e4;
                }
              }
            }
          const r3 = {};
          i3.forEach((t4) => {
            const i4 = e3[t4], n3 = i4.__expires;
            Object.keys(i4).forEach((e4) => {
              "__priority" === e4 || "__expires" === e4 || Object.prototype.hasOwnProperty.call(r3, e4) || (r3[e4] = Kq({ value: i4[e4] }, n3 && { expires: n3 }));
            });
          });
          try {
            const e4 = JSON.stringify(r3), t4 = window.btoa(e4);
            window.localStorage.setItem("websdk_ng_global_parameter", t4), JD.debug("Caching global parameters ".concat(e4)), gP("debug", this, "cacheGlobalParameterConfig", e4);
          } catch (e4) {
            JD.error("Error caching global parameters:", e4.message), gP("error", this, "cacheGlobalParameterConfig", void 0, e4.message);
          }
        }
      }) || jq;
      function Wq(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function Yq(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? Wq(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : Wq(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      class Jq extends MD {
        constructor(e3, t3, i3, r3) {
          super(), MN(this, "spec", void 0), MN(this, "token", void 0), MN(this, "websocket", void 0), MN(this, "pingpongTimer", void 0), MN(this, "reconnectMode", "retry"), MN(this, "serviceMode", void 0), MN(this, "reqId", 0), MN(this, "commandReqId", 0), MN(this, "handleWebSocketOpen", () => {
            this.reconnectMode = "retry", this.startPingPong();
          }), MN(this, "handleWebSocketMessage", (e4) => {
            if (!e4.data)
              return;
            const t4 = JSON.parse(e4.data);
            t4.requestId ? this.emit("@".concat(t4.requestId, "-").concat(t4.sid), t4) : this.serviceMode === kk.INJECT ? this.emit(Vk.INJECT_STREAM_STATUS, t4) : (pj.workerEvent(this.spec.sid, { actionType: "status", serverCode: t4.code, workerType: this.serviceMode === kk.TRANSCODE ? 1 : 2 }), this.emit(Vk.PUBLISH_STREAM_STATUS, t4));
          }), this.spec = t3, this.token = e3, this.serviceMode = r3, this.websocket = new qJ("live-streaming", i3), this.websocket.on(Lk.CONNECTED, this.handleWebSocketOpen), this.websocket.on(Lk.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(Lk.REQUEST_NEW_URLS, (e4, t4) => {
            vK(this, Vk.REQUEST_NEW_ADDRESS).then(e4).catch(t4);
          }), this.websocket.on(Lk.RECONNECTING, () => {
            this.websocket.reconnectMode = this.reconnectMode;
          });
        }
        init(e3) {
          return this.websocket.init(e3);
        }
        async request(e3, t3, i3, r3) {
          this.reqId += 1, "request" === e3 && (this.commandReqId += 1);
          const n3 = this.commandReqId, o3 = this.reqId;
          if (!o3 || !this.websocket)
            throw new QD(xD.UNEXPECTED_ERROR);
          const s3 = Yq({ command: e3, sdkVersion: "4.15.0" === CP ? "0.0.1" : CP, seq: o3, requestId: o3, allocate: i3, cname: this.spec.cname, appId: this.spec.appId, sid: this.spec.sid, uid: this.spec.uid.toString(), ts: Math.floor(Date.now() / 1e3) }, t3);
          if ("closed" === this.websocket.state)
            throw new QD(xD.WS_DISCONNECT);
          const a3 = () => new l_((e4, t4) => {
            this.websocket.once(Lk.CLOSED, () => t4(new QD(xD.WS_ABORT))), this.websocket.once(Lk.CONNECTED, e4);
          });
          "connected" !== this.websocket.state && await a3(), s3.clientRequest && (s3.clientRequest.workerToken = this.token);
          const c3 = new l_((e4, t4) => {
            const i4 = () => {
              t4(new QD(xD.WS_ABORT));
            };
            this.websocket.once(Lk.RECONNECTING, i4), this.websocket.once(Lk.CLOSED, i4), this.once("@".concat(o3, "-").concat(this.spec.sid), (t5) => {
              e4(t5);
            });
          });
          r3 && pj.workerEvent(this.spec.sid, Yq(Yq({}, r3), {}, { requestId: n3, actionType: "request", payload: JSON.stringify(t3.clientRequest), serverCode: 0, code: 0 }));
          const d3 = Date.now();
          this.websocket.sendMessage(s3);
          let u3 = null;
          try {
            u3 = await c3;
          } catch (r4) {
            if ("closed" === this.websocket.state)
              throw r4;
            return await a3(), await this.request(e3, t3, i3);
          }
          return r3 && pj.workerEvent(this.spec.sid, Yq(Yq({}, r3), {}, { requestId: n3, actionType: "response", payload: JSON.stringify(u3.serverResponse), serverCode: u3.code, success: 200 === u3.code, responseTime: Date.now() - d3 })), 200 !== u3.code && this.handleResponseError(u3), u3;
        }
        tryNextAddress() {
          this.reconnectMode = "tryNext", this.websocket.reconnect("tryNext");
        }
        close() {
          const e3 = "4.15.0" === CP ? "0.0.1" : CP;
          this.reqId += 1, "connected" === this.websocket.state ? (this.websocket.sendMessage({ command: "request", appId: this.spec.appId, cname: this.spec.cname, uid: this.spec.uid.toString(), sdkVersion: e3, sid: this.spec.sid, seq: this.reqId, ts: Math.floor(Date.now() / 1e3), requestId: this.reqId, clientRequest: { command: "DestroyWorker" } }), this.websocket.close(false, true)) : this.websocket.close(false), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);
        }
        handleResponseError(e3) {
          switch (e3.code) {
            case Gk.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:
              return void JD.warning("live stream response already exists stream");
            case Gk.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:
            case Gk.LIVE_STREAM_RESPONSE_BAD_STREAM:
            case Gk.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:
              return new QD(xD.LIVE_STREAMING_INVALID_ARGUMENT, "", { code: e3.code }).throw();
            case Gk.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:
              if ("UnpublishStream" === e3.serverResponse.command || "UninjectStream" === e3.serverResponse.command)
                return;
              throw new QD(xD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case Gk.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:
              return new QD(xD.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", { code: e3.code }).throw();
            case Gk.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const t3 = new QD(xD.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);
              return this.emit(Vk.WARNING, t3, e3.serverResponse.url);
            }
            case Gk.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN: {
              const t3 = new QD(xD.LIVE_STREAMING_WARN_FREQUENT_REQUEST);
              return this.emit(Vk.WARNING, t3, e3.serverResponse.url);
            }
            case Gk.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:
              throw new QD(xD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case Gk.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:
              return new QD(xD.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", { code: e3.code }).throw();
            case Gk.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM: {
              const t3 = new QD(xD.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);
              return this.emit(Vk.WARNING, t3, e3.serverResponse.url);
            }
            case Gk.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:
              return new QD(xD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e3.code }).throw();
            case Gk.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:
              throw new QD(xD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", { retry: true, changeAddress: true });
            case Gk.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case Gk.LIVE_STREAM_RESPONSE_WORKER_QUIT:
              if ("UnpublishStream" === e3.serverResponse.command || "UninjectStream" === e3.serverResponse.command)
                return;
              throw new QD(xD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case Gk.ERROR_FAIL_SEND_MESSAGE:
              if ("UnpublishStream" === e3.serverResponse.command || "UninjectStream" === e3.serverResponse.command)
                return;
              if ("UpdateTranscoding" === e3.serverResponse.command || "ControlStream" === e3.serverResponse.command)
                return new QD(xD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { code: e3.code }).throw();
              throw new QD(xD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case Gk.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case Gk.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case Gk.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case Gk.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
              return new QD(xD.LIVE_STREAMING_CDN_ERROR, "", { code: e3.code }).throw();
          }
        }
        startPingPong() {
          this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(() => {
            "connected" === this.websocket.state && this.request("ping", {}).catch(_K);
          }, 6e3);
        }
      }
      function qq(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function Xq(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? qq(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : qq(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      class zq extends MD {
        constructor(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : FD, i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : FD;
          super(), MN(this, "onLiveStreamWarning", void 0), MN(this, "onLiveStreamError", void 0), MN(this, "onInjectStatusChange", void 0), MN(this, "spec", void 0), MN(this, "retryTimeout", 1e4), MN(this, "connection", void 0), MN(this, "httpRetryConfig", void 0), MN(this, "wsRetryConfig", void 0), MN(this, "streamingTasks", /* @__PURE__ */ new Map()), MN(this, "isStartingStreamingTask", false), MN(this, "taskMutex", new fj("live-streaming")), MN(this, "cancelToken", kD.CancelToken.source()), MN(this, "transcodingConfig", void 0), MN(this, "injectConfig", Xq({}, Fk)), MN(this, "injectLoopTimes", 0), MN(this, "uapResponse", void 0), MN(this, "lastTaskId", 1), MN(this, "statusError", /* @__PURE__ */ new Map()), this.spec = e3, this.httpRetryConfig = i3, this.wsRetryConfig = t3;
        }
        async setTranscodingConfig(e3) {
          const t3 = Xq(Xq({}, Qk), e3);
          66 !== t3.videoCodecProfile && 77 !== t3.videoCodecProfile && 100 !== t3.videoCodecProfile && (JD.debug("[".concat(this.spec.clientId, "] set transcoding config, fix video codec profile: ").concat(t3.videoCodecProfile, " -> 100")), t3.videoCodecProfile = 100), t3.transcodingUsers || (t3.transcodingUsers = t3.userConfigs), t3.transcodingUsers && (t3.transcodingUsers = t3.transcodingUsers.map((e4) => Xq(Xq(Xq({}, Mk), e4), {}, { zOrder: e4.zOrder ? e4.zOrder + 1 : 1 }))), function(e4) {
            GL(e4.width) || UL(e4.width, "config.width", 0, 1e4), GL(e4.height) || UL(e4.height, "config.height", 0, 1e4), GL(e4.videoBitrate) || UL(e4.videoBitrate, "config.videoBitrate", 1, 1e6), GL(e4.videoFrameRate) || UL(e4.videoFrameRate, "config.videoFrameRate"), GL(e4.lowLatency) || BL(e4.lowLatency, "config.lowLatency"), GL(e4.audioSampleRate) || ML(e4.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), GL(e4.audioBitrate) || UL(e4.audioBitrate, "config.audioBitrate", 1, 128), GL(e4.audioChannels) || ML(e4.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]), GL(e4.videoGop) || UL(e4.videoGop, "config.videoGop"), GL(e4.videoCodecProfile) || ML(e4.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]), GL(e4.userCount) || UL(e4.userCount, "config.userCount", 0, 17), GL(e4.backgroundColor) || UL(e4.backgroundColor, "config.backgroundColor", 0, 16777215), GL(e4.userConfigExtraInfo) || QL(e4.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, false), e4.transcodingUsers && !GL(e4.transcodingUsers) && (FL(e4.transcodingUsers, "config.transcodingUsers"), e4.transcodingUsers.forEach((e5, t4) => {
              jL(e5.uid), GL(e5.x) || UL(e5.x, "transcodingUser[".concat(t4, "].x"), 0, 1e4), GL(e5.y) || UL(e5.y, "transcodingUser[".concat(t4, "].y"), 0, 1e4), GL(e5.width) || UL(e5.width, "transcodingUser[".concat(t4, "].width"), 0, 1e4), GL(e5.height) || UL(e5.height, "transcodingUser[".concat(t4, "].height"), 0, 1e4), GL(e5.zOrder) || UL(e5.zOrder - 1, "transcodingUser[".concat(t4, "].zOrder"), 0, 100), GL(e5.alpha) || UL(e5.alpha, "transcodingUser[".concat(t4, "].alpha"), 0, 1, false);
            })), GL(e4.watermark) || xk(e4.watermark, "watermark"), GL(e4.backgroundImage) || xk(e4.backgroundImage, "backgroundImage"), e4.images && !GL(e4.images) && (FL(e4.images, "config.images"), e4.images.forEach((e5, t4) => {
              xk(e5, "images[".concat(t4, "]"));
            }));
          }(t3);
          const i3 = [];
          t3.images && i3.push(...t3.images.map((e4) => Xq(Xq(Xq({}, Uk), e4), {}, { zOrder: 255 }))), t3.backgroundImage && (i3.push(Xq(Xq(Xq({}, Uk), t3.backgroundImage), {}, { zOrder: 0 })), delete t3.backgroundImage), t3.watermark && (i3.push(Xq(Xq(Xq({}, Uk), t3.watermark), {}, { zOrder: 255 })), delete t3.watermark), t3.images = i3, t3.transcodingUsers && (t3.userConfigs = t3.transcodingUsers.map((e4) => Xq({}, e4)), t3.userCount = t3.transcodingUsers.length, delete t3.transcodingUsers);
          const r3 = (t3.userConfigs || []).map((e4) => "number" == typeof e4.uid ? l_.resolve(e4.uid) : Mq(e4.uid, this.spec, this.cancelToken.token, this.httpRetryConfig));
          if ((await l_.all(r3)).forEach((e4, i4) => {
            t3.userConfigs && t3.userConfigs[i4] && (t3.userConfigs[i4].uid = e4);
          }), this.transcodingConfig = t3, this.connection)
            try {
              var n3;
              const e4 = await this.connection.request("request", { clientRequest: { command: "UpdateTranscoding", transcodingConfig: this.transcodingConfig } }, false, { command: "UpdateTranscoding", workerType: 1, requestByUser: true, tid: Array.from(MG(n3 = this.streamingTasks).call(n3)).map((e5) => e5.taskId).join("#") });
              JD.debug("[".concat(this.spec.clientId, "] update live transcoding config success, code: ").concat(e4.code, ", config:"), JSON.stringify(this.transcodingConfig));
            } catch (e4) {
              if (!e4.data || !e4.data.retry)
                throw e4;
              e4.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach((t4) => {
                JD.warning("[".concat(this.spec.clientId, "] live streaming receive error"), e4.toString(), "try to republish", t4.url), this.startLiveStreamingTask(t4.url, t4.mode, e4).then(() => {
                  JD.debug("[".concat(this.spec.clientId, "] live streaming republish ").concat(t4.url, " success"));
                }).catch((e5) => {
                  JD.error("[".concat(this.spec.clientId, "] live streaming republish failed"), t4.url, e5.toString()), this.onLiveStreamError && this.onLiveStreamError(t4.url, e5);
                });
              });
            }
        }
        setInjectStreamConfig(e3, t3) {
          this.injectConfig = Object.assign({}, this.injectConfig, e3), this.injectLoopTimes = t3;
        }
        async startLiveStreamingTask(e3, t3, i3) {
          var r3;
          if (Array.from(MG(r3 = this.streamingTasks).call(r3)).find((e4) => e4.mode === kk.INJECT) && t3 === kk.INJECT)
            return new QD(xD.LIVE_STREAMING_TASK_CONFLICT, "inject stream over limit").throw();
          if (!this.transcodingConfig && t3 === kk.TRANSCODE)
            throw new QD(xD.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task");
          let n3 = { command: "PublishStream", ts: Date.now(), url: e3, uid: this.spec.uid.toString(), autoDestroyTime: 100, acceptImageTimeout: true };
          JD.debug("[".concat(this.spec.clientId, "] start live streaming ").concat(e3, ", mode: ").concat(t3));
          const o3 = await this.taskMutex.lock();
          if (!this.connection && i3)
            return void o3();
          if (this.streamingTasks.get(e3) && !i3)
            return o3(), new QD(xD.LIVE_STREAMING_TASK_CONFLICT).throw();
          try {
            this.connection || (this.connection = await this.connect(t3));
          } catch (e4) {
            throw o3(), e4;
          }
          switch (t3) {
            case kk.TRANSCODE:
              n3.transcodingConfig = Xq({}, this.transcodingConfig);
              break;
            case kk.RAW:
              break;
            case kk.INJECT:
              n3 = { cname: this.spec.cname, command: "InjectStream", sid: this.spec.sid, transcodingConfig: this.injectConfig, ts: Date.now(), url: e3, loopTimes: this.injectLoopTimes };
          }
          this.uapResponse && this.uapResponse.vid && (n3.vid = this.uapResponse.vid), this.isStartingStreamingTask = true;
          const s3 = this.lastTaskId++;
          try {
            const r4 = new l_((t4, r5) => {
              EK(this.retryTimeout).then(() => {
                if (i3)
                  return r5(i3);
                const t5 = this.statusError.get(e3);
                return t5 ? (this.statusError.delete(e3), r5(t5)) : void 0;
              });
            }), a3 = await l_.race([this.connection.request("request", { clientRequest: n3 }, true, { url: e3, command: "PublishStream", workerType: t3 === kk.TRANSCODE ? 1 : 2, requestByUser: !i3, tid: s3.toString() }), r4]);
            this.isStartingStreamingTask = false, JD.debug("[".concat(this.spec.clientId, "] live streaming started, code: ").concat(a3.code)), this.streamingTasks.set(e3, { clientRequest: n3, mode: t3, url: e3, taskId: s3 }), o3();
          } catch (r4) {
            if (o3(), this.isStartingStreamingTask = false, !r4.data || !r4.data.retry || i3)
              throw r4;
            return r4.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e3, t3, r4)) : await this.startLiveStreamingTask(e3, t3, r4);
          }
        }
        stopLiveStreamingTask(e3) {
          return new l_((t3, i3) => {
            const r3 = this.streamingTasks.get(e3);
            if (!r3 || !this.connection)
              return new QD(xD.UNEXPECTED_ERROR, "can not find streaming task to stop").throw();
            const n3 = r3.mode;
            r3.abortTask = () => {
              JD.debug("[".concat(this.spec.clientId, "] stop live streaming success(worker exception)")), this.streamingTasks.delete(e3), t3();
            }, this.connection.request("request", { clientRequest: { command: n3 === kk.INJECT ? "UninjectStream" : "UnpublishStream", url: r3.url } }, false, { url: e3, command: "UnPublishStream", workerType: n3 === kk.TRANSCODE ? 1 : 2, requestByUser: true, tid: (this.lastTaskId++).toString() }).then((i4) => {
              JD.debug("[".concat(this.spec.clientId, "] stop live streaming success, code: ").concat(i4.code)), this.streamingTasks.delete(e3), 0 === this.streamingTasks.size && n3 !== kk.INJECT && (this.connection && this.connection.close(), this.connection = void 0), t3(), n3 === kk.INJECT && this.onInjectStatusChange && this.onInjectStatusChange(Bk.INJECT_STREAM_STATUS_STOP_SUCCESS, this.spec.uid, e3);
            }).catch(i3);
          });
        }
        async controlInjectStream(e3, t3, i3, r3) {
          const n3 = this.streamingTasks.get(e3);
          if (!n3 || !this.connection || n3.mode !== kk.INJECT)
            throw new QD(xD.INVALID_OPERATION, "can not find inject stream task to control");
          return (await this.connection.request("request", { clientRequest: { command: "ControlStream", url: e3, control: t3, audioVolume: i3, position: r3 } })).serverResponse;
        }
        resetAllTask() {
          var e3;
          const t3 = Array.from(MG(e3 = this.streamingTasks).call(e3));
          this.terminate();
          for (const e4 of t3)
            this.startLiveStreamingTask(e4.url, e4.mode).catch((t4) => {
              this.onLiveStreamError && this.onLiveStreamError(e4.url, t4);
            });
        }
        terminate() {
          this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = /* @__PURE__ */ new Map(), this.isStartingStreamingTask = false, this.statusError = /* @__PURE__ */ new Map(), this.cancelToken = kD.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0;
        }
        async connect(e3) {
          if (this.connection)
            throw new QD(xD.UNEXPECTED_ERROR, "live streaming connection has already connected");
          const t3 = await vK(this, jk.REQUEST_WORKER_MANAGER_LIST, e3);
          return this.uapResponse = t3, this.connection = new Jq(t3.workerToken, this.spec, this.wsRetryConfig, e3), this.connection.on(Vk.WARNING, (e4, t4) => this.onLiveStreamWarning && this.onLiveStreamWarning(t4, e4)), this.connection.on(Vk.PUBLISH_STREAM_STATUS, (e4) => this.handlePublishStreamServer(e4)), this.connection.on(Vk.INJECT_STREAM_STATUS, (e4) => this.handleInjectStreamServerStatus(e4)), this.connection.on(Vk.REQUEST_NEW_ADDRESS, (t4, i3) => {
            if (!this.connection)
              return i3(new QD(xD.UNEXPECTED_ERROR, "can not get new live streaming address list"));
            vK(this, jk.REQUEST_WORKER_MANAGER_LIST, e3).then((e4) => {
              this.uapResponse = e4, t4(e4.addressList);
            }).catch(i3);
          }), await this.connection.init(t3.addressList), this.connection;
        }
        handlePublishStreamServer(e3) {
          const t3 = e3.serverStatus && e3.serverStatus.url || "empty_url", i3 = this.streamingTasks.get(t3), r3 = e3.reason;
          switch (e3.code) {
            case Gk.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case Gk.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case Gk.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case Gk.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: {
              const r4 = new QD(xD.LIVE_STREAMING_CDN_ERROR, "", { code: e3.code });
              if (i3)
                return JD.error(r4.toString()), this.onLiveStreamError && this.onLiveStreamError(t3, r4);
              if (!this.isStartingStreamingTask)
                return;
              this.statusError.set(t3, r4);
            }
            case Gk.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const e4 = new QD(xD.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, r3);
              return this.onLiveStreamWarning && this.onLiveStreamWarning(t3, e4);
            }
            case Gk.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case Gk.LIVE_STREAM_RESPONSE_WORKER_QUIT: {
              var n3;
              if (!this.connection)
                return;
              this.connection.tryNextAddress();
              const t4 = Array.from(MG(n3 = this.streamingTasks).call(n3));
              for (const i4 of t4)
                i4.abortTask ? i4.abortTask() : (JD.warning("[".concat(this.spec.clientId, "] publish stream status code"), e3.code, "try to republish", i4.url), this.startLiveStreamingTask(i4.url, i4.mode, new QD(xD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e3.code })).then(() => {
                  JD.debug("[".concat(this.spec.clientId, "] republish live stream success"), i4.url);
                }).catch((e4) => {
                  JD.error(e4.toString()), this.onLiveStreamError && this.onLiveStreamError(i4.url, e4);
                }));
              return;
            }
          }
        }
        handleInjectStreamServerStatus(e3) {
          const t3 = Number(e3.uid), i3 = e3.serverStatus && e3.serverStatus.url;
          switch (e3.code) {
            case 200:
              return void (this.onInjectStatusChange && this.onInjectStatusChange(Bk.INJECT_STREAM_STATUS_START_SUCCESS, t3, i3));
            case 451:
              return this.onInjectStatusChange && this.onInjectStatusChange(Bk.INJECT_STREAM_STATUS_START_ALREADY_EXISTS, t3, i3), void this.streamingTasks.delete(i3);
            case 453:
              return this.onInjectStatusChange && this.onInjectStatusChange(Bk.INJECT_STREAM_STATUS_START_UNAUTHORIZED, t3, i3), void this.streamingTasks.delete(i3);
            case 470:
              return this.onInjectStatusChange && this.onInjectStatusChange(Bk.INJECT_STREAM_STATUS_BROKEN, t3, i3), void this.streamingTasks.delete(i3);
            case 499:
              return this.onInjectStatusChange && this.onInjectStatusChange(Bk.INJECT_STREAM_STATUS_START_TIMEOUT, t3, i3), void this.streamingTasks.delete(i3);
            default:
              return void JD.debug("inject stream server status", e3);
          }
        }
        hasUrl(e3) {
          return this.streamingTasks.has(e3);
        }
      }
      class Zq {
        constructor() {
          MN(this, "destChannelMediaInfos", /* @__PURE__ */ new Map()), MN(this, "srcChannelMediaInfo", void 0);
        }
        setSrcChannelInfo(e3) {
          oB(e3), this.srcChannelMediaInfo = e3;
        }
        addDestChannelInfo(e3) {
          oB(e3), this.destChannelMediaInfos.set(e3.channelName, e3);
        }
        removeDestChannelInfo(e3) {
          VL(e3), this.destChannelMediaInfos.delete(e3);
        }
        getSrcChannelMediaInfo() {
          return this.srcChannelMediaInfo;
        }
        getDestChannelMediaInfo() {
          return this.destChannelMediaInfos;
        }
      }
      function $q(e3) {
        if (!(e3 instanceof Zq)) {
          return new QD(xD.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]").throw();
        }
        const t3 = e3.getSrcChannelMediaInfo(), i3 = e3.getDestChannelMediaInfo();
        if (!t3) {
          return new QD(xD.INVALID_PARAMS, "srcChannelMediaInfo should not be empty").throw();
        }
        if (0 === i3.size) {
          return new QD(xD.INVALID_PARAMS, "destChannelMediaInfo should not be empty").throw();
        }
      }
      class eX extends MD {
        constructor(e3, t3, i3) {
          super(), MN(this, "ws", void 0), MN(this, "requestId", 1), MN(this, "heartBeatTimer", void 0), MN(this, "joinInfo", void 0), MN(this, "clientId", void 0), MN(this, "onOpen", () => {
            this.emit("open"), this.startHeartBeatCheck();
          }), MN(this, "onClose", (e4) => {
            this.emit("close"), this.dispose();
          }), MN(this, "onMessage", (e4) => {
            const t4 = JSON.parse(e4.data);
            if (!t4 || "serverResponse" !== t4.command || !t4.requestId)
              return t4 && "serverStatus" === t4.command && t4.serverStatus && t4.serverStatus.command ? (this.emit("status", t4.serverStatus), void this.emit(t4.serverStatus.command, t4.serverStatus)) : void 0;
            this.emit("req_".concat(t4.requestId), t4);
          }), this.joinInfo = e3, this.clientId = t3, this.ws = new qJ("cross-channel-".concat(this.clientId), i3), this.ws.on(Lk.RECONNECTING, () => {
            this.ws.reconnectMode = "retry", this.emit("reconnecting");
          }), this.ws.on(Lk.CONNECTED, this.onOpen), this.ws.on(Lk.ON_MESSAGE, this.onMessage), this.ws.on(Lk.CLOSED, this.onClose);
        }
        isConnect() {
          return "connected" === this.ws.state;
        }
        sendMessage(e3) {
          const t3 = this.requestId++;
          return e3.requestId = t3, e3.seq = t3, this.ws.sendMessage(e3), t3;
        }
        waitStatus(e3) {
          return new l_((t3, i3) => {
            const r3 = window.setTimeout(() => {
              i3(new QD(xD.TIMEOUT, "wait status timeout, status: ".concat(e3)));
            }, 5e3);
            this.once(e3, (n3) => {
              window.clearTimeout(r3), n3.state && 0 !== n3.state ? i3(new QD(xD.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: ".concat(e3))) : t3(void 0);
            }), this.once("dispose", () => {
              window.clearTimeout(r3), i3(new QD(xD.WS_ABORT));
            });
          });
        }
        async request(e3) {
          if ("closed" === this.ws.state)
            throw new QD(xD.WS_DISCONNECT);
          const t3 = () => new l_((e4, t4) => {
            this.ws.once(Lk.CLOSED, () => t4(new QD(xD.WS_ABORT))), this.ws.once(Lk.CONNECTED, e4);
          });
          "connected" !== this.ws.state && await t3();
          const i3 = this.sendMessage(e3), r3 = new l_((e4, t4) => {
            const r4 = () => {
              t4(new QD(xD.WS_ABORT));
            };
            this.ws.once(Lk.RECONNECTING, r4), this.ws.once(Lk.CLOSED, r4), this.once("req_".concat(i3), e4), EK(3e3).then(() => {
              this.removeAllListeners("req_".concat(i3)), this.ws.off(Lk.RECONNECTING, r4), this.ws.off(Lk.CLOSED, r4), t4(new QD(xD.TIMEOUT, "cross channel ws request timeout"));
            });
          }), n3 = await r3;
          if (!n3 || 200 !== n3.code)
            throw new QD(xD.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: ".concat(JSON.stringify(n3)));
          return n3;
        }
        async connect(e3) {
          this.ws.removeAllListeners(Lk.REQUEST_NEW_URLS), this.ws.on(Lk.REQUEST_NEW_URLS, (t3) => {
            t3(e3);
          }), await this.ws.init(e3);
        }
        dispose() {
          this.clearHeartBeatCheck(), this.emit("dispose"), this.removeAllListeners(), this.ws.close();
        }
        sendPing(e3) {
          const t3 = this.requestId++;
          return e3.requestId = t3, this.ws.sendMessage(e3), t3;
        }
        startHeartBeatCheck() {
          this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval(() => {
            this.sendPing({ command: "ping", appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sid: this.joinInfo.sid, ts: +new Date(), requestId: 0 });
          }, 3e3);
        }
        clearHeartBeatCheck() {
          window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0;
        }
      }
      class tX extends MD {
        set state(e3) {
          e3 !== this._state && (e3 !== Yk.RELAY_STATE_FAILURE && (this.errorCode = Jk.RELAY_OK), this.emit("state", e3, this.errorCode), this._state = e3);
        }
        get state() {
          return this._state;
        }
        constructor(e3, t3, i3, r3) {
          super(), MN(this, "joinInfo", void 0), MN(this, "sid", void 0), MN(this, "clientId", void 0), MN(this, "cancelToken", kD.CancelToken.source()), MN(this, "workerToken", void 0), MN(this, "requestId", 0), MN(this, "signal", void 0), MN(this, "prevChannelMediaConfig", void 0), MN(this, "httpRetryConfig", void 0), MN(this, "_state", Yk.RELAY_STATE_IDLE), MN(this, "errorCode", Jk.RELAY_OK), MN(this, "onStatus", (e4) => {
            JD.debug("[".concat(this.clientId, "] ChannelMediaStatus: ").concat(JSON.stringify(e4))), e4 && e4.command && ("onAudioPacketReceived" === e4.command && this.emit("event", Wk.PACKET_RECEIVED_AUDIO_FROM_SRC), "onVideoPacketReceived" === e4.command && this.emit("event", Wk.PACKET_RECEIVED_VIDEO_FROM_SRC), "onSrcTokenPrivilegeDidExpire" === e4.command && (this.errorCode = Jk.SRC_TOKEN_EXPIRED, this.state = Yk.RELAY_STATE_FAILURE), "onDestTokenPrivilegeDidExpire" === e4.command && (this.errorCode = Jk.DEST_TOKEN_EXPIRED, this.state = Yk.RELAY_STATE_FAILURE));
          }), MN(this, "onReconnect", async () => {
            JD.debug("[".concat(this.clientId, "] ChannelMediaSocket disconnect, reconnecting")), this.emit("event", Wk.NETWORK_DISCONNECTED), this.state = Yk.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch((e4) => {
              this.state !== Yk.RELAY_STATE_IDLE && (JD.error("auto restart channel media relay failed", e4.toString()), this.errorCode = Jk.SERVER_CONNECTION_LOST, this.state = Yk.RELAY_STATE_FAILURE);
            });
          }), this.joinInfo = e3, this.clientId = t3, this.sid = IK(), this.signal = new eX(this.joinInfo, this.clientId, i3), this.httpRetryConfig = r3;
        }
        async startChannelMediaRelay(e3) {
          if (this.state !== Yk.RELAY_STATE_IDLE)
            throw new QD(xD.INVALID_OPERATION);
          this.state = Yk.RELAY_STATE_CONNECTING, await this.connect(), JD.debug("[".concat(this.clientId, "] startChannelMediaRelay: connect success"));
          try {
            await this.sendStartRelayMessage(e3);
          } catch (e4) {
            if (e4.data && e4.data.serverResponse && "SetSourceChannel" === e4.data.serverResponse.command)
              throw new QD(xD.CROSS_CHANNEL_FAILED_JOIN_SRC);
            if (e4.data && e4.data.serverResponse && "SetDestChannelStatus" === e4.serverResponse.command)
              throw new QD(xD.CROSS_CHANNEL_FAILED_JOIN_DEST);
            if (e4.data && e4.data.serverResponse && "StartPacketTransfer" === e4.serverResponse.command)
              throw new QD(xD.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);
            throw e4;
          }
          this.prevChannelMediaConfig = e3;
        }
        async updateChannelMediaRelay(e3) {
          if (this.state !== Yk.RELAY_STATE_RUNNING)
            throw new QD(xD.INVALID_OPERATION);
          await this.sendUpdateMessage(e3), this.prevChannelMediaConfig = e3;
        }
        async stopChannelMediaRelay() {
          await this.sendStopRelayMessage(), JD.debug("[".concat(this.clientId, "] stopChannelMediaRelay: send stop message success")), this.state = Yk.RELAY_STATE_IDLE, this.dispose();
        }
        dispose() {
          JD.debug("[".concat(this.clientId, "] disposeChannelMediaRelay")), this.cancelToken.cancel(), this.cancelToken = kD.CancelToken.source(), this.state = Yk.RELAY_STATE_IDLE, this.emit("dispose"), this.signal.dispose(), this.prevChannelMediaConfig = void 0;
        }
        async connect() {
          const e3 = await Fq(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);
          this.workerToken = e3.workerToken, await this.signal.connect(e3.addressList), this.emit("event", Wk.NETWORK_CONNECTED), this.signal.on("status", this.onStatus), this.signal.on("reconnecting", this.onReconnect);
        }
        async sendStartRelayMessage(e3) {
          const t3 = this.genMessage(Hk.StopPacketTransfer);
          await this.signal.request(t3), await this.signal.waitStatus("Normal Quit"), JD.debug("[".concat(this.clientId, "] startChannelMediaRelay: StopPacketTransfer success"));
          const i3 = this.genMessage(Hk.SetSdkProfile, e3);
          await this.signal.request(i3), JD.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSdkProfile success"));
          const r3 = this.genMessage(Hk.SetSourceChannel, e3);
          await this.signal.request(r3), await this.signal.waitStatus("SetSourceChannelStatus"), this.emit("event", Wk.PACKET_JOINED_SRC_CHANNEL), JD.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceChannel success"));
          const n3 = this.genMessage(Hk.SetSourceUserId, e3);
          await this.signal.request(n3), JD.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceUserId success"));
          const o3 = this.genMessage(Hk.SetDestChannel, e3);
          await this.signal.request(o3), await this.signal.waitStatus("SetDestChannelStatus"), this.emit("event", Wk.PACKET_JOINED_DEST_CHANNEL), JD.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetDestChannel success"));
          const s3 = this.genMessage(Hk.StartPacketTransfer, e3);
          await this.signal.request(s3), this.emit("event", Wk.PACKET_SENT_TO_DEST_CHANNEL), this.state = Yk.RELAY_STATE_RUNNING, JD.debug("[".concat(this.clientId, "] startChannelMediaRelay: StartPacketTransfer success"));
        }
        async sendUpdateMessage(e3) {
          const t3 = this.genMessage(Hk.UpdateDestChannel, e3);
          await this.signal.request(t3), this.emit("event", Wk.PACKET_UPDATE_DEST_CHANNEL), JD.debug("[".concat(this.clientId, "] sendUpdateMessage: UpdateDestChannel success"));
        }
        async sendStopRelayMessage() {
          const e3 = this.genMessage(Hk.StopPacketTransfer);
          await this.signal.request(e3), JD.debug("[".concat(this.clientId, "] sendStopRelayMessage: StopPacketTransfer success"));
        }
        genMessage(e3, t3) {
          const i3 = [], r3 = [], n3 = [];
          this.requestId += 1;
          const o3 = { appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sdkVersion: CP, sid: this.sid, ts: Date.now(), requestId: this.requestId, seq: this.requestId, allocate: true, clientRequest: {} };
          "4.15.0" === o3.sdkVersion && (o3.sdkVersion = "0.0.1");
          let s3 = null, a3 = null;
          switch (e3) {
            case Hk.SetSdkProfile:
              return o3.clientRequest = { command: "SetSdkProfile", type: "multi_channel" }, o3;
            case Hk.SetSourceChannel:
              if (a3 = t3 && t3.getSrcChannelMediaInfo(), !a3)
                throw new QD(xD.UNEXPECTED_ERROR, "can not find source config");
              return o3.clientRequest = { command: "SetSourceChannel", uid: "0", channelName: a3.channelName, token: a3.token || this.joinInfo.appId }, o3;
            case Hk.SetSourceUserId:
              if (a3 = t3 && t3.getSrcChannelMediaInfo(), !a3)
                throw new QD(xD.UNEXPECTED_ERROR, "can not find source config");
              return o3.clientRequest = { command: "SetSourceUserId", uid: a3.uid + "" }, o3;
            case Hk.SetDestChannel:
              if (s3 = t3 && t3.getDestChannelMediaInfo(), !s3)
                throw new QD(xD.UNEXPECTED_ERROR, "can not find dest config");
              return s3.forEach((e4) => {
                i3.push(e4.channelName), r3.push(e4.uid + ""), n3.push(e4.token || this.joinInfo.appId);
              }), o3.clientRequest = { command: "SetDestChannel", channelName: i3, uid: r3, token: n3 }, o3;
            case Hk.StartPacketTransfer:
              return o3.clientRequest = { command: "StartPacketTransfer" }, o3;
            case Hk.Reconnect:
              return o3.clientRequest = { command: "Reconnect" }, o3;
            case Hk.StopPacketTransfer:
              return o3.clientRequest = { command: "StopPacketTransfer" }, o3;
            case Hk.UpdateDestChannel:
              if (s3 = t3 && t3.getDestChannelMediaInfo(), !s3)
                throw new QD(xD.UNEXPECTED_ERROR, "can not find dest config");
              return s3.forEach((e4) => {
                i3.push(e4.channelName), r3.push(e4.uid + ""), n3.push(e4.token || this.joinInfo.appId);
              }), o3.clientRequest = { command: "UpdateDestChannel", channelName: i3, uid: r3, token: n3 }, o3;
          }
          return o3;
        }
      }
      const iX = (e3) => {
        const t3 = document.createElement("canvas");
        return t3.width = 2, t3.height = 2, new l_((i3, r3) => {
          t3.toBlob(async (e4) => {
            if (t3.remove(), e4) {
              const r4 = await rX(e4);
              i3({ buffer: r4, width: t3.width, height: t3.height });
            } else
              r3(new QD(xD.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
          }, e3, 1);
        });
      }, rX = async (e3) => {
        const t3 = await e3.arrayBuffer();
        return new Uint8Array(t3);
      };
      const nX = new class extends MD {
        get visibility() {
          return document.visibilityState;
        }
        get lastHiddenTime() {
          return this._lastHiddenTime;
        }
        get lastVisibleTime() {
          return this._lastVisibleTime;
        }
        constructor() {
          super(), MN(this, "_lastHiddenTime", NaN), MN(this, "_lastVisibleTime", NaN), document.addEventListener("visibilitychange", () => {
            "hidden" === document.visibilityState ? this._lastHiddenTime = Date.now() : this._lastVisibleTime = Date.now(), this.emit("VISIBILITY_CHANGE", document.visibilityState);
          });
        }
      }();
      var oX;
      let sX = mP("AgoraRTCPlayer", "trackId")(oX = class {
        get videoElementStatus() {
          return this._videoElementStatus;
        }
        set videoElementStatus(e3) {
          e3 !== this._videoElementStatus && (JD.debug("[".concat(this.trackId, "] video-element-status change ").concat(this._videoElementStatus, " => ").concat(e3)), pP("debug", ["HTMLVideoElement", this.trackId], "statusChange", "".concat(this._videoElementStatus, " => ").concat(e3)), this._videoElementStatus = e3);
        }
        constructor(e3) {
          MN(this, "trackId", void 0), MN(this, "config", void 0), MN(this, "onFirstVideoFrameDecoded", void 0), MN(this, "freezeTimeCounterList", []), MN(this, "timeUpdatedCount", 0), MN(this, "freezeTime", 0), MN(this, "playbackTime", 0), MN(this, "lastTimeUpdatedTime", 0), MN(this, "autoplayFailed", false), MN(this, "videoTrack", void 0), MN(this, "container", void 0), MN(this, "videoElement", void 0), MN(this, "videoElementCheckInterval", void 0), MN(this, "_videoElementStatus", qL.NONE), MN(this, "slot", void 0), MN(this, "isGettingVideoDimensions", false), MN(this, "handleVideoEvents", (e4) => {
            switch (e4.type) {
              case "play":
              case "playing":
                this.startGetVideoDimensions(), this.videoElementStatus = qL.PLAYING;
                break;
              case "loadeddata":
                this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded();
                break;
              case "canplay":
                this.videoElementStatus = qL.CANPLAY;
                break;
              case "stalled":
                this.videoElementStatus = qL.STALLED;
                break;
              case "suspend":
                this.videoElementStatus = qL.SUSPEND;
                break;
              case "pause":
                this.videoElementStatus = qL.PAUSED, EN() || vN() || pN() && this.autoplayFailed || !this.videoElement || !this.videoTrack || "live" !== this.videoTrack.readyState || (JD.debug("[track-".concat(this.trackId, "] video element paused, auto resume")), hP("debug", this, "video element paused, auto resume"), this.videoElement.play());
                break;
              case "waiting":
                this.videoElementStatus = qL.WAITING;
                break;
              case "abort":
                this.videoElementStatus = qL.ABORT;
                break;
              case "ended":
                this.videoElementStatus = qL.ENDED;
                break;
              case "emptied":
                this.videoElementStatus = qL.EMPTIED;
                break;
              case "timeupdate": {
                const e5 = Date.now();
                if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10)
                  return void (this.lastTimeUpdatedTime = e5);
                const t3 = e5 - this.lastTimeUpdatedTime;
                if ("hidden" === nX.visibility)
                  return;
                if (this.lastTimeUpdatedTime < nX.lastHiddenTime && e5 > nX.lastVisibleTime)
                  return void (this.lastTimeUpdatedTime = e5);
                for (this.lastTimeUpdatedTime = e5, t3 > 500 && (this.freezeTime += t3), this.playbackTime += t3; this.playbackTime >= 6e3; )
                  this.playbackTime -= 6e3, this.freezeTimeCounterList.push(Math.min(6e3, this.freezeTime)), this.freezeTime = Math.max(0, this.freezeTime - 6e3);
                break;
              }
            }
          }), MN(this, "startGetVideoDimensions", () => {
            const e4 = () => {
              if (this.isGettingVideoDimensions = true, this.videoElement && this.videoElement.videoWidth * this.videoElement.videoHeight > 4)
                return JD.debug("[".concat(this.trackId, "] current video dimensions:"), this.videoElement.videoWidth, this.videoElement.videoHeight), gP("debug", this, "startGetVideoDimensions", { videoWidth: this.videoElement.videoWidth, videoHeight: this.videoElement.videoHeight }), void (this.isGettingVideoDimensions = false);
              setTimeout(e4, 500);
            };
            !this.isGettingVideoDimensions && e4();
          }), MN(this, "autoResumeAfterInterruption", () => {
            this.videoElement && this.videoTrack && "live" === this.videoTrack.readyState && "running" === Tj.curState && (SN() ? (JD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.2")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : CN() ? (JD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.1")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : _N() && (JD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.0")), this.videoElement.pause(), this.videoElement.play()));
          }), MN(this, "autoResumeAfterInterruptionOnIOS15", () => {
            this.videoElement && this.videoTrack && "live" === this.videoTrack.readyState && (SN() ? (JD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.2")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : CN() ? (JD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.1")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : _N() && (JD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.0")), this.videoElement.pause(), this.videoElement.play()));
          }), this.slot = e3.element, this.trackId = e3.trackId, this.updateConfig(e3), Tj.on(_j.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), Tj.on(_j.IOS_15_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15);
        }
        updateConfig(e3) {
          this.config = e3, this.trackId = e3.trackId;
          const t3 = e3.element;
          t3 !== this.slot && (this.destroy(), this.slot = t3), this.createElements();
        }
        updateVideoTrack(e3) {
          this.videoTrack !== e3 && (this.videoTrack = e3, this.createElements());
        }
        play(e3) {
          if (this.videoElement) {
            const t3 = this.videoElement.play();
            t3 && t3.catch && t3.catch((t4) => {
              e3 && pj.autoplayFailed(e3, "video", t4.message, this.trackId), gP("warning", this, "play", t4.toString(), "error"), "NotAllowedError" === t4.name ? (JD.warning("detected video element autoplay failed", t4), this.autoplayFailed = true, this.handleAutoPlayFailed()) : JD.warning("[".concat(this.trackId, "] play warning: "), t4);
            });
            const i3 = oN();
            if (("Safari" === i3.name && 15 === Number(i3.version) || IN()) && t3 && t3.then && t3.catch) {
              const e4 = () => {
                this.config.mirror && this.videoElement && (this.videoElement.style.transform = "rotateY(180deg)");
              };
              t3.then(e4).catch(e4);
            }
          }
        }
        getCurrentFrame() {
          if (!this.videoElement)
            return new ImageData(2, 2);
          const e3 = document.createElement("canvas");
          e3.width = this.videoElement.videoWidth, e3.height = this.videoElement.videoHeight;
          const t3 = e3.getContext("2d");
          if (!t3)
            return JD.error("create canvas context failed!"), gP("error", this, "getCurrentFrame", "create canvas context failed!", "error"), new ImageData(2, 2);
          t3.drawImage(this.videoElement, 0, 0, e3.width, e3.height);
          const i3 = t3.getImageData(0, 0, e3.width, e3.height);
          return e3.remove(), i3;
        }
        async getCurrentFrameToUint8Array(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          if (!this.videoElement)
            return await iX(e3);
          const i3 = document.createElement("canvas");
          i3.width = this.videoElement.videoWidth, i3.height = this.videoElement.videoHeight;
          const r3 = i3.getContext("2d");
          return r3 ? (r3.drawImage(this.videoElement, 0, 0, i3.width, i3.height), new l_((r4, n3) => {
            i3.toBlob(async (e4) => {
              if (i3.remove(), e4) {
                const t4 = await rX(e4);
                r4({ buffer: t4, width: i3.width, height: i3.height });
              } else
                n3(new QD(xD.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
            }, e3, t3 < 0 ? 0.1 : t3 > 1 ? 1 : t3);
          })) : await iX(e3);
        }
        destroy() {
          if (Tj.off(_j.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), Tj.off(_j.IOS_15_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15), this.videoElement && (this.videoElement.srcObject = null, this.videoElement.remove(), this.videoElement = void 0), this.container) {
            try {
              this.container.remove(), this.slot.removeChild(this.container);
            } catch (e3) {
            }
            this.container = void 0;
          }
          this.freezeTimeCounterList = [];
        }
        createElements() {
          this.container || (this.container = document.createElement("div")), this.container.id = "agora-video-player-".concat(this.trackId), this.container.style.width = "100%", this.container.style.height = "100%", this.container.style.position = "relative", this.container.style.overflow = "hidden", this.videoTrack ? (this.container.style.backgroundColor = "black", this.createVideoElement(), this.container.appendChild(this.videoElement)) : this.removeVideoElement(), this.slot.appendChild(this.container);
        }
        createVideoElement() {
          this.videoElement || (this.videoElementStatus = qL.INIT, this.videoElement = document.createElement("video"), this.videoElement.onerror = () => this.videoElementStatus = qL.ERROR, this.container && this.container.appendChild(this.videoElement), aX.forEach((e4) => {
            this.videoElement && this.videoElement.addEventListener(e4, this.handleVideoEvents);
          }), this.videoElementCheckInterval = window.setInterval(() => {
            !document.getElementById("video_".concat(this.trackId)) && this.videoElement && (this.videoElementStatus = qL.DESTROYED);
          }, 1e3)), this.videoElement.id = "video_".concat(this.trackId), this.videoElement.className = "agora_video_player", this.videoElement.style.width = "100%", this.videoElement.style.height = "100%", this.videoElement.style.position = "absolute", this.videoElement.controls = false, this.videoElement.setAttribute("playsinline", ""), this.videoElement.style.left = "0", this.videoElement.style.top = "0", wN() && (this.videoElement.poster = "noposter");
          const e3 = oN();
          if ("Safari" === e3.name && 15 === Number(e3.version) || IN() || !this.config.mirror || (this.videoElement.style.transform = "rotateY(180deg)"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", this.videoElement.setAttribute("muted", ""), this.videoElement.muted = true, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream) {
            this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, gN() && this.videoElement.load());
          } else
            this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, gN() && this.videoElement.load();
          const t3 = this.videoElement.play();
          void 0 !== t3 && t3.catch((e4) => {
            JD.debug("[".concat(this.trackId, "] playback interrupted"), e4.toString()), hP("debug", this, "play back interrupted: ".concat(e4.toString()));
          });
        }
        removeVideoElement() {
          if (this.videoElement) {
            aX.forEach((e3) => {
              this.videoElement && this.videoElement.removeEventListener(e3, this.handleVideoEvents);
            }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0);
            try {
              this.container && this.container.removeChild(this.videoElement);
            } catch (e3) {
            }
            this.videoElement = void 0, this.videoElementStatus = qL.NONE;
          }
        }
        handleAutoPlayFailed() {
          if (this.videoElement) {
            const e3 = (t3) => {
              t3.preventDefault(), this.videoElement && (this.videoElement.play().then(() => {
                JD.debug("[".concat(this.trackId, "] Video element for trackId:").concat(this.trackId, " autoplay resumed.")), hP("debug", this, "video element autoplay resumed");
              }).catch((e4) => {
                JD.error(e4);
              }), this.autoplayFailed = false, bN() ? document.body.removeEventListener("click", e3, true) : (document.body.removeEventListener("touchstart", e3, true), document.body.removeEventListener("mousedown", e3, true)));
            };
            bN() ? document.body.addEventListener("click", e3, true) : (document.body.addEventListener("touchstart", e3, true), document.body.addEventListener("mousedown", e3, true)), oj();
          }
        }
        getVideoElement() {
          return this.videoElement;
        }
        getContainerElement() {
          return this.container;
        }
      }) || oX;
      const aX = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "timeupdate"];
      var cX = { exports: {} };
      function dX(e3, t3, i3) {
        const r3 = e3.createShader(i3);
        if (!r3) {
          return new QD(xD.WEBGL_INTERNAL_ERROR, "can not create shader").throw();
        }
        e3.shaderSource(r3, t3), e3.compileShader(r3);
        if (!e3.getShaderParameter(r3, e3.COMPILE_STATUS)) {
          const t4 = e3.getShaderInfoLog(r3);
          e3.deleteShader(r3);
          return new QD(xD.WEBGL_INTERNAL_ERROR, "error compiling shader:" + t4).throw();
        }
        return r3;
      }
      function uX(e3, t3, i3, r3) {
        const n3 = [];
        for (let i4 = 0; i4 < t3.length; ++i4) {
          const r4 = 0 === i4 ? e3.VERTEX_SHADER : e3.FRAGMENT_SHADER;
          n3.push(dX(e3, t3[i4], r4));
        }
        return function(e4, t4, i4, r4) {
          const n4 = e4.createProgram();
          if (!n4)
            throw new QD(xD.WEBGL_INTERNAL_ERROR, "can not create webgl program");
          if (t4.forEach((t5) => {
            e4.attachShader(n4, t5);
          }), i4 && i4.forEach((t5, i5) => {
            e4.bindAttribLocation(n4, r4 ? r4[i5] : i5, t5);
          }), e4.linkProgram(n4), !e4.getProgramParameter(n4, e4.LINK_STATUS)) {
            const t5 = e4.getProgramInfoLog(n4);
            throw e4.deleteProgram(n4), new QD(xD.WEBGL_INTERNAL_ERROR, "error in program linking:" + t5);
          }
          return n4;
        }(e3, n3, i3, r3);
      }
      !function(e3, t3) {
        var i3;
        self, i3 = () => (() => {
          var e4 = { 3536: (e5, t5, i5) => {
            var r4 = i5(1910);
            e5.exports = r4;
          }, 8171: (e5, t5, i5) => {
            i5(6450);
            var r4 = i5(4058).Object, n3 = e5.exports = function(e6, t6, i6) {
              return r4.defineProperty(e6, t6, i6);
            };
            r4.defineProperty.sham && (n3.sham = true);
          }, 2956: (e5, t5, i5) => {
            i5(7627), i5(6274), i5(5967), i5(8881), i5(4560), i5(7206), i5(4349), i5(7971);
            var r4 = i5(4058);
            e5.exports = r4.Promise;
          }, 3685: (e5, t5, i5) => {
            e5.exports = i5(621);
          }, 621: (e5, t5, i5) => {
            var r4 = i5(3536);
            e5.exports = r4;
          }, 4883: (e5, t5, i5) => {
            var r4 = i5(7475), n3 = i5(9826), o3 = TypeError;
            e5.exports = function(e6) {
              if (r4(e6))
                return e6;
              throw o3(n3(e6) + " is not a function");
            };
          }, 174: (e5, t5, i5) => {
            var r4 = i5(4284), n3 = i5(9826), o3 = TypeError;
            e5.exports = function(e6) {
              if (r4(e6))
                return e6;
              throw o3(n3(e6) + " is not a constructor");
            };
          }, 1851: (e5, t5, i5) => {
            var r4 = i5(7475), n3 = String, o3 = TypeError;
            e5.exports = function(e6) {
              if ("object" == typeof e6 || r4(e6))
                return e6;
              throw o3("Can't set " + n3(e6) + " as a prototype");
            };
          }, 8479: (e5) => {
            e5.exports = function() {
            };
          }, 5743: (e5, t5, i5) => {
            var r4 = i5(7046), n3 = TypeError;
            e5.exports = function(e6, t6) {
              if (r4(t6, e6))
                return e6;
              throw n3("Incorrect invocation");
            };
          }, 6059: (e5, t5, i5) => {
            var r4 = i5(941), n3 = String, o3 = TypeError;
            e5.exports = function(e6) {
              if (r4(e6))
                return e6;
              throw o3(n3(e6) + " is not an object");
            };
          }, 1692: (e5, t5, i5) => {
            var r4 = i5(4529), n3 = i5(9413), o3 = i5(623), s3 = function(e6) {
              return function(t6, i6, s4) {
                var a3, c3 = r4(t6), d3 = o3(c3), u3 = n3(s4, d3);
                if (e6 && i6 != i6) {
                  for (; d3 > u3; )
                    if ((a3 = c3[u3++]) != a3)
                      return true;
                } else
                  for (; d3 > u3; u3++)
                    if ((e6 || u3 in c3) && c3[u3] === i6)
                      return e6 || u3 || 0;
                return !e6 && -1;
              };
            };
            e5.exports = { includes: s3(true), indexOf: s3(false) };
          }, 3765: (e5, t5, i5) => {
            var r4 = i5(5329);
            e5.exports = r4([].slice);
          }, 1385: (e5, t5, i5) => {
            var r4 = i5(9813)("iterator"), n3 = false;
            try {
              var o3 = 0, s3 = { next: function() {
                return { done: !!o3++ };
              }, return: function() {
                n3 = true;
              } };
              s3[r4] = function() {
                return this;
              }, Array.from(s3, function() {
                throw 2;
              });
            } catch (e6) {
            }
            e5.exports = function(e6, t6) {
              if (!t6 && !n3)
                return false;
              var i6 = false;
              try {
                var o4 = {};
                o4[r4] = function() {
                  return { next: function() {
                    return { done: i6 = true };
                  } };
                }, e6(o4);
              } catch (e7) {
              }
              return i6;
            };
          }, 2532: (e5, t5, i5) => {
            var r4 = i5(4163), n3 = r4({}.toString), o3 = r4("".slice);
            e5.exports = function(e6) {
              return o3(n3(e6), 8, -1);
            };
          }, 9697: (e5, t5, i5) => {
            var r4 = i5(2885), n3 = i5(7475), o3 = i5(2532), s3 = i5(9813)("toStringTag"), a3 = Object, c3 = "Arguments" == o3(function() {
              return arguments;
            }());
            e5.exports = r4 ? o3 : function(e6) {
              var t6, i6, r5;
              return void 0 === e6 ? "Undefined" : null === e6 ? "Null" : "string" == typeof (i6 = function(e7, t7) {
                try {
                  return e7[t7];
                } catch (e8) {
                }
              }(t6 = a3(e6), s3)) ? i6 : c3 ? o3(t6) : "Object" == (r5 = o3(t6)) && n3(t6.callee) ? "Arguments" : r5;
            };
          }, 3489: (e5, t5, i5) => {
            var r4 = i5(953), n3 = i5(1136), o3 = i5(9677), s3 = i5(5988);
            e5.exports = function(e6, t6, i6) {
              for (var a3 = n3(t6), c3 = s3.f, d3 = o3.f, u3 = 0; u3 < a3.length; u3++) {
                var h3 = a3[u3];
                r4(e6, h3) || i6 && r4(i6, h3) || c3(e6, h3, d3(t6, h3));
              }
            };
          }, 4160: (e5, t5, i5) => {
            var r4 = i5(5981);
            e5.exports = !r4(function() {
              function e6() {
              }
              return e6.prototype.constructor = null, Object.getPrototypeOf(new e6()) !== e6.prototype;
            });
          }, 3538: (e5) => {
            e5.exports = function(e6, t5) {
              return { value: e6, done: t5 };
            };
          }, 2029: (e5, t5, i5) => {
            var r4 = i5(5746), n3 = i5(5988), o3 = i5(1887);
            e5.exports = r4 ? function(e6, t6, i6) {
              return n3.f(e6, t6, o3(1, i6));
            } : function(e6, t6, i6) {
              return e6[t6] = i6, e6;
            };
          }, 1887: (e5) => {
            e5.exports = function(e6, t5) {
              return { enumerable: !(1 & e6), configurable: !(2 & e6), writable: !(4 & e6), value: t5 };
            };
          }, 5929: (e5, t5, i5) => {
            var r4 = i5(2029);
            e5.exports = function(e6, t6, i6, n3) {
              return n3 && n3.enumerable ? e6[t6] = i6 : r4(e6, t6, i6), e6;
            };
          }, 5609: (e5, t5, i5) => {
            var r4 = i5(1899), n3 = Object.defineProperty;
            e5.exports = function(e6, t6) {
              try {
                n3(r4, e6, { value: t6, configurable: true, writable: true });
              } catch (i6) {
                r4[e6] = t6;
              }
              return t6;
            };
          }, 5746: (e5, t5, i5) => {
            var r4 = i5(5981);
            e5.exports = !r4(function() {
              return 7 != Object.defineProperty({}, 1, { get: function() {
                return 7;
              } })[1];
            });
          }, 6616: (e5) => {
            var t5 = "object" == typeof document && document.all, i5 = void 0 === t5 && void 0 !== t5;
            e5.exports = { all: t5, IS_HTMLDDA: i5 };
          }, 1333: (e5, t5, i5) => {
            var r4 = i5(1899), n3 = i5(941), o3 = r4.document, s3 = n3(o3) && n3(o3.createElement);
            e5.exports = function(e6) {
              return s3 ? o3.createElement(e6) : {};
            };
          }, 3281: (e5) => {
            e5.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
          }, 3321: (e5, t5, i5) => {
            var r4 = i5(8501), n3 = i5(6049);
            e5.exports = !r4 && !n3 && "object" == typeof window && "object" == typeof document;
          }, 8501: (e5) => {
            e5.exports = "object" == typeof Deno && Deno && "object" == typeof Deno.version;
          }, 4470: (e5, t5, i5) => {
            var r4 = i5(2861), n3 = i5(1899);
            e5.exports = /ipad|iphone|ipod/i.test(r4) && void 0 !== n3.Pebble;
          }, 2749: (e5, t5, i5) => {
            var r4 = i5(2861);
            e5.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(r4);
          }, 6049: (e5, t5, i5) => {
            var r4 = i5(2532), n3 = i5(1899);
            e5.exports = "process" == r4(n3.process);
          }, 8045: (e5, t5, i5) => {
            var r4 = i5(2861);
            e5.exports = /web0s(?!.*chrome)/i.test(r4);
          }, 2861: (e5, t5, i5) => {
            var r4 = i5(626);
            e5.exports = r4("navigator", "userAgent") || "";
          }, 3385: (e5, t5, i5) => {
            var r4, n3, o3 = i5(1899), s3 = i5(2861), a3 = o3.process, c3 = o3.Deno, d3 = a3 && a3.versions || c3 && c3.version, u3 = d3 && d3.v8;
            u3 && (n3 = (r4 = u3.split("."))[0] > 0 && r4[0] < 4 ? 1 : +(r4[0] + r4[1])), !n3 && s3 && (!(r4 = s3.match(/Edge\/(\d+)/)) || r4[1] >= 74) && (r4 = s3.match(/Chrome\/(\d+)/)) && (n3 = +r4[1]), e5.exports = n3;
          }, 6759: (e5) => {
            e5.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
          }, 3995: (e5, t5, i5) => {
            var r4 = i5(5329), n3 = Error, o3 = r4("".replace), s3 = String(n3("zxcasd").stack), a3 = /\n\s*at [^:]*:[^\n]*/, c3 = a3.test(s3);
            e5.exports = function(e6, t6) {
              if (c3 && "string" == typeof e6 && !n3.prepareStackTrace)
                for (; t6--; )
                  e6 = o3(e6, a3, "");
              return e6;
            };
          }, 8780: (e5, t5, i5) => {
            var r4 = i5(5981), n3 = i5(1887);
            e5.exports = !r4(function() {
              var e6 = Error("a");
              return !("stack" in e6) || (Object.defineProperty(e6, "stack", n3(1, 7)), 7 !== e6.stack);
            });
          }, 6887: (e5, t5, i5) => {
            var r4 = i5(1899), n3 = i5(9730), o3 = i5(5329), s3 = i5(7475), a3 = i5(9677).f, c3 = i5(7252), d3 = i5(4058), u3 = i5(6843), h3 = i5(2029), A3 = i5(953), l3 = function(e6) {
              var t6 = function(i6, r5, o4) {
                if (this instanceof t6) {
                  switch (arguments.length) {
                    case 0:
                      return new e6();
                    case 1:
                      return new e6(i6);
                    case 2:
                      return new e6(i6, r5);
                  }
                  return new e6(i6, r5, o4);
                }
                return n3(e6, this, arguments);
              };
              return t6.prototype = e6.prototype, t6;
            };
            e5.exports = function(e6, t6) {
              var i6, n4, p3, g3, E3, f3, m3, I3, _3 = e6.target, C3 = e6.global, S3 = e6.stat, v3 = e6.proto, T3 = C3 ? r4 : S3 ? r4[_3] : (r4[_3] || {}).prototype, R3 = C3 ? d3 : d3[_3] || h3(d3, _3, {})[_3], y3 = R3.prototype;
              for (p3 in t6)
                i6 = !c3(C3 ? p3 : _3 + (S3 ? "." : "#") + p3, e6.forced) && T3 && A3(T3, p3), E3 = R3[p3], i6 && (f3 = e6.dontCallGetSet ? (I3 = a3(T3, p3)) && I3.value : T3[p3]), g3 = i6 && f3 ? f3 : t6[p3], i6 && typeof E3 == typeof g3 || (m3 = e6.bind && i6 ? u3(g3, r4) : e6.wrap && i6 ? l3(g3) : v3 && s3(g3) ? o3(g3) : g3, (e6.sham || g3 && g3.sham || E3 && E3.sham) && h3(m3, "sham", true), h3(R3, p3, m3), v3 && (A3(d3, n4 = _3 + "Prototype") || h3(d3, n4, {}), h3(d3[n4], p3, g3), e6.real && y3 && !y3[p3] && h3(y3, p3, g3)));
            };
          }, 5981: (e5) => {
            e5.exports = function(e6) {
              try {
                return !!e6();
              } catch (e7) {
                return true;
              }
            };
          }, 9730: (e5, t5, i5) => {
            var r4 = i5(8285), n3 = Function.prototype, o3 = n3.apply, s3 = n3.call;
            e5.exports = "object" == typeof Reflect && Reflect.apply || (r4 ? s3.bind(o3) : function() {
              return s3.apply(o3, arguments);
            });
          }, 6843: (e5, t5, i5) => {
            var r4 = i5(5329), n3 = i5(4883), o3 = i5(8285), s3 = r4(r4.bind);
            e5.exports = function(e6, t6) {
              return n3(e6), void 0 === t6 ? e6 : o3 ? s3(e6, t6) : function() {
                return e6.apply(t6, arguments);
              };
            };
          }, 8285: (e5, t5, i5) => {
            var r4 = i5(5981);
            e5.exports = !r4(function() {
              var e6 = function() {
              }.bind();
              return "function" != typeof e6 || e6.hasOwnProperty("prototype");
            });
          }, 8834: (e5, t5, i5) => {
            var r4 = i5(8285), n3 = Function.prototype.call;
            e5.exports = r4 ? n3.bind(n3) : function() {
              return n3.apply(n3, arguments);
            };
          }, 9417: (e5, t5, i5) => {
            var r4 = i5(5746), n3 = i5(953), o3 = Function.prototype, s3 = r4 && Object.getOwnPropertyDescriptor, a3 = n3(o3, "name"), c3 = a3 && "something" === function() {
            }.name, d3 = a3 && (!r4 || r4 && s3(o3, "name").configurable);
            e5.exports = { EXISTS: a3, PROPER: c3, CONFIGURABLE: d3 };
          }, 4163: (e5, t5, i5) => {
            var r4 = i5(8285), n3 = Function.prototype, o3 = n3.call, s3 = r4 && n3.bind.bind(o3, o3);
            e5.exports = r4 ? s3 : function(e6) {
              return function() {
                return o3.apply(e6, arguments);
              };
            };
          }, 5329: (e5, t5, i5) => {
            var r4 = i5(2532), n3 = i5(4163);
            e5.exports = function(e6) {
              if ("Function" === r4(e6))
                return n3(e6);
            };
          }, 626: (e5, t5, i5) => {
            var r4 = i5(4058), n3 = i5(1899), o3 = i5(7475), s3 = function(e6) {
              return o3(e6) ? e6 : void 0;
            };
            e5.exports = function(e6, t6) {
              return arguments.length < 2 ? s3(r4[e6]) || s3(n3[e6]) : r4[e6] && r4[e6][t6] || n3[e6] && n3[e6][t6];
            };
          }, 2902: (e5, t5, i5) => {
            var r4 = i5(9697), n3 = i5(4229), o3 = i5(2119), s3 = i5(2077), a3 = i5(9813)("iterator");
            e5.exports = function(e6) {
              if (!o3(e6))
                return n3(e6, a3) || n3(e6, "@@iterator") || s3[r4(e6)];
            };
          }, 3476: (e5, t5, i5) => {
            var r4 = i5(8834), n3 = i5(4883), o3 = i5(6059), s3 = i5(9826), a3 = i5(2902), c3 = TypeError;
            e5.exports = function(e6, t6) {
              var i6 = arguments.length < 2 ? a3(e6) : t6;
              if (n3(i6))
                return o3(r4(i6, e6));
              throw c3(s3(e6) + " is not iterable");
            };
          }, 4229: (e5, t5, i5) => {
            var r4 = i5(4883), n3 = i5(2119);
            e5.exports = function(e6, t6) {
              var i6 = e6[t6];
              return n3(i6) ? void 0 : r4(i6);
            };
          }, 1899: (e5, t5, i5) => {
            var r4 = function(e6) {
              return e6 && e6.Math == Math && e6;
            };
            e5.exports = r4("object" == typeof globalThis && globalThis) || r4("object" == typeof window && window) || r4("object" == typeof self && self) || r4("object" == typeof i5.g && i5.g) || function() {
              return this;
            }() || Function("return this")();
          }, 953: (e5, t5, i5) => {
            var r4 = i5(5329), n3 = i5(9678), o3 = r4({}.hasOwnProperty);
            e5.exports = Object.hasOwn || function(e6, t6) {
              return o3(n3(e6), t6);
            };
          }, 7748: (e5) => {
            e5.exports = {};
          }, 4845: (e5, t5, i5) => {
            var r4 = i5(1899);
            e5.exports = function(e6, t6) {
              var i6 = r4.console;
              i6 && i6.error && (1 == arguments.length ? i6.error(e6) : i6.error(e6, t6));
            };
          }, 5463: (e5, t5, i5) => {
            var r4 = i5(626);
            e5.exports = r4("document", "documentElement");
          }, 2840: (e5, t5, i5) => {
            var r4 = i5(5746), n3 = i5(5981), o3 = i5(1333);
            e5.exports = !r4 && !n3(function() {
              return 7 != Object.defineProperty(o3("div"), "a", { get: function() {
                return 7;
              } }).a;
            });
          }, 7026: (e5, t5, i5) => {
            var r4 = i5(5329), n3 = i5(5981), o3 = i5(2532), s3 = Object, a3 = r4("".split);
            e5.exports = n3(function() {
              return !s3("z").propertyIsEnumerable(0);
            }) ? function(e6) {
              return "String" == o3(e6) ? a3(e6, "") : s3(e6);
            } : s3;
          }, 1302: (e5, t5, i5) => {
            var r4 = i5(5329), n3 = i5(7475), o3 = i5(3030), s3 = r4(Function.toString);
            n3(o3.inspectSource) || (o3.inspectSource = function(e6) {
              return s3(e6);
            }), e5.exports = o3.inspectSource;
          }, 3794: (e5, t5, i5) => {
            var r4 = i5(941), n3 = i5(2029);
            e5.exports = function(e6, t6) {
              r4(t6) && "cause" in t6 && n3(e6, "cause", t6.cause);
            };
          }, 5402: (e5, t5, i5) => {
            var r4, n3, o3, s3 = i5(7093), a3 = i5(1899), c3 = i5(941), d3 = i5(2029), u3 = i5(953), h3 = i5(3030), A3 = i5(4262), l3 = i5(7748), p3 = "Object already initialized", g3 = a3.TypeError, E3 = a3.WeakMap;
            if (s3 || h3.state) {
              var f3 = h3.state || (h3.state = new E3());
              f3.get = f3.get, f3.has = f3.has, f3.set = f3.set, r4 = function(e6, t6) {
                if (f3.has(e6))
                  throw g3(p3);
                return t6.facade = e6, f3.set(e6, t6), t6;
              }, n3 = function(e6) {
                return f3.get(e6) || {};
              }, o3 = function(e6) {
                return f3.has(e6);
              };
            } else {
              var m3 = A3("state");
              l3[m3] = true, r4 = function(e6, t6) {
                if (u3(e6, m3))
                  throw g3(p3);
                return t6.facade = e6, d3(e6, m3, t6), t6;
              }, n3 = function(e6) {
                return u3(e6, m3) ? e6[m3] : {};
              }, o3 = function(e6) {
                return u3(e6, m3);
              };
            }
            e5.exports = { set: r4, get: n3, has: o3, enforce: function(e6) {
              return o3(e6) ? n3(e6) : r4(e6, {});
            }, getterFor: function(e6) {
              return function(t6) {
                var i6;
                if (!c3(t6) || (i6 = n3(t6)).type !== e6)
                  throw g3("Incompatible receiver, " + e6 + " required");
                return i6;
              };
            } };
          }, 6782: (e5, t5, i5) => {
            var r4 = i5(9813), n3 = i5(2077), o3 = r4("iterator"), s3 = Array.prototype;
            e5.exports = function(e6) {
              return void 0 !== e6 && (n3.Array === e6 || s3[o3] === e6);
            };
          }, 7475: (e5, t5, i5) => {
            var r4 = i5(6616), n3 = r4.all;
            e5.exports = r4.IS_HTMLDDA ? function(e6) {
              return "function" == typeof e6 || e6 === n3;
            } : function(e6) {
              return "function" == typeof e6;
            };
          }, 4284: (e5, t5, i5) => {
            var r4 = i5(5329), n3 = i5(5981), o3 = i5(7475), s3 = i5(9697), a3 = i5(626), c3 = i5(1302), d3 = function() {
            }, u3 = [], h3 = a3("Reflect", "construct"), A3 = /^\s*(?:class|function)\b/, l3 = r4(A3.exec), p3 = !A3.exec(d3), g3 = function(e6) {
              if (!o3(e6))
                return false;
              try {
                return h3(d3, u3, e6), true;
              } catch (e7) {
                return false;
              }
            }, E3 = function(e6) {
              if (!o3(e6))
                return false;
              switch (s3(e6)) {
                case "AsyncFunction":
                case "GeneratorFunction":
                case "AsyncGeneratorFunction":
                  return false;
              }
              try {
                return p3 || !!l3(A3, c3(e6));
              } catch (e7) {
                return true;
              }
            };
            E3.sham = true, e5.exports = !h3 || n3(function() {
              var e6;
              return g3(g3.call) || !g3(Object) || !g3(function() {
                e6 = true;
              }) || e6;
            }) ? E3 : g3;
          }, 7252: (e5, t5, i5) => {
            var r4 = i5(5981), n3 = i5(7475), o3 = /#|\.prototype\./, s3 = function(e6, t6) {
              var i6 = c3[a3(e6)];
              return i6 == u3 || i6 != d3 && (n3(t6) ? r4(t6) : !!t6);
            }, a3 = s3.normalize = function(e6) {
              return String(e6).replace(o3, ".").toLowerCase();
            }, c3 = s3.data = {}, d3 = s3.NATIVE = "N", u3 = s3.POLYFILL = "P";
            e5.exports = s3;
          }, 2119: (e5) => {
            e5.exports = function(e6) {
              return null == e6;
            };
          }, 941: (e5, t5, i5) => {
            var r4 = i5(7475), n3 = i5(6616), o3 = n3.all;
            e5.exports = n3.IS_HTMLDDA ? function(e6) {
              return "object" == typeof e6 ? null !== e6 : r4(e6) || e6 === o3;
            } : function(e6) {
              return "object" == typeof e6 ? null !== e6 : r4(e6);
            };
          }, 2529: (e5) => {
            e5.exports = true;
          }, 6664: (e5, t5, i5) => {
            var r4 = i5(626), n3 = i5(7475), o3 = i5(7046), s3 = i5(2302), a3 = Object;
            e5.exports = s3 ? function(e6) {
              return "symbol" == typeof e6;
            } : function(e6) {
              var t6 = r4("Symbol");
              return n3(t6) && o3(t6.prototype, a3(e6));
            };
          }, 3091: (e5, t5, i5) => {
            var r4 = i5(6843), n3 = i5(8834), o3 = i5(6059), s3 = i5(9826), a3 = i5(6782), c3 = i5(623), d3 = i5(7046), u3 = i5(3476), h3 = i5(2902), A3 = i5(7609), l3 = TypeError, p3 = function(e6, t6) {
              this.stopped = e6, this.result = t6;
            }, g3 = p3.prototype;
            e5.exports = function(e6, t6, i6) {
              var E3, f3, m3, I3, _3, C3, S3, v3 = i6 && i6.that, T3 = !(!i6 || !i6.AS_ENTRIES), R3 = !(!i6 || !i6.IS_RECORD), y3 = !(!i6 || !i6.IS_ITERATOR), w3 = !(!i6 || !i6.INTERRUPTED), b3 = r4(t6, v3), N3 = function(e7) {
                return E3 && A3(E3, "normal", e7), new p3(true, e7);
              }, O3 = function(e7) {
                return T3 ? (o3(e7), w3 ? b3(e7[0], e7[1], N3) : b3(e7[0], e7[1])) : w3 ? b3(e7, N3) : b3(e7);
              };
              if (R3)
                E3 = e6.iterator;
              else if (y3)
                E3 = e6;
              else {
                if (!(f3 = h3(e6)))
                  throw l3(s3(e6) + " is not iterable");
                if (a3(f3)) {
                  for (m3 = 0, I3 = c3(e6); I3 > m3; m3++)
                    if ((_3 = O3(e6[m3])) && d3(g3, _3))
                      return _3;
                  return new p3(false);
                }
                E3 = u3(e6, f3);
              }
              for (C3 = R3 ? e6.next : E3.next; !(S3 = n3(C3, E3)).done; ) {
                try {
                  _3 = O3(S3.value);
                } catch (e7) {
                  A3(E3, "throw", e7);
                }
                if ("object" == typeof _3 && _3 && d3(g3, _3))
                  return _3;
              }
              return new p3(false);
            };
          }, 7609: (e5, t5, i5) => {
            var r4 = i5(8834), n3 = i5(6059), o3 = i5(4229);
            e5.exports = function(e6, t6, i6) {
              var s3, a3;
              n3(e6);
              try {
                if (!(s3 = o3(e6, "return"))) {
                  if ("throw" === t6)
                    throw i6;
                  return i6;
                }
                s3 = r4(s3, e6);
              } catch (e7) {
                a3 = true, s3 = e7;
              }
              if ("throw" === t6)
                throw i6;
              if (a3)
                throw s3;
              return n3(s3), i6;
            };
          }, 3847: (e5, t5, i5) => {
            var r4 = i5(5143).IteratorPrototype, n3 = i5(9290), o3 = i5(1887), s3 = i5(904), a3 = i5(2077), c3 = function() {
              return this;
            };
            e5.exports = function(e6, t6, i6, d3) {
              var u3 = t6 + " Iterator";
              return e6.prototype = n3(r4, { next: o3(+!d3, i6) }), s3(e6, u3, false, true), a3[u3] = c3, e6;
            };
          }, 5105: (e5, t5, i5) => {
            var r4 = i5(6887), n3 = i5(8834), o3 = i5(2529), s3 = i5(9417), a3 = i5(7475), c3 = i5(3847), d3 = i5(249), u3 = i5(8929), h3 = i5(904), A3 = i5(2029), l3 = i5(5929), p3 = i5(9813), g3 = i5(2077), E3 = i5(5143), f3 = s3.PROPER, m3 = s3.CONFIGURABLE, I3 = E3.IteratorPrototype, _3 = E3.BUGGY_SAFARI_ITERATORS, C3 = p3("iterator"), S3 = "keys", v3 = "values", T3 = "entries", R3 = function() {
              return this;
            };
            e5.exports = function(e6, t6, i6, s4, p4, E4, y3) {
              c3(i6, t6, s4);
              var w3, b3, N3, O3 = function(e7) {
                if (e7 === p4 && B3)
                  return B3;
                if (!_3 && e7 in L3)
                  return L3[e7];
                switch (e7) {
                  case S3:
                  case v3:
                  case T3:
                    return function() {
                      return new i6(this, e7);
                    };
                }
                return function() {
                  return new i6(this);
                };
              }, D3 = t6 + " Iterator", P3 = false, L3 = e6.prototype, k3 = L3[C3] || L3["@@iterator"] || p4 && L3[p4], B3 = !_3 && k3 || O3(p4), M3 = "Array" == t6 && L3.entries || k3;
              if (M3 && (w3 = d3(M3.call(new e6()))) !== Object.prototype && w3.next && (o3 || d3(w3) === I3 || (u3 ? u3(w3, I3) : a3(w3[C3]) || l3(w3, C3, R3)), h3(w3, D3, true, true), o3 && (g3[D3] = R3)), f3 && p4 == v3 && k3 && k3.name !== v3 && (!o3 && m3 ? A3(L3, "name", v3) : (P3 = true, B3 = function() {
                return n3(k3, this);
              })), p4)
                if (b3 = { values: O3(v3), keys: E4 ? B3 : O3(S3), entries: O3(T3) }, y3)
                  for (N3 in b3)
                    (_3 || P3 || !(N3 in L3)) && l3(L3, N3, b3[N3]);
                else
                  r4({ target: t6, proto: true, forced: _3 || P3 }, b3);
              return o3 && !y3 || L3[C3] === B3 || l3(L3, C3, B3, { name: p4 }), g3[t6] = B3, b3;
            };
          }, 5143: (e5, t5, i5) => {
            var r4, n3, o3, s3 = i5(5981), a3 = i5(7475), c3 = i5(941), d3 = i5(9290), u3 = i5(249), h3 = i5(5929), A3 = i5(9813), l3 = i5(2529), p3 = A3("iterator"), g3 = false;
            [].keys && ("next" in (o3 = [].keys()) ? (n3 = u3(u3(o3))) !== Object.prototype && (r4 = n3) : g3 = true), !c3(r4) || s3(function() {
              var e6 = {};
              return r4[p3].call(e6) !== e6;
            }) ? r4 = {} : l3 && (r4 = d3(r4)), a3(r4[p3]) || h3(r4, p3, function() {
              return this;
            }), e5.exports = { IteratorPrototype: r4, BUGGY_SAFARI_ITERATORS: g3 };
          }, 2077: (e5) => {
            e5.exports = {};
          }, 623: (e5, t5, i5) => {
            var r4 = i5(3057);
            e5.exports = function(e6) {
              return r4(e6.length);
            };
          }, 5331: (e5) => {
            var t5 = Math.ceil, i5 = Math.floor;
            e5.exports = Math.trunc || function(e6) {
              var r4 = +e6;
              return (r4 > 0 ? i5 : t5)(r4);
            };
          }, 6132: (e5, t5, i5) => {
            var r4, n3, o3, s3, a3, c3, d3, u3, h3 = i5(1899), A3 = i5(6843), l3 = i5(9677).f, p3 = i5(2941).set, g3 = i5(2749), E3 = i5(4470), f3 = i5(8045), m3 = i5(6049), I3 = h3.MutationObserver || h3.WebKitMutationObserver, _3 = h3.document, C3 = h3.process, S3 = h3.Promise, v3 = l3(h3, "queueMicrotask"), T3 = v3 && v3.value;
            T3 || (r4 = function() {
              var e6, t6;
              for (m3 && (e6 = C3.domain) && e6.exit(); n3; ) {
                t6 = n3.fn, n3 = n3.next;
                try {
                  t6();
                } catch (e7) {
                  throw n3 ? s3() : o3 = void 0, e7;
                }
              }
              o3 = void 0, e6 && e6.enter();
            }, g3 || m3 || f3 || !I3 || !_3 ? !E3 && S3 && S3.resolve ? ((d3 = S3.resolve(void 0)).constructor = S3, u3 = A3(d3.then, d3), s3 = function() {
              u3(r4);
            }) : m3 ? s3 = function() {
              C3.nextTick(r4);
            } : (p3 = A3(p3, h3), s3 = function() {
              p3(r4);
            }) : (a3 = true, c3 = _3.createTextNode(""), new I3(r4).observe(c3, { characterData: true }), s3 = function() {
              c3.data = a3 = !a3;
            })), e5.exports = T3 || function(e6) {
              var t6 = { fn: e6, next: void 0 };
              o3 && (o3.next = t6), n3 || (n3 = t6, s3()), o3 = t6;
            };
          }, 9520: (e5, t5, i5) => {
            var r4 = i5(4883), n3 = TypeError, o3 = function(e6) {
              var t6, i6;
              this.promise = new e6(function(e7, r5) {
                if (void 0 !== t6 || void 0 !== i6)
                  throw n3("Bad Promise constructor");
                t6 = e7, i6 = r5;
              }), this.resolve = r4(t6), this.reject = r4(i6);
            };
            e5.exports.f = function(e6) {
              return new o3(e6);
            };
          }, 4649: (e5, t5, i5) => {
            var r4 = i5(5803);
            e5.exports = function(e6, t6) {
              return void 0 === e6 ? arguments.length < 2 ? "" : t6 : r4(e6);
            };
          }, 9290: (e5, t5, i5) => {
            var r4, n3 = i5(6059), o3 = i5(9938), s3 = i5(6759), a3 = i5(7748), c3 = i5(5463), d3 = i5(1333), u3 = i5(4262)("IE_PROTO"), h3 = function() {
            }, A3 = function(e6) {
              return "<script>" + e6 + "<\/script>";
            }, l3 = function(e6) {
              e6.write(A3("")), e6.close();
              var t6 = e6.parentWindow.Object;
              return e6 = null, t6;
            }, p3 = function() {
              try {
                r4 = new ActiveXObject("htmlfile");
              } catch (e7) {
              }
              var e6, t6;
              p3 = "undefined" != typeof document ? document.domain && r4 ? l3(r4) : ((t6 = d3("iframe")).style.display = "none", c3.appendChild(t6), t6.src = String("javascript:"), (e6 = t6.contentWindow.document).open(), e6.write(A3("document.F=Object")), e6.close(), e6.F) : l3(r4);
              for (var i6 = s3.length; i6--; )
                delete p3.prototype[s3[i6]];
              return p3();
            };
            a3[u3] = true, e5.exports = Object.create || function(e6, t6) {
              var i6;
              return null !== e6 ? (h3.prototype = n3(e6), i6 = new h3(), h3.prototype = null, i6[u3] = e6) : i6 = p3(), void 0 === t6 ? i6 : o3.f(i6, t6);
            };
          }, 9938: (e5, t5, i5) => {
            var r4 = i5(5746), n3 = i5(3937), o3 = i5(5988), s3 = i5(6059), a3 = i5(4529), c3 = i5(4771);
            t5.f = r4 && !n3 ? Object.defineProperties : function(e6, t6) {
              s3(e6);
              for (var i6, r5 = a3(t6), n4 = c3(t6), d3 = n4.length, u3 = 0; d3 > u3; )
                o3.f(e6, i6 = n4[u3++], r5[i6]);
              return e6;
            };
          }, 5988: (e5, t5, i5) => {
            var r4 = i5(5746), n3 = i5(2840), o3 = i5(3937), s3 = i5(6059), a3 = i5(3894), c3 = TypeError, d3 = Object.defineProperty, u3 = Object.getOwnPropertyDescriptor;
            t5.f = r4 ? o3 ? function(e6, t6, i6) {
              if (s3(e6), t6 = a3(t6), s3(i6), "function" == typeof e6 && "prototype" === t6 && "value" in i6 && "writable" in i6 && !i6.writable) {
                var r5 = u3(e6, t6);
                r5 && r5.writable && (e6[t6] = i6.value, i6 = { configurable: "configurable" in i6 ? i6.configurable : r5.configurable, enumerable: "enumerable" in i6 ? i6.enumerable : r5.enumerable, writable: false });
              }
              return d3(e6, t6, i6);
            } : d3 : function(e6, t6, i6) {
              if (s3(e6), t6 = a3(t6), s3(i6), n3)
                try {
                  return d3(e6, t6, i6);
                } catch (e7) {
                }
              if ("get" in i6 || "set" in i6)
                throw c3("Accessors not supported");
              return "value" in i6 && (e6[t6] = i6.value), e6;
            };
          }, 9677: (e5, t5, i5) => {
            var r4 = i5(5746), n3 = i5(8834), o3 = i5(6760), s3 = i5(1887), a3 = i5(4529), c3 = i5(3894), d3 = i5(953), u3 = i5(2840), h3 = Object.getOwnPropertyDescriptor;
            t5.f = r4 ? h3 : function(e6, t6) {
              if (e6 = a3(e6), t6 = c3(t6), u3)
                try {
                  return h3(e6, t6);
                } catch (e7) {
                }
              if (d3(e6, t6))
                return s3(!n3(o3.f, e6, t6), e6[t6]);
            };
          }, 946: (e5, t5, i5) => {
            var r4 = i5(5629), n3 = i5(6759).concat("length", "prototype");
            t5.f = Object.getOwnPropertyNames || function(e6) {
              return r4(e6, n3);
            };
          }, 7857: (e5, t5) => {
            t5.f = Object.getOwnPropertySymbols;
          }, 249: (e5, t5, i5) => {
            var r4 = i5(953), n3 = i5(7475), o3 = i5(9678), s3 = i5(4262), a3 = i5(4160), c3 = s3("IE_PROTO"), d3 = Object, u3 = d3.prototype;
            e5.exports = a3 ? d3.getPrototypeOf : function(e6) {
              var t6 = o3(e6);
              if (r4(t6, c3))
                return t6[c3];
              var i6 = t6.constructor;
              return n3(i6) && t6 instanceof i6 ? i6.prototype : t6 instanceof d3 ? u3 : null;
            };
          }, 7046: (e5, t5, i5) => {
            var r4 = i5(5329);
            e5.exports = r4({}.isPrototypeOf);
          }, 5629: (e5, t5, i5) => {
            var r4 = i5(5329), n3 = i5(953), o3 = i5(4529), s3 = i5(1692).indexOf, a3 = i5(7748), c3 = r4([].push);
            e5.exports = function(e6, t6) {
              var i6, r5 = o3(e6), d3 = 0, u3 = [];
              for (i6 in r5)
                !n3(a3, i6) && n3(r5, i6) && c3(u3, i6);
              for (; t6.length > d3; )
                n3(r5, i6 = t6[d3++]) && (~s3(u3, i6) || c3(u3, i6));
              return u3;
            };
          }, 4771: (e5, t5, i5) => {
            var r4 = i5(5629), n3 = i5(6759);
            e5.exports = Object.keys || function(e6) {
              return r4(e6, n3);
            };
          }, 6760: (e5, t5) => {
            var i5 = {}.propertyIsEnumerable, r4 = Object.getOwnPropertyDescriptor, n3 = r4 && !i5.call({ 1: 2 }, 1);
            t5.f = n3 ? function(e6) {
              var t6 = r4(this, e6);
              return !!t6 && t6.enumerable;
            } : i5;
          }, 8929: (e5, t5, i5) => {
            var r4 = i5(5329), n3 = i5(6059), o3 = i5(1851);
            e5.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
              var e6, t6 = false, i6 = {};
              try {
                (e6 = r4(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(i6, []), t6 = i6 instanceof Array;
              } catch (e7) {
              }
              return function(i7, r5) {
                return n3(i7), o3(r5), t6 ? e6(i7, r5) : i7.__proto__ = r5, i7;
              };
            }() : void 0);
          }, 5623: (e5, t5, i5) => {
            var r4 = i5(2885), n3 = i5(9697);
            e5.exports = r4 ? {}.toString : function() {
              return "[object " + n3(this) + "]";
            };
          }, 9811: (e5, t5, i5) => {
            var r4 = i5(8834), n3 = i5(7475), o3 = i5(941), s3 = TypeError;
            e5.exports = function(e6, t6) {
              var i6, a3;
              if ("string" === t6 && n3(i6 = e6.toString) && !o3(a3 = r4(i6, e6)))
                return a3;
              if (n3(i6 = e6.valueOf) && !o3(a3 = r4(i6, e6)))
                return a3;
              if ("string" !== t6 && n3(i6 = e6.toString) && !o3(a3 = r4(i6, e6)))
                return a3;
              throw s3("Can't convert object to primitive value");
            };
          }, 1136: (e5, t5, i5) => {
            var r4 = i5(626), n3 = i5(5329), o3 = i5(946), s3 = i5(7857), a3 = i5(6059), c3 = n3([].concat);
            e5.exports = r4("Reflect", "ownKeys") || function(e6) {
              var t6 = o3.f(a3(e6)), i6 = s3.f;
              return i6 ? c3(t6, i6(e6)) : t6;
            };
          }, 4058: (e5) => {
            e5.exports = {};
          }, 2: (e5) => {
            e5.exports = function(e6) {
              try {
                return { error: false, value: e6() };
              } catch (e7) {
                return { error: true, value: e7 };
              }
            };
          }, 7742: (e5, t5, i5) => {
            var r4 = i5(1899), n3 = i5(6991), o3 = i5(7475), s3 = i5(7252), a3 = i5(1302), c3 = i5(9813), d3 = i5(3321), u3 = i5(8501), h3 = i5(2529), A3 = i5(3385), l3 = n3 && n3.prototype, p3 = c3("species"), g3 = false, E3 = o3(r4.PromiseRejectionEvent), f3 = s3("Promise", function() {
              var e6 = a3(n3), t6 = e6 !== String(n3);
              if (!t6 && 66 === A3)
                return true;
              if (h3 && (!l3.catch || !l3.finally))
                return true;
              if (!A3 || A3 < 51 || !/native code/.test(e6)) {
                var i6 = new n3(function(e7) {
                  e7(1);
                }), r5 = function(e7) {
                  e7(function() {
                  }, function() {
                  });
                };
                if ((i6.constructor = {})[p3] = r5, !(g3 = i6.then(function() {
                }) instanceof r5))
                  return true;
              }
              return !t6 && (d3 || u3) && !E3;
            });
            e5.exports = { CONSTRUCTOR: f3, REJECTION_EVENT: E3, SUBCLASSING: g3 };
          }, 6991: (e5, t5, i5) => {
            var r4 = i5(1899);
            e5.exports = r4.Promise;
          }, 6584: (e5, t5, i5) => {
            var r4 = i5(6059), n3 = i5(941), o3 = i5(9520);
            e5.exports = function(e6, t6) {
              if (r4(e6), n3(t6) && t6.constructor === e6)
                return t6;
              var i6 = o3.f(e6);
              return (0, i6.resolve)(t6), i6.promise;
            };
          }, 1542: (e5, t5, i5) => {
            var r4 = i5(6991), n3 = i5(1385), o3 = i5(7742).CONSTRUCTOR;
            e5.exports = o3 || !n3(function(e6) {
              r4.all(e6).then(void 0, function() {
              });
            });
          }, 8397: (e5) => {
            var t5 = function() {
              this.head = null, this.tail = null;
            };
            t5.prototype = { add: function(e6) {
              var t6 = { item: e6, next: null };
              this.head ? this.tail.next = t6 : this.head = t6, this.tail = t6;
            }, get: function() {
              var e6 = this.head;
              if (e6)
                return this.head = e6.next, this.tail === e6 && (this.tail = null), e6.item;
            } }, e5.exports = t5;
          }, 8219: (e5, t5, i5) => {
            var r4 = i5(2119), n3 = TypeError;
            e5.exports = function(e6) {
              if (r4(e6))
                throw n3("Can't call method on " + e6);
              return e6;
            };
          }, 4431: (e5, t5, i5) => {
            var r4 = i5(626), n3 = i5(5988), o3 = i5(9813), s3 = i5(5746), a3 = o3("species");
            e5.exports = function(e6) {
              var t6 = r4(e6), i6 = n3.f;
              s3 && t6 && !t6[a3] && i6(t6, a3, { configurable: true, get: function() {
                return this;
              } });
            };
          }, 904: (e5, t5, i5) => {
            var r4 = i5(2885), n3 = i5(5988).f, o3 = i5(2029), s3 = i5(953), a3 = i5(5623), c3 = i5(9813)("toStringTag");
            e5.exports = function(e6, t6, i6, d3) {
              if (e6) {
                var u3 = i6 ? e6 : e6.prototype;
                s3(u3, c3) || n3(u3, c3, { configurable: true, value: t6 }), d3 && !r4 && o3(u3, "toString", a3);
              }
            };
          }, 4262: (e5, t5, i5) => {
            var r4 = i5(8726), n3 = i5(9418), o3 = r4("keys");
            e5.exports = function(e6) {
              return o3[e6] || (o3[e6] = n3(e6));
            };
          }, 3030: (e5, t5, i5) => {
            var r4 = i5(1899), n3 = i5(5609), o3 = "__core-js_shared__", s3 = r4[o3] || n3(o3, {});
            e5.exports = s3;
          }, 8726: (e5, t5, i5) => {
            var r4 = i5(2529), n3 = i5(3030);
            (e5.exports = function(e6, t6) {
              return n3[e6] || (n3[e6] = void 0 !== t6 ? t6 : {});
            })("versions", []).push({ version: "3.26.0", mode: r4 ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.0/LICENSE", source: "https://github.com/zloirock/core-js" });
          }, 487: (e5, t5, i5) => {
            var r4 = i5(6059), n3 = i5(174), o3 = i5(2119), s3 = i5(9813)("species");
            e5.exports = function(e6, t6) {
              var i6, a3 = r4(e6).constructor;
              return void 0 === a3 || o3(i6 = r4(a3)[s3]) ? t6 : n3(i6);
            };
          }, 4620: (e5, t5, i5) => {
            var r4 = i5(5329), n3 = i5(2435), o3 = i5(5803), s3 = i5(8219), a3 = r4("".charAt), c3 = r4("".charCodeAt), d3 = r4("".slice), u3 = function(e6) {
              return function(t6, i6) {
                var r5, u4, h3 = o3(s3(t6)), A3 = n3(i6), l3 = h3.length;
                return A3 < 0 || A3 >= l3 ? e6 ? "" : void 0 : (r5 = c3(h3, A3)) < 55296 || r5 > 56319 || A3 + 1 === l3 || (u4 = c3(h3, A3 + 1)) < 56320 || u4 > 57343 ? e6 ? a3(h3, A3) : r5 : e6 ? d3(h3, A3, A3 + 2) : u4 - 56320 + (r5 - 55296 << 10) + 65536;
              };
            };
            e5.exports = { codeAt: u3(false), charAt: u3(true) };
          }, 3405: (e5, t5, i5) => {
            var r4 = i5(3385), n3 = i5(5981);
            e5.exports = !!Object.getOwnPropertySymbols && !n3(function() {
              var e6 = Symbol();
              return !String(e6) || !(Object(e6) instanceof Symbol) || !Symbol.sham && r4 && r4 < 41;
            });
          }, 2941: (e5, t5, i5) => {
            var r4, n3, o3, s3, a3 = i5(1899), c3 = i5(9730), d3 = i5(6843), u3 = i5(7475), h3 = i5(953), A3 = i5(5981), l3 = i5(5463), p3 = i5(3765), g3 = i5(1333), E3 = i5(8348), f3 = i5(2749), m3 = i5(6049), I3 = a3.setImmediate, _3 = a3.clearImmediate, C3 = a3.process, S3 = a3.Dispatch, v3 = a3.Function, T3 = a3.MessageChannel, R3 = a3.String, y3 = 0, w3 = {};
            try {
              r4 = a3.location;
            } catch (e6) {
            }
            var b3 = function(e6) {
              if (h3(w3, e6)) {
                var t6 = w3[e6];
                delete w3[e6], t6();
              }
            }, N3 = function(e6) {
              return function() {
                b3(e6);
              };
            }, O3 = function(e6) {
              b3(e6.data);
            }, D3 = function(e6) {
              a3.postMessage(R3(e6), r4.protocol + "//" + r4.host);
            };
            I3 && _3 || (I3 = function(e6) {
              E3(arguments.length, 1);
              var t6 = u3(e6) ? e6 : v3(e6), i6 = p3(arguments, 1);
              return w3[++y3] = function() {
                c3(t6, void 0, i6);
              }, n3(y3), y3;
            }, _3 = function(e6) {
              delete w3[e6];
            }, m3 ? n3 = function(e6) {
              C3.nextTick(N3(e6));
            } : S3 && S3.now ? n3 = function(e6) {
              S3.now(N3(e6));
            } : T3 && !f3 ? (s3 = (o3 = new T3()).port2, o3.port1.onmessage = O3, n3 = d3(s3.postMessage, s3)) : a3.addEventListener && u3(a3.postMessage) && !a3.importScripts && r4 && "file:" !== r4.protocol && !A3(D3) ? (n3 = D3, a3.addEventListener("message", O3, false)) : n3 = "onreadystatechange" in g3("script") ? function(e6) {
              l3.appendChild(g3("script")).onreadystatechange = function() {
                l3.removeChild(this), b3(e6);
              };
            } : function(e6) {
              setTimeout(N3(e6), 0);
            }), e5.exports = { set: I3, clear: _3 };
          }, 9413: (e5, t5, i5) => {
            var r4 = i5(2435), n3 = Math.max, o3 = Math.min;
            e5.exports = function(e6, t6) {
              var i6 = r4(e6);
              return i6 < 0 ? n3(i6 + t6, 0) : o3(i6, t6);
            };
          }, 4529: (e5, t5, i5) => {
            var r4 = i5(7026), n3 = i5(8219);
            e5.exports = function(e6) {
              return r4(n3(e6));
            };
          }, 2435: (e5, t5, i5) => {
            var r4 = i5(5331);
            e5.exports = function(e6) {
              var t6 = +e6;
              return t6 != t6 || 0 === t6 ? 0 : r4(t6);
            };
          }, 3057: (e5, t5, i5) => {
            var r4 = i5(2435), n3 = Math.min;
            e5.exports = function(e6) {
              return e6 > 0 ? n3(r4(e6), 9007199254740991) : 0;
            };
          }, 9678: (e5, t5, i5) => {
            var r4 = i5(8219), n3 = Object;
            e5.exports = function(e6) {
              return n3(r4(e6));
            };
          }, 6935: (e5, t5, i5) => {
            var r4 = i5(8834), n3 = i5(941), o3 = i5(6664), s3 = i5(4229), a3 = i5(9811), c3 = i5(9813), d3 = TypeError, u3 = c3("toPrimitive");
            e5.exports = function(e6, t6) {
              if (!n3(e6) || o3(e6))
                return e6;
              var i6, c4 = s3(e6, u3);
              if (c4) {
                if (void 0 === t6 && (t6 = "default"), i6 = r4(c4, e6, t6), !n3(i6) || o3(i6))
                  return i6;
                throw d3("Can't convert object to primitive value");
              }
              return void 0 === t6 && (t6 = "number"), a3(e6, t6);
            };
          }, 3894: (e5, t5, i5) => {
            var r4 = i5(6935), n3 = i5(6664);
            e5.exports = function(e6) {
              var t6 = r4(e6, "string");
              return n3(t6) ? t6 : t6 + "";
            };
          }, 2885: (e5, t5, i5) => {
            var r4 = {};
            r4[i5(9813)("toStringTag")] = "z", e5.exports = "[object z]" === String(r4);
          }, 5803: (e5, t5, i5) => {
            var r4 = i5(9697), n3 = String;
            e5.exports = function(e6) {
              if ("Symbol" === r4(e6))
                throw TypeError("Cannot convert a Symbol value to a string");
              return n3(e6);
            };
          }, 9826: (e5) => {
            var t5 = String;
            e5.exports = function(e6) {
              try {
                return t5(e6);
              } catch (e7) {
                return "Object";
              }
            };
          }, 9418: (e5, t5, i5) => {
            var r4 = i5(5329), n3 = 0, o3 = Math.random(), s3 = r4(1 .toString);
            e5.exports = function(e6) {
              return "Symbol(" + (void 0 === e6 ? "" : e6) + ")_" + s3(++n3 + o3, 36);
            };
          }, 2302: (e5, t5, i5) => {
            var r4 = i5(3405);
            e5.exports = r4 && !Symbol.sham && "symbol" == typeof Symbol.iterator;
          }, 3937: (e5, t5, i5) => {
            var r4 = i5(5746), n3 = i5(5981);
            e5.exports = r4 && n3(function() {
              return 42 != Object.defineProperty(function() {
              }, "prototype", { value: 42, writable: false }).prototype;
            });
          }, 8348: (e5) => {
            var t5 = TypeError;
            e5.exports = function(e6, i5) {
              if (e6 < i5)
                throw t5("Not enough arguments");
              return e6;
            };
          }, 7093: (e5, t5, i5) => {
            var r4 = i5(1899), n3 = i5(7475), o3 = r4.WeakMap;
            e5.exports = n3(o3) && /native code/.test(String(o3));
          }, 9813: (e5, t5, i5) => {
            var r4 = i5(1899), n3 = i5(8726), o3 = i5(953), s3 = i5(9418), a3 = i5(3405), c3 = i5(2302), d3 = n3("wks"), u3 = r4.Symbol, h3 = u3 && u3.for, A3 = c3 ? u3 : u3 && u3.withoutSetter || s3;
            e5.exports = function(e6) {
              if (!o3(d3, e6) || !a3 && "string" != typeof d3[e6]) {
                var t6 = "Symbol." + e6;
                a3 && o3(u3, e6) ? d3[e6] = u3[e6] : d3[e6] = c3 && h3 ? h3(t6) : A3(t6);
              }
              return d3[e6];
            };
          }, 9812: (e5, t5, i5) => {
            var r4 = i5(6887), n3 = i5(7046), o3 = i5(249), s3 = i5(8929), a3 = i5(3489), c3 = i5(9290), d3 = i5(2029), u3 = i5(1887), h3 = i5(3995), A3 = i5(3794), l3 = i5(3091), p3 = i5(4649), g3 = i5(9813), E3 = i5(8780), f3 = g3("toStringTag"), m3 = Error, I3 = [].push, _3 = function(e6, t6) {
              var i6, r5 = arguments.length > 2 ? arguments[2] : void 0, a4 = n3(C3, this);
              s3 ? i6 = s3(m3(), a4 ? o3(this) : C3) : (i6 = a4 ? this : c3(C3), d3(i6, f3, "Error")), void 0 !== t6 && d3(i6, "message", p3(t6)), E3 && d3(i6, "stack", h3(i6.stack, 1)), A3(i6, r5);
              var u4 = [];
              return l3(e6, I3, { that: u4 }), d3(i6, "errors", u4), i6;
            };
            s3 ? s3(_3, m3) : a3(_3, m3, { name: true });
            var C3 = _3.prototype = c3(m3.prototype, { constructor: u3(1, _3), message: u3(1, ""), name: u3(1, "AggregateError") });
            r4({ global: true, constructor: true, arity: 2 }, { AggregateError: _3 });
          }, 7627: (e5, t5, i5) => {
            i5(9812);
          }, 6274: (e5, t5, i5) => {
            var r4 = i5(4529), n3 = i5(8479), o3 = i5(2077), s3 = i5(5402), a3 = i5(5988).f, c3 = i5(5105), d3 = i5(3538), u3 = i5(2529), h3 = i5(5746), A3 = "Array Iterator", l3 = s3.set, p3 = s3.getterFor(A3);
            e5.exports = c3(Array, "Array", function(e6, t6) {
              l3(this, { type: A3, target: r4(e6), index: 0, kind: t6 });
            }, function() {
              var e6 = p3(this), t6 = e6.target, i6 = e6.kind, r5 = e6.index++;
              return !t6 || r5 >= t6.length ? (e6.target = void 0, d3(void 0, true)) : d3("keys" == i6 ? r5 : "values" == i6 ? t6[r5] : [r5, t6[r5]], false);
            }, "values");
            var g3 = o3.Arguments = o3.Array;
            if (n3("keys"), n3("values"), n3("entries"), !u3 && h3 && "values" !== g3.name)
              try {
                a3(g3, "name", { value: "values" });
              } catch (e6) {
              }
          }, 6450: (e5, t5, i5) => {
            var r4 = i5(6887), n3 = i5(5746), o3 = i5(5988).f;
            r4({ target: "Object", stat: true, forced: Object.defineProperty !== o3, sham: !n3 }, { defineProperty: o3 });
          }, 5967: () => {
          }, 4560: (e5, t5, i5) => {
            var r4 = i5(6887), n3 = i5(8834), o3 = i5(4883), s3 = i5(9520), a3 = i5(2), c3 = i5(3091);
            r4({ target: "Promise", stat: true }, { allSettled: function(e6) {
              var t6 = this, i6 = s3.f(t6), r5 = i6.resolve, d3 = i6.reject, u3 = a3(function() {
                var i7 = o3(t6.resolve), s4 = [], a4 = 0, d4 = 1;
                c3(e6, function(e7) {
                  var o4 = a4++, c4 = false;
                  d4++, n3(i7, t6, e7).then(function(e8) {
                    c4 || (c4 = true, s4[o4] = { status: "fulfilled", value: e8 }, --d4 || r5(s4));
                  }, function(e8) {
                    c4 || (c4 = true, s4[o4] = { status: "rejected", reason: e8 }, --d4 || r5(s4));
                  });
                }), --d4 || r5(s4);
              });
              return u3.error && d3(u3.value), i6.promise;
            } });
          }, 6890: (e5, t5, i5) => {
            var r4 = i5(6887), n3 = i5(8834), o3 = i5(4883), s3 = i5(9520), a3 = i5(2), c3 = i5(3091);
            r4({ target: "Promise", stat: true, forced: i5(1542) }, { all: function(e6) {
              var t6 = this, i6 = s3.f(t6), r5 = i6.resolve, d3 = i6.reject, u3 = a3(function() {
                var i7 = o3(t6.resolve), s4 = [], a4 = 0, u4 = 1;
                c3(e6, function(e7) {
                  var o4 = a4++, c4 = false;
                  u4++, n3(i7, t6, e7).then(function(e8) {
                    c4 || (c4 = true, s4[o4] = e8, --u4 || r5(s4));
                  }, d3);
                }), --u4 || r5(s4);
              });
              return u3.error && d3(u3.value), i6.promise;
            } });
          }, 7206: (e5, t5, i5) => {
            var r4 = i5(6887), n3 = i5(8834), o3 = i5(4883), s3 = i5(626), a3 = i5(9520), c3 = i5(2), d3 = i5(3091), u3 = "No one promise resolved";
            r4({ target: "Promise", stat: true }, { any: function(e6) {
              var t6 = this, i6 = s3("AggregateError"), r5 = a3.f(t6), h3 = r5.resolve, A3 = r5.reject, l3 = c3(function() {
                var r6 = o3(t6.resolve), s4 = [], a4 = 0, c4 = 1, l4 = false;
                d3(e6, function(e7) {
                  var o4 = a4++, d4 = false;
                  c4++, n3(r6, t6, e7).then(function(e8) {
                    d4 || l4 || (l4 = true, h3(e8));
                  }, function(e8) {
                    d4 || l4 || (d4 = true, s4[o4] = e8, --c4 || A3(new i6(s4, u3)));
                  });
                }), --c4 || A3(new i6(s4, u3));
              });
              return l3.error && A3(l3.value), r5.promise;
            } });
          }, 3376: (e5, t5, i5) => {
            var r4 = i5(6887), n3 = i5(2529), o3 = i5(7742).CONSTRUCTOR, s3 = i5(6991), a3 = i5(626), c3 = i5(7475), d3 = i5(5929), u3 = s3 && s3.prototype;
            if (r4({ target: "Promise", proto: true, forced: o3, real: true }, { catch: function(e6) {
              return this.then(void 0, e6);
            } }), !n3 && c3(s3)) {
              var h3 = a3("Promise").prototype.catch;
              u3.catch !== h3 && d3(u3, "catch", h3, { unsafe: true });
            }
          }, 6934: (e5, t5, i5) => {
            var r4, n3, o3, s3 = i5(6887), a3 = i5(2529), c3 = i5(6049), d3 = i5(1899), u3 = i5(8834), h3 = i5(5929), A3 = i5(8929), l3 = i5(904), p3 = i5(4431), g3 = i5(4883), E3 = i5(7475), f3 = i5(941), m3 = i5(5743), I3 = i5(487), _3 = i5(2941).set, C3 = i5(6132), S3 = i5(4845), v3 = i5(2), T3 = i5(8397), R3 = i5(5402), y3 = i5(6991), w3 = i5(7742), b3 = i5(9520), N3 = "Promise", O3 = w3.CONSTRUCTOR, D3 = w3.REJECTION_EVENT, P3 = w3.SUBCLASSING, L3 = R3.getterFor(N3), k3 = R3.set, B3 = y3 && y3.prototype, M3 = y3, U3 = B3, x3 = d3.TypeError, Q3 = d3.document, F3 = d3.process, V3 = b3.f, j3 = V3, G3 = !!(Q3 && Q3.createEvent && d3.dispatchEvent), K3 = "unhandledrejection", H3 = function(e6) {
              var t6;
              return !(!f3(e6) || !E3(t6 = e6.then)) && t6;
            }, W3 = function(e6, t6) {
              var i6, r5, n4, o4 = t6.value, s4 = 1 == t6.state, a4 = s4 ? e6.ok : e6.fail, c4 = e6.resolve, d4 = e6.reject, h4 = e6.domain;
              try {
                a4 ? (s4 || (2 === t6.rejection && z3(t6), t6.rejection = 1), true === a4 ? i6 = o4 : (h4 && h4.enter(), i6 = a4(o4), h4 && (h4.exit(), n4 = true)), i6 === e6.promise ? d4(x3("Promise-chain cycle")) : (r5 = H3(i6)) ? u3(r5, i6, c4, d4) : c4(i6)) : d4(o4);
              } catch (e7) {
                h4 && !n4 && h4.exit(), d4(e7);
              }
            }, Y3 = function(e6, t6) {
              e6.notified || (e6.notified = true, C3(function() {
                for (var i6, r5 = e6.reactions; i6 = r5.get(); )
                  W3(i6, e6);
                e6.notified = false, t6 && !e6.rejection && q3(e6);
              }));
            }, J3 = function(e6, t6, i6) {
              var r5, n4;
              G3 ? ((r5 = Q3.createEvent("Event")).promise = t6, r5.reason = i6, r5.initEvent(e6, false, true), d3.dispatchEvent(r5)) : r5 = { promise: t6, reason: i6 }, !D3 && (n4 = d3["on" + e6]) ? n4(r5) : e6 === K3 && S3("Unhandled promise rejection", i6);
            }, q3 = function(e6) {
              u3(_3, d3, function() {
                var t6, i6 = e6.facade, r5 = e6.value;
                if (X3(e6) && (t6 = v3(function() {
                  c3 ? F3.emit("unhandledRejection", r5, i6) : J3(K3, i6, r5);
                }), e6.rejection = c3 || X3(e6) ? 2 : 1, t6.error))
                  throw t6.value;
              });
            }, X3 = function(e6) {
              return 1 !== e6.rejection && !e6.parent;
            }, z3 = function(e6) {
              u3(_3, d3, function() {
                var t6 = e6.facade;
                c3 ? F3.emit("rejectionHandled", t6) : J3("rejectionhandled", t6, e6.value);
              });
            }, Z2 = function(e6, t6, i6) {
              return function(r5) {
                e6(t6, r5, i6);
              };
            }, $2 = function(e6, t6, i6) {
              e6.done || (e6.done = true, i6 && (e6 = i6), e6.value = t6, e6.state = 2, Y3(e6, true));
            }, ee2 = function(e6, t6, i6) {
              if (!e6.done) {
                e6.done = true, i6 && (e6 = i6);
                try {
                  if (e6.facade === t6)
                    throw x3("Promise can't be resolved itself");
                  var r5 = H3(t6);
                  r5 ? C3(function() {
                    var i7 = { done: false };
                    try {
                      u3(r5, t6, Z2(ee2, i7, e6), Z2($2, i7, e6));
                    } catch (t7) {
                      $2(i7, t7, e6);
                    }
                  }) : (e6.value = t6, e6.state = 1, Y3(e6, false));
                } catch (t7) {
                  $2({ done: false }, t7, e6);
                }
              }
            };
            if (O3 && (U3 = (M3 = function(e6) {
              m3(this, U3), g3(e6), u3(r4, this);
              var t6 = L3(this);
              try {
                e6(Z2(ee2, t6), Z2($2, t6));
              } catch (e7) {
                $2(t6, e7);
              }
            }).prototype, (r4 = function(e6) {
              k3(this, { type: N3, done: false, notified: false, parent: false, reactions: new T3(), rejection: false, state: 0, value: void 0 });
            }).prototype = h3(U3, "then", function(e6, t6) {
              var i6 = L3(this), r5 = V3(I3(this, M3));
              return i6.parent = true, r5.ok = !E3(e6) || e6, r5.fail = E3(t6) && t6, r5.domain = c3 ? F3.domain : void 0, 0 == i6.state ? i6.reactions.add(r5) : C3(function() {
                W3(r5, i6);
              }), r5.promise;
            }), n3 = function() {
              var e6 = new r4(), t6 = L3(e6);
              this.promise = e6, this.resolve = Z2(ee2, t6), this.reject = Z2($2, t6);
            }, b3.f = V3 = function(e6) {
              return e6 === M3 || void 0 === e6 ? new n3(e6) : j3(e6);
            }, !a3 && E3(y3) && B3 !== Object.prototype)) {
              o3 = B3.then, P3 || h3(B3, "then", function(e6, t6) {
                var i6 = this;
                return new M3(function(e7, t7) {
                  u3(o3, i6, e7, t7);
                }).then(e6, t6);
              }, { unsafe: true });
              try {
                delete B3.constructor;
              } catch (e6) {
              }
              A3 && A3(B3, U3);
            }
            s3({ global: true, constructor: true, wrap: true, forced: O3 }, { Promise: M3 }), l3(M3, N3, false, true), p3(N3);
          }, 4349: (e5, t5, i5) => {
            var r4 = i5(6887), n3 = i5(2529), o3 = i5(6991), s3 = i5(5981), a3 = i5(626), c3 = i5(7475), d3 = i5(487), u3 = i5(6584), h3 = i5(5929), A3 = o3 && o3.prototype;
            if (r4({ target: "Promise", proto: true, real: true, forced: !!o3 && s3(function() {
              A3.finally.call({ then: function() {
              } }, function() {
              });
            }) }, { finally: function(e6) {
              var t6 = d3(this, a3("Promise")), i6 = c3(e6);
              return this.then(i6 ? function(i7) {
                return u3(t6, e6()).then(function() {
                  return i7;
                });
              } : e6, i6 ? function(i7) {
                return u3(t6, e6()).then(function() {
                  throw i7;
                });
              } : e6);
            } }), !n3 && c3(o3)) {
              var l3 = a3("Promise").prototype.finally;
              A3.finally !== l3 && h3(A3, "finally", l3, { unsafe: true });
            }
          }, 8881: (e5, t5, i5) => {
            i5(6934), i5(6890), i5(3376), i5(5921), i5(4069), i5(4482);
          }, 5921: (e5, t5, i5) => {
            var r4 = i5(6887), n3 = i5(8834), o3 = i5(4883), s3 = i5(9520), a3 = i5(2), c3 = i5(3091);
            r4({ target: "Promise", stat: true, forced: i5(1542) }, { race: function(e6) {
              var t6 = this, i6 = s3.f(t6), r5 = i6.reject, d3 = a3(function() {
                var s4 = o3(t6.resolve);
                c3(e6, function(e7) {
                  n3(s4, t6, e7).then(i6.resolve, r5);
                });
              });
              return d3.error && r5(d3.value), i6.promise;
            } });
          }, 4069: (e5, t5, i5) => {
            var r4 = i5(6887), n3 = i5(8834), o3 = i5(9520);
            r4({ target: "Promise", stat: true, forced: i5(7742).CONSTRUCTOR }, { reject: function(e6) {
              var t6 = o3.f(this);
              return n3(t6.reject, void 0, e6), t6.promise;
            } });
          }, 4482: (e5, t5, i5) => {
            var r4 = i5(6887), n3 = i5(626), o3 = i5(2529), s3 = i5(6991), a3 = i5(7742).CONSTRUCTOR, c3 = i5(6584), d3 = n3("Promise"), u3 = o3 && !a3;
            r4({ target: "Promise", stat: true, forced: o3 || a3 }, { resolve: function(e6) {
              return c3(u3 && this === d3 ? s3 : this, e6);
            } });
          }, 7971: (e5, t5, i5) => {
            var r4 = i5(4620).charAt, n3 = i5(5803), o3 = i5(5402), s3 = i5(5105), a3 = i5(3538), c3 = "String Iterator", d3 = o3.set, u3 = o3.getterFor(c3);
            s3(String, "String", function(e6) {
              d3(this, { type: c3, string: n3(e6), index: 0 });
            }, function() {
              var e6, t6 = u3(this), i6 = t6.string, n4 = t6.index;
              return n4 >= i6.length ? a3(void 0, true) : (e6 = r4(i6, n4), t6.index += e6.length, a3(e6, false));
            });
          }, 7634: (e5, t5, i5) => {
            i5(6274);
            var r4 = i5(3281), n3 = i5(1899), o3 = i5(9697), s3 = i5(2029), a3 = i5(2077), c3 = i5(9813)("toStringTag");
            for (var d3 in r4) {
              var u3 = n3[d3], h3 = u3 && u3.prototype;
              h3 && o3(h3) !== c3 && s3(h3, c3, d3), a3[d3] = a3.Array;
            }
          }, 1910: (e5, t5, i5) => {
            var r4 = i5(8171);
            e5.exports = r4;
          }, 7460: (e5, t5, i5) => {
            var r4 = i5(2956);
            i5(7634), e5.exports = r4;
          }, 9662: (e5, t5, i5) => {
            var r4 = i5(614), n3 = i5(6330), o3 = TypeError;
            e5.exports = function(e6) {
              if (r4(e6))
                return e6;
              throw o3(n3(e6) + " is not a function");
            };
          }, 6077: (e5, t5, i5) => {
            var r4 = i5(614), n3 = String, o3 = TypeError;
            e5.exports = function(e6) {
              if ("object" == typeof e6 || r4(e6))
                return e6;
              throw o3("Can't set " + n3(e6) + " as a prototype");
            };
          }, 1223: (e5, t5, i5) => {
            var r4 = i5(5112), n3 = i5(30), o3 = i5(3070).f, s3 = r4("unscopables"), a3 = Array.prototype;
            null == a3[s3] && o3(a3, s3, { configurable: true, value: n3(null) }), e5.exports = function(e6) {
              a3[s3][e6] = true;
            };
          }, 9670: (e5, t5, i5) => {
            var r4 = i5(111), n3 = String, o3 = TypeError;
            e5.exports = function(e6) {
              if (r4(e6))
                return e6;
              throw o3(n3(e6) + " is not an object");
            };
          }, 1318: (e5, t5, i5) => {
            var r4 = i5(5656), n3 = i5(1400), o3 = i5(6244), s3 = function(e6) {
              return function(t6, i6, s4) {
                var a3, c3 = r4(t6), d3 = o3(c3), u3 = n3(s4, d3);
                if (e6 && i6 != i6) {
                  for (; d3 > u3; )
                    if ((a3 = c3[u3++]) != a3)
                      return true;
                } else
                  for (; d3 > u3; u3++)
                    if ((e6 || u3 in c3) && c3[u3] === i6)
                      return e6 || u3 || 0;
                return !e6 && -1;
              };
            };
            e5.exports = { includes: s3(true), indexOf: s3(false) };
          }, 4326: (e5, t5, i5) => {
            var r4 = i5(84), n3 = r4({}.toString), o3 = r4("".slice);
            e5.exports = function(e6) {
              return o3(n3(e6), 8, -1);
            };
          }, 648: (e5, t5, i5) => {
            var r4 = i5(1694), n3 = i5(614), o3 = i5(4326), s3 = i5(5112)("toStringTag"), a3 = Object, c3 = "Arguments" == o3(function() {
              return arguments;
            }());
            e5.exports = r4 ? o3 : function(e6) {
              var t6, i6, r5;
              return void 0 === e6 ? "Undefined" : null === e6 ? "Null" : "string" == typeof (i6 = function(e7, t7) {
                try {
                  return e7[t7];
                } catch (e8) {
                }
              }(t6 = a3(e6), s3)) ? i6 : c3 ? o3(t6) : "Object" == (r5 = o3(t6)) && n3(t6.callee) ? "Arguments" : r5;
            };
          }, 9920: (e5, t5, i5) => {
            var r4 = i5(2597), n3 = i5(3887), o3 = i5(1236), s3 = i5(3070);
            e5.exports = function(e6, t6, i6) {
              for (var a3 = n3(t6), c3 = s3.f, d3 = o3.f, u3 = 0; u3 < a3.length; u3++) {
                var h3 = a3[u3];
                r4(e6, h3) || i6 && r4(i6, h3) || c3(e6, h3, d3(t6, h3));
              }
            };
          }, 8544: (e5, t5, i5) => {
            var r4 = i5(7293);
            e5.exports = !r4(function() {
              function e6() {
              }
              return e6.prototype.constructor = null, Object.getPrototypeOf(new e6()) !== e6.prototype;
            });
          }, 6178: (e5) => {
            e5.exports = function(e6, t5) {
              return { value: e6, done: t5 };
            };
          }, 8880: (e5, t5, i5) => {
            var r4 = i5(9781), n3 = i5(3070), o3 = i5(9114);
            e5.exports = r4 ? function(e6, t6, i6) {
              return n3.f(e6, t6, o3(1, i6));
            } : function(e6, t6, i6) {
              return e6[t6] = i6, e6;
            };
          }, 9114: (e5) => {
            e5.exports = function(e6, t5) {
              return { enumerable: !(1 & e6), configurable: !(2 & e6), writable: !(4 & e6), value: t5 };
            };
          }, 8052: (e5, t5, i5) => {
            var r4 = i5(614), n3 = i5(3070), o3 = i5(6339), s3 = i5(3072);
            e5.exports = function(e6, t6, i6, a3) {
              a3 || (a3 = {});
              var c3 = a3.enumerable, d3 = void 0 !== a3.name ? a3.name : t6;
              if (r4(i6) && o3(i6, d3, a3), a3.global)
                c3 ? e6[t6] = i6 : s3(t6, i6);
              else {
                try {
                  a3.unsafe ? e6[t6] && (c3 = true) : delete e6[t6];
                } catch (e7) {
                }
                c3 ? e6[t6] = i6 : n3.f(e6, t6, { value: i6, enumerable: false, configurable: !a3.nonConfigurable, writable: !a3.nonWritable });
              }
              return e6;
            };
          }, 3072: (e5, t5, i5) => {
            var r4 = i5(7854), n3 = Object.defineProperty;
            e5.exports = function(e6, t6) {
              try {
                n3(r4, e6, { value: t6, configurable: true, writable: true });
              } catch (i6) {
                r4[e6] = t6;
              }
              return t6;
            };
          }, 9781: (e5, t5, i5) => {
            var r4 = i5(7293);
            e5.exports = !r4(function() {
              return 7 != Object.defineProperty({}, 1, { get: function() {
                return 7;
              } })[1];
            });
          }, 4154: (e5) => {
            var t5 = "object" == typeof document && document.all, i5 = void 0 === t5 && void 0 !== t5;
            e5.exports = { all: t5, IS_HTMLDDA: i5 };
          }, 317: (e5, t5, i5) => {
            var r4 = i5(7854), n3 = i5(111), o3 = r4.document, s3 = n3(o3) && n3(o3.createElement);
            e5.exports = function(e6) {
              return s3 ? o3.createElement(e6) : {};
            };
          }, 8324: (e5) => {
            e5.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
          }, 8509: (e5, t5, i5) => {
            var r4 = i5(317)("span").classList, n3 = r4 && r4.constructor && r4.constructor.prototype;
            e5.exports = n3 === Object.prototype ? void 0 : n3;
          }, 8113: (e5, t5, i5) => {
            var r4 = i5(5005);
            e5.exports = r4("navigator", "userAgent") || "";
          }, 7392: (e5, t5, i5) => {
            var r4, n3, o3 = i5(7854), s3 = i5(8113), a3 = o3.process, c3 = o3.Deno, d3 = a3 && a3.versions || c3 && c3.version, u3 = d3 && d3.v8;
            u3 && (n3 = (r4 = u3.split("."))[0] > 0 && r4[0] < 4 ? 1 : +(r4[0] + r4[1])), !n3 && s3 && (!(r4 = s3.match(/Edge\/(\d+)/)) || r4[1] >= 74) && (r4 = s3.match(/Chrome\/(\d+)/)) && (n3 = +r4[1]), e5.exports = n3;
          }, 748: (e5) => {
            e5.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
          }, 1060: (e5, t5, i5) => {
            var r4 = i5(1702), n3 = Error, o3 = r4("".replace), s3 = String(n3("zxcasd").stack), a3 = /\n\s*at [^:]*:[^\n]*/, c3 = a3.test(s3);
            e5.exports = function(e6, t6) {
              if (c3 && "string" == typeof e6 && !n3.prepareStackTrace)
                for (; t6--; )
                  e6 = o3(e6, a3, "");
              return e6;
            };
          }, 2914: (e5, t5, i5) => {
            var r4 = i5(7293), n3 = i5(9114);
            e5.exports = !r4(function() {
              var e6 = Error("a");
              return !("stack" in e6) || (Object.defineProperty(e6, "stack", n3(1, 7)), 7 !== e6.stack);
            });
          }, 2109: (e5, t5, i5) => {
            var r4 = i5(7854), n3 = i5(1236).f, o3 = i5(8880), s3 = i5(8052), a3 = i5(3072), c3 = i5(9920), d3 = i5(4705);
            e5.exports = function(e6, t6) {
              var i6, u3, h3, A3, l3, p3 = e6.target, g3 = e6.global, E3 = e6.stat;
              if (i6 = g3 ? r4 : E3 ? r4[p3] || a3(p3, {}) : (r4[p3] || {}).prototype)
                for (u3 in t6) {
                  if (A3 = t6[u3], h3 = e6.dontCallGetSet ? (l3 = n3(i6, u3)) && l3.value : i6[u3], !d3(g3 ? u3 : p3 + (E3 ? "." : "#") + u3, e6.forced) && void 0 !== h3) {
                    if (typeof A3 == typeof h3)
                      continue;
                    c3(A3, h3);
                  }
                  (e6.sham || h3 && h3.sham) && o3(A3, "sham", true), s3(i6, u3, A3, e6);
                }
            };
          }, 7293: (e5) => {
            e5.exports = function(e6) {
              try {
                return !!e6();
              } catch (e7) {
                return true;
              }
            };
          }, 2104: (e5, t5, i5) => {
            var r4 = i5(4374), n3 = Function.prototype, o3 = n3.apply, s3 = n3.call;
            e5.exports = "object" == typeof Reflect && Reflect.apply || (r4 ? s3.bind(o3) : function() {
              return s3.apply(o3, arguments);
            });
          }, 4374: (e5, t5, i5) => {
            var r4 = i5(7293);
            e5.exports = !r4(function() {
              var e6 = function() {
              }.bind();
              return "function" != typeof e6 || e6.hasOwnProperty("prototype");
            });
          }, 6916: (e5, t5, i5) => {
            var r4 = i5(4374), n3 = Function.prototype.call;
            e5.exports = r4 ? n3.bind(n3) : function() {
              return n3.apply(n3, arguments);
            };
          }, 6530: (e5, t5, i5) => {
            var r4 = i5(9781), n3 = i5(2597), o3 = Function.prototype, s3 = r4 && Object.getOwnPropertyDescriptor, a3 = n3(o3, "name"), c3 = a3 && "something" === function() {
            }.name, d3 = a3 && (!r4 || r4 && s3(o3, "name").configurable);
            e5.exports = { EXISTS: a3, PROPER: c3, CONFIGURABLE: d3 };
          }, 84: (e5, t5, i5) => {
            var r4 = i5(4374), n3 = Function.prototype, o3 = n3.call, s3 = r4 && n3.bind.bind(o3, o3);
            e5.exports = r4 ? s3 : function(e6) {
              return function() {
                return o3.apply(e6, arguments);
              };
            };
          }, 1702: (e5, t5, i5) => {
            var r4 = i5(4326), n3 = i5(84);
            e5.exports = function(e6) {
              if ("Function" === r4(e6))
                return n3(e6);
            };
          }, 5005: (e5, t5, i5) => {
            var r4 = i5(7854), n3 = i5(614), o3 = function(e6) {
              return n3(e6) ? e6 : void 0;
            };
            e5.exports = function(e6, t6) {
              return arguments.length < 2 ? o3(r4[e6]) : r4[e6] && r4[e6][t6];
            };
          }, 8173: (e5, t5, i5) => {
            var r4 = i5(9662), n3 = i5(8554);
            e5.exports = function(e6, t6) {
              var i6 = e6[t6];
              return n3(i6) ? void 0 : r4(i6);
            };
          }, 7854: (e5, t5, i5) => {
            var r4 = function(e6) {
              return e6 && e6.Math == Math && e6;
            };
            e5.exports = r4("object" == typeof globalThis && globalThis) || r4("object" == typeof window && window) || r4("object" == typeof self && self) || r4("object" == typeof i5.g && i5.g) || function() {
              return this;
            }() || Function("return this")();
          }, 2597: (e5, t5, i5) => {
            var r4 = i5(1702), n3 = i5(7908), o3 = r4({}.hasOwnProperty);
            e5.exports = Object.hasOwn || function(e6, t6) {
              return o3(n3(e6), t6);
            };
          }, 3501: (e5) => {
            e5.exports = {};
          }, 490: (e5, t5, i5) => {
            var r4 = i5(5005);
            e5.exports = r4("document", "documentElement");
          }, 4664: (e5, t5, i5) => {
            var r4 = i5(9781), n3 = i5(7293), o3 = i5(317);
            e5.exports = !r4 && !n3(function() {
              return 7 != Object.defineProperty(o3("div"), "a", { get: function() {
                return 7;
              } }).a;
            });
          }, 8361: (e5, t5, i5) => {
            var r4 = i5(1702), n3 = i5(7293), o3 = i5(4326), s3 = Object, a3 = r4("".split);
            e5.exports = n3(function() {
              return !s3("z").propertyIsEnumerable(0);
            }) ? function(e6) {
              return "String" == o3(e6) ? a3(e6, "") : s3(e6);
            } : s3;
          }, 9587: (e5, t5, i5) => {
            var r4 = i5(614), n3 = i5(111), o3 = i5(7674);
            e5.exports = function(e6, t6, i6) {
              var s3, a3;
              return o3 && r4(s3 = t6.constructor) && s3 !== i6 && n3(a3 = s3.prototype) && a3 !== i6.prototype && o3(e6, a3), e6;
            };
          }, 2788: (e5, t5, i5) => {
            var r4 = i5(1702), n3 = i5(614), o3 = i5(5465), s3 = r4(Function.toString);
            n3(o3.inspectSource) || (o3.inspectSource = function(e6) {
              return s3(e6);
            }), e5.exports = o3.inspectSource;
          }, 8340: (e5, t5, i5) => {
            var r4 = i5(111), n3 = i5(8880);
            e5.exports = function(e6, t6) {
              r4(t6) && "cause" in t6 && n3(e6, "cause", t6.cause);
            };
          }, 9909: (e5, t5, i5) => {
            var r4, n3, o3, s3 = i5(4811), a3 = i5(7854), c3 = i5(111), d3 = i5(8880), u3 = i5(2597), h3 = i5(5465), A3 = i5(6200), l3 = i5(3501), p3 = "Object already initialized", g3 = a3.TypeError, E3 = a3.WeakMap;
            if (s3 || h3.state) {
              var f3 = h3.state || (h3.state = new E3());
              f3.get = f3.get, f3.has = f3.has, f3.set = f3.set, r4 = function(e6, t6) {
                if (f3.has(e6))
                  throw g3(p3);
                return t6.facade = e6, f3.set(e6, t6), t6;
              }, n3 = function(e6) {
                return f3.get(e6) || {};
              }, o3 = function(e6) {
                return f3.has(e6);
              };
            } else {
              var m3 = A3("state");
              l3[m3] = true, r4 = function(e6, t6) {
                if (u3(e6, m3))
                  throw g3(p3);
                return t6.facade = e6, d3(e6, m3, t6), t6;
              }, n3 = function(e6) {
                return u3(e6, m3) ? e6[m3] : {};
              }, o3 = function(e6) {
                return u3(e6, m3);
              };
            }
            e5.exports = { set: r4, get: n3, has: o3, enforce: function(e6) {
              return o3(e6) ? n3(e6) : r4(e6, {});
            }, getterFor: function(e6) {
              return function(t6) {
                var i6;
                if (!c3(t6) || (i6 = n3(t6)).type !== e6)
                  throw g3("Incompatible receiver, " + e6 + " required");
                return i6;
              };
            } };
          }, 614: (e5, t5, i5) => {
            var r4 = i5(4154), n3 = r4.all;
            e5.exports = r4.IS_HTMLDDA ? function(e6) {
              return "function" == typeof e6 || e6 === n3;
            } : function(e6) {
              return "function" == typeof e6;
            };
          }, 4705: (e5, t5, i5) => {
            var r4 = i5(7293), n3 = i5(614), o3 = /#|\.prototype\./, s3 = function(e6, t6) {
              var i6 = c3[a3(e6)];
              return i6 == u3 || i6 != d3 && (n3(t6) ? r4(t6) : !!t6);
            }, a3 = s3.normalize = function(e6) {
              return String(e6).replace(o3, ".").toLowerCase();
            }, c3 = s3.data = {}, d3 = s3.NATIVE = "N", u3 = s3.POLYFILL = "P";
            e5.exports = s3;
          }, 8554: (e5) => {
            e5.exports = function(e6) {
              return null == e6;
            };
          }, 111: (e5, t5, i5) => {
            var r4 = i5(614), n3 = i5(4154), o3 = n3.all;
            e5.exports = n3.IS_HTMLDDA ? function(e6) {
              return "object" == typeof e6 ? null !== e6 : r4(e6) || e6 === o3;
            } : function(e6) {
              return "object" == typeof e6 ? null !== e6 : r4(e6);
            };
          }, 1913: (e5) => {
            e5.exports = false;
          }, 2190: (e5, t5, i5) => {
            var r4 = i5(5005), n3 = i5(614), o3 = i5(7976), s3 = i5(3307), a3 = Object;
            e5.exports = s3 ? function(e6) {
              return "symbol" == typeof e6;
            } : function(e6) {
              var t6 = r4("Symbol");
              return n3(t6) && o3(t6.prototype, a3(e6));
            };
          }, 3061: (e5, t5, i5) => {
            var r4 = i5(3383).IteratorPrototype, n3 = i5(30), o3 = i5(9114), s3 = i5(8003), a3 = i5(7497), c3 = function() {
              return this;
            };
            e5.exports = function(e6, t6, i6, d3) {
              var u3 = t6 + " Iterator";
              return e6.prototype = n3(r4, { next: o3(+!d3, i6) }), s3(e6, u3, false, true), a3[u3] = c3, e6;
            };
          }, 1656: (e5, t5, i5) => {
            var r4 = i5(2109), n3 = i5(6916), o3 = i5(1913), s3 = i5(6530), a3 = i5(614), c3 = i5(3061), d3 = i5(9518), u3 = i5(7674), h3 = i5(8003), A3 = i5(8880), l3 = i5(8052), p3 = i5(5112), g3 = i5(7497), E3 = i5(3383), f3 = s3.PROPER, m3 = s3.CONFIGURABLE, I3 = E3.IteratorPrototype, _3 = E3.BUGGY_SAFARI_ITERATORS, C3 = p3("iterator"), S3 = "keys", v3 = "values", T3 = "entries", R3 = function() {
              return this;
            };
            e5.exports = function(e6, t6, i6, s4, p4, E4, y3) {
              c3(i6, t6, s4);
              var w3, b3, N3, O3 = function(e7) {
                if (e7 === p4 && B3)
                  return B3;
                if (!_3 && e7 in L3)
                  return L3[e7];
                switch (e7) {
                  case S3:
                  case v3:
                  case T3:
                    return function() {
                      return new i6(this, e7);
                    };
                }
                return function() {
                  return new i6(this);
                };
              }, D3 = t6 + " Iterator", P3 = false, L3 = e6.prototype, k3 = L3[C3] || L3["@@iterator"] || p4 && L3[p4], B3 = !_3 && k3 || O3(p4), M3 = "Array" == t6 && L3.entries || k3;
              if (M3 && (w3 = d3(M3.call(new e6()))) !== Object.prototype && w3.next && (o3 || d3(w3) === I3 || (u3 ? u3(w3, I3) : a3(w3[C3]) || l3(w3, C3, R3)), h3(w3, D3, true, true), o3 && (g3[D3] = R3)), f3 && p4 == v3 && k3 && k3.name !== v3 && (!o3 && m3 ? A3(L3, "name", v3) : (P3 = true, B3 = function() {
                return n3(k3, this);
              })), p4)
                if (b3 = { values: O3(v3), keys: E4 ? B3 : O3(S3), entries: O3(T3) }, y3)
                  for (N3 in b3)
                    (_3 || P3 || !(N3 in L3)) && l3(L3, N3, b3[N3]);
                else
                  r4({ target: t6, proto: true, forced: _3 || P3 }, b3);
              return o3 && !y3 || L3[C3] === B3 || l3(L3, C3, B3, { name: p4 }), g3[t6] = B3, b3;
            };
          }, 3383: (e5, t5, i5) => {
            var r4, n3, o3, s3 = i5(7293), a3 = i5(614), c3 = i5(111), d3 = i5(30), u3 = i5(9518), h3 = i5(8052), A3 = i5(5112), l3 = i5(1913), p3 = A3("iterator"), g3 = false;
            [].keys && ("next" in (o3 = [].keys()) ? (n3 = u3(u3(o3))) !== Object.prototype && (r4 = n3) : g3 = true), !c3(r4) || s3(function() {
              var e6 = {};
              return r4[p3].call(e6) !== e6;
            }) ? r4 = {} : l3 && (r4 = d3(r4)), a3(r4[p3]) || h3(r4, p3, function() {
              return this;
            }), e5.exports = { IteratorPrototype: r4, BUGGY_SAFARI_ITERATORS: g3 };
          }, 7497: (e5) => {
            e5.exports = {};
          }, 6244: (e5, t5, i5) => {
            var r4 = i5(7466);
            e5.exports = function(e6) {
              return r4(e6.length);
            };
          }, 6339: (e5, t5, i5) => {
            var r4 = i5(7293), n3 = i5(614), o3 = i5(2597), s3 = i5(9781), a3 = i5(6530).CONFIGURABLE, c3 = i5(2788), d3 = i5(9909), u3 = d3.enforce, h3 = d3.get, A3 = Object.defineProperty, l3 = s3 && !r4(function() {
              return 8 !== A3(function() {
              }, "length", { value: 8 }).length;
            }), p3 = String(String).split("String"), g3 = e5.exports = function(e6, t6, i6) {
              "Symbol(" === String(t6).slice(0, 7) && (t6 = "[" + String(t6).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), i6 && i6.getter && (t6 = "get " + t6), i6 && i6.setter && (t6 = "set " + t6), (!o3(e6, "name") || a3 && e6.name !== t6) && (s3 ? A3(e6, "name", { value: t6, configurable: true }) : e6.name = t6), l3 && i6 && o3(i6, "arity") && e6.length !== i6.arity && A3(e6, "length", { value: i6.arity });
              try {
                i6 && o3(i6, "constructor") && i6.constructor ? s3 && A3(e6, "prototype", { writable: false }) : e6.prototype && (e6.prototype = void 0);
              } catch (e7) {
              }
              var r5 = u3(e6);
              return o3(r5, "source") || (r5.source = p3.join("string" == typeof t6 ? t6 : "")), e6;
            };
            Function.prototype.toString = g3(function() {
              return n3(this) && h3(this).source || c3(this);
            }, "toString");
          }, 4758: (e5) => {
            var t5 = Math.ceil, i5 = Math.floor;
            e5.exports = Math.trunc || function(e6) {
              var r4 = +e6;
              return (r4 > 0 ? i5 : t5)(r4);
            };
          }, 6277: (e5, t5, i5) => {
            var r4 = i5(1340);
            e5.exports = function(e6, t6) {
              return void 0 === e6 ? arguments.length < 2 ? "" : t6 : r4(e6);
            };
          }, 30: (e5, t5, i5) => {
            var r4, n3 = i5(9670), o3 = i5(6048), s3 = i5(748), a3 = i5(3501), c3 = i5(490), d3 = i5(317), u3 = i5(6200)("IE_PROTO"), h3 = function() {
            }, A3 = function(e6) {
              return "<script>" + e6 + "<\/script>";
            }, l3 = function(e6) {
              e6.write(A3("")), e6.close();
              var t6 = e6.parentWindow.Object;
              return e6 = null, t6;
            }, p3 = function() {
              try {
                r4 = new ActiveXObject("htmlfile");
              } catch (e7) {
              }
              var e6, t6;
              p3 = "undefined" != typeof document ? document.domain && r4 ? l3(r4) : ((t6 = d3("iframe")).style.display = "none", c3.appendChild(t6), t6.src = String("javascript:"), (e6 = t6.contentWindow.document).open(), e6.write(A3("document.F=Object")), e6.close(), e6.F) : l3(r4);
              for (var i6 = s3.length; i6--; )
                delete p3.prototype[s3[i6]];
              return p3();
            };
            a3[u3] = true, e5.exports = Object.create || function(e6, t6) {
              var i6;
              return null !== e6 ? (h3.prototype = n3(e6), i6 = new h3(), h3.prototype = null, i6[u3] = e6) : i6 = p3(), void 0 === t6 ? i6 : o3.f(i6, t6);
            };
          }, 6048: (e5, t5, i5) => {
            var r4 = i5(9781), n3 = i5(3353), o3 = i5(3070), s3 = i5(9670), a3 = i5(5656), c3 = i5(1956);
            t5.f = r4 && !n3 ? Object.defineProperties : function(e6, t6) {
              s3(e6);
              for (var i6, r5 = a3(t6), n4 = c3(t6), d3 = n4.length, u3 = 0; d3 > u3; )
                o3.f(e6, i6 = n4[u3++], r5[i6]);
              return e6;
            };
          }, 3070: (e5, t5, i5) => {
            var r4 = i5(9781), n3 = i5(4664), o3 = i5(3353), s3 = i5(9670), a3 = i5(4948), c3 = TypeError, d3 = Object.defineProperty, u3 = Object.getOwnPropertyDescriptor;
            t5.f = r4 ? o3 ? function(e6, t6, i6) {
              if (s3(e6), t6 = a3(t6), s3(i6), "function" == typeof e6 && "prototype" === t6 && "value" in i6 && "writable" in i6 && !i6.writable) {
                var r5 = u3(e6, t6);
                r5 && r5.writable && (e6[t6] = i6.value, i6 = { configurable: "configurable" in i6 ? i6.configurable : r5.configurable, enumerable: "enumerable" in i6 ? i6.enumerable : r5.enumerable, writable: false });
              }
              return d3(e6, t6, i6);
            } : d3 : function(e6, t6, i6) {
              if (s3(e6), t6 = a3(t6), s3(i6), n3)
                try {
                  return d3(e6, t6, i6);
                } catch (e7) {
                }
              if ("get" in i6 || "set" in i6)
                throw c3("Accessors not supported");
              return "value" in i6 && (e6[t6] = i6.value), e6;
            };
          }, 1236: (e5, t5, i5) => {
            var r4 = i5(9781), n3 = i5(6916), o3 = i5(5296), s3 = i5(9114), a3 = i5(5656), c3 = i5(4948), d3 = i5(2597), u3 = i5(4664), h3 = Object.getOwnPropertyDescriptor;
            t5.f = r4 ? h3 : function(e6, t6) {
              if (e6 = a3(e6), t6 = c3(t6), u3)
                try {
                  return h3(e6, t6);
                } catch (e7) {
                }
              if (d3(e6, t6))
                return s3(!n3(o3.f, e6, t6), e6[t6]);
            };
          }, 8006: (e5, t5, i5) => {
            var r4 = i5(6324), n3 = i5(748).concat("length", "prototype");
            t5.f = Object.getOwnPropertyNames || function(e6) {
              return r4(e6, n3);
            };
          }, 5181: (e5, t5) => {
            t5.f = Object.getOwnPropertySymbols;
          }, 9518: (e5, t5, i5) => {
            var r4 = i5(2597), n3 = i5(614), o3 = i5(7908), s3 = i5(6200), a3 = i5(8544), c3 = s3("IE_PROTO"), d3 = Object, u3 = d3.prototype;
            e5.exports = a3 ? d3.getPrototypeOf : function(e6) {
              var t6 = o3(e6);
              if (r4(t6, c3))
                return t6[c3];
              var i6 = t6.constructor;
              return n3(i6) && t6 instanceof i6 ? i6.prototype : t6 instanceof d3 ? u3 : null;
            };
          }, 7976: (e5, t5, i5) => {
            var r4 = i5(1702);
            e5.exports = r4({}.isPrototypeOf);
          }, 6324: (e5, t5, i5) => {
            var r4 = i5(1702), n3 = i5(2597), o3 = i5(5656), s3 = i5(1318).indexOf, a3 = i5(3501), c3 = r4([].push);
            e5.exports = function(e6, t6) {
              var i6, r5 = o3(e6), d3 = 0, u3 = [];
              for (i6 in r5)
                !n3(a3, i6) && n3(r5, i6) && c3(u3, i6);
              for (; t6.length > d3; )
                n3(r5, i6 = t6[d3++]) && (~s3(u3, i6) || c3(u3, i6));
              return u3;
            };
          }, 1956: (e5, t5, i5) => {
            var r4 = i5(6324), n3 = i5(748);
            e5.exports = Object.keys || function(e6) {
              return r4(e6, n3);
            };
          }, 5296: (e5, t5) => {
            var i5 = {}.propertyIsEnumerable, r4 = Object.getOwnPropertyDescriptor, n3 = r4 && !i5.call({ 1: 2 }, 1);
            t5.f = n3 ? function(e6) {
              var t6 = r4(this, e6);
              return !!t6 && t6.enumerable;
            } : i5;
          }, 7674: (e5, t5, i5) => {
            var r4 = i5(1702), n3 = i5(9670), o3 = i5(6077);
            e5.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
              var e6, t6 = false, i6 = {};
              try {
                (e6 = r4(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(i6, []), t6 = i6 instanceof Array;
              } catch (e7) {
              }
              return function(i7, r5) {
                return n3(i7), o3(r5), t6 ? e6(i7, r5) : i7.__proto__ = r5, i7;
              };
            }() : void 0);
          }, 2140: (e5, t5, i5) => {
            var r4 = i5(6916), n3 = i5(614), o3 = i5(111), s3 = TypeError;
            e5.exports = function(e6, t6) {
              var i6, a3;
              if ("string" === t6 && n3(i6 = e6.toString) && !o3(a3 = r4(i6, e6)))
                return a3;
              if (n3(i6 = e6.valueOf) && !o3(a3 = r4(i6, e6)))
                return a3;
              if ("string" !== t6 && n3(i6 = e6.toString) && !o3(a3 = r4(i6, e6)))
                return a3;
              throw s3("Can't convert object to primitive value");
            };
          }, 3887: (e5, t5, i5) => {
            var r4 = i5(5005), n3 = i5(1702), o3 = i5(8006), s3 = i5(5181), a3 = i5(9670), c3 = n3([].concat);
            e5.exports = r4("Reflect", "ownKeys") || function(e6) {
              var t6 = o3.f(a3(e6)), i6 = s3.f;
              return i6 ? c3(t6, i6(e6)) : t6;
            };
          }, 2626: (e5, t5, i5) => {
            var r4 = i5(3070).f;
            e5.exports = function(e6, t6, i6) {
              i6 in e6 || r4(e6, i6, { configurable: true, get: function() {
                return t6[i6];
              }, set: function(e7) {
                t6[i6] = e7;
              } });
            };
          }, 4488: (e5, t5, i5) => {
            var r4 = i5(8554), n3 = TypeError;
            e5.exports = function(e6) {
              if (r4(e6))
                throw n3("Can't call method on " + e6);
              return e6;
            };
          }, 8003: (e5, t5, i5) => {
            var r4 = i5(3070).f, n3 = i5(2597), o3 = i5(5112)("toStringTag");
            e5.exports = function(e6, t6, i6) {
              e6 && !i6 && (e6 = e6.prototype), e6 && !n3(e6, o3) && r4(e6, o3, { configurable: true, value: t6 });
            };
          }, 6200: (e5, t5, i5) => {
            var r4 = i5(2309), n3 = i5(9711), o3 = r4("keys");
            e5.exports = function(e6) {
              return o3[e6] || (o3[e6] = n3(e6));
            };
          }, 5465: (e5, t5, i5) => {
            var r4 = i5(7854), n3 = i5(3072), o3 = "__core-js_shared__", s3 = r4[o3] || n3(o3, {});
            e5.exports = s3;
          }, 2309: (e5, t5, i5) => {
            var r4 = i5(1913), n3 = i5(5465);
            (e5.exports = function(e6, t6) {
              return n3[e6] || (n3[e6] = void 0 !== t6 ? t6 : {});
            })("versions", []).push({ version: "3.26.0", mode: r4 ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.0/LICENSE", source: "https://github.com/zloirock/core-js" });
          }, 6293: (e5, t5, i5) => {
            var r4 = i5(7392), n3 = i5(7293);
            e5.exports = !!Object.getOwnPropertySymbols && !n3(function() {
              var e6 = Symbol();
              return !String(e6) || !(Object(e6) instanceof Symbol) || !Symbol.sham && r4 && r4 < 41;
            });
          }, 1400: (e5, t5, i5) => {
            var r4 = i5(9303), n3 = Math.max, o3 = Math.min;
            e5.exports = function(e6, t6) {
              var i6 = r4(e6);
              return i6 < 0 ? n3(i6 + t6, 0) : o3(i6, t6);
            };
          }, 5656: (e5, t5, i5) => {
            var r4 = i5(8361), n3 = i5(4488);
            e5.exports = function(e6) {
              return r4(n3(e6));
            };
          }, 9303: (e5, t5, i5) => {
            var r4 = i5(4758);
            e5.exports = function(e6) {
              var t6 = +e6;
              return t6 != t6 || 0 === t6 ? 0 : r4(t6);
            };
          }, 7466: (e5, t5, i5) => {
            var r4 = i5(9303), n3 = Math.min;
            e5.exports = function(e6) {
              return e6 > 0 ? n3(r4(e6), 9007199254740991) : 0;
            };
          }, 7908: (e5, t5, i5) => {
            var r4 = i5(4488), n3 = Object;
            e5.exports = function(e6) {
              return n3(r4(e6));
            };
          }, 7593: (e5, t5, i5) => {
            var r4 = i5(6916), n3 = i5(111), o3 = i5(2190), s3 = i5(8173), a3 = i5(2140), c3 = i5(5112), d3 = TypeError, u3 = c3("toPrimitive");
            e5.exports = function(e6, t6) {
              if (!n3(e6) || o3(e6))
                return e6;
              var i6, c4 = s3(e6, u3);
              if (c4) {
                if (void 0 === t6 && (t6 = "default"), i6 = r4(c4, e6, t6), !n3(i6) || o3(i6))
                  return i6;
                throw d3("Can't convert object to primitive value");
              }
              return void 0 === t6 && (t6 = "number"), a3(e6, t6);
            };
          }, 4948: (e5, t5, i5) => {
            var r4 = i5(7593), n3 = i5(2190);
            e5.exports = function(e6) {
              var t6 = r4(e6, "string");
              return n3(t6) ? t6 : t6 + "";
            };
          }, 1694: (e5, t5, i5) => {
            var r4 = {};
            r4[i5(5112)("toStringTag")] = "z", e5.exports = "[object z]" === String(r4);
          }, 1340: (e5, t5, i5) => {
            var r4 = i5(648), n3 = String;
            e5.exports = function(e6) {
              if ("Symbol" === r4(e6))
                throw TypeError("Cannot convert a Symbol value to a string");
              return n3(e6);
            };
          }, 6330: (e5) => {
            var t5 = String;
            e5.exports = function(e6) {
              try {
                return t5(e6);
              } catch (e7) {
                return "Object";
              }
            };
          }, 9711: (e5, t5, i5) => {
            var r4 = i5(1702), n3 = 0, o3 = Math.random(), s3 = r4(1 .toString);
            e5.exports = function(e6) {
              return "Symbol(" + (void 0 === e6 ? "" : e6) + ")_" + s3(++n3 + o3, 36);
            };
          }, 3307: (e5, t5, i5) => {
            var r4 = i5(6293);
            e5.exports = r4 && !Symbol.sham && "symbol" == typeof Symbol.iterator;
          }, 3353: (e5, t5, i5) => {
            var r4 = i5(9781), n3 = i5(7293);
            e5.exports = r4 && n3(function() {
              return 42 != Object.defineProperty(function() {
              }, "prototype", { value: 42, writable: false }).prototype;
            });
          }, 4811: (e5, t5, i5) => {
            var r4 = i5(7854), n3 = i5(614), o3 = r4.WeakMap;
            e5.exports = n3(o3) && /native code/.test(String(o3));
          }, 5112: (e5, t5, i5) => {
            var r4 = i5(7854), n3 = i5(2309), o3 = i5(2597), s3 = i5(9711), a3 = i5(6293), c3 = i5(3307), d3 = n3("wks"), u3 = r4.Symbol, h3 = u3 && u3.for, A3 = c3 ? u3 : u3 && u3.withoutSetter || s3;
            e5.exports = function(e6) {
              if (!o3(d3, e6) || !a3 && "string" != typeof d3[e6]) {
                var t6 = "Symbol." + e6;
                a3 && o3(u3, e6) ? d3[e6] = u3[e6] : d3[e6] = c3 && h3 ? h3(t6) : A3(t6);
              }
              return d3[e6];
            };
          }, 9191: (e5, t5, i5) => {
            var r4 = i5(5005), n3 = i5(2597), o3 = i5(8880), s3 = i5(7976), a3 = i5(7674), c3 = i5(9920), d3 = i5(2626), u3 = i5(9587), h3 = i5(6277), A3 = i5(8340), l3 = i5(1060), p3 = i5(2914), g3 = i5(9781), E3 = i5(1913);
            e5.exports = function(e6, t6, i6, f3) {
              var m3 = "stackTraceLimit", I3 = f3 ? 2 : 1, _3 = e6.split("."), C3 = _3[_3.length - 1], S3 = r4.apply(null, _3);
              if (S3) {
                var v3 = S3.prototype;
                if (!E3 && n3(v3, "cause") && delete v3.cause, !i6)
                  return S3;
                var T3 = r4("Error"), R3 = t6(function(e7, t7) {
                  var i7 = h3(f3 ? t7 : e7, void 0), r5 = f3 ? new S3(e7) : new S3();
                  return void 0 !== i7 && o3(r5, "message", i7), p3 && o3(r5, "stack", l3(r5.stack, 2)), this && s3(v3, this) && u3(r5, this, R3), arguments.length > I3 && A3(r5, arguments[I3]), r5;
                });
                if (R3.prototype = v3, "Error" !== C3 ? a3 ? a3(R3, T3) : c3(R3, T3, { name: true }) : g3 && m3 in S3 && (d3(R3, S3, m3), d3(R3, S3, "prepareStackTrace")), c3(R3, S3), !E3)
                  try {
                    v3.name !== C3 && o3(v3, "name", C3), v3.constructor = R3;
                  } catch (e7) {
                  }
                return R3;
              }
            };
          }, 6992: (e5, t5, i5) => {
            var r4 = i5(5656), n3 = i5(1223), o3 = i5(7497), s3 = i5(9909), a3 = i5(3070).f, c3 = i5(1656), d3 = i5(6178), u3 = i5(1913), h3 = i5(9781), A3 = "Array Iterator", l3 = s3.set, p3 = s3.getterFor(A3);
            e5.exports = c3(Array, "Array", function(e6, t6) {
              l3(this, { type: A3, target: r4(e6), index: 0, kind: t6 });
            }, function() {
              var e6 = p3(this), t6 = e6.target, i6 = e6.kind, r5 = e6.index++;
              return !t6 || r5 >= t6.length ? (e6.target = void 0, d3(void 0, true)) : d3("keys" == i6 ? r5 : "values" == i6 ? t6[r5] : [r5, t6[r5]], false);
            }, "values");
            var g3 = o3.Arguments = o3.Array;
            if (n3("keys"), n3("values"), n3("entries"), !u3 && h3 && "values" !== g3.name)
              try {
                a3(g3, "name", { value: "values" });
              } catch (e6) {
              }
          }, 1703: (e5, t5, i5) => {
            var r4 = i5(2109), n3 = i5(7854), o3 = i5(2104), s3 = i5(9191), a3 = n3.WebAssembly, c3 = 7 !== Error("e", { cause: 7 }).cause, d3 = function(e6, t6) {
              var i6 = {};
              i6[e6] = s3(e6, t6, c3), r4({ global: true, constructor: true, arity: 1, forced: c3 }, i6);
            }, u3 = function(e6, t6) {
              if (a3 && a3[e6]) {
                var i6 = {};
                i6[e6] = s3("WebAssembly." + e6, t6, c3), r4({ target: "WebAssembly", stat: true, constructor: true, arity: 1, forced: c3 }, i6);
              }
            };
            d3("Error", function(e6) {
              return function(t6) {
                return o3(e6, this, arguments);
              };
            }), d3("EvalError", function(e6) {
              return function(t6) {
                return o3(e6, this, arguments);
              };
            }), d3("RangeError", function(e6) {
              return function(t6) {
                return o3(e6, this, arguments);
              };
            }), d3("ReferenceError", function(e6) {
              return function(t6) {
                return o3(e6, this, arguments);
              };
            }), d3("SyntaxError", function(e6) {
              return function(t6) {
                return o3(e6, this, arguments);
              };
            }), d3("TypeError", function(e6) {
              return function(t6) {
                return o3(e6, this, arguments);
              };
            }), d3("URIError", function(e6) {
              return function(t6) {
                return o3(e6, this, arguments);
              };
            }), u3("CompileError", function(e6) {
              return function(t6) {
                return o3(e6, this, arguments);
              };
            }), u3("LinkError", function(e6) {
              return function(t6) {
                return o3(e6, this, arguments);
              };
            }), u3("RuntimeError", function(e6) {
              return function(t6) {
                return o3(e6, this, arguments);
              };
            });
          }, 3948: (e5, t5, i5) => {
            var r4 = i5(7854), n3 = i5(8324), o3 = i5(8509), s3 = i5(6992), a3 = i5(8880), c3 = i5(5112), d3 = c3("iterator"), u3 = c3("toStringTag"), h3 = s3.values, A3 = function(e6, t6) {
              if (e6) {
                if (e6[d3] !== h3)
                  try {
                    a3(e6, d3, h3);
                  } catch (t7) {
                    e6[d3] = h3;
                  }
                if (e6[u3] || a3(e6, u3, t6), n3[t6]) {
                  for (var i6 in s3)
                    if (e6[i6] !== s3[i6])
                      try {
                        a3(e6, i6, s3[i6]);
                      } catch (t7) {
                        e6[i6] = s3[i6];
                      }
                }
              }
            };
            for (var l3 in n3)
              A3(r4[l3] && r4[l3].prototype, l3);
            A3(o3, "DOMTokenList");
          }, 6226: (e5, t5, i5) => {
            e5.exports = i5(7460);
          }, 7445: (e5, t5, i5) => {
            e5.exports = i5(3685);
          } }, t4 = {};
          function i4(r4) {
            var n3 = t4[r4];
            if (void 0 !== n3)
              return n3.exports;
            var o3 = t4[r4] = { exports: {} };
            return e4[r4](o3, o3.exports, i4), o3.exports;
          }
          i4.n = (e5) => {
            var t5 = e5 && e5.__esModule ? () => e5.default : () => e5;
            return i4.d(t5, { a: t5 }), t5;
          }, i4.d = (e5, t5) => {
            for (var r4 in t5)
              i4.o(t5, r4) && !i4.o(e5, r4) && Object.defineProperty(e5, r4, { enumerable: true, get: t5[r4] });
          }, i4.g = function() {
            if ("object" == typeof globalThis)
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch (e5) {
              if ("object" == typeof window)
                return window;
            }
          }(), i4.o = (e5, t5) => Object.prototype.hasOwnProperty.call(e5, t5), i4.r = (e5) => {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e5, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e5, "__esModule", { value: true });
          };
          var r3 = {};
          return (() => {
            i4.r(r3), i4.d(r3, { AudioExtension: () => _3, AudioProcessor: () => m3, Extension: () => I3, PromiseMutex: () => T3, Ticker: () => S3, VideoProcessor: () => f3, logger: () => u3, reporter: () => l3 });
            var e5 = i4(7445);
            function t5(t6, i5, r4) {
              return i5 in t6 ? e5(t6, i5, { value: r4, enumerable: true, configurable: true, writable: true }) : t6[i5] = r4, t6;
            }
            i4(1703), i4(6992), i4(3948);
            var n3 = i4(6226), o3 = i4.n(n3);
            const s3 = Date.now(), a3 = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 };
            function c3() {
              const e6 = new Date();
              return e6.toTimeString().split(" ")[0] + ":" + e6.getMilliseconds();
            }
            const d3 = (e6) => {
              for (const t6 in a3)
                if (Object.prototype.hasOwnProperty.call(a3, t6) && a3[t6] === e6)
                  return t6;
              return "DEFAULT";
            }, u3 = new class {
              constructor() {
                t5(this, "logLevel", a3.DEBUG), t5(this, "hookLog", void 0);
              }
              debug() {
                for (var e6 = arguments.length, t6 = new Array(e6), i5 = 0; i5 < e6; i5++)
                  t6[i5] = arguments[i5];
                const r4 = [a3.DEBUG].concat(t6);
                this.log.apply(this, r4);
              }
              info() {
                for (var e6 = arguments.length, t6 = new Array(e6), i5 = 0; i5 < e6; i5++)
                  t6[i5] = arguments[i5];
                const r4 = [a3.INFO].concat(t6);
                this.log.apply(this, r4);
              }
              warning() {
                for (var e6 = arguments.length, t6 = new Array(e6), i5 = 0; i5 < e6; i5++)
                  t6[i5] = arguments[i5];
                const r4 = [a3.WARNING].concat(t6);
                this.log.apply(this, r4);
              }
              error() {
                for (var e6 = arguments.length, t6 = new Array(e6), i5 = 0; i5 < e6; i5++)
                  t6[i5] = arguments[i5];
                const r4 = [a3.ERROR].concat(t6);
                this.log.apply(this, r4);
              }
              log() {
                for (var e6, t6 = arguments.length, i5 = new Array(t6), r4 = 0; r4 < t6; r4++)
                  i5[r4] = arguments[r4];
                if (Date.now() - s3 < 100)
                  return void setTimeout(() => {
                    this.log(...i5);
                  }, Date.now() - s3);
                const n4 = Math.max(0, Math.min(4, i5[0]));
                if (i5[0] = c3() + " Agora-Extension [".concat(d3(n4), "]:"), n4 < this.logLevel)
                  return;
                const o4 = c3() + " %cAgora-Extension [".concat(d3(n4), "]:");
                let u4 = [];
                switch (n4) {
                  case a3.DEBUG:
                    u4 = [o4, "color: #64B5F6;"].concat(i5.slice(1)), console.log.apply(console, u4);
                    break;
                  case a3.INFO:
                    u4 = [o4, "color: #1E88E5; font-weight: bold;"].concat(i5.slice(1)), console.log.apply(console, u4);
                    break;
                  case a3.WARNING:
                    u4 = [o4, "color: #FB8C00; font-weight: bold;"].concat(i5.slice(1)), console.warn.apply(console, u4);
                    break;
                  case a3.ERROR:
                    u4 = [o4, "color: #B00020; font-weight: bold;"].concat(i5.slice(1)), console.error.apply(console, u4);
                }
                null === (e6 = this.hookLog) || void 0 === e6 || e6.call(this, n4, u4);
              }
            }();
            function h3(e6, t6) {
              var i5 = Object.keys(e6);
              if (Object.getOwnPropertySymbols) {
                var r4 = Object.getOwnPropertySymbols(e6);
                t6 && (r4 = r4.filter(function(t7) {
                  return Object.getOwnPropertyDescriptor(e6, t7).enumerable;
                })), i5.push.apply(i5, r4);
              }
              return i5;
            }
            function A3(e6) {
              for (var i5 = 1; i5 < arguments.length; i5++) {
                var r4 = null != arguments[i5] ? arguments[i5] : {};
                i5 % 2 ? h3(Object(r4), true).forEach(function(i6) {
                  t5(e6, i6, r4[i6]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e6, Object.getOwnPropertyDescriptors(r4)) : h3(Object(r4)).forEach(function(t6) {
                  Object.defineProperty(e6, t6, Object.getOwnPropertyDescriptor(r4, t6));
                });
              }
              return e6;
            }
            const l3 = new class {
              constructor() {
                t5(this, "apiInvokeMsgQueue", []), t5(this, "hookApiInvoke", void 0);
              }
              reportApiInvoke(e6) {
                e6.timeout = e6.timeout || 6e4, e6.reportResult = void 0 === e6.reportResult || e6.reportResult;
                const t6 = Date.now(), i5 = () => ({ name: e6.name, apiInvokeTime: t6, options: e6.options });
                let r4 = false;
                var n4;
                (n4 = e6.timeout, new (o3())((e7) => {
                  window.setTimeout(e7, n4);
                })).then(() => {
                  r4 || (this.sendApiInvoke(A3(A3({}, i5()), {}, { error: "API_INVOKE_TIMEOUT", success: false })), u3.debug("".concat(e6.name, " timeout")));
                });
                const s4 = new Error("".concat(e6.name, ": this api invoke is end"));
                return { onSuccess: (t7) => {
                  if (r4)
                    throw s4;
                  r4 = true, this.sendApiInvoke(A3(A3({}, i5()), {}, { success: true }, e6.reportResult && { result: t7 }));
                }, onError: (e7) => {
                  if (r4)
                    throw e7;
                  r4 = true, this.sendApiInvoke(A3(A3({}, i5()), {}, { success: false, error: e7.toString() }));
                } };
              }
              sendApiInvoke(e6) {
                this.hookApiInvoke ? (this.hookApiInvoke([...this.apiInvokeMsgQueue, e6]), this.apiInvokeMsgQueue = []) : this.apiInvokeMsgQueue.push(e6);
              }
            }();
            function p3(e6, t6) {
              var i5 = Object.keys(e6);
              if (Object.getOwnPropertySymbols) {
                var r4 = Object.getOwnPropertySymbols(e6);
                t6 && (r4 = r4.filter(function(t7) {
                  return Object.getOwnPropertyDescriptor(e6, t7).enumerable;
                })), i5.push.apply(i5, r4);
              }
              return i5;
            }
            function g3(e6) {
              for (var i5 = 1; i5 < arguments.length; i5++) {
                var r4 = null != arguments[i5] ? arguments[i5] : {};
                i5 % 2 ? p3(Object(r4), true).forEach(function(i6) {
                  t5(e6, i6, r4[i6]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e6, Object.getOwnPropertyDescriptors(r4)) : p3(Object(r4)).forEach(function(t6) {
                  Object.defineProperty(e6, t6, Object.getOwnPropertyDescriptor(r4, t6));
                });
              }
              return e6;
            }
            class E3 extends class {
              constructor() {
                t5(this, "_events", {}), t5(this, "addListener", this.on);
              }
              getListeners(e6) {
                return this._events[e6] ? this._events[e6].map((e7) => e7.listener) : [];
              }
              on(e6, t6) {
                this._events[e6] || (this._events[e6] = []);
                const i5 = this._events[e6];
                -1 === this._indexOfListener(i5, t6) && i5.push({ listener: t6, once: false });
              }
              once(e6, t6) {
                this._events[e6] || (this._events[e6] = []);
                const i5 = this._events[e6];
                -1 === this._indexOfListener(i5, t6) && i5.push({ listener: t6, once: true });
              }
              off(e6, t6) {
                if (!this._events[e6])
                  return;
                const i5 = this._events[e6], r4 = this._indexOfListener(i5, t6);
                -1 !== r4 && i5.splice(r4, 1), 0 === this._events[e6].length && delete this._events[e6];
              }
              removeAllListeners(e6) {
                e6 ? delete this._events[e6] : this._events = {};
              }
              emit(e6) {
                this._events[e6] || (this._events[e6] = []);
                const t6 = this._events[e6].map((e7) => e7);
                for (var i5 = arguments.length, r4 = new Array(i5 > 1 ? i5 - 1 : 0), n4 = 1; n4 < i5; n4++)
                  r4[n4 - 1] = arguments[n4];
                for (let i6 = 0; i6 < t6.length; i6 += 1) {
                  const n5 = t6[i6];
                  n5.once && this.off(e6, n5.listener), n5.listener.apply(this, r4 || []);
                }
              }
              _indexOfListener(e6, t6) {
                let i5 = e6.length;
                for (; i5--; )
                  if (e6[i5].listener === t6)
                    return i5;
                return -1;
              }
              emitAsPromise(e6) {
                for (var t6 = arguments.length, i5 = new Array(t6 > 1 ? t6 - 1 : 0), r4 = 1; r4 < t6; r4++)
                  i5[r4 - 1] = arguments[r4];
                return 0 === this.getListeners(e6).length ? o3().reject(new Error("No promise event handler.")) : new (o3())((t7, r5) => {
                  this.emit(e6, ...i5, t7, r5);
                });
              }
              emitAsPromiseNoResponse(e6) {
                for (var t6 = arguments.length, i5 = new Array(t6 > 1 ? t6 - 1 : 0), r4 = 1; r4 < t6; r4++)
                  i5[r4 - 1] = arguments[r4];
                return 0 === this.getListeners(e6).length ? o3().resolve() : new (o3())((t7, r5) => {
                  this.emit(e6, ...i5, t7, r5);
                });
              }
            } {
              get enabled() {
                return this._enabled;
              }
              output(e6, t6) {
                if (this.outputTrack === e6)
                  return;
                const i5 = l3.reportApiInvoke({ name: "".concat(this.name, ".output"), options: { track: null == e6 ? void 0 : e6.toString() } });
                this.outputTrack = e6, this.destination && this.destination.updateInput({ track: e6, context: t6 }), i5.onSuccess();
              }
              constructor() {
                super(), t5(this, "inputTrack", void 0), t5(this, "outputTrack", void 0), t5(this, "_enabled", true), t5(this, "_source", void 0), t5(this, "ID", function e6() {
                  let t6 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7, i5 = arguments.length > 1 ? arguments[1] : void 0;
                  const r4 = Math.random().toString(16).substr(2, t6).toLowerCase();
                  return r4.length === t6 ? "".concat(i5).concat(r4) : "".concat(i5).concat(r4) + e6(t6 - r4.length, "");
                }(6, "")), t5(this, "destination", void 0), t5(this, "context", void 0), t5(this, "name", void 0);
              }
              enable() {
                if (this._enabled)
                  return;
                const e6 = l3.reportApiInvoke({ name: "".concat(this.name, ".enable"), options: true });
                u3.info("".concat(this.name, "-").concat(this.ID, " enabled")), this._enabled = true;
                try {
                  var t6;
                  const i5 = null === (t6 = this.onEnableChange) || void 0 === t6 ? void 0 : t6.call(this, this._enabled);
                  if (i5 instanceof o3())
                    return i5.then(() => {
                      e6.onSuccess();
                    }).catch((t7) => {
                      throw e6.onError(t7), t7;
                    });
                  e6.onSuccess();
                } catch (t7) {
                  throw e6.onError(t7), t7;
                }
              }
              disable() {
                if (!this._enabled)
                  return;
                const e6 = l3.reportApiInvoke({ name: "".concat(this.name, ".enable"), options: false });
                u3.info("".concat(this.name, "-").concat(this.ID, " disabled")), this._enabled = false;
                try {
                  var t6;
                  const i5 = null === (t6 = this.onEnableChange) || void 0 === t6 ? void 0 : t6.call(this, this._enabled);
                  if (i5 instanceof o3())
                    return i5.then(() => {
                      e6.onSuccess();
                    }).catch((t7) => {
                      throw e6.onError(t7), t7;
                    });
                  e6.onSuccess();
                } catch (t7) {
                  throw e6.onError(t7), t7;
                }
              }
            }
            class f3 extends E3 {
              get kind() {
                return "video";
              }
              pipe(e6) {
                const t6 = l3.reportApiInvoke({ name: "".concat(this.name, ".pipe"), options: { processor: e6.name } });
                if (this.destination === e6)
                  return t6.onSuccess(), e6;
                if (e6._source) {
                  const i5 = new Error("Processor ".concat(e6.name, " already being piped, please call ").concat(e6._source.name, ".unpipe() beforehand."));
                  throw t6.onError(i5), i5;
                }
                return this.destination && this.unpipe(), this.destination = e6, e6._source = this, this.context && this.destination.updateInput({ track: this.outputTrack, context: this.context }), t6.onSuccess(), e6;
              }
              unpipe() {
                if (!this.destination)
                  return;
                const e6 = l3.reportApiInvoke({ name: "".concat(this.name, ".unpipe"), options: { processor: this.destination.name } });
                u3.info("unpiping processor ".concat(this.destination.name, "-").concat(this.destination.ID));
                try {
                  const t6 = this.destination;
                  this.destination._source = void 0, this.destination = void 0, t6.reset();
                } finally {
                  e6.onSuccess();
                }
              }
              updateInput(e6) {
                var t6, i5;
                e6.context !== this.context && (this.context = e6.context, null === (t6 = this.onPiped) || void 0 === t6 || t6.call(this, this.context), this.destination && this.destination.updateInput({ track: this.outputTrack, context: e6.context })), e6.track && this.inputTrack !== e6.track && (this.inputTrack = e6.track, null === (i5 = this.onTrack) || void 0 === i5 || i5.call(this, e6.track, this.context));
              }
              reset() {
                var e6;
                this.context && this.context.requestRevertConstraints(this), this.inputTrack = void 0, this.context = void 0, null === (e6 = this.onUnpiped) || void 0 === e6 || e6.call(this), this.destination && this.destination.reset();
              }
            }
            class m3 extends E3 {
              constructor() {
                super(...arguments), t5(this, "inputNode", void 0), t5(this, "outputNode", void 0), t5(this, "destination", void 0), t5(this, "context", void 0);
              }
              get kind() {
                return "audio";
              }
              pipe(e6) {
                const t6 = l3.reportApiInvoke({ name: "".concat(this.name, ".pipe"), options: { processor: e6.name } });
                if (this.destination === e6)
                  return t6.onSuccess(), e6;
                if (e6._source) {
                  const i5 = new Error("Processor ".concat(e6.name, " already being piped, please call ").concat(e6._source.name, ".unpipe() beforehand."));
                  throw t6.onError(i5), i5;
                }
                return this.destination && this.unpipe(), this.destination = e6, e6._source = this, this.context && this.destination.updateInput({ track: this.outputTrack, node: this.outputNode, context: this.context }), t6.onSuccess(), e6;
              }
              unpipe() {
                if (!this.destination)
                  return;
                u3.info("unpiping processor ".concat(this.destination.name, "-").concat(this.destination.ID));
                const e6 = l3.reportApiInvoke({ name: "".concat(this.name, ".unpipe"), options: { processor: this.destination.name } });
                try {
                  var t6;
                  let i5 = this.destination;
                  null === (t6 = this.outputNode) || void 0 === t6 || t6.disconnect(), this.destination._source = void 0, this.destination = void 0, i5.reset();
                } finally {
                  e6.onSuccess();
                }
              }
              output(e6, t6) {
                if (e6 instanceof MediaStreamTrack)
                  super.output(e6, t6);
                else if (e6 instanceof AudioNode) {
                  if (this.outputNode === e6)
                    return;
                  const i5 = l3.reportApiInvoke({ name: "".concat(this.name, ".output"), options: g3(g3({}, e6 instanceof MediaStreamTrack && { track: e6.toString() }), e6 instanceof AudioNode && { audioNode: e6.toString() }) });
                  this.outputNode = e6, this.destination && this.destination.updateInput({ node: e6, context: t6 }), i5.onSuccess();
                }
              }
              updateInput(e6) {
                var t6, i5, r4;
                e6.context !== this.context && (this.context = e6.context, null === (t6 = this.onPiped) || void 0 === t6 || t6.call(this, this.context), this.destination && this.destination.updateInput({ track: this.outputTrack, node: this.outputNode, context: e6.context })), e6.track && this.inputTrack !== e6.track && (this.inputTrack = e6.track, null === (i5 = this.onTrack) || void 0 === i5 || i5.call(this, e6.track, this.context)), e6.node && this.inputNode !== e6.node && (this.inputNode = e6.node, null === (r4 = this.onNode) || void 0 === r4 || r4.call(this, e6.node, this.context));
              }
              reset() {
                var e6;
                this.context && this.context.requestRevertConstraints(this), this.inputTrack = void 0, this.inputNode = void 0, null === (e6 = this.onUnpiped) || void 0 === e6 || e6.call(this, this.context), this.context = void 0, this.destination && this.destination.reset();
              }
            }
            class I3 {
              constructor() {
                t5(this, "__registered__", false), t5(this, "logger", u3), t5(this, "reporter", l3), t5(this, "parameters", {});
              }
              createProcessor() {
                if (!this.__registered__)
                  throw new Error("Extension not registered yet!");
                return this._createProcessor();
              }
            }
            class _3 extends I3 {
            }
            let C3;
            class S3 {
              get running() {
                return this._running;
              }
              constructor(e6, i5) {
                if (t5(this, "type", void 0), t5(this, "interval", void 0), t5(this, "fn", void 0), t5(this, "_running", false), t5(this, "_osc", void 0), !e6)
                  throw new Error();
                if (i5 <= 0)
                  throw new Error();
                this.type = e6, this.interval = i5;
              }
              add(e6) {
                this.fn = e6;
              }
              remove() {
                this.fn = void 0;
              }
              start() {
                if (!this._running)
                  switch (this._running = true, this.type) {
                    case "Timer": {
                      const e6 = () => {
                        setTimeout(() => {
                          this.fn && this.fn(), this._running && e6();
                        }, this.interval);
                      };
                      e6();
                      break;
                    }
                    case "RAF": {
                      const e6 = (t6) => {
                        requestAnimationFrame((i5) => {
                          i5 - t6 < this.interval ? this._running && e6(t6) : (this.fn && this.fn(), this._running && e6(i5));
                        });
                      };
                      e6(performance.now());
                      break;
                    }
                    case "Oscillator": {
                      C3 || (C3 = new AudioContext());
                      const e6 = C3.createGain();
                      let t6;
                      e6.gain.value = 0, e6.connect(C3.destination);
                      const i5 = () => {
                        this.fn && this.fn(), t6 && t6.disconnect(), t6 = C3.createOscillator(), this._osc = t6, t6.connect(e6), this._running && (t6.onended = i5, t6.start(0), t6.stop(C3.currentTime + this.interval / 1e3));
                      };
                      i5();
                      break;
                    }
                  }
              }
              stop() {
                this._running = false, this._osc && (this._osc.onended = null, this._osc = void 0);
              }
            }
            let v3 = 1;
            class T3 {
              constructor(e6) {
                t5(this, "lockingPromise", o3().resolve()), t5(this, "locks", 0), t5(this, "name", ""), t5(this, "lockId", void 0), this.lockId = v3++, e6 && (this.name = e6);
              }
              get isLocked() {
                return this.locks > 0;
              }
              lock(e6) {
                let t6;
                this.locks += 1;
                const i5 = new (o3())((e7) => {
                  t6 = () => {
                    this.locks -= 1, e7();
                  };
                }), r4 = this.lockingPromise.then(() => t6);
                return this.lockingPromise = this.lockingPromise.then(() => i5), r4;
              }
            }
          })(), r3;
        })(), e3.exports = i3();
      }(cX);
      var hX;
      !!!document.documentMode && !!window.StyleMedia && (HTMLCanvasElement.prototype.getContext = (hX = HTMLCanvasElement.prototype.getContext, function() {
        let e3 = arguments;
        const t3 = e3[0];
        return "webgl" === t3 && (e3 = [].slice.call(arguments), e3[0] = "experimental-webgl"), hX.apply(null, e3);
      }));
      const AX = [31, 222, 239, 159, 192, 236, 164, 81, 54, 227, 176, 149, 2, 247, 75, 141, 183, 54, 213, 216, 158, 92, 111, 49, 228, 111, 150, 6, 135, 79, 35, 212, 4, 155, 200, 168, 37, 107, 243, 110, 144, 179, 51, 81, 55, 78, 223, 242, 191, 211, 74, 119, 203, 151, 142, 62, 31, 41, 132, 22, 35, 155, 87, 123, 119, 117, 216, 57, 201, 53, 228, 67, 201, 40, 106, 24, 80, 176, 187, 253, 60, 63, 136, 100, 20, 12, 177, 99, 64, 38, 101, 143, 111, 176, 251, 211, 145, 136, 34, 23, 79, 136, 202, 95, 105, 199, 125, 67, 180, 44, 210, 179, 228, 4, 85, 160, 188, 64, 26, 46, 6, 61, 201, 103, 248, 18, 97, 254, 140, 36, 115, 106, 48, 124, 102, 216, 155, 120, 36, 227, 165, 217, 7, 227, 191, 128, 212, 157, 80, 37, 117, 175, 24, 214, 47, 221, 183, 211, 51, 174, 251, 223, 159, 167, 152, 53, 36, 107, 199, 223, 91, 62, 46, 194, 11, 80, 121, 188, 219, 2, 99, 99, 232, 229, 173, 234, 21, 30, 236, 177, 243, 142, 97, 48, 108, 56, 62, 172, 56, 216, 3, 42, 79, 138, 23, 88, 182, 39, 5, 118, 68, 135, 178, 56, 9, 94, 189, 44, 104, 9, 238, 231, 174, 122, 85, 247, 231, 86, 74, 8, 189, 147, 218, 180, 58, 76, 227, 17, 46, 90, 194, 100, 51, 178, 72, 163, 151, 243, 166, 130, 85, 1, 223, 130, 152, 242, 85, 255, 28, 173, 97, 252, 119, 215, 177, 119, 86, 104, 136, 82, 40, 72, 53, 11, 18, 26, 240, 188, 76, 110, 39, 31, 189];
      function lX(e3) {
        const t3 = new Uint8Array([99, 114, 121, 112, 116, 105, 105]), i3 = t3.length, r3 = e3, n3 = r3.length, o3 = new Uint8Array(n3), s3 = new Uint8Array(256);
        for (let e4 = 0; e4 < 256; e4++)
          s3[e4] = e4;
        let a3 = 0;
        for (let e4 = 0; e4 < 256; e4++)
          a3 = (a3 + s3[e4] + t3[e4 % i3]) % 256, [s3[e4], s3[a3]] = [s3[a3], s3[e4]];
        let c3, d3 = 0;
        a3 = 0;
        for (let e4 = 0; e4 < 0 + n3; e4++)
          d3 = (d3 + 1) % 256, a3 = (a3 + s3[d3]) % 256, [s3[d3], s3[a3]] = [s3[a3], s3[d3]], c3 = s3[(s3[d3] + s3[a3]) % 256], e4 >= 0 && (o3[e4 - 0] = r3[e4 - 0] ^ c3);
        const u3 = String.fromCharCode.apply(null, Array.from(o3));
        return Function("var winSize = 5; return `" + u3 + "`")();
      }
      const pX = [11, 196, 242, 139, 198, 252, 188, 5, 59, 170, 161, 152, 17, 229, 24, 141, 133, 54, 214, 206, 133, 26, 66, 126, 255, 11, 245, 10, 146, 92, 52, 134, 108, 152, 221, 191, 124, 116, 248, 106, 130, 251, 59, 105, 43, 91, 135, 199, 181, 223, 10, 51, 134, 194, 240, 46, 9, 3, 141, 22, 35, 146, 76, 23, 109, 117, 208, 41, 201, 45, 218, 76, 203, 105, 51, 58, 97, 154, 145, 236, 49, 18, 183, 127, 27, 12, 210, 122, 73, 42, 37, 143, 36, 207, 251, 211, 145, 191, 56, 10, 88, 222, 181, 125, 22, 238, 123, 71, 177, 107, 218, 254, 173, 28, 34, 253, 249, 67, 83, 97, 73, 111, 219, 43, 181, 82, 38, 230, 136, 109, 22, 67];
      class gX {
        constructor(e3, t3) {
          MN(this, "program", void 0), MN(this, "gl", void 0), MN(this, "kernel", void 0), this.gl = e3, this.kernel = t3 || pX, this.program = function(e4, t4) {
            const i3 = lX(t4), r3 = uX(e4, [lX(AX), i3]);
            {
              const t5 = e4.getAttribLocation(r3, "a_position"), i4 = e4.createBuffer();
              e4.bindBuffer(e4.ARRAY_BUFFER, i4), e4.bufferData(e4.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), e4.STATIC_DRAW), e4.enableVertexAttribArray(t5);
              const n3 = 2, o3 = e4.FLOAT, s3 = false, a3 = 0, c3 = 0;
              e4.vertexAttribPointer(t5, n3, o3, s3, a3, c3);
            }
            {
              const t5 = e4.getAttribLocation(r3, "a_texCoord"), i4 = e4.createBuffer();
              e4.bindBuffer(e4.ARRAY_BUFFER, i4), e4.bufferData(e4.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), e4.STATIC_DRAW), e4.enableVertexAttribArray(t5);
              const n3 = 2, o3 = e4.FLOAT, s3 = false, a3 = 0, c3 = 0;
              e4.vertexAttribPointer(t5, n3, o3, s3, a3, c3);
            }
            return r3;
          }(this.gl, this.kernel);
        }
        setUniforms() {
          const e3 = this.gl.getUniformLocation(this.program, "u_flipY");
          this.gl.uniform1f(e3, 1);
        }
      }
      class EX extends gX {
        constructor(e3, t3, i3, r3) {
          super(e3, t3), MN(this, "xOffset", void 0), MN(this, "yOffset", void 0), MN(this, "denoiseLevel", 5), this.xOffset = 1 / i3, this.yOffset = 1 / r3;
        }
        setUniforms() {
          const e3 = this.gl.getUniformLocation(this.program, "u_flipY"), t3 = this.gl.getUniformLocation(this.program, "u_singleStepOffset"), i3 = this.gl.getUniformLocation(this.program, "u_denoiseLevel");
          this.gl.uniform2f(t3, this.xOffset, this.yOffset), this.gl.uniform1f(i3, this.denoiseLevel), this.gl.uniform1f(e3, 1);
        }
        setParameters(e3) {
          void 0 !== e3.denoiseLevel && (this.denoiseLevel = e3.denoiseLevel);
        }
        setSize(e3, t3) {
          this.xOffset = 1 / e3, this.yOffset = 1 / t3;
        }
      }
      const fX = [11, 196, 242, 139, 198, 252, 188, 5, 59, 170, 161, 152, 17, 229, 24, 141, 133, 54, 214, 206, 133, 26, 66, 126, 255, 11, 245, 10, 146, 92, 52, 134, 108, 155, 210, 164, 99, 114, 228, 96, 130, 251, 59, 105, 43, 91, 135, 199, 181, 223, 10, 51, 133, 194, 247, 34, 31, 39, 142, 28, 2, 130, 18, 109, 84, 124, 223, 62, 140, 52, 128, 47, 208, 47, 115, 39, 4, 200, 220, 171, 53, 36, 150, 101, 10, 75, 247, 121, 74, 36, 35, 143, 108, 176, 235, 211, 135, 164, 36, 11, 88, 160, 148, 35, 6, 221, 41, 32, 166, 109, 205, 171, 228, 4, 26, 169, 244, 82, 119, 102, 86, 61, 201, 103, 248, 18, 97, 242, 182, 34, 121, 70, 28, 71, 126, 197, 223, 126, 14, 244, 149, 192, 12, 176, 187, 149, 212, 156, 22, 44, 36, 133, 10, 216, 63, 198, 213, 154, 116, 230, 253, 154, 154, 249, 215, 55, 60, 34, 196, 229, 76, 50, 44, 135, 22, 77, 113, 247, 142, 94, 60, 23, 172, 145, 175, 218, 81, 86, 162, 239, 180, 205, 63, 118, 3, 110, 123, 224, 127, 158, 124, 15, 127, 157, 27, 66, 176, 33, 24, 51, 53, 194, 178, 56, 6, 74, 191, 111, 51, 78, 174, 157, 229, 17, 22, 178, 231, 92, 25, 23, 191, 157, 137, 188, 54, 64, 176, 13, 22, 81, 207, 45, 108, 203, 83, 186, 130, 237, 186, 153, 110, 8, 196, 168, 152, 161, 28, 238, 46, 184, 36, 185, 20, 203, 183, 98, 95, 41, 149, 93, 105, 37, 116, 91, 68, 105, 164, 217, 30, 42, 60, 53, 173, 213, 177, 216, 195, 53, 204, 173, 128, 243, 42, 122, 205, 65, 97, 129, 194, 68, 218, 91, 141, 11, 224, 124, 132, 138, 119, 36, 220, 161, 39, 214, 146, 183, 193, 225, 23, 177, 201, 243, 128, 160, 33, 75, 86, 126, 139, 254, 232, 14, 13, 85, 2, 112, 17, 150, 36, 180, 86, 226, 225, 126, 197, 17, 228, 225, 142, 245, 37, 170, 39, 96, 187, 190, 2, 35, 85, 237, 11, 189, 1, 79, 237, 2, 1, 114, 246, 109, 190, 66, 54, 153, 43, 218, 204, 70, 6, 204, 162, 247, 18, 130, 123, 30, 60, 165, 130, 142, 210, 133, 91, 127, 117, 71, 38, 145, 172, 7, 5, 16, 220, 222, 111, 98, 141, 239, 208, 125, 26, 238, 28, 0, 216, 89, 13, 7, 119, 134, 194, 75, 41, 67, 174, 1, 217, 80, 101, 40, 26, 59, 28, 59, 46, 108, 138, 38, 157, 167, 28, 234, 73, 177, 42, 42, 102, 108, 26, 181, 27, 178, 42, 43, 52, 28, 110, 117, 198, 173, 176, 178, 101, 225, 150, 36, 139, 108, 105, 10, 237, 222, 3, 143, 126, 18, 144, 115, 74, 56, 114, 134, 231, 159, 212, 62, 126, 80, 173, 216, 167, 4, 81, 18, 52, 17, 144, 218, 32, 139, 207, 104, 128, 229, 99, 84, 120, 31, 87, 227, 154, 91, 196, 63, 123, 111, 125, 36, 52, 57, 168, 113, 150, 189, 204, 24, 104, 196, 237, 86, 163, 68, 197, 202, 170, 212, 191, 81, 193, 111, 255, 162, 181, 202, 156, 146, 196, 96, 16, 118, 117, 55, 71, 156, 31, 163, 242, 204, 239, 11, 150, 27, 126, 115, 154, 107, 247, 134, 158, 125, 255, 146, 35, 183, 209, 36, 116, 87, 215, 172, 5, 251, 133, 114, 254, 141, 195, 6, 145, 4, 111, 182, 167, 74, 154, 152, 68, 18, 146, 88, 106, 200, 154, 15, 176, 94, 86, 66, 178, 101, 219, 35, 188, 129, 66, 28, 41, 110, 174, 53, 88, 174, 64, 191, 206, 127, 48, 126, 214, 216, 93, 119, 2, 166, 99, 181, 222, 29, 218, 28, 195, 219, 125, 44, 50, 16, 99, 174, 225, 51, 133, 120, 184, 159, 168, 75, 242, 162, 124, 255, 81, 25, 153, 109, 69, 220, 176, 4, 237, 196, 233, 19, 8, 240, 160, 39, 122, 81, 29, 188, 144, 249, 170, 174, 137, 30, 10, 93, 133, 151, 199, 248, 175, 38, 41, 144, 229, 245, 149, 25, 240, 138, 179, 114, 182, 84, 50, 103, 95, 31, 199, 31, 87, 208, 203, 199, 135, 49, 211, 43, 52, 36, 74, 59, 37, 22, 136, 171, 244, 126, 18, 251, 39, 159, 241, 66, 206, 127, 149, 159, 182, 143, 232, 199, 136, 46, 150, 32, 51, 221, 74, 22, 102, 93, 22, 44, 132, 140, 199, 43, 69, 249, 77, 75, 140, 70, 4, 252, 98, 235, 77, 190, 125, 18, 56, 21, 10, 244, 42, 2, 246, 62, 127, 241, 123, 137, 22, 247, 219, 177, 160, 84, 18, 10, 84, 97, 251, 127, 102, 16, 209, 181, 100, 94, 56, 238, 209, 207, 76, 189, 95, 15, 165, 139, 143, 189, 96, 225, 55, 112, 178, 27, 218, 198, 223, 251, 52, 123, 94, 130, 220, 142, 216, 116, 237, 18, 254, 49, 59, 128, 41, 29, 15, 179, 164, 85, 76, 167, 166, 151, 39, 221, 2, 190, 68, 167, 26, 177, 114, 141, 4, 67, 25, 69, 182, 38, 166, 160, 27, 151, 148, 108, 48, 227, 60, 112, 48, 22, 159, 76, 127, 251, 63, 254, 177, 113, 217, 197, 95, 179, 109, 128, 138, 99, 27, 249, 10, 174, 155, 129, 80, 39, 165, 252, 85, 60, 131, 183, 98, 107, 68, 207, 19, 233, 231, 55, 225, 126, 77, 49, 53, 145, 203, 113, 29, 208, 64, 237, 182, 229, 165, 7, 11, 169, 106, 253, 116, 141, 200, 62, 16, 38, 121, 55, 148, 91, 83, 160, 140, 126, 121, 12, 79, 189, 72, 172, 31, 243, 240, 209, 229, 32, 220, 91, 229, 81, 94, 247, 121, 153, 151, 232, 182, 171, 198, 50, 31, 152, 245, 172, 151, 130, 55, 62, 125, 38, 155, 229, 78, 207, 148, 201, 2, 78, 63, 119, 107, 168, 78, 139, 141, 163, 177, 191, 239, 141, 39, 182, 174, 40, 76, 226, 62, 125, 209, 6, 6, 34, 37, 147, 85, 204, 103, 51, 191, 36, 248, 17, 175, 20, 1, 53, 16, 35, 143, 237, 177, 125, 86, 29, 219, 235, 20, 121, 205, 59, 5, 250, 107, 109, 32, 224, 30, 152, 143, 113, 151, 95, 85, 19, 254, 164, 135, 124, 68, 136, 199, 29, 31, 244, 91, 10, 84, 127, 101, 210, 70, 226, 195, 140, 70, 166, 54, 217, 165, 84, 42, 165, 175, 100, 234, 124, 121, 105, 53, 101, 118, 174, 101, 220, 147, 68, 161, 37, 0, 182, 220, 142, 221, 155, 230, 115, 164, 10, 214, 208, 120, 91, 152, 66, 27, 81, 184, 48, 84, 70, 7, 128, 153, 217, 218, 249, 226, 70, 130, 200, 156, 61, 227, 21, 164, 137, 193, 221, 119, 10, 134, 204, 23, 20, 17, 90, 94, 105, 204, 39, 99, 1, 64, 153, 45, 213, 19, 247, 97, 194, 49, 35, 125, 255, 195, 139, 63, 209, 175, 208, 147, 189, 244, 204, 24, 211, 99, 142, 18, 92, 130, 254, 182, 231, 235, 93, 10, 127, 175, 87, 35, 62, 110, 137, 184, 39, 114, 200, 150, 11, 190, 40, 162, 168, 223, 203, 110, 242, 192, 234, 26, 11, 54, 155, 38, 48, 79, 109, 101, 119, 165, 187, 223, 5, 20, 168, 171, 241, 20, 243, 108, 199, 3, 155, 69, 244, 149, 0, 187, 110, 12, 233, 42, 151, 189, 139, 133, 104, 3, 30, 16, 200, 69, 4, 123, 103, 144, 12, 106, 182, 1, 127, 91, 125, 158, 12, 144, 238, 232, 209, 101, 159, 56, 163, 240, 179, 50, 169, 120, 219, 176, 87, 77, 45, 247, 153, 190, 82, 132, 50, 137, 209, 97, 19, 35, 247, 161, 62, 77, 16, 71, 152, 72, 61, 50, 99, 157, 154, 56, 58, 175, 27, 73, 121, 229, 195, 228, 132, 69, 233, 169, 100, 21, 123, 17, 3, 164, 6, 146, 106, 196, 29, 3, 250, 217, 164, 23, 171, 203, 14, 242, 239, 249, 169, 116, 138, 209, 98, 113, 181, 122, 35, 162, 216, 46, 230, 4, 155, 142, 118, 216, 232, 229, 28, 12, 158, 153, 126, 149, 171, 172, 231, 99, 211, 57, 114, 136, 183, 114, 74, 35, 233, 115, 127, 253, 157, 38, 49, 136, 141, 25, 161, 255, 232, 110, 101, 208, 166, 186, 226, 12, 185, 19, 155, 53, 93, 155, 39, 161, 7, 124, 213, 52, 223, 125, 211, 242, 253, 22, 13, 131, 115, 167, 198, 188, 90, 209, 63, 224, 92, 112, 118, 220, 165, 31, 164, 43, 58, 197, 77, 17, 247, 77, 164, 74, 77, 218, 18, 187, 41, 76, 189, 127, 98, 18, 226, 231, 71, 115, 236, 68, 183, 111, 50, 168, 88, 247, 9, 123, 65, 180, 88, 74, 44, 101, 101, 173, 11];
      class mX extends EX {
        constructor(e3, t3, i3) {
          super(e3, fX, t3, i3);
        }
      }
      const IX = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 165, 108, 122, 254, 125, 130, 229, 55, 109, 113, 11, 210, 238, 163, 213, 86, 116, 156, 248, 215, 63, 20, 48, 173, 31, 55, 133, 18, 105, 32, 16, 204, 35, 128, 38, 212, 87, 200, 97, 114, 40, 12, 210, 193, 171, 59, 33, 158, 108, 14, 75, 228, 74, 65, 32, 57, 192, 112, 156, 234, 250, 140, 189, 40, 20, 6, 230, 135, 52, 17, 200, 123, 68, 183, 44, 215, 187, 234, 2, 13, 169, 234, 94, 115, 60, 6, 107, 224, 118, 254, 88, 2, 235, 134, 36, 120, 5, 85, 94, 126, 222, 223, 101, 105, 227, 147, 199, 64, 185, 246, 143, 183, 210, 30, 37, 127, 226, 79, 156, 118, 147, 208, 131, 51, 248, 232, 217, 206, 181, 218, 58, 61, 112, 244, 227, 68, 45, 41, 206, 69, 12, 45, 163, 205, 75, 6, 23, 167, 145, 250, 237, 92, 84, 164, 240, 253, 216, 54, 85, 7, 108, 62, 255, 42, 217, 3, 27, 0, 196, 94, 28, 241, 120, 80, 92, 89, 135, 228, 125, 2, 3, 242, 39, 116, 64, 248, 216, 177, 122, 66, 178, 180, 9, 7, 33, 186, 208, 213, 188, 59, 78, 243, 95, 123, 28, 142, 45, 99, 130, 7, 167, 194, 156, 238, 199, 10, 71, 141, 251, 221, 158, 16, 255, 38, 181, 36, 184, 20, 136, 240, 55, 27, 51, 191, 82, 105, 55, 97, 78, 74, 121, 191, 161, 91, 126, 105, 103, 174, 139, 223, 145, 150, 120, 156, 240, 252, 182, 105, 104, 205, 65, 97, 129, 194, 68, 218, 91, 141, 11, 224, 124, 132, 138, 119, 36, 201, 211, 39, 203, 146, 225, 246, 252, 21, 161, 250, 188, 137, 190, 42, 4, 90, 126, 211, 171, 240, 113, 67, 28, 92, 57, 77, 200, 125, 224, 19, 178, 142, 112, 202, 5, 233, 229, 128, 235, 105, 239, 102, 52, 179, 224, 87, 45, 68, 211, 10, 187, 9, 38, 190, 86, 25, 43, 175, 56, 231, 11, 108, 220, 36, 129, 131, 19, 93, 163, 239, 169, 118, 205, 50, 77, 121, 139, 139, 141, 197, 170, 20, 44, 39, 19, 97, 205, 228, 8, 106, 67, 210, 135, 111, 127, 141, 185, 175, 123, 26, 226, 42, 29, 217, 16, 99, 9, 46, 157, 232, 22, 3, 105, 174, 73, 144, 23, 110, 55, 84, 46, 4, 116, 39, 113, 205, 58, 158, 242, 7, 208, 75, 162, 55, 115, 35, 52, 124, 235, 114, 178, 55, 43, 98, 17, 100, 33, 134, 237, 190, 230, 60, 184, 192, 104, 146, 52, 58, 79, 174, 180, 81, 155, 114, 0, 153, 113, 90, 51, 86, 150, 254, 136, 205, 104, 39, 11, 190, 187, 233, 80, 81, 81, 56, 18, 222, 148, 116, 155, 156, 33, 132, 226, 127, 84, 34, 83, 28, 249, 153, 18, 197, 10, 116, 102, 125, 45, 47, 36, 235, 46, 212, 166, 209, 3, 125, 132, 237, 124, 163, 68, 197, 202, 232, 152, 234, 75, 235, 103, 248, 160, 241, 213, 151, 144, 130, 37, 23, 51, 48, 55, 12, 227, 31, 163, 242, 251, 245, 22, 129, 77, 20, 35, 150, 20, 181, 203, 138, 69, 233, 215, 109, 178, 209, 52, 85, 96, 221, 179, 56, 249, 138, 111, 250, 141, 134, 95, 152, 92, 109, 183, 174, 104, 151, 156, 31, 66, 211, 10, 57, 141, 167, 18, 177, 27, 126, 74, 252, 29, 143, 121, 173, 203, 8, 27, 44, 123, 148, 57, 88, 163, 68, 228, 158, 62, 98, 121, 192, 228, 94, 92, 72, 241, 33, 230, 173, 0, 197, 1, 194, 144, 111, 91, 60, 0, 106, 181, 203, 51, 133, 120, 250, 158, 184, 93, 216, 184, 126, 253, 21, 22, 155, 99, 80, 205, 227, 69, 231, 141, 165, 71, 70, 252, 223, 105, 51, 93, 22, 165, 135, 233, 177, 164, 139, 53, 5, 85, 151, 134, 214, 165, 249, 100, 24, 186, 207, 245, 149, 68, 218, 204, 252, 32, 190, 90, 48, 76, 57, 31, 201, 15, 52, 130, 135, 152, 206, 63, 198, 100, 126, 36, 2, 104, 116, 0, 160, 163, 186, 2, 91, 165, 57, 149, 163, 12, 239, 121, 152, 209, 224, 136, 248, 135, 136, 46, 150, 32, 51, 154, 6, 105, 0, 71, 30, 44, 175, 147, 139, 34, 91, 184, 78, 31, 145, 18, 3, 250, 122, 166, 47, 252, 109, 19, 40, 10, 123, 163, 99, 76, 133, 119, 37, 180, 38, 207, 79, 171, 185, 188];
      class _X extends EX {
        constructor(e3, t3, i3) {
          super(e3, IX, t3, i3);
        }
      }
      const CX = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 160, 96, 121, 255, 120, 207, 227, 114, 120, 38, 72, 149, 145, 165, 227, 75, 122, 158, 250, 232, 46, 34, 52, 135, 9, 30, 144, 17, 110, 126, 110, 130, 71, 156, 46, 210, 67, 202, 51, 119, 97, 3, 211, 214, 227, 45, 109, 151, 97, 21, 10, 229, 53, 80, 26, 51, 202, 119, 128, 230, 197, 140, 135, 40, 14, 88, 128, 202, 95, 21, 208, 96, 83, 185, 98, 216, 242, 224, 15, 25, 224, 233, 86, 96, 46, 80, 120, 220, 48, 187, 86, 30, 240, 140, 46, 95, 81, 48, 90, 117, 140, 177, 51, 107, 235, 158, 137, 5, 241, 191, 154, 149, 219, 30, 126, 85, 175, 10, 216, 63, 139, 216, 151, 122, 251, 224, 202, 220, 227, 221, 53, 122, 34, 213, 224, 94, 45, 14, 200, 68, 31, 61, 175, 208, 17, 120, 82, 244, 138, 208, 165, 21, 19, 236, 232, 180, 217, 50, 74, 70, 126, 114, 227, 62, 192, 124, 9, 85, 148, 33, 77, 255, 117, 75, 102, 87, 151, 255, 87, 74, 74, 181, 111, 108, 9, 249, 220, 174, 59, 80, 254, 168, 29, 30, 94, 171, 133, 133, 195, 105, 64, 254, 68, 65, 18, 158, 54, 73, 203, 65, 175, 151, 170, 236, 138, 17, 119, 128, 237, 214, 189, 28, 250, 38, 149, 97, 242, 81, 212, 254, 57, 18, 120, 155, 64, 96, 108, 75, 78, 74, 121, 191, 243, 30, 42, 60, 103, 165, 196, 160, 195, 216, 99, 182, 173, 214, 182, 105, 53, 231, 3, 45, 212, 144, 101, 217, 65, 141, 44, 230, 125, 151, 154, 123, 57, 134, 223, 98, 133, 156, 238, 137, 181, 80, 175, 230, 167, 131, 180, 13, 69, 77, 44, 156, 165, 252, 14, 27, 85, 71, 1, 82, 196, 64, 243, 26, 167, 146, 98, 201, 6, 195, 247, 200, 224, 44, 177, 104, 109, 187, 231, 83, 118, 28, 159, 92, 179, 28, 14, 162, 81, 84, 21, 168, 34, 156, 21, 127, 215, 88, 218, 208, 11, 92, 161, 239, 239, 82, 221, 59, 86, 83, 201, 199, 216, 151, 139, 23, 54, 39, 52, 103, 204, 247, 24, 102, 94, 157, 138, 42, 49, 131, 183, 208, 50, 95, 236, 54, 6, 211, 26, 68, 72, 56, 212, 134, 24, 91, 114, 132, 1, 217, 80, 38, 47, 29, 47, 0, 107, 102, 99, 129, 33, 140, 243, 74, 251, 89, 247, 103, 12, 114, 58, 113, 240, 72, 188, 39, 48, 72, 89, 45, 102, 206, 245, 247, 231, 56, 167, 129, 122, 222, 47, 40, 78, 227, 159, 64, 206, 34, 127, 203, 127, 87, 40, 108, 152, 238, 147, 231, 46, 104, 89, 182, 180, 232, 86, 89, 91, 57, 10, 222, 202, 59, 199, 135, 60, 199, 189, 40, 84, 125, 28, 84, 162, 210, 91, 143, 34, 106, 117, 118, 3, 125, 126, 237, 60, 131, 173, 153, 69, 49, 212, 204, 117, 163, 31, 239, 202, 232, 152, 234, 3, 162, 32, 176, 184, 184, 196, 154, 131, 144, 115, 6, 53, 122, 55, 69, 166, 19, 230, 183, 175, 244, 1, 156, 11, 37, 121, 134, 121, 152, 142, 158, 125, 229, 150, 44, 183, 216, 109, 7, 65, 222, 169, 56, 222, 140, 110, 233, 157, 138, 66, 208, 6, 111, 166, 188, 76, 208, 222, 4, 104, 211, 10, 57, 141, 243, 65, 228, 86, 85, 88, 169, 91, 237, 56, 249, 133, 77, 21, 32, 37, 230, 55, 0, 184, 110, 228, 158, 62, 98, 45, 147, 177, 19, 119, 89, 164, 103, 132, 239, 84, 139, 68, 204, 157, 49, 41, 50, 89, 113, 159, 203, 51, 133, 120, 184, 210, 237, 15, 249, 187, 100, 253, 50, 16, 154, 112, 64, 193, 254, 10, 235, 200, 253, 84, 31, 169, 171, 39, 122, 70, 46, 186, 139, 212, 162, 173, 158, 41, 23, 86, 148, 172, 196, 237, 242, 58, 102, 180, 150, 238, 191, 25, 240, 204, 252, 125, 148, 29, 124, 51, 95, 10, 196, 55, 49, 159, 138, 144, 255, 126, 205, 43, 49, 42, 17, 59, 60, 77, 139, 177, 239, 64, 36, 224, 98, 205, 234, 70, 199, 103, 139, 218, 206, 207, 178, 217, 255, 32, 134, 59, 25, 221, 74, 22, 102, 82, 19, 20, 170, 142, 134, 42, 106, 249, 64, 80, 222, 28, 21, 169, 50, 235, 4, 237, 56, 81, 87, 76, 32, 251, 42, 6, 173, 105, 54, 191, 8, 136, 5, 245, 206, 239, 176, 9, 116, 24];
      class SX extends EX {
        constructor(e3, t3, i3) {
          super(e3, CX, t3, i3);
        }
      }
      const vX = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 190, 100, 112, 230, 97, 199, 225, 96, 74, 99, 94, 248, 222, 162, 213, 95, 122, 158, 212, 233, 42, 22, 37, 217, 115, 36, 152, 30, 123, 116, 104, 212, 109, 129, 41, 220, 77, 213, 97, 124, 45, 4, 219, 197, 171, 40, 18, 149, 104, 20, 4, 248, 102, 64, 9, 50, 217, 124, 131, 180, 188, 159, 170, 63, 1, 84, 130, 150, 117, 14, 212, 118, 67, 165, 97, 207, 242, 251, 15, 30, 187, 188, 77, 79, 122, 67, 101, 252, 109, 244, 82, 37, 191, 227, 35, 114, 87, 57, 71, 99, 218, 155, 54, 101, 239, 138, 197, 13, 226, 228, 176, 157, 158, 87, 98, 55, 251, 79, 150, 64, 138, 200, 135, 40, 132, 135, 207, 146, 252, 222, 57, 58, 111, 151, 225, 78, 59, 36, 210, 70, 29, 121, 160, 210, 31, 109, 67, 167, 194, 177, 236, 91, 108, 164, 229, 130, 211, 59, 66, 93, 18, 107, 226, 54, 210, 51, 8, 77, 217, 19, 73, 187, 33, 30, 59, 9, 135, 162, 49, 5, 11, 225, 111, 119, 11, 247, 218, 129, 115, 83, 205, 170, 21, 4, 69, 210, 133, 134, 245, 109, 15, 177, 9, 81, 81, 203, 105, 42, 158, 12, 255, 151, 165, 230, 205, 5, 92, 196, 251, 211, 187, 27, 214, 43, 186, 91, 233, 85, 192, 229, 15, 71, 38, 220, 20, 38, 101, 44, 78, 7, 60, 251, 186, 75, 103, 108, 53, 166, 220, 186, 208, 194, 120, 207, 230, 159, 248, 22, 32, 142, 124, 96, 157, 222, 60, 191, 65, 145, 6, 239, 125, 151, 147, 50, 58, 130, 207, 110, 131, 223, 231, 137, 238, 28, 182, 216, 167, 198, 191, 37, 67, 76, 1, 144, 232, 218, 79, 72, 28, 65, 101, 43, 216, 64, 253, 16, 173, 179, 123, 140, 27, 233, 245, 199, 230, 36, 181, 102, 114, 247, 162, 18, 34, 20, 212, 25, 171, 24, 28, 143, 80, 94, 40, 167, 34, 209, 61, 117, 130, 1, 198, 196, 7, 21, 252, 180, 255, 92, 128, 119, 9, 48, 156, 138, 136, 151, 143, 23, 44, 52, 3, 40, 197, 228, 31, 123, 67, 163, 140, 32, 54, 204, 187, 149, 80, 19, 255, 82, 120, 195, 12, 110, 65, 56, 212, 143, 22, 78, 44, 234, 72, 140, 29, 118, 103, 18, 36, 7, 122, 50, 37, 139, 47, 142, 243, 25, 208, 88, 237, 126, 50, 103, 127, 19, 183, 29, 169, 29, 1, 55, 23, 100, 32, 129, 239, 243, 160, 61, 178, 197, 117, 199, 45, 57, 26, 165, 135, 92, 218, 59, 0, 197, 54, 13, 96, 40, 141, 212, 221, 131, 103, 46, 22, 228, 191, 167, 73, 20, 86, 62, 11, 147, 217, 116, 205, 203, 110, 134, 249, 51, 6, 123, 23, 86, 231, 157, 8, 144, 83, 126, 115, 118, 35, 96, 36, 229, 36, 220, 228, 143, 71, 45, 223, 129, 48, 236, 5, 145, 202, 188, 208, 184, 70, 241, 104, 255, 188, 181, 146, 210, 206, 144, 53, 77, 101, 120, 38, 8, 245, 80, 230, 165, 160, 183, 83, 202, 79, 127, 57, 214, 126, 242, 150, 208, 40, 239, 148, 35, 163, 201, 97, 74, 70, 214, 181, 63, 240, 147, 33, 253, 149, 140, 77, 197, 82, 126, 189, 231, 7, 196, 212, 80, 14, 151, 24, 57, 144, 243, 81, 234, 66, 24, 19, 236, 2, 137, 121, 246, 129, 65, 7, 99, 110, 174, 54, 74, 182, 81, 234, 142, 37, 72, 110, 220, 255, 64, 119, 10, 188, 111, 191, 228, 1, 205, 9, 204, 143, 56, 62, 125, 84, 106, 225, 131, 97, 192, 43, 240, 157, 161, 75, 168, 247, 44, 175, 65, 81, 192, 48, 21, 157, 167, 80, 191, 130, 161, 75, 85, 186, 174, 42, 117, 1, 68, 252, 204, 138, 254, 203, 152, 21, 13, 64, 144, 195, 207, 238, 229, 54, 103, 247, 159, 245, 211, 85, 191, 141, 168, 32, 234, 85, 46, 118, 12, 5, 199, 4, 19, 217, 203, 202, 156, 33, 143, 114, 116, 60, 66, 40, 58, 77, 208, 237, 171, 26, 72, 175, 114, 205, 248, 87, 137, 62, 210, 143, 151, 197, 167, 210, 241, 122, 150, 104, 122, 154, 2, 70, 102, 83, 19, 36, 141, 136, 199, 42, 79, 229, 71, 86, 194, 109, 31, 236, 80, 166, 17, 230, 109, 1, 40, 28, 46, 224, 56, 20, 230, 47, 100, 254, 116, 208, 76, 169, 157, 241, 175, 3, 70, 85, 31, 38, 245, 58, 33, 80, 145, 237, 8, 22, 71, 224, 158, 156, 31, 249, 81, 87, 247, 230, 199, 237, 96, 167, 123, 63, 243, 79, 156, 206, 203, 160, 54, 124, 68, 253, 215, 132, 235, 57, 185, 92, 238, 55, 59, 210, 104, 71, 26, 183, 180, 71, 12, 255, 224, 192, 65, 154, 72, 244, 8, 164, 10, 248, 46, 207, 30, 92, 1, 80, 244, 31, 189, 138, 88, 216, 218, 63, 100, 227, 116, 57, 119, 94, 135, 5, 126, 255, 32, 191, 163, 61, 209, 194, 88, 248, 112, 139, 173, 43, 69, 134, 3, 160, 151, 137, 25, 98, 239, 166, 19, 123, 208, 180, 31, 120, 30, 191, 75, 183, 179, 126, 180, 125, 92, 107, 105, 206, 138, 28, 67, 139, 3, 188, 230, 184, 255, 121, 13, 181, 45, 160, 114, 202, 194, 123, 87, 55, 124, 97, 164, 82, 95, 232, 216, 117, 62, 5, 90, 176, 82, 167, 52, 160, 153, 174, 168, 105, 146, 91, 248, 81, 79, 249, 97, 138, 133, 170, 245, 229, 132, 61, 5, 149, 224, 246, 194, 213, 61, 12, 109, 44, 136, 235, 95, 219, 133, 220, 27, 93, 36, 93, 124, 180, 81, 141, 152, 220, 170, 163, 229, 197, 124, 171, 232, 48, 70, 251, 106, 119, 150, 20, 16, 49, 119, 247, 42, 132, 36, 76, 254, 124, 177, 66, 175, 9, 1, 39, 92, 127, 195, 171, 198, 34, 2, 64, 144, 179, 72, 40, 151, 110, 89, 229, 42, 125, 33, 238, 16, 220, 228, 51, 203, 8, 1, 68, 145, 253, 133, 118, 93, 163, 129, 22, 13, 248, 65, 12, 4, 63, 101, 210, 70, 170, 138, 203, 14, 246, 54, 194, 195, 27, 107, 241, 175, 35, 171, 49, 52, 106, 121, 45, 36, 152, 85, 215, 132, 78, 167, 34, 18, 167, 245, 152, 133, 134, 170, 120, 182, 10, 146, 191, 37, 2, 205, 47, 125, 20, 203, 44, 88, 81, 32, 150, 223, 220, 218, 238, 254, 30, 212, 167, 221, 115, 156, 82, 226, 137, 220, 221, 97, 3, 139, 202, 33, 9, 27, 26, 126, 40, 215, 25, 126, 9, 82, 208, 49, 217, 14, 161, 81, 196, 61, 60, 87, 254, 213, 194, 81, 216, 161, 151, 209, 166, 222, 230, 24, 128, 117, 140, 92, 4, 203, 254, 170, 253, 249, 88, 90, 112, 226, 18, 44, 122, 39, 158, 158, 56, 69, 204, 159, 5, 179, 51, 197, 233, 139, 216, 102, 226, 206, 248, 15, 78, 112, 214, 126, 67, 28, 40, 38, 98, 190, 178, 206, 67, 94, 245, 254, 160, 101, 176, 32, 157, 26, 132, 83, 252, 228, 87, 242, 32, 127, 160, 112, 210, 224, 133, 149, 115, 41, 30, 16, 200, 69, 89, 81, 77, 144, 12, 106, 182, 73, 54, 28, 53, 195, 28, 216, 179, 179, 136, 35, 141, 102, 234, 177, 240, 34, 186, 106, 145, 245, 3, 84, 48, 251, 157, 245, 11, 217, 111, 227, 138, 42, 67, 114, 211, 177, 37, 103, 16, 71, 152, 72, 117, 123, 36, 213, 202, 56, 124, 227, 84, 8, 45, 229, 149, 165, 214, 69, 244, 169, 55, 68, 62, 94, 104, 228, 74, 205, 123, 222, 17, 7, 172, 158, 227, 74, 206, 149, 67, 175, 171, 251, 185, 121, 151, 223, 63, 35, 229, 32, 49, 190, 209, 120, 137, 69, 213, 214, 19, 150, 187, 177, 28, 12, 158, 153, 126, 149, 171, 167, 234, 120, 129, 109, 32, 157, 180, 75, 66, 56, 233, 115, 127, 230, 157, 32, 34, 143, 156, 31, 230, 168, 174, 125, 118, 195, 249, 243, 165, 81, 246, 10, 144, 15, 103, 139, 55, 173, 7, 59, 136, 69, 172, 54, 132, 165, 140, 78, 77, 230, 33, 169, 129, 188, 71, 209, 109, 161, 8, 57, 57, 199, 143, 31, 164, 43, 58, 130, 1, 110, 145, 31, 229, 13, 46, 149, 94, 244, 106, 76, 238, 105, 107, 1, 183, 177, 10, 61, 225, 94, 185, 116, 58, 183, 95, 225, 22, 119, 19, 248, 28, 13, 123, 125, 108, 158, 64, 184, 77, 245, 153, 162, 217, 227, 208, 41, 185, 211, 235, 41, 153, 181, 54, 166, 165, 11, 154, 55, 21, 184, 209, 192, 249, 44, 164, 160, 29, 229, 159, 82, 156, 198, 241, 183, 114, 83, 137, 186, 151, 148, 31, 21, 197, 216, 145, 32, 13, 50, 22, 241, 137, 39, 71, 28, 142, 160, 215, 107, 221, 45, 202, 104, 227, 110, 186, 12, 150, 145, 240, 51, 49, 44, 196, 115, 224, 238, 149, 189, 134, 99, 67, 241, 62, 157, 240, 114, 247, 195, 26, 200, 141, 97, 147, 249, 23, 150, 174, 10, 13, 219, 81, 73, 58, 242, 96, 250, 243, 15, 49, 218, 58, 230, 104, 252, 175, 150, 123, 86, 185, 84, 90, 198, 6, 36, 0, 99, 72, 28, 166, 238, 115, 231, 171, 249, 179, 71, 174, 68, 156, 227, 17, 198, 79, 73, 142, 99, 144, 20, 80, 62, 80, 191, 142, 46, 71, 9, 243, 6, 8, 214, 116, 72, 190, 106, 161, 19, 185, 100, 9, 187, 64, 94, 86, 203, 174, 156, 245, 222, 95, 54, 30, 148, 19, 11, 50, 112, 96, 61, 237, 159, 173, 7, 154, 127, 175, 79, 48, 97, 89, 78, 126, 66, 171, 204, 158, 195, 27, 226, 205, 222, 157, 89, 251, 90, 125, 37, 212, 27, 97, 3, 141, 247, 175, 50, 121, 7, 187, 68, 196, 181, 202, 167, 189, 57, 84, 81, 222, 23, 27, 84, 130, 176, 98, 66, 240, 207, 18, 23, 28, 163, 163, 194, 45, 37, 129, 202, 170, 97, 189, 0, 81, 238, 0, 39, 199, 163, 35, 211, 206, 247, 65, 29, 116, 242, 67, 102, 235, 13, 136, 232, 230, 114, 146, 187, 7, 254, 142, 26, 121, 16, 237, 5, 160, 201, 114, 94, 178, 199, 95, 212, 241, 45, 112, 180, 188, 72, 86, 114, 189, 155, 149, 149, 163, 210, 112, 101, 12, 69, 225, 75, 202, 223, 28, 242, 90, 215, 156, 169, 224, 245, 135, 128, 92, 148, 217, 131, 208, 255, 25, 135, 117, 136, 5, 104, 185, 249, 161, 228, 214, 16, 105, 204, 9, 182, 135, 153, 220, 101, 244, 160, 207, 58, 182, 118, 185, 240, 57, 245, 123, 13, 112, 182, 106, 229, 220, 90, 29, 86, 215, 96, 147, 232, 2, 55, 131, 225, 137, 68, 245, 89, 141, 252, 97, 3, 129, 155, 216, 223, 98, 116, 45, 78, 85, 141, 161, 74, 215, 7, 150, 171, 225, 59, 78, 221, 152, 236, 14, 117, 100, 208, 158, 86, 13, 185, 124, 87, 157, 111, 40, 187, 182, 124, 173, 71, 173, 23, 199, 52, 155, 190, 134, 11, 23, 64, 25, 215, 39, 115, 231, 173, 77, 72, 114, 54, 252, 116, 178, 59, 221, 106, 241, 119, 254, 30, 226, 241, 204, 233, 113, 197, 96, 146, 0, 41, 67, 3, 231, 126, 12, 218, 202, 22, 171, 114, 249, 176, 134, 160, 19, 216, 31, 229, 118, 226, 62, 242, 126, 126, 42, 127, 130, 68, 218, 218, 81, 202, 106, 217, 191, 25, 177, 82, 97, 81, 36, 232, 137, 58, 90, 216, 190, 117, 235, 20, 194, 144, 76, 178, 27, 213, 13, 208, 18, 29, 118, 126, 49, 98, 203, 179, 128, 237, 100, 32, 242, 189, 212, 6, 210, 210, 188, 161, 205, 13, 124, 119, 13, 215, 112, 41, 183, 176, 215, 168, 210, 182, 111, 1, 115, 2, 239, 141, 8, 177, 124, 112, 48, 197, 2, 239, 11, 99, 4, 36, 77, 69, 47, 244, 19, 153, 61, 19, 2, 96, 176, 7, 112, 122, 131, 169, 25, 189, 116, 171, 49, 12, 121, 162, 79, 154, 74, 251, 50, 233, 182, 63, 180, 224, 118, 49, 253, 21, 20, 16, 31, 144, 184, 93, 174, 231, 244, 183, 13, 49, 225, 189, 211, 73, 185, 49, 110, 142, 25, 226, 45, 176, 233, 204, 74, 33, 16, 205, 88, 131, 92, 157, 170, 175, 68, 170, 61, 53, 116, 165, 16, 27, 182, 160, 181, 87, 241, 15, 151, 85, 107, 76, 167, 129, 25, 172, 127, 184, 138, 153, 222, 228, 125, 64, 44, 45, 32, 12, 227, 148, 106, 152, 83, 240, 166, 54, 235, 32, 190, 12, 242, 164, 123, 189, 53, 194, 141, 104, 43, 202, 110, 4, 168, 119, 245, 232, 179, 178, 198, 1, 224, 87, 86, 160, 31, 19, 140, 233, 102, 191, 204, 4, 98, 138, 163, 191, 106, 24, 213, 47, 208, 82, 137, 132, 131, 16, 253, 84, 25, 144, 90, 159, 148, 16, 196, 84, 166, 61, 160, 101, 229, 227, 93, 118, 59, 87, 66, 16, 128, 59, 96, 131, 250, 20, 184, 150, 205, 91, 227, 201, 62, 35, 79, 180, 172, 173, 85, 197, 106, 153, 238, 229, 60, 204, 65, 193, 230, 94, 101, 177, 134, 6, 165, 53, 171, 142, 208, 155, 2, 11, 4, 202, 127, 54, 17, 142, 117, 227, 121, 128, 204, 192, 147, 147, 92, 189, 5, 224, 148, 72, 18, 83, 101, 126, 124, 228, 153, 242, 123, 229, 247, 92, 221, 6, 73, 227, 250, 87, 167, 194, 129, 187, 73, 38, 185, 109, 217, 240, 193, 88, 50, 178, 180, 151, 54, 197, 187, 137, 190, 166, 233, 1, 103, 204, 88, 31, 127, 185, 29, 65, 1, 29, 254, 223, 14, 83, 167, 215, 114, 248, 30, 173, 89, 173, 187, 69, 5, 105, 117, 15, 106, 94, 173, 63, 227, 25, 230, 190, 136, 168, 177, 175, 107, 91, 126, 254, 34, 188, 25, 118, 48, 12, 226, 130, 153, 162, 57, 47, 181, 212, 79, 160, 97, 64, 157, 246, 90, 53, 43, 149, 76, 102, 15, 195, 107, 58, 242, 84, 172, 29, 81, 198, 113, 81, 251, 138, 182, 154, 111, 30, 171, 129, 56, 17, 45, 214, 153, 112, 117, 203, 174, 40, 38, 234, 236, 32, 4, 112, 225, 26, 187, 195, 246, 252, 9, 218, 69, 160, 223, 178, 54, 148, 81, 8, 134, 151, 75, 248, 63, 224, 240, 48, 75, 250, 221, 85, 46, 100, 50, 3, 70, 64, 102, 111, 160, 155, 233, 59, 147, 184, 57, 61, 6, 126, 79, 176, 16, 185, 94, 166, 33, 135, 78, 42, 75, 140, 208, 140, 44, 153, 187, 64, 103, 119, 160, 236, 16, 239, 74, 218, 219, 212, 207, 110, 53, 30, 76, 248, 40, 111, 98, 44, 20, 113, 204, 233, 109, 135, 96, 107, 39, 163, 203, 125, 45, 157, 152, 71, 239, 175, 174, 159, 147, 80, 111, 93, 38, 253, 228, 154, 225, 181, 101, 12, 241, 127, 65, 49, 189, 5, 85, 151, 237, 213, 143, 14, 104, 138, 54, 52, 27, 4, 132, 67, 35, 156, 86, 157, 73, 16, 229, 222, 245, 110, 79, 165, 179, 56, 179, 53, 218, 229, 100, 58, 87, 149, 48, 231, 64, 63, 115, 67, 3, 172, 6, 186, 115, 154, 60, 53, 214, 152, 149, 89, 234, 37, 143, 82, 255, 64, 28, 183, 93, 112, 39, 70, 185, 57, 0, 199, 9, 61, 175, 219, 41, 76, 37, 176, 82, 125, 65, 53, 160, 214, 105, 62, 153, 244, 222, 96, 205, 6, 178, 85, 41, 240, 113, 0, 96, 149, 38, 3, 195, 18, 152, 41, 246, 3, 103, 29, 110, 134, 30, 101, 75, 46, 103, 199, 184, 20, 230, 8, 55, 120, 4, 229, 168, 35, 43, 7, 28, 161, 143, 87, 27, 87, 79, 255, 186, 44, 195, 158, 155, 181, 119, 81, 172, 217, 107, 95, 98, 55, 243, 186, 66, 105, 48, 224, 123, 232, 84, 156, 20, 10, 156, 208, 204, 52, 34, 228, 136, 97, 242, 200, 246, 211, 67, 202, 40, 241, 91, 92, 253, 9, 54, 72, 131, 221, 106, 178, 32, 44, 182, 4, 225, 193, 37, 20, 249, 249, 231, 10, 206, 18, 71, 254, 221, 187, 172, 88, 204, 6, 127, 138, 102, 7, 208, 75, 147, 219, 199, 177, 79, 36, 170, 101, 207, 177, 109, 95, 143, 217, 41, 199, 80, 183, 201, 2, 254, 12, 55, 23, 198, 14, 255, 69, 245, 138, 155, 129, 227, 167, 168, 130, 156, 135, 14, 96, 93, 48, 99, 143, 107, 126, 92, 117, 143, 112, 108, 193, 228, 84, 13, 41, 186, 27, 172, 92, 201, 149, 116, 19, 112, 197, 116, 209, 128, 102, 1, 55, 152, 177, 28, 37, 34, 50, 83, 41, 199, 74, 178, 59, 111, 67, 118, 35, 252, 36, 33, 87, 28, 170, 17, 215, 47, 90, 154, 124, 137, 15, 14, 211, 59, 75, 59, 30, 77, 0, 49, 37, 225, 191, 87, 101, 127, 214, 227, 160, 99, 174, 234, 82, 148, 235, 16, 241, 219, 147, 170, 127, 221, 250, 116, 39, 218, 156, 72, 227, 172, 55, 0, 79, 188, 76, 51, 222, 232, 24, 36, 62, 94, 154, 3, 61, 230, 146, 114, 253, 0, 128, 58, 253, 90, 72, 211, 242, 38, 39, 133, 153, 161, 119, 105, 195, 152, 225, 208, 105, 140, 80, 217, 186, 196, 157, 21, 116, 230, 116, 139, 25, 159, 143, 118, 128, 77, 201, 238, 247, 228, 15, 168, 4, 133, 148, 21, 148, 12, 44, 241, 7, 115, 17, 129, 176, 202, 46, 130, 122, 129, 235, 141, 223, 85, 21, 199, 65, 181, 169, 52, 174, 161, 153, 62, 25, 164, 115, 213, 89, 138, 199, 103, 79, 200, 165, 135, 249, 244, 27, 209, 178, 240, 129, 211, 61, 9, 111, 157, 147, 119, 36, 119, 255, 110, 130, 84, 49, 210, 225, 247, 100, 26, 121, 127, 163, 160, 26, 79, 99, 24, 77, 65, 32, 178, 109, 36, 27, 253, 173, 110, 183, 11, 14, 211, 57, 130, 254, 124, 104, 165, 219, 31, 70, 97, 14, 194, 39, 61, 26, 141, 125, 228, 126, 194, 184, 101, 160, 204, 106, 128, 144, 106, 103, 171, 18, 246, 129, 220, 85, 172, 151, 123, 5, 73, 155, 192, 175, 91, 157, 239, 61, 237, 116, 170, 65, 233, 56, 19, 49, 114, 168, 190, 3, 214, 53, 250, 90, 213, 244, 88, 101, 30, 229, 248, 124, 15, 71, 141, 27, 172, 235, 21, 129, 211, 72, 61, 172, 112, 170, 128, 135, 96, 196, 221, 255, 27, 176, 105, 188, 183, 121, 33, 37, 149, 53, 131, 226, 233, 29, 167, 234, 218, 109, 53, 185, 152, 36, 248, 53, 61, 235, 78, 21, 201, 214, 210, 163, 12, 251, 187, 45, 188, 137, 126, 127, 237, 92, 234, 91, 240, 225, 38, 194, 57, 213, 251, 237, 171, 30, 99, 52, 14, 49, 84, 101, 252, 237, 7, 166, 122, 114, 32, 107, 32, 207, 239, 136, 168, 178, 12, 11, 241, 233, 230, 146, 132, 18, 83, 233, 41, 172, 17, 6, 161, 42, 113, 87, 40, 255, 185, 1, 146, 128, 5, 240, 126, 131, 71, 42, 54, 124, 205, 2, 122, 71, 30, 222, 229, 40, 134, 142, 102, 97, 239, 151, 177, 1, 230, 231, 49, 123, 219, 28, 129, 91, 152, 112, 13, 154, 81, 197, 226, 255, 112, 158, 178, 177, 55, 181, 108, 138, 185, 245, 29, 186, 21, 73, 188, 209, 154, 200, 89, 116, 235, 198, 144, 36, 87, 248, 22, 7, 200, 122, 7, 148, 44, 42, 87, 140, 238, 204, 95, 231, 252, 0, 136, 0, 22, 39, 70, 123, 125, 165, 113, 227, 172, 146, 163, 128, 158, 36, 52, 91, 19, 36, 245, 27, 150, 138, 141, 11, 67, 239, 224, 65, 24, 116, 101, 7, 39, 46, 142, 172, 164, 243, 148, 0, 33, 226, 59, 47, 203, 137, 156, 241, 66, 250, 157, 30, 204, 101, 143, 134, 98, 238, 155, 226, 25, 184, 136, 219, 89, 100, 193, 11, 143, 71, 139, 243, 230, 151, 0, 249, 1, 78, 26, 32, 93, 104, 157, 67, 97, 164, 248, 86, 124, 146, 93, 74, 222, 228, 167, 55, 53, 100, 135, 216, 109, 13, 64, 37, 106, 177, 200, 200, 182, 92, 251, 69, 31, 243, 89, 80, 198, 14, 132, 203, 72, 103, 28, 104, 217, 24, 97, 223, 113, 11, 29, 178, 191, 210, 46, 162, 255, 68, 99, 8, 237, 213, 162, 152, 193, 183, 121, 203, 19, 108, 182, 29, 86, 26, 192, 103, 220, 103, 205, 154, 179, 197, 9, 22, 73, 127, 175, 146, 38, 119, 210, 0, 24, 180, 21, 245, 215, 204, 91, 186, 119, 138, 183, 239, 15, 155, 231, 248, 133, 39, 24, 101, 144, 236, 10, 230, 54, 174, 227, 73, 21, 110, 10, 160, 241, 232, 131, 14, 212, 127, 232, 59, 122, 65, 146, 54, 163, 9, 189, 190, 121, 88, 170, 62, 194, 14, 204, 152, 245, 38, 131, 37, 91, 81, 72, 114, 29, 115, 239, 182, 56, 44, 156, 159, 177, 180, 82, 160, 93, 97, 86, 183, 236, 50, 95, 85, 39, 71, 181, 225, 152, 143, 63, 123, 117, 34, 44, 109, 160, 166, 229, 240, 91, 138, 102, 54, 180, 173, 44, 50, 80, 42, 124, 7, 50, 124, 211, 239, 21, 94, 197, 185, 239, 213, 107, 142, 64, 95, 124, 125, 17, 180, 97, 189, 101, 52, 48, 19, 112, 12, 70, 9, 212, 177, 54, 118, 66, 84, 147, 236, 248, 26, 124, 95, 103, 135, 254, 124, 49, 112, 186, 99, 120, 90, 8, 194, 191, 88, 57, 242, 65, 61, 10, 104, 246, 197, 252, 19, 159, 58, 194, 75, 173, 242, 103, 8, 115, 84, 69, 238, 149, 26, 15, 159, 182, 141, 132, 119, 70, 29, 53, 20, 143, 46, 163, 204, 6, 236, 59, 45, 185, 172, 89, 119, 83, 38, 144, 36, 222, 96, 151, 26, 99, 195, 163, 170, 133, 92, 159, 214, 53, 150, 116, 90, 176, 69, 145, 130, 15, 172, 140, 217, 215, 101, 163, 115, 161, 65, 101, 8, 7, 183, 113, 213, 134, 58, 175, 130, 251, 143, 173, 248, 168, 135, 60, 159, 30, 194, 68, 208, 119, 120, 2, 40, 178, 227, 247, 161, 77, 47, 136, 46, 244, 163, 72, 65, 158, 25, 225, 195, 61, 132, 182, 204, 177, 186, 200, 81, 2, 65, 105, 212, 72, 94, 203, 232, 217, 182, 123, 251, 228, 160, 1, 161, 204, 123, 20, 37, 1, 77, 208, 179, 45, 149, 181, 122, 102, 190, 123, 213, 164, 231, 41, 216, 130, 234, 248, 208, 251, 252, 220, 84, 209, 67, 47, 61, 220, 5, 142, 162, 26, 236, 121, 142, 248, 132, 255, 65, 122, 203, 196, 102, 191, 187, 2, 195, 127, 255, 193, 92, 49, 91, 186, 154, 39, 156, 29, 211, 172, 49, 104, 245, 114, 153, 223, 211, 199, 249, 35, 130, 160, 128, 0, 152, 176, 183, 20, 236, 113, 193, 108, 26, 255, 11, 237, 102, 133, 245, 94, 115, 114, 10, 89, 229, 214, 221, 99, 149, 30, 99, 37, 246, 10, 26, 26, 39, 92, 123, 170, 73, 211, 127, 227, 54, 30, 86, 133, 159, 112, 225, 91, 148, 100, 174, 149, 75, 143, 14, 140, 20, 44, 64, 212, 5, 243, 8, 116, 63, 30, 97, 42, 123, 20, 73, 212, 85, 207, 83, 122, 27, 251, 233, 84, 10, 17, 236, 232, 83, 200, 127, 119, 143, 163, 204, 220, 167, 59, 231, 20, 106, 186, 222, 191, 8, 40, 234, 21, 25, 180, 13, 116, 250, 152, 224, 174, 75, 3, 205, 38, 173, 215, 236, 151, 185, 121, 254, 244, 154, 239, 17, 53, 106, 164, 61, 49, 116, 216, 118, 94, 150, 35, 181, 26, 238, 66, 49, 211, 221, 132, 146, 166, 115, 39, 136, 36, 205, 230, 179, 31, 197, 51, 148, 165, 109, 38, 70, 37, 148, 52, 44, 209, 250, 98, 58, 246, 225, 103, 198, 101, 26, 25, 196, 207, 8, 166, 21, 88, 252, 175, 253, 10, 88, 107, 157, 19, 225, 61, 12, 246, 221, 37, 239, 186, 167, 137, 142, 135, 222, 128, 174, 62, 95, 216, 38, 141, 157, 45, 232, 97, 217, 173, 203, 234, 116, 129, 69, 206, 189, 94, 221, 12, 54, 139, 186, 247, 184, 16, 200, 121, 244, 104, 8, 7, 35, 111, 47, 188, 10, 140, 92, 73, 143, 206, 203, 72, 122, 184, 20, 102, 197, 130, 64, 150, 63, 96, 239, 8, 132, 111, 217, 84, 91, 198, 32, 43, 100, 138, 241, 15, 160, 42, 190, 253, 193, 184, 164, 124, 29, 210, 96, 67, 224, 221, 182, 29, 218, 129, 149, 29, 128, 174, 98, 88, 88, 125, 56, 40, 255, 120, 5, 0, 87, 174, 42, 150, 90, 112, 201, 183, 169, 19, 57, 195, 191, 12, 58, 244, 235, 132, 25, 145, 72, 146, 214, 8, 125, 100, 135, 12, 5, 102, 97, 248, 174, 24, 159, 90, 33, 43, 187, 6, 61, 212, 241, 225, 190, 219, 252, 197, 123, 129, 164, 108, 123, 55, 230, 4, 153, 166, 105, 234, 15, 85, 216, 23, 56, 32, 3, 41, 110, 68, 146, 172, 133, 202, 98, 41, 7, 47, 152, 35, 255, 168, 106, 241, 226, 222, 77, 244, 52, 185, 65, 252, 227, 32, 66, 38, 11, 172, 60, 28, 28, 103, 84, 1, 1, 205, 182, 190, 28, 189, 102, 253, 43, 1, 191, 148, 116, 10, 227, 18, 81, 93, 80, 239, 157, 232, 215, 180, 163, 165, 161, 109, 177, 71, 150, 244, 144, 208, 160, 110, 22, 174, 60, 206, 43, 103, 121, 55, 103, 114, 115, 173, 238, 13, 10, 227, 251, 41, 176, 216, 158, 229, 216, 55, 234, 128, 128, 20, 167, 106, 181, 86, 163, 130, 215, 110, 149, 191, 10, 227, 215, 8, 214, 154, 178, 181, 15, 19, 0, 247, 250, 97, 74, 43, 157, 55, 94, 174, 41, 41, 9, 199, 97, 20, 91, 32, 18, 10, 43, 98, 240, 247, 203, 20, 250, 117, 160, 44, 229, 202, 187, 64, 54, 124, 15, 184, 169, 129, 27, 160, 240, 26, 61, 255, 60, 166, 60, 144, 209, 84, 55, 187, 186, 168, 13, 124, 125, 29, 17, 100, 249, 227, 62, 205, 78, 179, 163, 168, 139, 168, 21, 38, 83, 239, 151, 74, 43, 66, 2, 92, 72, 71, 94, 216, 134, 238, 20, 45, 158, 213, 164, 73, 57, 80, 47, 198, 184, 130, 223, 227, 71, 132, 133, 235, 177, 85, 174, 142, 124, 172, 200, 54, 229, 40, 126, 60, 76, 92, 216, 153, 56, 241, 174, 66, 141, 90, 226, 3, 30, 68, 234, 71, 187, 163, 112, 146, 255, 22, 143, 170, 204, 3, 127, 179, 81, 139, 160, 37, 77, 246, 128, 220, 196, 158, 153, 73, 177, 65, 199, 119, 29, 197, 144, 130, 248, 206, 155, 253, 108, 213, 124, 7, 223, 221, 162, 146, 134, 242, 65, 99, 162, 107, 120, 247, 214, 207, 96, 150, 169, 131, 208, 218, 221, 28, 24, 112, 208, 23, 1, 130, 142, 232, 56, 104, 45, 33, 158, 95, 255, 123, 31, 74, 76, 120, 178, 155, 213, 6, 195, 164, 8, 8, 69, 241, 197, 127, 83, 169, 21, 167, 19, 94, 143, 252, 33, 159, 248, 241, 170, 153, 147, 1, 149, 199, 201, 131, 170, 79, 236, 212, 209, 143, 107, 98, 24, 123, 56, 33, 193, 85, 247, 64, 225, 135, 210, 78, 145, 57, 16, 145, 71, 170, 20, 133, 87, 235, 4, 166, 239, 100, 82, 235, 81, 50, 223, 9, 193, 52, 49, 86, 129, 190, 196, 82, 165, 107, 63, 115, 161, 98, 33, 20, 193, 29, 42, 151, 205, 252, 124, 72, 245, 48, 181, 67, 7, 13, 21, 127, 59, 226, 188, 144, 129, 112, 244, 192, 121, 213, 80, 42, 196, 1, 13, 107, 108, 78, 0, 40, 121, 225, 148, 237, 234, 209, 216, 238, 9, 147, 226, 254, 96, 89, 212, 72, 193, 106, 75, 135, 74, 227, 67, 255, 92, 191, 81, 188, 124, 226, 149, 152, 142, 15, 159, 195, 238, 114, 55, 255, 166, 157, 230, 59, 148, 170, 166, 151, 65, 213, 104, 253, 253, 112, 150, 82, 147, 137, 27, 214, 100, 247, 65, 81, 92, 47, 86, 217, 7, 45, 120, 81, 130, 31, 236, 243, 76, 78, 3, 45, 105, 172, 220, 71, 48, 220, 94, 196, 249, 163, 193, 133, 50, 236, 205, 20, 55, 2, 63, 14, 127, 69, 113, 212, 204, 12, 58, 79, 89, 86, 29, 61, 199, 201, 64, 149, 6, 144, 182, 150, 129, 31, 18, 167, 120, 248, 82, 107, 25, 143, 128, 27, 161, 28, 25, 153, 183, 217, 238, 78, 186, 106, 92, 27, 202, 219, 165, 96, 0, 216, 234, 169, 73, 101, 39, 182, 113, 217, 240, 170, 116, 172, 221, 250, 233, 48, 49, 242, 83, 227, 92, 181, 184, 72, 230, 180, 21, 15, 108, 135, 25, 38, 153, 25, 124, 227, 26, 149, 73, 236, 39, 211, 244, 149, 58, 183, 132, 26, 223, 219, 174, 144, 117, 233, 219, 165, 205, 157, 159, 222, 184, 52, 47, 241, 201, 123, 65, 24, 44, 55, 215, 177, 168, 250, 179, 115, 190, 227, 123, 158, 163, 179, 224, 69, 196, 66, 207, 254, 243, 101, 221, 193, 140, 250, 4, 28, 222, 52, 96, 138, 160, 33, 218, 64, 118, 214, 234, 201, 152, 148, 91, 178, 111, 107, 144, 142, 6, 182, 102, 72, 188, 34, 213, 181, 26, 223, 58, 255, 103, 81, 17, 47, 169, 11, 245, 224, 123, 148, 215, 237, 186, 107, 75, 152, 90, 202, 166, 22, 149, 197, 5, 246, 238, 78, 76, 229, 106, 199, 94, 127, 195, 0, 45, 82, 6, 159, 103, 96, 138, 231, 71, 46, 107, 59, 216, 39, 43, 12, 221, 27, 214, 56, 155, 145, 66, 187, 169, 250, 235, 78, 211, 179, 239, 183, 198, 163, 93, 5, 196, 24, 174, 143, 225, 106, 139, 89, 98, 13, 127, 207, 184, 194, 30, 1, 165, 198, 169, 8, 197, 118, 86, 163, 221, 138, 23, 209, 61, 116, 79, 99, 233, 43, 130, 60, 244, 85, 229, 243, 172, 123, 148, 200, 120, 192, 127, 211, 52, 11, 159, 41, 95, 212, 230, 188, 169, 156, 137, 29, 212, 12, 148, 168, 148, 133, 243, 44, 241, 139, 127, 24, 246, 220, 227, 125, 209, 97, 60, 52, 162, 192, 146, 49, 161, 92, 138, 112, 189, 128, 59, 126, 125, 46, 207, 60, 79, 231, 174, 152, 209, 68, 223, 205, 2, 38, 14, 91, 116, 159, 255, 28, 27, 178, 248, 164, 104, 158, 79, 69, 214, 234, 157, 12, 75, 163, 83, 253, 245, 202, 61, 213, 176, 6, 197, 230, 29, 208, 166, 253, 194, 254, 235, 29, 141, 241, 70, 249, 15, 62, 0, 148, 163, 135, 52, 122, 40, 96, 87, 31, 179, 152, 51, 216, 133, 184, 122, 198, 203, 60, 115, 218, 191, 193, 16, 178, 25, 148, 252, 112, 104, 103, 252, 36, 92, 221, 28, 179, 43, 199, 198, 151, 128, 100, 252, 217, 161, 249, 34, 201, 172, 118, 52, 180, 252, 104, 7, 223, 44, 116, 102, 212, 21, 40, 224, 184, 55, 163, 210, 21, 207, 161, 239, 51, 54, 155, 41, 133, 18, 67, 48, 3, 165, 130, 251, 4, 79, 214, 57, 72, 130, 157, 212, 144], TX = [0, 1, 3, 4, 6, 7, 9, 10, 12, 13, 15, 16, 18, 19, 21, 22, 24, 26, 29, 31, 34, 36, 39, 41, 44, 46, 49, 51, 54, 56, 59, 61, 64, 65, 66, 67, 68, 69, 70, 72, 73, 74, 75, 76, 77, 79, 80, 81, 82, 83, 84, 85, 87, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99, 101, 102, 103, 104, 105, 106, 107, 109, 110, 111, 112, 113, 114, 116, 117, 118, 119, 120, 121, 123, 124, 125, 126, 127, 128, 129, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 145, 146, 147, 148, 149, 150, 151, 153, 154, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 168, 169, 170, 171, 172, 173, 175, 176, 177, 178, 179, 180, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 195, 197, 198, 199, 200, 201, 202, 204, 205, 206, 207, 208, 209, 210, 212, 213, 214, 215, 216, 217, 219, 220, 221, 222, 223, 224, 226, 226, 226, 227, 227, 227, 228, 228, 228, 229, 229, 229, 230, 230, 231, 231, 231, 232, 232, 232, 233, 233, 233, 234, 234, 235, 235, 235, 236, 236, 236, 237, 237, 237, 238, 238, 239, 239, 239, 240, 240, 240, 241, 241, 241, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255], RX = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 35, 36, 37, 39, 40, 42, 43, 44, 46, 47, 49, 50, 51, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 66, 67, 68, 69, 71, 72, 73, 74, 76, 77, 78, 79, 81, 82, 83, 84, 86, 87, 88, 90, 91, 92, 93, 95, 96, 97, 98, 100, 101, 102, 103, 105, 106, 107, 108, 110, 111, 112, 113, 115, 116, 117, 118, 120, 121, 122, 124, 125, 126, 127, 129, 130, 131, 132, 134, 135, 136, 137, 139, 140, 141, 142, 144, 145, 146, 147, 149, 150, 151, 152, 154, 155, 156, 158, 159, 160, 161, 163, 164, 165, 166, 168, 169, 170, 171, 173, 174, 175, 176, 178, 179, 180, 181, 183, 184, 185, 186, 188, 189, 190, 192, 193, 194, 195, 197, 198, 199, 200, 202, 203, 204, 205, 207, 208, 209, 210, 212, 213, 214, 215, 217, 218, 219, 220, 222, 223, 224, 226, 226, 226, 227, 227, 228, 228, 229, 229, 230, 230, 231, 231, 232, 232, 233, 233, 234, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238, 239, 239, 240, 240, 241, 241, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255], yX = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 69, 70, 72, 73, 74, 76, 77, 78, 80, 81, 83, 84, 85, 87, 88, 89, 91, 92, 94, 95, 96, 98, 99, 100, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 116, 117, 118, 120, 121, 122, 124, 125, 127, 128, 129, 131, 132, 133, 135, 136, 138, 139, 140, 142, 143, 144, 146, 147, 149, 150, 151, 153, 154, 155, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 192, 193, 193, 194, 195, 195, 196, 197, 197, 198, 199, 199, 200, 201, 201, 202, 203, 203, 204, 205, 205, 206, 207, 207, 208, 209, 209, 210, 211, 211, 212, 213, 213, 214, 215, 215, 216, 217, 217, 218, 219, 219, 220, 221, 221, 222, 223, 223, 224, 225, 225, 226, 227, 227, 228, 229, 229, 230, 231, 231, 232, 233, 233, 234, 235, 235, 236, 237, 237, 238, 239, 239, 240, 241, 241, 242, 243, 243, 244, 245, 245, 246, 247, 247, 248, 249, 249, 250, 251, 251, 252, 253, 253, 254, 255];
      class wX extends EX {
        constructor(e3, t3, i3, r3) {
          super(e3, vX, i3, r3), MN(this, "inputTexture", void 0), MN(this, "lightLevel", 0.1), MN(this, "rednessLevel", 0.5), MN(this, "mskin_he_max", 175 / 180 * 3.141593), MN(this, "mskin_he_min", 115 / 180 * 3.141593), MN(this, "mskin_hc_max", 173 / 180 * 3.141593), MN(this, "mskin_hc_min", 116 / 180 * 3.141593), MN(this, "mskin_hc_axis", 2.04203545), MN(this, "mfacts_rotate_c", 0), MN(this, "mfacts_rotate_le", 0), MN(this, "mfacts_rotate_ge", 0), MN(this, "tab_addr", null), MN(this, "lutTextures", []), this.inputTexture = t3, this.init();
        }
        setUniforms() {
          const e3 = this.gl.getUniformLocation(this.program, "u_flipY"), t3 = this.gl.getUniformLocation(this.program, "u_denoiseLevel");
          this.gl.uniform1f(t3, this.denoiseLevel), this.gl.uniform1f(e3, 1);
          const i3 = this.gl.getUniformLocation(this.program, "light");
          this.gl.uniform1f(i3, this.lightLevel);
          const r3 = this.gl.getUniformLocation(this.program, "redness");
          this.gl.uniform1f(r3, this.rednessLevel);
          const n3 = this.gl.getUniformLocation(this.program, "skin_he_max"), o3 = this.gl.getUniformLocation(this.program, "skin_he_min"), s3 = this.gl.getUniformLocation(this.program, "skin_hc_max"), a3 = this.gl.getUniformLocation(this.program, "skin_hc_min"), c3 = this.gl.getUniformLocation(this.program, "skin_hc_axis"), d3 = this.gl.getUniformLocation(this.program, "facts_rotate_c"), u3 = this.gl.getUniformLocation(this.program, "facts_rotate_le"), h3 = this.gl.getUniformLocation(this.program, "facts_rotate_ge");
          this.gl.uniform1f(n3, this.mskin_he_max), this.gl.uniform1f(o3, this.mskin_he_min), this.gl.uniform1f(s3, this.mskin_hc_max), this.gl.uniform1f(a3, this.mskin_hc_min), this.gl.uniform1f(c3, this.mskin_hc_axis), this.gl.uniform1f(d3, this.mfacts_rotate_c), this.gl.uniform1f(u3, this.mfacts_rotate_le), this.gl.uniform1f(h3, this.mfacts_rotate_ge);
          const A3 = this.gl.getUniformLocation(this.program, "u_originImage");
          this.gl.activeTexture(this.gl.TEXTURE2), this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture), this.gl.uniform1i(A3, 2);
          const l3 = ["lighten_lut"], p3 = [this.gl.TEXTURE3];
          for (let e4 = 0; e4 < l3.length; e4++) {
            const t4 = this.gl.getUniformLocation(this.program, l3[e4]);
            this.gl.activeTexture(p3[e4]), this.gl.bindTexture(this.gl.TEXTURE_2D, this.lutTextures[e4]), this.gl.uniform1i(t4, e4 + 3);
          }
        }
        setParameters(e3) {
          void 0 !== e3.denoiseLevel && (this.denoiseLevel = e3.denoiseLevel), void 0 !== e3.lightLevel && (this.lightLevel = e3.lightLevel), void 0 !== e3.rednessLevel && (this.rednessLevel = e3.rednessLevel, this.updateRedness(this.rednessLevel)), e3.lighteningContrastLevel && this.updateLut(e3.lighteningContrastLevel);
        }
        init() {
          this.tab_addr = new Uint8Array(RX);
          const e3 = [this.tab_addr], t3 = [256], i3 = [1];
          for (let r3 = 0; r3 < e3.length; r3++) {
            const n3 = this.gl.createTexture();
            if (!n3)
              throw new QD(xD.WEBGL_INTERNAL_ERROR, "create lut texture failed");
            this.gl.bindTexture(this.gl.TEXTURE_2D, n3), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, t3[r3], i3[r3], 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, e3[r3]), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.lutTextures.push(n3);
          }
        }
        updateRedness(e3) {
          const t3 = 3.141593;
          let i3, r3, n3 = e3, o3 = n3;
          n3 > 1 && (n3 = 1), n3 < 0 && (n3 = 0), o3 > 1 && (o3 = 1), o3 < 0 && (o3 = 0), this.mfacts_rotate_c = 0.8 * n3, o3 < 0.8 && (o3 = 0), this.mskin_he_max = 175 / 180 * t3, this.mskin_hc_max = 173 / 180 * t3, this.mskin_he_min = (115 - 4 * o3) / 180 * t3, this.mskin_hc_min = (116 - 4 * o3) / 180 * t3, this.mskin_hc_axis = (117 - 4 * o3) / 180 * t3, this.mskin_hc_axis < this.mskin_hc_min && (this.mskin_hc_axis = this.mskin_hc_min), this.mskin_hc_min < t3 / 2 && (this.mskin_hc_min = t3 / 2), this.mskin_hc_axis < t3 / 2 && (this.mskin_hc_axis = t3 / 2), this.mskin_he_min < t3 / 2 && (this.mskin_he_min = t3 / 2), this.mskin_hc_max > t3 && (this.mskin_hc_max = t3), this.mskin_hc_axis > t3 && (this.mskin_hc_axis = t3), this.mskin_he_max > t3 && (this.mskin_he_max = t3), i3 = this.mskin_he_max - this.mskin_hc_max, r3 = this.mskin_hc_max - this.mskin_hc_axis, this.mfacts_rotate_ge = i3 > 0.01 ? this.mfacts_rotate_c * r3 / i3 : this.mfacts_rotate_c, i3 = this.mskin_hc_min - this.mskin_he_min, r3 = this.mskin_hc_axis - this.mskin_hc_min, this.mfacts_rotate_le = i3 > 0.01 ? this.mfacts_rotate_c * r3 / i3 : this.mfacts_rotate_c;
        }
        updateLut(e3) {
          let t3 = null;
          if (0 === e3 && (t3 = RX), 1 === e3 && (t3 = yX), 2 === e3 && (t3 = TX), !t3)
            throw new QD(xD.WEBGL_INTERNAL_ERROR, "invalid ylut_table value:" + e3);
          this.tab_addr = new Uint8Array(t3);
          const i3 = [this.tab_addr], r3 = [256], n3 = [1];
          for (let e4 = 0; e4 < i3.length; e4++)
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.lutTextures[e4]), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, r3[e4], n3[e4], 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, i3[e4]);
        }
      }
      class bX {
        constructor() {
          MN(this, "gl", null), MN(this, "canvas", null), MN(this, "programs", []), MN(this, "commonProgram", null), MN(this, "inputTexture", null), MN(this, "outputTextures", []), MN(this, "fbos", []), MN(this, "originalFrameWidth", 0), MN(this, "originalFrameHeight", 0), MN(this, "enableBeauty", false), MN(this, "denoiseLevel", 5), MN(this, "lightLevel", 0.35), MN(this, "rednessLevel", 0.5), MN(this, "lighteningContrastLevel", 1);
        }
        setEnableBeauty(e3) {
          this.enableBeauty = !!e3;
        }
        init(e3, t3, i3) {
          if (!wB().supportWebGL)
            throw new QD(xD.NOT_SUPPORTED, "your browser is not support webGL");
          if (this.gl = i3.getContext("webgl"), !this.gl)
            throw new QD(xD.WEBGL_INTERNAL_ERROR, "can not get webgl context");
          if (this.initGL(e3, t3), !this.inputTexture)
            throw new QD(xD.WEBGL_INTERNAL_ERROR, "can not find input texture");
          this.canvas = i3, this.programs.push(new gX(this.gl)), this.programs.push(new mX(this.gl, e3, t3)), this.programs.push(new _X(this.gl, e3, t3)), this.programs.push(new SX(this.gl, e3, t3)), this.programs.push(new wX(this.gl, this.inputTexture, e3, t3)), this.commonProgram = this.programs[0].program, this.setDenoiseLevel(this.denoiseLevel), this.setLightLevel(this.lightLevel), this.setRednessLevel(this.rednessLevel), this.setContrastLevel(this.lighteningContrastLevel);
        }
        render(e3) {
          if (!this.gl || !this.commonProgram || !this.canvas)
            return void JD.warning("video effect manager is not init!");
          let t3 = 0;
          if (this.originalFrameHeight === e3.videoWidth && this.originalFrameWidth === e3.videoHeight)
            t3 = 2;
          else if (this.originalFrameHeight !== e3.videoHeight || this.originalFrameWidth !== e3.videoWidth) {
            if (JD.debug("beauty effect: resolution changed ".concat(this.originalFrameWidth, "x").concat(this.originalFrameHeight, " -> ").concat(e3.videoWidth, "x").concat(e3.videoHeight)), 0 === e3.videoHeight || 0 === e3.videoWidth)
              return void JD.debug("beauty effect: skip 0 resolution frame");
            this.canvas.width = e3.videoWidth, this.canvas.height = e3.videoHeight, e3.setAttribute("width", e3.videoWidth.toString()), e3.setAttribute("height", e3.videoHeight.toString()), this.release(), this.init(e3.videoWidth, e3.videoHeight, this.canvas);
          }
          this.gl.viewport(0, 0, e3.videoWidth, e3.videoHeight), this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, e3);
          const i3 = this.enableBeauty ? this.programs.length - 1 : 0;
          for (let e4 = 0; e4 <= i3; e4++) {
            const i4 = this.programs[e4].program;
            this.gl.useProgram(i4);
            const r4 = this.gl.getUniformLocation(i4, "u_image");
            this.programs[e4].setUniforms(), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbos[t3 + e4 % 2]), this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.gl.drawArrays(this.gl.TRIANGLES, 0, 6), this.gl.activeTexture(this.gl.TEXTURE0), this.gl.bindTexture(this.gl.TEXTURE_2D, this.outputTextures[t3 + e4 % 2]), this.gl.uniform1i(r4, 0);
          }
          this.gl.useProgram(this.commonProgram);
          const r3 = this.gl.getUniformLocation(this.commonProgram, "u_flipY");
          this.gl.uniform1f(r3, -1), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null), this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
        }
        setDenoiseLevel(e3) {
          this.programs.forEach((t3) => {
            t3 instanceof EX && t3.setParameters({ denoiseLevel: e3 });
          }), this.denoiseLevel = e3;
        }
        setLightLevel(e3) {
          this.programs.forEach((t3) => {
            t3 instanceof EX && t3.setParameters({ lightLevel: e3 });
          }), this.lightLevel = e3;
        }
        setRednessLevel(e3) {
          this.programs.forEach((t3) => {
            t3 instanceof EX && t3.setParameters({ rednessLevel: e3 });
          }), this.rednessLevel = e3;
        }
        setContrastLevel(e3) {
          this.programs.forEach((t3) => {
            t3 instanceof EX && t3.setParameters({ lighteningContrastLevel: e3 });
          }), this.lighteningContrastLevel = e3;
        }
        setSize(e3, t3) {
          this.programs.forEach((i3) => {
            i3 instanceof EX && i3.setSize(e3, t3);
          });
        }
        release() {
          this.gl = null, this.commonProgram = null, this.inputTexture = null, this.programs = [], this.outputTextures = [], this.fbos = [];
        }
        initGL(e3, t3) {
          if (!this.gl)
            throw new QD(xD.WEBGL_INTERNAL_ERROR, "can not find webgl context");
          this.inputTexture = this.gl.createTexture(), this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
          for (let i3 = 0; i3 < 4; i3++) {
            const r3 = this.gl.createTexture();
            if (!r3)
              throw new QD(xD.WEBGL_INTERNAL_ERROR, "create texture failed");
            this.gl.bindTexture(this.gl.TEXTURE_2D, r3), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), i3 < 2 ? this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, e3, t3, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null) : this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, t3, e3, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
            const n3 = this.gl.createFramebuffer();
            if (!n3)
              throw new QD(xD.WEBGL_INTERNAL_ERROR, "create frame buffer failed");
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, n3), this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, r3, 0), this.outputTextures.push(r3), this.fbos.push(n3);
          }
          this.gl.viewport(0, 0, e3, t3), this.originalFrameWidth = e3, this.originalFrameHeight = t3;
        }
      }
      class NX {
        constructor() {
          MN(this, "targetFrameRate", 0), MN(this, "recordedFrameCount", 0), MN(this, "recordingTime", 2), MN(this, "recordID", void 0);
        }
        async startRecordBeautyEffectOutput(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4;
          if (this.recordID)
            throw new QD(xD.UNEXPECTED_ERROR, "another beauty effect recording is in progress");
          const i3 = mK(6, "");
          return this.recordID = i3, this.targetFrameRate = e3, this.recordedFrameCount = 0, this.recordingTime = t3, await EK(1e3 * this.recordingTime), this.recordID !== i3 ? (this.recordID = void 0, true) : (this.recordID = void 0, this.recordedFrameCount < this.targetFrameRate * this.recordingTime / 2 ? (JD.warning("detect beauty effect overload, current framerate", this.recordedFrameCount / 2), false) : (JD.debug("beauty effect current framerate", this.recordedFrameCount / 2), true));
        }
        stopRecordBeautyEffectOutput() {
          this.targetFrameRate = 0, this.recordedFrameCount = 0, this.recordID = void 0;
        }
        addFrame() {
          this.recordID && (this.recordedFrameCount += 1);
        }
      }
      class OX extends cX.exports.VideoProcessor {
        constructor() {
          super(), MN(this, "name", "BeautyProcessor"), MN(this, "fps", 15), MN(this, "canvas", void 0), MN(this, "video", void 0), MN(this, "manager", void 0), MN(this, "overloadDetector", new NX()), MN(this, "stopChromeBackgroundLoop", null), MN(this, "onOverload", void 0), MN(this, "stopLoop", void 0), MN(this, "lastRenderTime", 0), this.fps = 30, this.manager = new bX(), this._enabled = false;
        }
        async onEnableChange(e3) {
          this.manager.setEnableBeauty(e3), this.context && this.inputTrack && (e3 ? await this.startEffect(this.inputTrack, this.context) : await this.stopEffect(this.inputTrack, this.context));
        }
        async setBeautyEffectOptions(e3) {
          if (function(e4) {
            void 0 !== e4.smoothnessLevel && UL(e4.smoothnessLevel, "options.smoothnessLevel", 0, 1, false), void 0 !== e4.lighteningLevel && UL(e4.lighteningLevel, "options.lighteningLevel", 0, 1, false), void 0 !== e4.rednessLevel && UL(e4.rednessLevel, "options.rednessLevel", 0, 1, false), void 0 !== e4.lighteningContrastLevel && ML(e4.lighteningContrastLevel, "options.lighteningContrastLevel", [0, 1, 2]);
          }(e3), void 0 !== e3.smoothnessLevel) {
            const t3 = Math.max(0.1, 10 * e3.smoothnessLevel);
            this.manager.setDenoiseLevel(t3);
          }
          if (void 0 !== e3.lighteningLevel) {
            const t3 = Math.max(0.1, e3.lighteningLevel / 2);
            this.manager.setLightLevel(t3);
          }
          if (void 0 !== e3.rednessLevel) {
            const t3 = Math.max(0.01, e3.rednessLevel);
            this.manager.setRednessLevel(t3);
          }
          if (void 0 !== e3.lighteningContrastLevel) {
            const t3 = e3.lighteningContrastLevel;
            this.manager.setContrastLevel(t3);
          }
        }
        async onTrack(e3, t3) {
          var i3;
          this.video && this.enabled && (null === (i3 = this.stopLoop) || void 0 === i3 || i3.call(this), await this.stopEffect(e3, t3));
          await this.startEffect(e3, t3);
        }
        async startEffect(e3, t3) {
          if (!this.enabled)
            return;
          const i3 = oN(), r3 = await this.renderWithWebGL(e3);
          this.output(r3, t3), JD.info("start video effect, output:", this.outputTrack), this.overloadDetector.startRecordBeautyEffectOutput(this.fps).then((e4) => {
            e4 || this.onOverload && this.onOverload();
          });
          let n3 = false;
          this.stopLoop = () => {
            n3 = true;
          };
          const o3 = () => {
            this.enabled && !n3 && requestAnimationFrame(o3);
            const e4 = Date.now(), t4 = 1e3 / this.fps, i4 = this.lastRenderTime ? e4 - this.lastRenderTime : t4;
            i4 < t4 || (this.lastRenderTime = e4 - (i4 - t4), this.video && this.video.paused && this.video.play(), this.enabled && this.video && (this.manager.render(this.video), this.outputTrack && this.outputTrack.requestFrame && this.outputTrack.requestFrame(), this.overloadDetector.addFrame()));
          };
          requestAnimationFrame(o3), i3.name === tN.CHROME && document.addEventListener("visibilitychange", () => {
            document.hidden ? this.stopChromeBackgroundLoop = Nj(() => {
              this.enabled && this.video && this.manager.render(this.video), this.outputTrack && this.outputTrack.requestFrame && this.outputTrack.requestFrame(), this.overloadDetector.addFrame();
            }, this.fps) : this.stopChromeBackgroundLoop && (this.stopChromeBackgroundLoop(), this.stopChromeBackgroundLoop = null);
          }, false);
        }
        async renderWithWebGL(e3) {
          this.canvas && (this.canvas.remove(), this.canvas = void 0), this.video && (this.video.remove(), this.video = void 0), this.canvas = document.createElement("canvas"), this.video = document.createElement("video"), this.video.setAttribute("autoplay", ""), this.video.setAttribute("muted", ""), this.video.muted = true, this.video.setAttribute("playsinline", ""), this.video.setAttribute("style", "display:none"), this.video.srcObject = new MediaStream([e3]);
          const t3 = new l_((e4) => {
            const t4 = () => {
              this.video && this.video.removeEventListener("playing", t4), e4(void 0);
            };
            this.video && this.video.addEventListener("playing", t4);
          });
          this.video.play(), await t3;
          const i3 = e3.getSettings(), r3 = i3.width || this.video.videoWidth, n3 = i3.height || this.video.videoHeight;
          if (i3.frameRate && this.fps !== i3.frameRate && (this.fps = i3.frameRate, JD.debug("beauty video processor: set fps to", this.fps)), JD.debug("beauty video processor: width ".concat(r3, " height ").concat(n3)), !r3 || !n3)
            throw new QD(xD.BEAUTY_PROCESSOR_INTERNAL_ERROR, "can not get track resolution");
          this.canvas.width = r3, this.canvas.height = n3, this.video.setAttribute("width", r3.toString()), this.video.setAttribute("height", n3.toString()), this.manager.init(r3, n3, this.canvas);
          const o3 = wB();
          return this.canvas.captureStream(o3.supportRequestFrame ? 0 : this.fps).getVideoTracks()[0];
        }
        async stopEffect(e3, t3) {
          JD.info("stop video effect"), this.overloadDetector.stopRecordBeautyEffectOutput(), this.manager.release(), this.canvas && this.canvas.remove(), this.video && this.video.remove(), this.canvas = void 0, this.video = void 0, this.output(e3, t3);
        }
      }
      function DX(e3) {
        const t3 = {};
        if (e3.facingMode && (t3.facingMode = e3.facingMode), e3.cameraId && (t3.deviceId = { exact: e3.cameraId }), !e3.encoderConfig)
          return t3;
        const i3 = wP(e3.encoderConfig);
        return t3.width = i3.width, t3.height = i3.height, !RN() && i3.frameRate && (t3.frameRate = i3.frameRate), oN().name === tN.EDGE && "object" == typeof t3.frameRate && (t3.frameRate.max = 60), gN() && (t3.frameRate = { ideal: 30, max: 30 }), t3;
      }
      function PX(e3) {
        const t3 = {};
        e3.screenSourceType && (t3.mediaSource = e3.screenSourceType), e3.extensionId && lN() && (t3.extensionId = e3.extensionId), e3.electronScreenSourceId && (t3.sourceId = e3.electronScreenSourceId);
        const i3 = e3.encoderConfig ? bP(e3.encoderConfig) : null;
        return t3.mandatory = { chromeMediaSource: "desktop", maxWidth: i3 ? i3.width : void 0, maxHeight: i3 ? i3.height : void 0 }, i3 && i3.frameRate && ("number" == typeof i3.frameRate ? (t3.mandatory.maxFrameRate = i3.frameRate, t3.mandatory.minFrameRate = i3.frameRate) : (t3.mandatory.maxFrameRate = i3.frameRate.max || i3.frameRate.ideal || i3.frameRate.exact || void 0, t3.mandatory.minFrameRate = i3.frameRate.min || i3.frameRate.ideal || i3.frameRate.exact || void 0), t3.frameRate = i3.frameRate), i3 && i3.width && (t3.width = i3.width), i3 && i3.height && (t3.height = i3.height), t3;
      }
      function LX(e3) {
        const t3 = {};
        if (RN() || (void 0 !== e3.AGC && (t3.autoGainControl = e3.AGC), void 0 !== e3.AEC && (t3.echoCancellation = e3.AEC), void 0 !== e3.ANS && (t3.noiseSuppression = e3.ANS, lN() && e3.ANS && (t3.googHighpassFilter = e3.ANS))), e3.encoderConfig) {
          const i3 = DP(e3.encoderConfig);
          t3.channelCount = i3.stereo ? 2 : 1, t3.sampleRate = i3.sampleRate, t3.sampleSize = i3.sampleSize;
        }
        return e3.microphoneId && (t3.deviceId = { exact: e3.microphoneId }), wN() && (t3.sampleRate = void 0), t3;
      }
      var kX, BX;
      !function(e3) {
        e3.COVERED = "COVERED", e3.POSITION = "POSITION", e3.SIZE = "SIZE", e3.STYLE = "STYLE";
      }(kX || (kX = {})), function(e3) {
        e3.UNMOUNTED = "UNMOUNTED", e3.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT";
      }(BX || (BX = {}));
      var MX, UX, xX, QX, FX, VX, jX, GX, KX, HX, WX, YX, JX, qX, XX, zX, ZX, $X, ez, tz, iz, rz, nz, oz, sz, az, cz = new class {
        constructor() {
          MN(this, "_clientSize", null), MN(this, "getClientWidth", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), MN(this, "getClientHeight", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), MN(this, "getStyle", (e3) => window.getComputedStyle(e3, null)), MN(this, "checkCssVisibleProperty", (e3) => {
            let t3 = true;
            const i3 = this.getStyle(e3), { display: r3, visibility: n3, opacity: o3, filter: s3 } = i3;
            if (("none" === r3 || ["hidden", "collapse"].includes(n3) || Number(o3) < 0.1) && (t3 = false), !t3)
              return false;
            if (s3) {
              s3.split(" ").filter((e4) => {
                const t4 = e4.split("(")[0];
                return ["brightness", "blur", "opacity"].includes(t4);
              }).map((e4) => {
                const [t4, i4] = e4.split(/\(|\)/);
                return [t4, Number(i4.match(/^[0-9\.]+/))];
              }).forEach((e4) => {
                const [i4, r4] = e4;
                switch (i4) {
                  case "brightness":
                    (r4 < 0.1 || r4 > 3) && (t3 = false);
                    break;
                  case "blur":
                    r4 > 3 && (t3 = false);
                    break;
                  case "opacity":
                    r4 < 0.1 && (t3 = false);
                }
              });
            }
            return t3;
          }), MN(this, "checkPropertyUpToAllParentNodes", (e3, t3) => {
            let i3 = true, r3 = true;
            const n3 = (e4) => t3(e4);
            let o3 = e3;
            for (; o3 && r3; ) {
              n3(o3) || (i3 = false, r3 = false), o3 = o3.parentElement, o3 || (r3 = false);
            }
            return i3;
          }), MN(this, "checkActualCssVisibleIncludeInherit", (e3) => this.checkPropertyUpToAllParentNodes(e3, this.checkCssVisibleProperty)), MN(this, "getSizeAboutClient", (e3) => {
            const { width: t3, height: i3, left: r3, right: n3, top: o3, bottom: s3 } = e3.getBoundingClientRect(), a3 = this.getClientWidth(), c3 = this.getClientHeight();
            return { width: t3, height: i3, left: r3, right: n3, top: o3, bottom: s3, clientWidth: a3, clientHeight: c3, clientMin: Math.min(a3, c3) };
          }), MN(this, "checkActualSize", () => {
            const { width: e3, height: t3, clientMin: i3 } = this._clientSize;
            return this.checkSizeIsVisible(e3, t3, i3);
          }), MN(this, "elementFromPoint", (e3, t3) => document.elementFromPoint ? document.elementFromPoint(e3, t3) : null), MN(this, "checkCoverForAPoint", (e3, t3, i3) => {
            const r3 = this.elementFromPoint(e3, t3);
            return null !== r3 && r3 !== i3;
          }), MN(this, "getPointPositionList", () => {
            const { width: e3, height: t3, left: i3, top: r3 } = this._clientSize, n3 = e3 / 6, o3 = t3 / 6, s3 = [], a3 = 10 ** 6;
            for (let e4 = 0; e4 < 5; e4++)
              for (let t4 = 0; t4 < 5; t4++) {
                const c3 = (i3 * a3 + (0 === e4 ? 0.1 : 4 === e4 ? (n3 * e4 * a3 - 1e5) / a3 : n3 * e4) * a3) / a3, d3 = (r3 * a3 + (0 === t4 ? 0.1 : 4 === t4 ? (o3 * t4 * a3 - 1e5) / a3 : o3 * t4) * a3) / a3;
                s3.push({ x: c3, y: d3 });
              }
            return [...s3];
          }), MN(this, "checkElementCover", (e3) => this.getPointPositionList().map((t3) => this.checkCoverForAPoint(t3.x, t3.y, e3)).filter((e4) => !!e4).length > 6), MN(this, "checkSizeIsVisible", (e3, t3, i3) => (e3 > 50 || i3 / e3 <= 10) && (t3 > 50 || i3 / t3 <= 10)), MN(this, "checkSizeOfPartInClient", () => {
            const { left: e3, right: t3, top: i3, bottom: r3, clientHeight: n3, clientWidth: o3, clientMin: s3 } = this._clientSize;
            let a3, c3, d3, u3;
            if (e3 < 0)
              a3 = 0;
            else {
              if (!(e3 < o3))
                return false;
              a3 = e3;
            }
            if (t3 < 0)
              return false;
            if (c3 = t3 < o3 ? t3 : o3, i3 < 0)
              d3 = 0;
            else {
              if (!(i3 < n3))
                return false;
              d3 = i3;
            }
            if (r3 < 0)
              return false;
            u3 = r3 < n3 ? r3 : n3;
            const h3 = c3 - a3, A3 = u3 - d3;
            return this.checkSizeIsVisible(h3, A3, s3);
          }), MN(this, "returnHiddenResult", (e3) => (this._clientSize = null, { visible: false, reason: e3 })), MN(this, "checkOneElementVisible", (e3) => {
            if (e3 instanceof HTMLElement) {
              if (this.checkElementIsMountedOnDom(e3)) {
                if (this.checkActualCssVisibleIncludeInherit(e3)) {
                  if (this._clientSize = this.getSizeAboutClient(e3), this.checkElementCover(e3))
                    return this.returnHiddenResult(kX.COVERED);
                  {
                    const e4 = this.checkActualSize(), t3 = this.checkSizeOfPartInClient();
                    return e4 && !t3 ? this.returnHiddenResult(kX.POSITION) : e4 ? (this._clientSize = null, { visible: true }) : this.returnHiddenResult(kX.SIZE);
                  }
                }
                return this.returnHiddenResult(kX.STYLE);
              }
              return this.returnHiddenResult(BX.UNMOUNTED);
            }
            return this.returnHiddenResult(BX.INVALID_HTML_ELEMENT);
          }), MN(this, "checkElementIsMountedOnDom", (e3) => this.checkPropertyUpToAllParentNodes(e3, (e4) => "HTML" !== e4.nodeName.toUpperCase() ? null !== e4.parentElement : !!document.documentElement));
        }
      }();
      function dz(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function uz(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? dz(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : dz(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      let hz = (MX = mP("LocalVideoTrack", "getTrackId"), UX = Zj(), xX = mj("LocalVideoTrack", "_enabledMutex"), QX = lj({ className: "LocalVideoTrack" }), FX = Zj(), VX = mj("LocalVideoTrack", "_enabledMutex"), jX = lj({ className: "LocalVideoTrack" }), GX = Zj(), KX = Zj(), HX = Zj(), WX = Zj(), YX = Zj(), JX = Zj(), qX = Zj(), XX = Zj(), zX = Zj(), MX((VV(($X = class e3 extends Ij {
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== qL.PLAYING);
        }
        constructor(e4, t3, i3, r3, n3, o3) {
          super(e4, n3), MN(this, "trackMediaType", "video"), MN(this, "_player", void 0), MN(this, "_videoBeautyProcessor", void 0), MN(this, "_videoVisibleTimer", null), MN(this, "_previousVideoVisibleStatus", void 0), MN(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), MN(this, "_encoderConfig", void 0), MN(this, "_scalabiltyMode", { numSpatialLayers: 1, numTemporalLayers: 1 }), MN(this, "_optimizationMode", void 0), MN(this, "_videoHeight", void 0), MN(this, "_videoWidth", void 0), MN(this, "_forceBitrateLimit", void 0), MN(this, "_enabled", true), MN(this, "processorDestination", void 0), MN(this, "processorContext", void 0), this.updateMediaStreamTrackResolution(), this._encoderConfig = t3, this._scalabiltyMode = i3, this._optimizationMode = r3, this._hints = o3 || [], -1 === this._hints.indexOf($k.SCREEN_TRACK) && this.updateBitrateFromProfile(), this.processorContext = new FG(this.getTrackId(), "local"), this.processorDestination = new QG(this.processorContext), this.bindProcessorDestinationEvents();
        }
        play(e4) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          const i3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.LOCAL_VIDEO_TRACK_PLAY, options: [this.getTrackId(), "string" == typeof e4 ? e4 : "HTMLElement", t3] });
          if ("string" == typeof e4) {
            const t4 = document.getElementById(e4);
            t4 ? e4 = t4 : (JD.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e4, '" element, use document.body')), hP("warning", this, 'can not find "#'.concat(e4, '" element, use document.body')), e4 = document.body);
          }
          JD.debug("[".concat(this.getTrackId(), "] start video playback"), JSON.stringify(t3)), gP("debug", this, "play", t3);
          const r3 = uz(uz(uz({}, this._getDefaultPlayerConfig()), t3), {}, { trackId: this.getTrackId(), element: e4 });
          this._player ? this._player.updateConfig(r3) : (this._player = new sX(r3), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
            try {
              const e5 = this.getVideoElementVisibleStatus();
              this.emit(iB.VIDEO_ELEMENT_VISIBLE_STATUS, e5);
            } catch (e5) {
            }
          }, LP("CHECK_VIDEO_VISIBLE_INTERVAL")), i3.onSuccess();
        }
        stop() {
          const e4 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.LOCAL_VIDEO_TRACK_STOP, options: [this.getTrackId()] });
          if (!this._player)
            return e4.onSuccess();
          this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, JD.debug("[".concat(this.getTrackId(), "] stop video playback")), gP("debug", this, "stop"), e4.onSuccess();
        }
        async setEnabled(e4, t3) {
          if (!t3) {
            if (e4 === this._enabled)
              return;
            this.stateCheck("enabled", e4);
          }
          if (JD.info("[".concat(this.getTrackId(), "] start setEnabled"), e4), gP("info", this, "setEnabled", e4), !e4) {
            this._originMediaStreamTrack.enabled = false;
            try {
              await TK(this, Zk.NEED_DISABLE_TRACK, this);
            } catch (t4) {
              throw JD.error("[".concat(this.getTrackId(), "] setEnabled to false error"), t4.toString()), gP("error", this, "setEnabled", e4, t4.toString()), t4;
            }
            return t3 || (this._enabled = false), JD.info("[".concat(this.getTrackId(), "] setEnabled to false success")), void gP("info", this, "setEnabled", e4, "success");
          }
          this._originMediaStreamTrack.enabled = true;
          try {
            await TK(this, Zk.NEED_ENABLE_TRACK, this);
          } catch (t4) {
            throw JD.error("[".concat(this.getTrackId(), "] setEnabled to true error"), t4.toString()), gP("error", this, "setEnabled", e4, t4.toString()), t4;
          }
          JD.info("[".concat(this.getTrackId(), "] setEnabled to true success")), gP("info", this, "setEnabled", e4, "success"), t3 || (this._enabled = true);
        }
        async setMuted(e4) {
          e4 !== this._muted && (this.stateCheck("muted", e4), this._muted = e4, this._originMediaStreamTrack.enabled = !e4, JD.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e4)), gP("debug", this, "setMuted", e4), e4 ? await TK(this, Zk.NEED_MUTE_TRACK, this) : await TK(this, Zk.NEED_UNMUTE_TRACK, this));
        }
        getStats() {
          PK(() => {
            JD.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead"), hP("warning", this, "[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");
          }, "localVideoTrackGetStatsWarning");
          const e4 = RK(this, Zk.GET_STATS);
          return e4 || uz({}, Nk);
        }
        async setBeautyEffect(e4) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          const i3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.LOCAL_VIDEO_TRACK_BEAUTY, options: [this.getTrackId(), e4, t3] });
          if (e4 || this._videoBeautyProcessor) {
            if (dN() === eN.IOS || dN() === eN.ANDROID) {
              const e5 = new QD(xD.INVALID_OPERATION, "can not enable beauty effect on mobile device");
              throw i3.onError(e5), e5;
            }
            if (!this._enabled && e4) {
              const e5 = new QD(xD.TRACK_IS_DISABLED, "can not enable beauty effect when track is disabled");
              throw i3.onError(e5), e5;
            }
            if (JD.info("[".concat(this.getTrackId(), "] start setBeautyEffect"), e4, JSON.stringify(t3)), gP("info", this, "setBeautyEffect", [e4, t3]), this._videoBeautyProcessor || e4) {
              try {
                if (!this._videoBeautyProcessor)
                  if (this._videoBeautyProcessor = new OX(), this.processor) {
                    const e5 = this.processor;
                    this.pipe(this._videoBeautyProcessor).pipe(e5);
                  } else
                    this.pipe(this._videoBeautyProcessor).pipe(this.processorDestination);
                await this._videoBeautyProcessor.setBeautyEffectOptions(t3), e4 ? await this._videoBeautyProcessor.enable() : await this._videoBeautyProcessor.disable();
              } catch (r3) {
                throw JD.error("[".concat(this.getTrackId(), "] setBeautyEffect error"), r3.toString()), gP("info", this, "setBeautyEffect", [e4, t3]), i3.onError(r3), r3;
              }
              JD.info("[".concat(this.getTrackId(), "] setBeautyEffect success")), gP("info", this, "setBeautyEffect", [e4, t3], "success"), i3.onSuccess();
            } else
              i3.onSuccess();
          }
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        async getCurrentFrameImage(e4) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return this._player ? this._player.getCurrentFrameToUint8Array(e4, t3) : await iX(e4);
        }
        clone(t3, i3, r3, n3) {
          const o3 = this._mediaStreamTrack.clone();
          return new e3(o3, t3, i3, r3, n3);
        }
        async setBitrateLimit(e4) {
          if (JD.debug("[".concat(this.getTrackId(), "] set bitrate limit, ").concat(JSON.stringify(e4))), gP("debug", this, "setBitrateLimit", e4), e4) {
            this._forceBitrateLimit = e4, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e4.max_bitrate ? this._encoderConfig.bitrateMax : e4.max_bitrate : this._encoderConfig.bitrateMax = e4.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e4.min_bitrate);
            try {
              await TK(this, Zk.NEED_UPDATE_VIDEO_ENCODER, this);
            } catch (e5) {
              return e5.throw();
            }
          }
        }
        async setOptimizationMode(e4) {
          if ("motion" !== e4 && "detail" !== e4 && "balanced" !== e4)
            return JD.error(xD.INVALID_PARAMS, "optimization mode must be motion, detail or balanced"), void gP("error", this, "setOptimizationMode", e4, xD.INVALID_PARAMS);
          const t3 = this._optimizationMode;
          try {
            this._optimizationMode = e4, await TK(this, Zk.SET_OPTIMIZATION_MODE, this);
          } catch (i3) {
            throw this._optimizationMode = t3, JD.error("[".concat(this.getTrackId(), "] set optimization mode failed"), i3.toString()), gP("error", this, "setOptimizationMode", e4, i3.toString()), i3;
          }
          JD.info("[".concat(this.getTrackId(), "] set optimization mode success (").concat(e4, ")")), gP("info", this, "setOptimizationMode", e4, "success");
        }
        setScalabiltyMode(e4) {
          if (1 === e4.numSpatialLayers && 1 !== e4.numTemporalLayers)
            return JD.error(xD.INVALID_PARAMS, "scalability mode currently not supported, no SVC."), gP("error", this, "setScalabiltyMode", e4, xD.INVALID_PARAMS), void (this._scalabiltyMode = { numSpatialLayers: 1, numTemporalLayers: 1 });
          this._scalabiltyMode = e4, JD.info("[".concat(this.getTrackId(), "] set scalability mode success (").concat(e4, ")")), gP("info", this, "setScalabiltyMode", e4, "success");
        }
        updateMediaStreamTrackResolution() {
          CK(this._originMediaStreamTrack).then((e4) => {
            let [t3, i3] = e4;
            this._videoHeight = i3, this._videoWidth = t3;
          }).catch(_K);
        }
        _updatePlayerSource() {
          this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        _getDefaultPlayerConfig() {
          return { fit: "contain" };
        }
        updateBitrateFromProfile() {
          if (!this._encoderConfig)
            return;
          const { width: e4, height: t3, frameRate: i3 } = this.getMediaStreamTrackSettings();
          if (!e4 || !t3 || !i3)
            return;
          const [r3, n3] = function(e5, t4, i4) {
            const r4 = LP("BITRATE_ADAPTER_TYPE");
            let n4;
            const o3 = 200 * Math.pow(i4 / 15, 0.6) * Math.pow(e5 * t4 / 640 / 360, 0.75), s3 = o3;
            if ("STANDARD_BITRATE" === r4)
              n4 = 4 * o3;
            else {
              if ("COMPATIABLE_BITRATE" !== r4)
                return;
              n4 = 2 * o3;
            }
            return [Math.floor(n4), Math.floor(s3)];
          }(e4, t3, i3) || [void 0, void 0];
          this._encoderConfig.bitrateMin || this._encoderConfig.bitrateMax || (this._encoderConfig.bitrateMin = n3, this._encoderConfig.bitrateMax = r3, JD.debug("[".concat(this.getTrackId(), "] update bitrate from profile, [w: ").concat(e4, ", h: ").concat(t3, ", fps: ").concat(i3, "] => [brMax: ").concat(r3, ", brMin: ").concat(n3, "]")), gP("debug", this, "updateBitrateFromProfile", void 0, "[w: ".concat(e4, ", h: ").concat(t3, ", fps: ").concat(i3, "] => [brMax: ").concat(r3, ", brMin: ").concat(n3, "]")));
        }
        getVideoElementVisibleStatus() {
          try {
            var e4, t3;
            const i3 = null == this || null === (e4 = this._player) || void 0 === e4 ? void 0 : e4.getContainerElement(), r3 = { track: this, element: null == this || null === (t3 = this._player) || void 0 === t3 ? void 0 : t3.getVideoElement(), slot: null == i3 ? void 0 : i3.parentElement }, { element: n3, slot: o3 } = r3;
            if (this.isPlaying && n3 instanceof HTMLVideoElement && o3 instanceof HTMLElement) {
              const e5 = cz.checkOneElementVisible(n3), t4 = Object.assign({}, e5);
              if (t4.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t4.visible;
                const e6 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t4.visible ? e6.onSuccess("Video is visible") : e6.onSuccess("Invisible because of ".concat(t4.reason));
              }
              return t4;
            }
            return;
          } catch (e5) {
            throw new QD(xD.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e5.message);
          }
        }
        async renewMediaStreamTrack(e4) {
        }
        pipe(e4) {
          if (this._videoBeautyProcessor && e4 !== this._videoBeautyProcessor)
            return this._videoBeautyProcessor.pipe(e4);
          if (this.processor === e4)
            return e4;
          if (e4._source)
            throw new QD(xD.INVALID_OPERATION, "Processor ".concat(e4.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e4, this.processor._source = this, e4.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e4;
        }
        unpipe() {
          if (!this.processor)
            return;
          if (this._videoBeautyProcessor && this.processor === this._videoBeautyProcessor)
            return void this._videoBeautyProcessor.unpipe();
          const e4 = this.processor;
          this.processor._source = void 0, this.processor = void 0, e4.reset();
        }
        close() {
          super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(mB.ON_TRACK, async (e4) => {
            e4 ? e4 !== this._mediaStreamTrack && (this._mediaStreamTrack = e4, this._updatePlayerSource(), await TK(this, Zk.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await TK(this, Zk.NEED_REPLACE_TRACK, this));
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(mB.ON_TRACK);
        }
        unbindProcessorContextEvents() {
          this.processorContext.removeAllListeners(IB.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(IB.REQUEST_CONSTRAINTS);
        }
      }).prototype, "play", [UX], Object.getOwnPropertyDescriptor($X.prototype, "play"), $X.prototype), VV($X.prototype, "setEnabled", [xX, QX, FX], Object.getOwnPropertyDescriptor($X.prototype, "setEnabled"), $X.prototype), VV($X.prototype, "setMuted", [VX, jX, GX], Object.getOwnPropertyDescriptor($X.prototype, "setMuted"), $X.prototype), VV($X.prototype, "getStats", [KX], Object.getOwnPropertyDescriptor($X.prototype, "getStats"), $X.prototype), VV($X.prototype, "setBeautyEffect", [HX], Object.getOwnPropertyDescriptor($X.prototype, "setBeautyEffect"), $X.prototype), VV($X.prototype, "getCurrentFrameData", [WX], Object.getOwnPropertyDescriptor($X.prototype, "getCurrentFrameData"), $X.prototype), VV($X.prototype, "getCurrentFrameImage", [YX], Object.getOwnPropertyDescriptor($X.prototype, "getCurrentFrameImage"), $X.prototype), VV($X.prototype, "setBitrateLimit", [JX], Object.getOwnPropertyDescriptor($X.prototype, "setBitrateLimit"), $X.prototype), VV($X.prototype, "setOptimizationMode", [qX], Object.getOwnPropertyDescriptor($X.prototype, "setOptimizationMode"), $X.prototype), VV($X.prototype, "setScalabiltyMode", [XX], Object.getOwnPropertyDescriptor($X.prototype, "setScalabiltyMode"), $X.prototype), VV($X.prototype, "updateMediaStreamTrackResolution", [zX], Object.getOwnPropertyDescriptor($X.prototype, "updateMediaStreamTrackResolution"), $X.prototype), ZX = $X)) || ZX), Az = (ez = mP("CameraVideoTrack", "getTrackId"), tz = Zj(), iz = mj("CameraVideoTrack", "_enabledMutex"), rz = lj({ className: "CameraVideoTrack" }), nz = Zj(), oz = Zj(), ez((VV((az = class extends hz {
        constructor(e3, t3, i3, r3, n3, o3) {
          super(e3, t3.encoderConfig ? wP(t3.encoderConfig) : {}, r3, n3, o3), MN(this, "_config", void 0), MN(this, "_originalConstraints", void 0), MN(this, "_constraints", void 0), MN(this, "_enabled", true), MN(this, "_deviceName", "default"), MN(this, "tryResumeVideoForIOS15WeChat", async () => {
            IN() && !SN() && TN() && this._enabled && !this._isClosed && (JD.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS 15 device on WeChat.")), await this.renewMediaStreamTrack());
          }), fP("info", this, "constructor", { trackId: o3, deviceId: e3.label, constraints: i3, config: t3 }), this._config = t3, this._originalConstraints = i3, this._constraints = i3, this._deviceName = e3.label, this._config.encoderConfig && (this._encoderConfig = wP(this._config.encoderConfig)), Tj.on(_j.IOS_15_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat), Tj.on(_j.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat), this.bindProcessorContextEvents();
        }
        async setDevice(e3) {
          const t3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.CAM_VIDEO_TRACK_SET_DEVICE, options: [this.getTrackId(), e3] });
          if (JD.info("[".concat(this.getTrackId(), "] set device to ").concat(e3)), gP("info", this, "setDevice", e3), this._enabled)
            try {
              const t4 = await Yj.getDeviceById(e3), i3 = {};
              i3.video = uz({}, this._constraints), i3.video.deviceId = { exact: e3 }, i3.video.facingMode = void 0, this._originMediaStreamTrack.stop();
              let r3 = null;
              try {
                r3 = await Gj(i3, this.getTrackId());
              } catch (t5) {
                throw JD.error("[".concat(this.getTrackId(), "] setDevice failed"), t5.toString()), gP("error", this, "setDevice", e3, t5.toString()), r3 = await Gj({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(r3.getVideoTracks()[0], false), t5;
              }
              await this._updateOriginMediaStreamTrack(r3.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution(), this._deviceName = t4.label, this._config.cameraId = e3, this._constraints.deviceId = { exact: e3 };
            } catch (i3) {
              throw t3.onError(i3), JD.error("[".concat(this.getTrackId(), "] setDevice error"), i3.toString()), gP("error", this, "setDevice", e3, i3.toString()), i3;
            }
          else
            try {
              const t4 = await Yj.getDeviceById(e3);
              this._deviceName = t4.label, this._config.cameraId = e3, this._constraints.deviceId = { exact: e3 };
            } catch (i3) {
              throw t3.onError(i3), JD.error("[".concat(this.getTrackId(), "] setDevice error"), i3.toString()), gP("error", this, "setDevice", e3, i3.toString()), i3;
            }
          JD.info("[".concat(this.getTrackId(), "] setDevice success")), gP("info", this, "setDevice", e3, "success"), t3.onSuccess();
        }
        async setEnabled(e3, t3) {
          if (!t3) {
            if (e3 === this._enabled)
              return;
            this.stateCheck("enabled", e3);
          }
          if (JD.info("[".concat(this.getTrackId(), "] start setEnabled"), e3), gP("info", this, "setEnabled", e3), !e3) {
            this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), t3 || (this._enabled = false);
            try {
              await TK(this, Zk.NEED_DISABLE_TRACK, this);
            } catch (t4) {
              throw JD.error("[".concat(this.getTrackId(), "] setEnabled to false error"), t4.toString()), gP("error", this, "setEnabled", e3, t4.toString()), t4;
            }
            return JD.info("[".concat(this.getTrackId(), "] setEnabled to false success")), void gP("info", this, "setEnabled", e3, "success");
          }
          const i3 = uz({}, this._constraints), r3 = Yj.searchDeviceIdByName(this._deviceName);
          r3 && !i3.deviceId && (i3.deviceId = { exact: r3 });
          try {
            const e4 = await Gj({ video: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], false), await TK(this, Zk.NEED_ENABLE_TRACK, this);
          } catch (t4) {
            throw JD.error("[".concat(this.getTrackId(), "] setEnabled true error"), t4.toString()), gP("error", this, "setEnabled", e3, t4.toString()), t4;
          }
          this.updateMediaStreamTrackResolution(), JD.info("[".concat(this.getTrackId(), "] setEnabled to true success")), gP("info", this, "setEnabled", e3, "success"), t3 || (this._enabled = true);
        }
        async setEncoderConfiguration(e3, t3) {
          const i3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG, options: [this.getTrackId(), e3] });
          if (!this._enabled) {
            const e4 = new QD(xD.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
            throw i3.onError(e4), e4;
          }
          e3 = wP(e3), this._forceBitrateLimit && (e3.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e3.bitrateMax, e3.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e3.bitrateMin);
          const r3 = OK(this._config);
          r3.encoderConfig = e3;
          const n3 = DX(r3);
          (pN() || EN() || vN()) && (n3.deviceId = void 0), JD.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e3), JSON.stringify(n3)), gP("debug", this, "setEncoderConfiguration", e3);
          try {
            await this._originMediaStreamTrack.applyConstraints(n3), this.updateMediaStreamTrackResolution();
          } catch (e4) {
            const t4 = new QD(xD.UNEXPECTED_ERROR, e4.toString());
            throw JD.error("[".concat(this.getTrackId(), "] applyConstraints error"), t4.toString()), gP("error", this, "setEncoderConfiguration", e4.toString()), i3.onError(t4), t4;
          }
          this._config = r3, this._constraints = n3, this._originalConstraints = n3, this._encoderConfig = e3, -1 === this._hints.indexOf($k.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await TK(this, Zk.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e4) {
            return i3.onError(e4), e4.throw();
          }
          i3.onSuccess();
        }
        _getDefaultPlayerConfig() {
          return { mirror: true, fit: "cover" };
        }
        onTrackEnded() {
          if ((EN() || vN()) && this._enabled && !this._isClosed && Tj.duringInterruption) {
            const e3 = async () => {
              Tj.off(_j.IOS_INTERRUPTION_END, e3), this._enabled && !this._isClosed && (JD.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS device.")), hP("debug", this, "try capture camera media device for interrupted iOS device."), await this.setEnabled(false), await this.setEnabled(true));
            };
            Tj.on(_j.IOS_INTERRUPTION_END, e3);
          } else
            JD.debug("[".concat(this.getTrackId(), "] track ended")), pP("debug", ["MediaStreamTrack", this.getTrackId()], "ended"), this.emit(iB.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e3) {
          const t3 = e3 || this._constraints, i3 = Yj.searchDeviceIdByName(this._deviceName);
          if (i3 && !t3.deviceId && (t3.deviceId = { exact: i3 }), this._enabled) {
            const e4 = await Gj({ video: t3 }, this.getTrackId());
            this._constraints = t3, await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], true), this.updateMediaStreamTrackResolution();
          }
        }
        close() {
          super.close(), Tj.off(_j.IOS_15_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat), Tj.off(_j.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat);
        }
        bindProcessorContextEvents() {
          this.processorContext.on(IB.REQUEST_UPDATE_CONSTRAINTS, async (e3, t3, i3) => {
            try {
              const i4 = Object.assign({}, this._originalConstraints, ...e3);
              await this.renewMediaStreamTrack(i4), t3();
            } catch (e4) {
              i3(e4);
            }
          }), this.processorContext.on(IB.REQUEST_CONSTRAINTS, async (e3) => {
            e3(this._originMediaStreamTrack.getSettings());
          });
        }
      }).prototype, "setDevice", [tz], Object.getOwnPropertyDescriptor(az.prototype, "setDevice"), az.prototype), VV(az.prototype, "setEnabled", [iz, rz, nz], Object.getOwnPropertyDescriptor(az.prototype, "setEnabled"), az.prototype), VV(az.prototype, "setEncoderConfiguration", [oz], Object.getOwnPropertyDescriptor(az.prototype, "setEncoderConfiguration"), az.prototype), sz = az)) || sz);
      class lz {
        get hasVideo() {
          return this._video_enabled_ && !this._video_muted_ && this._video_added_;
        }
        get hasAudio() {
          return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;
        }
        get audioTrack() {
          if (this.hasAudio)
            return this._audioTrack;
        }
        get videoTrack() {
          if (this.hasVideo)
            return this._videoTrack;
        }
        constructor(e3, t3) {
          MN(this, "uid", void 0), MN(this, "_uintid", void 0), MN(this, "_trust_in_room_", true), MN(this, "_trust_audio_enabled_state_", true), MN(this, "_trust_video_enabled_state_", true), MN(this, "_trust_audio_mute_state_", true), MN(this, "_trust_video_mute_state_", true), MN(this, "_audio_muted_", false), MN(this, "_video_muted_", false), MN(this, "_audio_enabled_", true), MN(this, "_video_enabled_", true), MN(this, "_audio_added_", false), MN(this, "_video_added_", false), MN(this, "_trust_video_stream_added_state_", true), MN(this, "_trust_audio_stream_added_state_", true), MN(this, "_audioTrack", void 0), MN(this, "_videoTrack", void 0), MN(this, "_audioSSRC", void 0), MN(this, "_videoSSRC", void 0), MN(this, "_audioOrtc", void 0), MN(this, "_videoOrtc", void 0), MN(this, "_cname", void 0), MN(this, "_rtxSsrcId", void 0), this.uid = e3, this._uintid = t3;
        }
      }
      var pz = A_, gz = am, Ez = gm;
      ka({ target: "Promise", stat: true }, { try: function(e3) {
        var t3 = gz.f(this), i3 = Ez(e3);
        return (i3.error ? t3.reject : t3.resolve)(i3.value), t3.promise;
      } });
      var fz = pz, mz = ka, Iz = vn, _z = ln, Cz = DF, Sz = no, vz = zo, Tz = Va, Rz = WP, yz = QF, wz = _V, bz = Io, Nz = Es("isConcatSpreadable"), Oz = 9007199254740991, Dz = "Maximum allowed index exceeded", Pz = Iz.TypeError, Lz = bz >= 51 || !_z(function() {
        var e3 = [];
        return e3[Nz] = false, e3.concat()[0] !== e3;
      }), kz = wz("concat"), Bz = function(e3) {
        if (!Sz(e3))
          return false;
        var t3 = e3[Nz];
        return void 0 !== t3 ? !!t3 : Cz(e3);
      };
      mz({ target: "Array", proto: true, forced: !Lz || !kz }, { concat: function(e3) {
        var t3, i3, r3, n3, o3, s3 = vz(this), a3 = yz(s3, 0), c3 = 0;
        for (t3 = -1, r3 = arguments.length; t3 < r3; t3++)
          if (Bz(o3 = -1 === t3 ? s3 : arguments[t3])) {
            if (c3 + (n3 = Tz(o3)) > Oz)
              throw Pz(Dz);
            for (i3 = 0; i3 < n3; i3++, c3++)
              i3 in o3 && Rz(a3, c3, o3[i3]);
          } else {
            if (c3 >= Oz)
              throw Pz(Dz);
            Rz(a3, c3++, o3);
          }
        return a3.length = c3, a3;
      } });
      var Mz = {}, Uz = Hn, xz = io, Qz = _A.f, Fz = ZP, Vz = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      Mz.f = function(e3) {
        return Vz && "Window" == Uz(e3) ? function(e4) {
          try {
            return Qz(e4);
          } catch (e5) {
            return Fz(Vz);
          }
        }(e3) : Qz(xz(e3));
      };
      var jz = {}, Gz = Es;
      jz.f = Gz;
      var Kz = oo, Hz = es, Wz = jz, Yz = ia.f, Jz = function(e3) {
        var t3 = Kz.Symbol || (Kz.Symbol = {});
        Hz(t3, e3) || Yz(t3, e3, { value: Wz.f(e3) });
      }, qz = ka, Xz = vn, zz = ho, Zz = bn, $z = kn, eZ = _n, tZ = Dn, iZ = So, rZ = ln, nZ = es, oZ = DF, sZ = Nn, aZ = no, cZ = Cn, dZ = No, uZ = ca, hZ = zo, AZ = io, lZ = ws, pZ = _p, gZ = Vn, EZ = _l, fZ = el, mZ = _A, IZ = Mz, _Z = FA, CZ = On, SZ = ia, vZ = zA, TZ = Bn, RZ = af, yZ = wg, wZ = jo.exports, bZ = OA, NZ = os, OZ = Es, DZ = jz, PZ = Jz, LZ = Hg, kZ = Ig, BZ = YF.forEach, MZ = tA("hidden"), UZ = "Symbol", xZ = OZ("toPrimitive"), QZ = kZ.set, FZ = kZ.getterFor(UZ), VZ = Object.prototype, jZ = Xz.Symbol, GZ = jZ && jZ.prototype, KZ = Xz.TypeError, HZ = Xz.QObject, WZ = zz("JSON", "stringify"), YZ = CZ.f, JZ = SZ.f, qZ = IZ.f, XZ = TZ.f, zZ = eZ([].push), ZZ = wZ("symbols"), $Z = wZ("op-symbols"), e$ = wZ("string-to-symbol-registry"), t$ = wZ("symbol-to-string-registry"), i$ = wZ("wks"), r$ = !HZ || !HZ.prototype || !HZ.prototype.findChild, n$ = tZ && rZ(function() {
        return 7 != EZ(JZ({}, "a", { get: function() {
          return JZ(this, "a", { value: 7 }).a;
        } })).a;
      }) ? function(e3, t3, i3) {
        var r3 = YZ(VZ, t3);
        r3 && delete VZ[t3], JZ(e3, t3, i3), r3 && e3 !== VZ && JZ(VZ, t3, r3);
      } : JZ, o$ = function(e3, t3) {
        var i3 = ZZ[e3] = EZ(GZ);
        return QZ(i3, { type: UZ, tag: e3, description: t3 }), tZ || (i3.description = t3), i3;
      }, s$ = function(e3, t3, i3) {
        e3 === VZ && s$($Z, t3, i3), uZ(e3);
        var r3 = lZ(t3);
        return uZ(i3), nZ(ZZ, r3) ? (i3.enumerable ? (nZ(e3, MZ) && e3[MZ][r3] && (e3[MZ][r3] = false), i3 = EZ(i3, { enumerable: gZ(0, false) })) : (nZ(e3, MZ) || JZ(e3, MZ, gZ(1, {})), e3[MZ][r3] = true), n$(e3, r3, i3)) : JZ(e3, r3, i3);
      }, a$ = function(e3, t3) {
        uZ(e3);
        var i3 = AZ(t3), r3 = fZ(i3).concat(h$(i3));
        return BZ(r3, function(t4) {
          tZ && !$z(c$, i3, t4) || s$(e3, t4, i3[t4]);
        }), e3;
      }, c$ = function(e3) {
        var t3 = lZ(e3), i3 = $z(XZ, this, t3);
        return !(this === VZ && nZ(ZZ, t3) && !nZ($Z, t3)) && (!(i3 || !nZ(this, t3) || !nZ(ZZ, t3) || nZ(this, MZ) && this[MZ][t3]) || i3);
      }, d$ = function(e3, t3) {
        var i3 = AZ(e3), r3 = lZ(t3);
        if (i3 !== VZ || !nZ(ZZ, r3) || nZ($Z, r3)) {
          var n3 = YZ(i3, r3);
          return !n3 || !nZ(ZZ, r3) || nZ(i3, MZ) && i3[MZ][r3] || (n3.enumerable = true), n3;
        }
      }, u$ = function(e3) {
        var t3 = qZ(AZ(e3)), i3 = [];
        return BZ(t3, function(e4) {
          nZ(ZZ, e4) || nZ(bZ, e4) || zZ(i3, e4);
        }), i3;
      }, h$ = function(e3) {
        var t3 = e3 === VZ, i3 = qZ(t3 ? $Z : AZ(e3)), r3 = [];
        return BZ(i3, function(e4) {
          !nZ(ZZ, e4) || t3 && !nZ(VZ, e4) || zZ(r3, ZZ[e4]);
        }), r3;
      };
      (iZ || (yZ(GZ = (jZ = function() {
        if (cZ(GZ, this))
          throw KZ("Symbol is not a constructor");
        var e3 = arguments.length && void 0 !== arguments[0] ? pZ(arguments[0]) : void 0, t3 = NZ(e3), i3 = function(e4) {
          this === VZ && $z(i3, $Z, e4), nZ(this, MZ) && nZ(this[MZ], t3) && (this[MZ][t3] = false), n$(this, t3, gZ(1, e4));
        };
        return tZ && r$ && n$(VZ, t3, { configurable: true, set: i3 }), o$(t3, e3);
      }).prototype, "toString", function() {
        return FZ(this).tag;
      }), yZ(jZ, "withoutSetter", function(e3) {
        return o$(NZ(e3), e3);
      }), TZ.f = c$, SZ.f = s$, vZ.f = a$, CZ.f = d$, mZ.f = IZ.f = u$, _Z.f = h$, DZ.f = function(e3) {
        return o$(OZ(e3), e3);
      }, tZ && JZ(GZ, "description", { configurable: true, get: function() {
        return FZ(this).description;
      } })), qz({ global: true, wrap: true, forced: !iZ, sham: !iZ }, { Symbol: jZ }), BZ(fZ(i$), function(e3) {
        PZ(e3);
      }), qz({ target: UZ, stat: true, forced: !iZ }, { for: function(e3) {
        var t3 = pZ(e3);
        if (nZ(e$, t3))
          return e$[t3];
        var i3 = jZ(t3);
        return e$[t3] = i3, t$[i3] = t3, i3;
      }, keyFor: function(e3) {
        if (!dZ(e3))
          throw KZ(e3 + " is not a symbol");
        if (nZ(t$, e3))
          return t$[e3];
      }, useSetter: function() {
        r$ = true;
      }, useSimple: function() {
        r$ = false;
      } }), qz({ target: "Object", stat: true, forced: !iZ, sham: !tZ }, { create: function(e3, t3) {
        return void 0 === t3 ? EZ(e3) : a$(EZ(e3), t3);
      }, defineProperty: s$, defineProperties: a$, getOwnPropertyDescriptor: d$ }), qz({ target: "Object", stat: true, forced: !iZ }, { getOwnPropertyNames: u$, getOwnPropertySymbols: h$ }), qz({ target: "Object", stat: true, forced: rZ(function() {
        _Z.f(1);
      }) }, { getOwnPropertySymbols: function(e3) {
        return _Z.f(hZ(e3));
      } }), WZ) && qz({ target: "JSON", stat: true, forced: !iZ || rZ(function() {
        var e3 = jZ();
        return "[null]" != WZ([e3]) || "{}" != WZ({ a: e3 }) || "{}" != WZ(Object(e3));
      }) }, { stringify: function(e3, t3, i3) {
        var r3 = RZ(arguments), n3 = t3;
        if ((aZ(t3) || void 0 !== e3) && !dZ(e3))
          return oZ(t3) || (t3 = function(e4, t4) {
            if (sZ(n3) && (t4 = $z(n3, this, e4, t4)), !dZ(t4))
              return t4;
          }), r3[1] = t3, Zz(WZ, null, r3);
      } });
      if (!GZ[xZ]) {
        var A$ = GZ.valueOf;
        yZ(GZ, xZ, function(e3) {
          return $z(A$, this);
        });
      }
      LZ(jZ, UZ), bZ[MZ] = true, Jz("asyncIterator"), Jz("hasInstance"), Jz("isConcatSpreadable"), Jz("iterator"), Jz("match"), Jz("matchAll"), Jz("replace"), Jz("search"), Jz("species"), Jz("split"), Jz("toPrimitive"), Jz("toStringTag"), Jz("unscopables"), Hg(vn.JSON, "JSON", true);
      var l$ = oo.Symbol;
      Jz("asyncDispose"), Jz("dispose"), Jz("matcher"), Jz("metadata"), Jz("observable"), Jz("patternMatch"), Jz("replaceAll");
      var p$ = l$, g$ = jz.f("asyncIterator"), E$ = g$;
      function f$(e3) {
        this.wrapped = e3;
      }
      function m$(e3) {
        var t3, i3;
        function r3(t4, i4) {
          try {
            var o3 = e3[t4](i4), s3 = o3.value, a3 = s3 instanceof f$;
            fz.resolve(a3 ? s3.wrapped : s3).then(function(e4) {
              a3 ? r3("return" === t4 ? "return" : "next", e4) : n3(o3.done ? "return" : "normal", e4);
            }, function(e4) {
              r3("throw", e4);
            });
          } catch (e4) {
            n3("throw", e4);
          }
        }
        function n3(e4, n4) {
          switch (e4) {
            case "return":
              t3.resolve({ value: n4, done: true });
              break;
            case "throw":
              t3.reject(n4);
              break;
            default:
              t3.resolve({ value: n4, done: false });
          }
          (t3 = t3.next) ? r3(t3.key, t3.arg) : i3 = null;
        }
        this._invoke = function(e4, n4) {
          return new fz(function(o3, s3) {
            var a3 = { key: e4, arg: n4, resolve: o3, reject: s3, next: null };
            i3 ? i3 = i3.next = a3 : (t3 = i3 = a3, r3(e4, n4));
          });
        }, "function" != typeof e3.return && (this.return = void 0);
      }
      function I$(e3) {
        return function() {
          return new m$(e3.apply(this, arguments));
        };
      }
      function _$(e3) {
        return new f$(e3);
      }
      m$.prototype["function" == typeof p$ && E$ || "@@asyncIterator"] = function() {
        return this;
      }, m$.prototype.next = function(e3) {
        return this._invoke("next", e3);
      }, m$.prototype.throw = function(e3) {
        return this._invoke("throw", e3);
      }, m$.prototype.return = function(e3) {
        return this._invoke("return", e3);
      };
      var C$ = jz.f("iterator");
      function S$(e3, t3) {
        var i3 = {}, r3 = false;
        function n3(i4, n4) {
          return r3 = true, n4 = new fz(function(t4) {
            t4(e3[i4](n4));
          }), { done: false, value: t3(n4) };
        }
        return i3[void 0 !== p$ && C$ || "@@iterator"] = function() {
          return this;
        }, i3.next = function(e4) {
          return r3 ? (r3 = false, e4) : n3("next", e4);
        }, "function" == typeof e3.throw && (i3.throw = function(e4) {
          if (r3)
            throw r3 = false, e4;
          return n3("throw", e4);
        }), "function" == typeof e3.return && (i3.return = function(e4) {
          return r3 ? (r3 = false, e4) : n3("return", e4);
        }), i3;
      }
      var v$ = g$, T$ = Gr, R$ = o, y$ = i, w$ = S, b$ = Be, N$ = x, O$ = H, D$ = _c, P$ = Tt.f, L$ = yr, k$ = y$.Symbol, B$ = k$ && k$.prototype;
      if (R$ && N$(k$) && (!("description" in B$) || void 0 !== k$().description)) {
        var M$ = {}, U$ = function() {
          var e3 = arguments.length < 1 || void 0 === arguments[0] ? void 0 : D$(arguments[0]), t3 = O$(B$, this) ? new k$(e3) : void 0 === e3 ? k$() : k$(e3);
          return "" === e3 && (M$[t3] = true), t3;
        };
        L$(U$, k$), U$.prototype = B$, B$.constructor = U$;
        var x$ = "Symbol(test)" == String(k$("test")), Q$ = w$(B$.toString), F$ = w$(B$.valueOf), V$ = /^Symbol\((.*)\)[^)]+$/, j$ = w$("".replace), G$ = w$("".slice);
        P$(B$, "description", { configurable: true, get: function() {
          var e3 = F$(this), t3 = Q$(e3);
          if (b$(M$, e3))
            return "";
          var i3 = x$ ? G$(t3, 7, -1) : j$(t3, V$, "$1");
          return "" === i3 ? void 0 : i3;
        } }), T$({ global: true, forced: true }, { Symbol: U$ });
      }
      var K$ = { exports: {} };
      function H$(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function W$(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? H$(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : H$(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      function Y$(e3, t3, i3, r3, n3, o3, s3) {
        let a3 = [], c3 = [], d3 = [], u3 = [], h3 = false, A3 = false;
        if (K$.exports.parse(e3).mediaDescriptions.forEach((e4) => {
          s3 && s3 !== e4.attributes.direction || ("video" !== e4.media.mediaType || h3 || (c3 = e4.attributes.payloads, u3 = e4.attributes.extmaps, h3 = true), "audio" !== e4.media.mediaType || A3 || (a3 = e4.attributes.payloads, d3 = e4.attributes.extmaps, A3 = true));
        }), !u3 || 0 === c3.length)
          throw new Error("Cannot get video capabilities from SDP.");
        if (!d3 || 0 === a3.length)
          throw new Error("Cannot get audio capabilities from SDP.");
        return c3.forEach((e4) => {
          var t4;
          null !== (t4 = e4.rtpMap) && void 0 !== t4 && t4.clockRate && (e4.rtpMap.clockRate = parseInt(e4.rtpMap.clockRate));
        }), a3.forEach((e4) => {
          var t4;
          null !== (t4 = e4.rtpMap) && void 0 !== t4 && t4.clockRate && (e4.rtpMap.clockRate = parseInt(e4.rtpMap.clockRate));
        }), t3 && (a3 = a3.filter((e4) => {
          var t4;
          return "rtx" !== (null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase());
        }), c3 = c3.filter((e4) => {
          var t4;
          return "rtx" !== (null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase());
        })), i3 && (c3 = c3.filter((e4) => {
          var t4;
          return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName) || "");
        })), r3 && (a3 = a3.filter((e4) => {
          var t4;
          return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName) || "");
        })), n3 && (null == n3 ? void 0 : n3.length) > 0 && (a3 = a3.filter((e4) => {
          var t4;
          return n3.includes((null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "");
        })), o3 && (null == o3 ? void 0 : o3.length) > 0 && (c3 = c3.filter((e4) => {
          var t4;
          return o3.includes((null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "");
        })), { audioCodecs: a3, videoCodecs: c3, audioExtensions: d3, videoExtensions: u3 };
      }
      function J$(e3) {
        const t3 = K$.exports.parse(e3);
        let i3, r3;
        for (const e4 of t3.mediaDescriptions) {
          if (!i3) {
            const t4 = e4.attributes.iceUfrag, r4 = e4.attributes.icePwd;
            if (!t4 || !r4)
              throw new Error("Cannot get iceUfrag or icePwd from SDP.");
            i3 = { iceUfrag: t4, icePwd: r4 };
          }
          if (!r3) {
            const t4 = e4.attributes.fingerprints;
            t4.length > 0 && (r3 = { fingerprints: t4 });
          }
        }
        if (!r3 && t3.attributes.fingerprints.length > 0 && (r3 = { fingerprints: t3.attributes.fingerprints }), !r3 || !i3)
          throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");
        return { iceParameters: i3, dtlsParameters: r3 };
      }
      function q$(e3, t3) {
        const i3 = [], r3 = e3.attributes.ssrcGroups.filter((e4) => "FID" === e4.semantic), n3 = e3.attributes.ssrcGroups.find((e4) => "SIM" === e4.semantic), o3 = e3.attributes.ssrcs;
        if (n3)
          n3.ssrcIds.forEach((e4) => {
            var n4;
            const o4 = null === (n4 = r3.find((t4) => t4.ssrcIds[0] === e4)) || void 0 === n4 ? void 0 : n4.ssrcIds[1];
            i3.push({ ssrcId: e4, rtx: t3 ? o4 : void 0 });
          });
        else if (r3.length > 0) {
          const e4 = r3[0].ssrcIds[0], n4 = r3[0].ssrcIds[1];
          i3.push({ ssrcId: e4, rtx: t3 ? n4 : void 0 });
        } else {
          if (0 === o3.length)
            throw new Error("No ssrcs found on local media description.");
          i3.push({ ssrcId: o3[0].ssrcId });
        }
        return i3;
      }
      function X$(e3, t3) {
        const { cname: i3 } = e3;
        let r3;
        t3 && t3.ip && "number" == typeof t3.port ? (r3 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t3.ip, port: t3.port.toString(), type: "host", extension: {} }], JD.debug("Using remote candidate from AP ".concat(t3.ip, ":").concat(t3.port)), hP("debug", [], "Using remote candidate from AP ".concat(t3.ip, ":").concat(t3.port)), t3.ip6 && (r3.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t3.ip6, port: t3.port.toString(), type: "host", extension: {} }), JD.debug("Using IPV6 remote candidate from AP ".concat(t3.ip6, ":").concat(t3.port)), hP("debug", [], "Using IPV6 remote candidate from AP ".concat(t3.ip6, ":").concat(t3.port)))) : r3 = e3.iceParameters.candidates.map((e4) => ({ foundation: e4.foundation, componentId: "1", transport: e4.protocol, priority: e4.priority.toString(), connectionAddress: e4.ip, port: e4.port.toString(), type: e4.type, extension: {} }));
        const n3 = { fingerprints: e3.dtlsParameters.fingerprints.map((e4) => ({ hashFunction: e4.algorithm, fingerprint: e4.fingerprint })) }, o3 = { iceUfrag: e3.iceParameters.iceUfrag, icePwd: e3.iceParameters.icePwd };
        let s3;
        switch (e3.dtlsParameters.role) {
          case "server":
            s3 = "passive";
            break;
          case "client":
            s3 = "active";
            break;
          case "auto":
            s3 = "actpass";
        }
        return { dtlsParameters: n3, iceParameters: o3, candidates: r3, rtpCapabilities: s1(e3.rtpCapabilities), setup: s3, cname: i3 };
      }
      function z$(e3, t3, i3) {
        const r3 = [], n3 = [];
        return e3.forEach((e4) => {
          let { ssrcId: o3, rtx: s3 } = e4;
          const a3 = mK(8, "track-"), c3 = { ssrcId: o3, attributes: W$({ label: a3, mslabel: i3 = i3 || mK(10, ""), msid: "".concat(i3, " ").concat(a3) }, t3 && { cname: t3 }) };
          if (r3.push(c3), void 0 !== s3) {
            const e5 = { ssrcId: s3, attributes: W$({ label: a3, mslabel: i3, msid: "".concat(i3, " ").concat(a3) }, t3 && { cname: t3 }) };
            r3.push(e5), n3.push({ semantic: "FID", ssrcIds: [o3, s3] });
          }
        }), e3.length > 1 && n3.push({ semantic: "SIM", ssrcIds: e3.map((e4) => {
          let { ssrcId: t4 } = e4;
          return t4;
        }) }), { ssrcs: r3, ssrcGroups: n3 };
      }
      function Z$(e3, t3) {
        t3 instanceof HG && e3.attributes.payloads.forEach((e4) => {
          var i3;
          const r3 = null === (i3 = e4.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName.toLowerCase();
          if (!r3 || -1 === ["opus", "pcmu", "pcma", "g722"].indexOf(r3))
            return;
          e4.fmtp || (e4.fmtp = { parameters: {} }), e4.fmtp.parameters.minptime = "10", e4.fmtp.parameters.useinbandfec = "1";
          const n3 = t3._encoderConfig;
          n3 && "pcmu" !== r3 && "pcma" !== r3 && "g722" !== r3 && (n3.bitrate && !gN() && (e4.fmtp.parameters.maxaveragebitrate = "".concat(Math.floor(1e3 * n3.bitrate))), n3.sampleRate && (e4.fmtp.parameters.maxplaybackrate = "".concat(n3.sampleRate), e4.fmtp.parameters["sprop-maxcapturerate"] = "".concat(n3.sampleRate)), n3.stereo && (e4.fmtp.parameters.stereo = "1", e4.fmtp.parameters["sprop-stereo"] = "1"));
        });
      }
      function $$(e3) {
        const t3 = e3.attributes.unrecognized.findIndex((e4) => "x-google-flag" === e4.attField && "conference" === e4.attValue);
        -1 !== t3 && e3.attributes.unrecognized.splice(t3, 1);
      }
      function e1(e3, t3) {
        if (!(t3 instanceof hz && t3._encoderConfig && -1 === t3._hints.indexOf($k.SCREEN_TRACK)))
          return;
        const i3 = t3._encoderConfig;
        wB().supportMinBitrate && i3.bitrateMin && e3.attributes.payloads.forEach((e4) => {
          var t4;
          ["h264", "vp8", "vp9", "av1"].includes((null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "") && (e4.fmtp || (e4.fmtp = { parameters: {} }), e4.fmtp.parameters["x-google-min-bitrate"] = "".concat(i3.bitrateMin));
        }), wB().supportMinBitrate && !t3._hints.includes($k.LOW_STREAM) && i3.bitrateMax && e3.attributes.payloads.forEach((e4) => {
          var t4;
          ["h264", "vp8", "vp9", "av1"].includes((null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "") && (e4.fmtp || (e4.fmtp = { parameters: {} }), e4.fmtp.parameters["x-google-start-bitrate"] = "".concat(LP("X_GOOGLE_START_BITRATE") || Math.floor(i3.bitrateMax)));
        });
      }
      function t1(e3) {
        if ("video" !== e3.media.mediaType)
          return;
        const t3 = oN();
        if (t3.name !== tN.SAFARI && t3.os !== eN.IOS)
          return;
        const i3 = e3.attributes.extmaps.findIndex((e4) => /video-orientation/g.test(e4.extensionName));
        -1 !== i3 && e3.attributes.extmaps.splice(i3, 1);
      }
      function i1(e3, t3, i3) {
        if (!t3)
          return;
        let r3, n3;
        if ("video" === e3.media.mediaType ? (r3 = i3.videoExtensions, n3 = i3.videoCodecs) : (r3 = i3.audioExtensions, n3 = i3.audioCodecs), true === t3.tcc) {
          const t4 = r3.find((e4) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e4.extensionName);
          if (t4) {
            e3.attributes.extmaps.find((e4) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e4.extensionName) || e3.attributes.extmaps.push({ entry: t4.entry, extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" });
            (function(e4, t5) {
              return t5.filter((t6) => !!e4.find((e5) => e5.payloadType === t6.payloadType && !!e5.rtcpFeedbacks.find((e6) => "transport-cc" === e6.type)));
            })(n3, e3.attributes.payloads).forEach((e4) => {
              e4.rtcpFeedbacks.find((e5) => "transport-cc" === e5.type) || e4.rtcpFeedbacks.push({ type: "transport-cc" });
            });
          }
        } else if (false === t3.tcc) {
          const t4 = e3.attributes.extmaps.findIndex((e4) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e4.extensionName);
          -1 !== t4 && e3.attributes.extmaps.splice(t4, 1), e3.attributes.payloads.forEach((e4) => {
            const t5 = e4.rtcpFeedbacks.findIndex((e5) => "transport-cc" === e5.type);
            -1 !== t5 && e4.rtcpFeedbacks.splice(t5, 1);
          });
        }
        if (true === t3.remb) {
          const t4 = r3.find((e4) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e4.extensionName);
          if (t4) {
            e3.attributes.extmaps.find((e4) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e4.extensionName) || e3.attributes.extmaps.push({ entry: t4.entry, extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" });
            (function(e4, t5) {
              return t5.filter((t6) => !!e4.find((e5) => e5.payloadType === t6.payloadType && !!e5.rtcpFeedbacks.find((e6) => "goog-remb" === e6.type)));
            })(n3, e3.attributes.payloads).forEach((e4) => {
              e4.rtcpFeedbacks.find((e5) => "goog-remb" === e5.type) || e4.rtcpFeedbacks.push({ type: "goog-remb" });
            });
          }
        } else if (false === t3.remb) {
          const t4 = e3.attributes.extmaps.findIndex((e4) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e4.extensionName);
          -1 !== t4 && e3.attributes.extmaps.splice(t4, 1), e3.attributes.payloads.forEach((e4) => {
            const t5 = e4.rtcpFeedbacks.findIndex((e5) => "goog-remb" === e5.type);
            -1 !== t5 && e4.rtcpFeedbacks.splice(t5, 1);
          });
        }
      }
      function r1(e3, t3, i3) {
        if (gN())
          return;
        if ("video" !== e3.media.mediaType)
          return;
        if (!(t3 instanceof hz))
          return;
        if ("vp9" !== i3 && "vp8" !== i3)
          return;
        if ("vp8" === i3 && !LP("SIMULCAST"))
          return;
        if (void 0 === t3._scalabiltyMode || t3._scalabiltyMode.numSpatialLayers <= 1)
          return;
        const r3 = "vp8" === i3 ? 2 : t3._scalabiltyMode.numSpatialLayers, n3 = e3.attributes.ssrcs[0], o3 = e3.attributes.ssrcGroups.find((e4) => "FID" === e4.semantic && e4.ssrcIds[0] === n3.ssrcId), s3 = { semantic: "SIM", ssrcIds: [n3.ssrcId] };
        for (let t4 = 1; t4 < r3; t4++)
          e3.attributes.ssrcs.push({ ssrcId: n3.ssrcId + t4, attributes: OK(n3.attributes) }), s3.ssrcIds.push(n3.ssrcId + t4), o3 && (e3.attributes.ssrcs.push({ ssrcId: o3.ssrcIds[1] + t4, attributes: OK(n3.attributes) }), e3.attributes.ssrcGroups.push({ semantic: "FID", ssrcIds: [n3.ssrcId + t4, o3.ssrcIds[1] + t4] }));
        e3.attributes.ssrcGroups.unshift(s3);
      }
      async function n1(e3, t3, i3, r3, n3) {
        const o3 = new RTCPeerConnection();
        o3.addTransceiver("video", { direction: "sendonly" }), o3.addTransceiver("audio", { direction: "sendonly" }), o3.addTransceiver("video", { direction: "recvonly" }), o3.addTransceiver("audio", { direction: "recvonly" });
        const s3 = (await o3.createOffer()).sdp, a3 = Y$(s3, e3, t3, i3, r3, n3, "sendonly"), c3 = Y$(s3, e3, t3, i3, r3, n3, "recvonly"), d3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, u3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, h3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
        if (o1(a3, c3, "videoExtensions", d3, u3, h3), o1(a3, c3, "videoCodecs", d3, u3, h3), o1(a3, c3, "audioExtensions", d3, u3, h3), o1(a3, c3, "audioCodecs", d3, u3, h3), LP("RAISE_H264_BASELINE_PRIORITY")) {
          const e4 = h3.videoCodecs.findIndex((e5) => {
            var t4, i4;
            return "h264" === (null === (t4 = e5.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLocaleLowerCase()) && "42001f" === (null === (i4 = e5.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]);
          });
          if (-1 !== e4) {
            const t4 = h3.videoCodecs.findIndex((e5) => {
              var t5;
              return "h264" === (null === (t5 = e5.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName.toLocaleLowerCase());
            });
            if (t4 < e4) {
              JD.debug("raising H264 baseline profile priority");
              const i4 = h3.videoCodecs[e4];
              h3.videoCodecs.splice(e4, 1), h3.videoCodecs.splice(t4, 0, i4);
            }
            -1 !== t4 && (u3.videoCodecs = u3.videoCodecs.filter((e5) => {
              var t5, i4;
              return !("h264" === (null === (t5 = e5.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (i4 = e5.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]));
            })), -1 !== t4 && LP("FILTER_SEND_H264_BASELINE") && (d3.videoCodecs = d3.videoCodecs.filter((e5) => {
              var t5, i4;
              return !("h264" === (null === (t5 = e5.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (i4 = e5.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]));
            }));
          }
        }
        try {
          o3.close();
        } catch (e4) {
        }
        return { send: d3, recv: u3, sendrecv: h3 };
      }
      function o1(e3, t3, i3, r3, n3, o3) {
        if ("videoExtensions" === i3 || "audioExtensions" === i3) {
          const s3 = [];
          return e3[i3].forEach((e4) => {
            t3[i3].some((t4, i4) => {
              if (e4.entry === t4.entry && e4.extensionName === t4.extensionName)
                return s3.push(i4), true;
            }) ? o3[i3].push(e4) : r3[i3].push(e4);
          }), void t3[i3].forEach((e4, t4) => {
            -1 === s3.indexOf(t4) && n3[i3].push(e4);
          });
        }
        if ("videoCodecs" === i3 || "audioCodecs" === i3) {
          const s3 = [];
          return e3[i3].forEach((e4) => {
            t3[i3].some((t4, i4) => {
              if (e4.payloadType === t4.payloadType && JSON.stringify(e4) === JSON.stringify(t4))
                return s3.push(i4), true;
            }) ? o3[i3].push(e4) : r3[i3].push(e4);
          }), void t3[i3].forEach((e4, t4) => {
            -1 === s3.indexOf(t4) && n3[i3].push(e4);
          });
        }
      }
      function s1(e3) {
        const { send: t3, recv: i3, sendrecv: r3 } = e3;
        if (!r3) {
          if (!t3 || !i3)
            throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");
          return { send: t3, recv: i3 };
        }
        let n3, o3;
        return t3 ? (n3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, n3.audioCodecs = [...t3.audioCodecs, ...r3.audioCodecs], n3.videoCodecs = [...t3.videoCodecs, ...r3.videoCodecs], n3.audioExtensions = [...t3.audioExtensions, ...r3.audioExtensions], n3.videoExtensions = [...t3.videoExtensions, ...r3.videoExtensions]) : n3 = r3, i3 ? (o3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, o3.audioCodecs = [...i3.audioCodecs, ...r3.audioCodecs], o3.videoCodecs = [...i3.videoCodecs, ...r3.videoCodecs], o3.audioExtensions = [...i3.audioExtensions, ...r3.audioExtensions], o3.videoExtensions = [...i3.videoExtensions, ...r3.videoExtensions]) : o3 = r3, { send: n3, recv: o3 };
      }
      function a1(e3) {
        if ("audio" !== e3.media.mediaType)
          return;
        e3.attributes.payloads.filter((e4) => {
          var t3;
          return "opus" === (null === (t3 = e4.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
        }).forEach((e4) => {
          e4.fmtp || (e4.fmtp = { parameters: {} }), e4.fmtp.parameters.stereo = "1", e4.fmtp.parameters["sprop-stereo"] = "1";
        });
      }
      !function(e3, t3) {
        e3.exports = (() => {
          var e4 = { 8: (e5, t5, i4) => {
            i4.r(t5), i4.d(t5, { Parser: () => S3, Printer: () => w3, parse: () => D3, print: () => P3 });
            const r3 = "\n", n3 = "".concat("\r").concat(r3), o3 = " ";
            let s3;
            function a3(e6) {
              return e6 >= "0" && e6 <= "9";
            }
            function c3(e6) {
              return e6 >= "!" && e6 <= "~";
            }
            function d3(e6) {
              return c3(e6) || e6 >= "\x80" && e6 <= "\xFF";
            }
            function u3(e6) {
              return "!" === e6 || e6 >= "#" && e6 <= "'" || e6 >= "*" && e6 <= "+" || e6 >= "-" && e6 <= "." || e6 >= "0" && e6 <= "9" || e6 >= "A" && e6 <= "Z" || e6 >= "^" && e6 <= "~";
            }
            function h3(e6) {
              return e6 >= "1" && e6 <= "9";
            }
            function A3(e6) {
              return e6 >= "A" && e6 <= "Z" || e6 >= "a" && e6 <= "z";
            }
            function l3(e6) {
              return "d" === e6 || "h" === e6 || "m" === e6 || "s" === e6;
            }
            function p3(e6) {
              return e6 > "" && e6 < "	" || e6 > "\v" && e6 < "\f" || e6 > "" && e6 < "\xFF";
            }
            function g3(e6) {
              return A3(e6) || a3(e6) || "+" === e6 || "/" === e6;
            }
            function E3(e6) {
              return a3(e6) || A3(e6) || "+" === e6 || "/" === e6 || "-" === e6 || "_" === e6;
            }
            function f3(e6) {
              return A3(e6) || a3(e6) || "+" === e6 || "/" === e6;
            }
            function m3(e6, t6) {
              var i5 = Object.keys(e6);
              if (Object.getOwnPropertySymbols) {
                var r4 = Object.getOwnPropertySymbols(e6);
                t6 && (r4 = r4.filter(function(t7) {
                  return Object.getOwnPropertyDescriptor(e6, t7).enumerable;
                })), i5.push.apply(i5, r4);
              }
              return i5;
            }
            function I3(e6) {
              for (var t6 = 1; t6 < arguments.length; t6++) {
                var i5 = null != arguments[t6] ? arguments[t6] : {};
                t6 % 2 ? m3(Object(i5), true).forEach(function(t7) {
                  _3(e6, t7, i5[t7]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e6, Object.getOwnPropertyDescriptors(i5)) : m3(Object(i5)).forEach(function(t7) {
                  Object.defineProperty(e6, t7, Object.getOwnPropertyDescriptor(i5, t7));
                });
              }
              return e6;
            }
            function _3(e6, t6, i5) {
              return t6 in e6 ? Object.defineProperty(e6, t6, { value: i5, enumerable: true, configurable: true, writable: true }) : e6[t6] = i5, e6;
            }
            !function(e6) {
              e6.VERSION = "v", e6.ORIGIN = "o", e6.SESSION_NAME = "s", e6.INFORMATION = "i", e6.URI = "u", e6.EMAIL = "e", e6.PHONE = "p", e6.CONNECTION = "c", e6.BANDWIDTH = "b", e6.TIME = "t", e6.REPEAT = "r", e6.ZONE_ADJUSTMENTS = "z", e6.KEY = "k", e6.ATTRIBUTE = "a", e6.MEDIA = "m";
            }(s3 || (s3 = {}));
            class C3 {
              consumeText(e6, t6) {
                let i5 = t6;
                for (; i5 < e6.length; ) {
                  const t7 = e6[i5];
                  if ("\0" === t7 || "\r" === t7 || t7 === r3)
                    break;
                  i5 += 1;
                }
                if (i5 - t6 == 0)
                  throw new Error("Invalid text, at ".concat(e6));
                return i5;
              }
              consumeUnicastAddress(e6, t6, i5) {
                return this.consumeTill(e6, t6, o3);
              }
              consumeOneOrMore(e6, t6, i5) {
                let r4 = t6;
                for (; i5(e6[r4]); )
                  r4++;
                if (r4 - t6 == 0)
                  throw new Error("Invalid rule at ".concat(t6, "."));
                return r4;
              }
              consumeSpace(e6, t6) {
                if (e6[t6] === o3)
                  return t6 + 1;
                throw new Error("Invalid space at ".concat(t6, "."));
              }
              consumeIP4Address(e6, t6) {
                let i5 = t6;
                for (let t7 = 0; t7 < 4; t7++)
                  if (i5 = this.consumeDecimalUChar(e6, i5), 3 !== t7) {
                    if ("." !== e6[i5])
                      throw new Error("Invalid IP4 address.");
                    i5++;
                  }
                return i5;
              }
              consumeDecimalUChar(e6, t6) {
                let i5 = t6;
                for (let t7 = 0; t7 < 3 && a3(e6[i5]); t7++, i5++)
                  ;
                if (i5 - t6 == 0)
                  throw new Error("Invalid decimal uchar.");
                const r4 = parseInt(e6.slice(t6, i5));
                if (r4 >= 0 && r4 <= 255)
                  return i5;
                throw new Error("Invalid decimal uchar");
              }
              consumeIP6Address(e6, t6) {
                let i5 = this.consumeHexpart(e6, t6);
                return ":" === e6[i5] ? (i5 += 1, i5 = this.consumeIP4Address(e6, i5), i5) : i5;
              }
              consumeHexpart(e6, t6) {
                let i5 = t6;
                if (":" === e6[i5] && ":" === e6[i5 + 1]) {
                  i5 += 2;
                  try {
                    i5 = this.consumeHexseq(e6, i5);
                  } catch (e7) {
                  }
                  return i5;
                }
                if (i5 = this.consumeHexseq(e6, i5), ":" === e6[i5] && ":" === e6[i5 + 1]) {
                  i5 += 2;
                  try {
                    i5 = this.consumeHexseq(e6, i5);
                  } catch (e7) {
                  }
                  return i5;
                }
                return i5;
              }
              consumeHexseq(e6, t6) {
                let i5 = t6;
                for (; i5 = this.consumeHex4(e6, i5), ":" === e6[i5] && ":" !== e6[i5 + 1]; )
                  i5 += 1;
                return i5;
              }
              consumeHex4(e6, t6) {
                let i5 = 0;
                for (; i5 < 4; i5++)
                  if (!((r4 = e6[t6 + i5]) >= "0" && r4 <= "9" || r4 >= "a" && r4 <= "f" || r4 >= "A" && r4 <= "F")) {
                    if (0 === i5)
                      throw new Error("Invalid hex 4");
                    break;
                  }
                var r4;
                return t6 + i5;
              }
              consumeFQDN(e6, t6) {
                let i5 = t6;
                for (; a3(e6[i5]) || A3(e6[i5]) || "-" === e6[i5] || "." === e6[i5]; )
                  i5 += 1;
                if (i5 - t6 < 4)
                  throw new Error("Invalid FQDN");
                return i5;
              }
              consumeExtnAddr(e6, t6) {
                return this.consumeOneOrMore(e6, t6, d3);
              }
              consumeMulticastAddress(e6, t6, i5) {
                switch (i5) {
                  case "IP4":
                  case "ip4":
                    return this.consumeIP4MulticastAddress(e6, t6);
                  case "IP6":
                  case "ip6":
                    return this.consumeIP6MulticastAddress(e6, t6);
                  default:
                    try {
                      return this.consumeFQDN(e6, t6);
                    } catch (i6) {
                      return this.consumeExtnAddr(e6, t6);
                    }
                }
              }
              consumeIP6MulticastAddress(e6, t6) {
                const i5 = this.consumeHexpart(e6, t6);
                return "/" === e6[i5] ? this.consumeInteger(e6, i5 + 1) : i5;
              }
              consumeIP4MulticastAddress(e6, t6) {
                let i5 = t6 + 3;
                const r4 = e6.slice(t6, i5), n4 = parseInt(r4);
                if (n4 < 224 || n4 > 239)
                  throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");
                for (let t7 = 0; t7 < 3; t7++) {
                  if ("." !== e6[i5])
                    throw new Error("Invalid IP4 multicast address.");
                  i5 += 1, i5 = this.consumeDecimalUChar(e6, i5);
                }
                return "/" === e6[i5] && (i5 += 1), i5 = this.consumeTTL(e6, i5), "/" === e6[i5] && (i5 = this.consumeInteger(e6, i5)), i5;
              }
              consumeInteger(e6, t6) {
                if (!h3(e6[t6]))
                  throw new Error("Invalid integer.");
                for (t6 += 1; a3(e6[t6]); )
                  t6 += 1;
                return t6;
              }
              consumeTTL(e6, t6) {
                if ("0" === e6[t6])
                  return t6 + 1;
                if (!h3(e6[t6]))
                  throw new Error("Invalid TTL.");
                t6 += 1;
                for (let i5 = 0; i5 < 2 && a3(e6[t6]); i5++)
                  t6 += 1;
                return t6;
              }
              consumeToken(e6, t6) {
                return this.consumeOneOrMore(e6, t6, u3);
              }
              consumeTime(e6, t6) {
                let i5 = t6;
                if ("0" === e6[i5])
                  return i5 + 1;
                for (h3(e6[i5]) && (i5 += 1); a3(e6[i5]); )
                  i5++;
                if (i5 - t6 < 10)
                  throw new Error("Invalid time");
                return i5;
              }
              consumeAddress(e6, t6) {
                return this.consumeTill(e6, t6, o3);
              }
              consumeTypedTime(e6, t6) {
                let i5 = t6;
                return i5 = this.consumeOneOrMore(e6, i5, a3), l3(e6[i5]) ? i5 + 1 : i5;
              }
              consumeRepeatInterval(e6, t6) {
                if (!h3(e6[t6]))
                  throw new Error("Invalid repeat interval");
                for (t6 += 1; a3(e6[t6]); )
                  t6 += 1;
                return l3(e6[t6]) && (t6 += 1), t6;
              }
              consumePort(e6, t6) {
                return this.consumeOneOrMore(e6, t6, a3);
              }
              consume(e6, t6, i5) {
                for (let r4 = 0; r4 < i5.length; r4++) {
                  if (t6 + r4 >= e6.length)
                    throw new Error("consume exceeding value length");
                  if (e6[t6 + r4] !== i5[r4])
                    throw new Error("consume ".concat(i5, " failed at ").concat(r4));
                }
                return t6 + i5.length;
              }
              consumeTill(e6, t6, i5) {
                let r4 = t6;
                for (; r4 < e6.length && ("string" != typeof i5 || e6[r4] !== i5) && ("function" != typeof i5 || !i5(e6[r4])); )
                  r4++;
                return r4;
              }
            }
            class S3 extends C3 {
              constructor() {
                super(), _3(this, "records", []), _3(this, "currentLine", 0);
              }
              parse(e6) {
                const t6 = this.probeEOL(e6);
                this.records = e6.split(t6).filter((e7) => !!e7.trim()).map(this.parseLine), this.currentLine = 0;
                const i5 = this.parseVersion(), r4 = this.parseOrigin(), n4 = this.parseSessionName(), o4 = this.parseInformation(), s4 = this.parseUri(), a4 = this.parseEmail(), c4 = this.parsePhone(), d4 = this.parseConnection(), u4 = this.parseBandWidth(), h4 = this.parseTimeFields(), A4 = this.parseKey(), l4 = this.parseSessionAttribute(), p4 = this.parseMediaDescription();
                if (this.currentLine !== this.records.length)
                  throw new Error("parsing failed, non exhaustive sdp lines.");
                return { version: i5, origin: r4, sessionName: n4, information: o4, uri: s4, emails: a4, phones: c4, connection: d4, bandwidths: u4, timeFields: h4, key: A4, attributes: l4, mediaDescriptions: p4 };
              }
              getCurrentRecord() {
                const e6 = this.records[this.currentLine];
                if (!e6)
                  throw new Error("Record doesn't exit.");
                return e6;
              }
              probeEOL(e6) {
                for (let t6 = 0; t6 < e6.length; t6++)
                  if (e6[t6] === r3)
                    return "\r" === e6[t6 - 1] ? n3 : r3;
                throw new Error("Invalid newline character.");
              }
              parseLine(e6, t6) {
                if (e6.length < 2)
                  throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");
                const i5 = e6[0];
                if ("=" !== e6[1])
                  throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');
                return { type: i5, value: e6.slice(2), line: t6, cur: 0 };
              }
              parseSessionAttribute() {
                const e6 = new T3();
                for (; this.currentLine < this.records.length; ) {
                  const t6 = this.getCurrentRecord();
                  if (t6.type !== s3.ATTRIBUTE)
                    break;
                  const i5 = { attField: this.extractOneOrMore(t6, (e7) => u3(e7) && ":" !== e7), _cur: 0 };
                  ":" === t6.value[t6.cur] && (t6.cur += 1, i5.attValue = this.extractOneOrMore(t6, p3)), e6.parse(i5), this.currentLine++;
                }
                return e6.digest();
              }
              parseMediaAttributes(e6) {
                const t6 = new R3(e6);
                for (; this.currentLine < this.records.length; ) {
                  const e7 = this.getCurrentRecord();
                  if (e7.type !== s3.ATTRIBUTE)
                    break;
                  const i5 = { attField: this.extractOneOrMore(e7, (e8) => u3(e8) && ":" !== e8), _cur: 0 };
                  ":" === e7.value[e7.cur] && (e7.cur += 1, i5.attValue = this.extractOneOrMore(e7, p3)), t6.parse(i5), this.currentLine++;
                }
                return t6.digest();
              }
              parseKey() {
                const e6 = this.getCurrentRecord();
                if (e6.type === s3.KEY) {
                  if ("prompt" === e6.value || "clear:" === e6.value || "base64:" === e6.value || "uri:" === e6.value)
                    return e6.value;
                  throw this.currentLine++, new Error("Invalid key.");
                }
              }
              parseZone() {
                const e6 = this.getCurrentRecord();
                if (e6.type === s3.ZONE_ADJUSTMENTS) {
                  const t6 = [];
                  for (; ; )
                    try {
                      const i5 = this.extract(e6, this.consumeTime);
                      this.consumeSpaceForRecord(e6);
                      let r4 = false;
                      "-" === e6.value[e6.cur] && (r4 = true, e6.cur += 1);
                      const n4 = this.extract(e6, this.consumeTypedTime);
                      t6.push({ time: i5, typedTime: n4, back: r4 });
                    } catch (e7) {
                      break;
                    }
                  if (0 === t6.length)
                    throw new Error("Invalid zone adjustments");
                  return this.currentLine++, t6;
                }
                return [];
              }
              parseRepeat() {
                const e6 = [];
                for (; ; ) {
                  const t6 = this.getCurrentRecord();
                  if (t6.type !== s3.REPEAT)
                    break;
                  {
                    const i5 = this.extract(t6, this.consumeRepeatInterval), r4 = this.parseTypedTime(t6);
                    e6.push({ repeatInterval: i5, typedTimes: r4 }), this.currentLine++;
                  }
                }
                return e6;
              }
              parseTypedTime(e6) {
                const t6 = [];
                for (; ; )
                  try {
                    this.consumeSpaceForRecord(e6), t6.push(this.extract(e6, this.consumeTypedTime));
                  } catch (e7) {
                    break;
                  }
                if (0 === t6.length)
                  throw new Error("Invalid typed time.");
                return t6;
              }
              parseTime() {
                const e6 = this.getCurrentRecord(), t6 = this.extract(e6, this.consumeTime);
                this.consumeSpaceForRecord(e6);
                const i5 = this.extract(e6, this.consumeTime);
                return this.currentLine++, { startTime: t6, stopTime: i5 };
              }
              parseBandWidth() {
                const e6 = [];
                for (; this.currentLine < this.records.length; ) {
                  const t6 = this.getCurrentRecord();
                  if (t6.type !== s3.BANDWIDTH)
                    break;
                  {
                    const i5 = this.extractOneOrMore(t6, u3);
                    if (":" !== t6.value[t6.cur])
                      throw new Error("Invalid bandwidth field.");
                    t6.cur++;
                    const r4 = this.extractOneOrMore(t6, a3);
                    e6.push({ bwtype: i5, bandwidth: r4 }), this.currentLine++;
                  }
                }
                return e6;
              }
              parseVersion() {
                const e6 = this.getCurrentRecord();
                if (e6.type !== s3.VERSION)
                  throw new Error("first sdp record must be version");
                const t6 = e6.value.slice(0, this.consumeOneOrMore(e6.value, 0, a3));
                if (t6.length !== e6.value.length)
                  throw new Error('invalid proto version, "v='.concat(e6.value, '"'));
                return this.currentLine++, t6;
              }
              parseOrigin() {
                const e6 = this.getCurrentRecord();
                if (e6.type !== s3.ORIGIN)
                  throw new Error("second line of sdp must be origin");
                const t6 = this.extractOneOrMore(e6, d3);
                this.consumeSpaceForRecord(e6);
                const i5 = this.extractOneOrMore(e6, a3);
                this.consumeSpaceForRecord(e6);
                const r4 = this.extractOneOrMore(e6, a3);
                this.consumeSpaceForRecord(e6);
                const n4 = this.extractOneOrMore(e6, u3);
                this.consumeSpaceForRecord(e6);
                const o4 = this.extractOneOrMore(e6, u3);
                this.consumeSpaceForRecord(e6);
                const c4 = this.extract(e6, this.consumeUnicastAddress);
                return this.currentLine++, { username: t6, sessId: i5, sessVersion: r4, nettype: n4, addrtype: o4, unicastAddress: c4 };
              }
              parseSessionName() {
                const e6 = this.getCurrentRecord();
                if (e6.type === s3.SESSION_NAME) {
                  const t6 = this.extract(e6, this.consumeText);
                  return this.currentLine++, t6;
                }
              }
              parseInformation() {
                const e6 = this.getCurrentRecord();
                if (e6.type !== s3.INFORMATION)
                  return;
                const t6 = this.extract(e6, this.consumeText);
                return this.currentLine++, t6;
              }
              parseUri() {
                const e6 = this.getCurrentRecord();
                if (e6.type === s3.URI)
                  return this.currentLine++, e6.value;
              }
              parseEmail() {
                const e6 = [];
                for (; ; ) {
                  const t6 = this.getCurrentRecord();
                  if (t6.type !== s3.EMAIL)
                    break;
                  e6.push(t6.value), this.currentLine++;
                }
                return e6;
              }
              parsePhone() {
                const e6 = [];
                for (; ; ) {
                  const t6 = this.getCurrentRecord();
                  if (t6.type !== s3.PHONE)
                    break;
                  e6.push(t6.value), this.currentLine++;
                }
                return e6;
              }
              parseConnection() {
                const e6 = this.getCurrentRecord();
                if (e6.type === s3.CONNECTION) {
                  const t6 = this.extractOneOrMore(e6, u3);
                  this.consumeSpaceForRecord(e6);
                  const i5 = this.extractOneOrMore(e6, u3);
                  this.consumeSpaceForRecord(e6);
                  const r4 = this.extract(e6, this.consumeAddress);
                  return this.currentLine++, { nettype: t6, addrtype: i5, address: r4 };
                }
              }
              parseMedia() {
                const e6 = this.getCurrentRecord(), t6 = this.extract(e6, this.consumeToken);
                this.consumeSpaceForRecord(e6);
                let i5 = this.extract(e6, this.consumePort);
                "/" === e6.value[e6.cur] && (e6.cur += 1, i5 += this.extract(e6, this.consumeInteger)), this.consumeSpaceForRecord(e6);
                const r4 = [];
                for (r4.push(this.extract(e6, this.consumeToken)); "/" === e6.value[e6.cur]; )
                  e6.cur += 1, r4.push(this.extract(e6, this.consumeToken));
                if (0 === r4.length)
                  throw new Error("Invalid proto");
                const n4 = this.parseFmt(e6);
                return this.currentLine++, { mediaType: t6, port: i5, protos: r4, fmts: n4 };
              }
              parseTimeFields() {
                const e6 = [];
                for (; this.getCurrentRecord().type === s3.TIME; ) {
                  const t6 = this.parseTime(), i5 = this.parseRepeat(), r4 = this.parseZone();
                  e6.push({ time: t6, repeats: i5, zones: r4 });
                }
                return e6;
              }
              parseMediaDescription() {
                const e6 = [];
                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s3.MEDIA; ) {
                  const t6 = this.parseMedia(), i5 = this.parseInformation(), r4 = this.parseConnections(), n4 = this.parseBandWidth(), o4 = this.parseKey(), s4 = this.parseMediaAttributes(t6);
                  e6.push({ media: t6, information: i5, connections: r4, bandwidths: n4, key: o4, attributes: s4 });
                }
                return e6;
              }
              parseConnections() {
                const e6 = [];
                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s3.CONNECTION; )
                  e6.push(this.parseConnection());
                return e6;
              }
              parseFmt(e6) {
                const t6 = [];
                for (; ; )
                  try {
                    this.consumeSpaceForRecord(e6), t6.push(this.extract(e6, this.consumeToken));
                  } catch (e7) {
                    break;
                  }
                if (0 === t6.length)
                  throw new Error("Invalid fmts");
                return t6;
              }
              extract(e6, t6, ...i5) {
                const r4 = t6.call(this, e6.value, e6.cur, ...i5), n4 = e6.value.slice(e6.cur, r4);
                return e6.cur = r4, n4;
              }
              extractOneOrMore(e6, t6) {
                const i5 = this.consumeOneOrMore(e6.value, e6.cur, t6), r4 = e6.value.slice(e6.cur, i5);
                return e6.cur = i5, r4;
              }
              consumeSpaceForRecord(e6) {
                if (e6.value[e6.cur] !== o3)
                  throw new Error("Invalid space at ".concat(e6.cur, "."));
                e6.cur += 1;
              }
            }
            class v3 extends C3 {
              constructor(...e6) {
                super(...e6), _3(this, "attributes", void 0), _3(this, "digested", false);
              }
              extractOneOrMore(e6, t6, i5) {
                const r4 = this.consumeOneOrMore(e6.attValue, e6._cur, t6), n4 = e6.attValue.slice(e6._cur, r4), [o4, s4] = i5 || [];
                if ("number" == typeof o4 && n4.length < o4)
                  throw new Error("error in length, should be more or equal than ".concat(o4, " characters."));
                if ("number" == typeof s4 && n4.length > s4)
                  throw new Error("error in length, should be less or equal than ".concat(s4, " characters."));
                return e6._cur = r4, n4;
              }
              consumeAttributeSpace(e6) {
                if (e6.attValue[e6._cur] !== o3)
                  throw new Error("Invalid space at ".concat(e6._cur, "."));
                e6._cur += 1;
              }
              extract(e6, t6, ...i5) {
                if (!e6.attValue)
                  throw new Error("Nothing to extract from attValue.");
                const r4 = t6.call(this, e6.attValue, e6._cur, ...i5), n4 = e6.attValue.slice(e6._cur, r4);
                return e6._cur = r4, n4;
              }
              atEnd(e6) {
                if (!e6.attValue)
                  throw new Error();
                return e6._cur >= e6.attValue.length;
              }
              peekChar(e6) {
                if (!e6.attValue)
                  throw new Error();
                return e6.attValue[e6._cur];
              }
              peek(e6, t6) {
                if (!e6.attValue)
                  throw new Error();
                for (let i5 = 0; i5 < t6.length; i5++)
                  if (t6[i5] !== e6.attValue[e6._cur + i5])
                    return false;
                return true;
              }
              parseIceUfrag(e6) {
                if (this.attributes.iceUfrag)
                  throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");
                this.attributes.iceUfrag = this.extractOneOrMore(e6, g3, [4, 256]);
              }
              parseIcePwd(e6) {
                if (this.attributes.icePwd)
                  throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");
                this.attributes.icePwd = this.extractOneOrMore(e6, g3, [22, 256]);
              }
              parseIceOptions(e6) {
                if (this.attributes.iceOptions)
                  throw new Error("Invalid ice-options, should be only one 'ice-options' line");
                const t6 = [];
                for (; !this.atEnd(e6); ) {
                  t6.push(this.extractOneOrMore(e6, g3));
                  try {
                    this.consumeAttributeSpace(e6);
                  } catch (t7) {
                    if (this.atEnd(e6))
                      break;
                    throw t7;
                  }
                }
                this.attributes.iceOptions = t6;
              }
              parseFingerprint(e6) {
                const t6 = this.extract(e6, this.consumeToken);
                this.consumeAttributeSpace(e6);
                const i5 = this.extract(e6, this.consumeTill);
                this.attributes.fingerprints.push({ hashFunction: t6, fingerprint: i5 });
              }
              parseExtmap(e6) {
                const t6 = this.extractOneOrMore(e6, a3);
                let i5;
                "/" === this.peekChar(e6) && (this.extract(e6, this.consume, "/"), i5 = this.extract(e6, this.consumeToken)), this.consumeAttributeSpace(e6);
                const r4 = this.extract(e6, this.consumeTill, o3), n4 = I3(I3({ entry: parseInt(t6, 10) }, i5 && { direction: i5 }), {}, { extensionName: r4 });
                this.peekChar(e6) === o3 && (this.consumeAttributeSpace(e6), n4.extensionAttributes = this.extract(e6, this.consumeTill)), this.attributes.extmaps.push(n4);
              }
              parseSetup(e6) {
                if (this.attributes.setup)
                  throw new Error("must only be one single 'a=setup' line.");
                const t6 = this.extract(e6, this.consumeTill);
                if ("active" !== t6 && "passive" !== t6 && "actpass" !== t6 && "holdconn" !== t6)
                  throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");
                this.attributes.setup = t6;
              }
            }
            class T3 extends v3 {
              constructor(...e6) {
                super(...e6), _3(this, "attributes", { unrecognized: [], groups: [], extmaps: [], fingerprints: [], identities: [] });
              }
              parse(e6) {
                if (this.digested)
                  throw new Error("already digested");
                try {
                  switch (e6.attField) {
                    case "group":
                      this.parseGroup(e6);
                      break;
                    case "ice-lite":
                      this.parseIceLite();
                      break;
                    case "ice-ufrag":
                      this.parseIceUfrag(e6);
                      break;
                    case "ice-pwd":
                      this.parseIcePwd(e6);
                      break;
                    case "ice-options":
                      this.parseIceOptions(e6);
                      break;
                    case "fingerprint":
                      this.parseFingerprint(e6);
                      break;
                    case "setup":
                      this.parseSetup(e6);
                      break;
                    case "tls-id":
                      this.parseTlsId(e6);
                      break;
                    case "identity":
                      this.parseIdentity(e6);
                      break;
                    case "extmap":
                      this.parseExtmap(e6);
                      break;
                    case "msid-semantic":
                      this.parseMsidSemantic(e6);
                      break;
                    default:
                      e6.ignored = true, this.attributes.unrecognized.push(e6);
                  }
                } catch (t6) {
                  throw console.error("parsing session attribute ".concat(e6.attField, ' error, "a=').concat(e6.attField, ":").concat(e6.attValue, '"')), t6;
                }
                if (!e6.ignored && e6.attValue && !this.atEnd(e6))
                  throw new Error("attribute parsing error");
              }
              digest() {
                return this.digested = true, this.attributes;
              }
              parseGroup(e6) {
                const t6 = this.extract(e6, this.consumeToken), i5 = [];
                for (; !this.atEnd(e6) && this.peekChar(e6) === o3; )
                  this.consumeAttributeSpace(e6), i5.push(this.extract(e6, this.consumeToken));
                this.attributes.groups.push({ semantic: t6, identificationTag: i5 });
              }
              parseIceLite() {
                if (this.attributes.iceLite)
                  throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");
                this.attributes.iceLite = true;
              }
              parseTlsId(e6) {
                if (this.attributes.tlsId)
                  throw new Error("must be only one tld-id line");
                this.attributes.tlsId = this.extractOneOrMore(e6, E3);
              }
              parseIdentity(e6) {
                const t6 = this.extractOneOrMore(e6, f3), i5 = [];
                for (; !this.atEnd(e6) && this.peekChar(e6) === o3; ) {
                  this.consumeAttributeSpace(e6);
                  const t7 = this.extract(e6, this.consumeToken);
                  this.extract(e6, this.consume, "=");
                  const r4 = this.extractOneOrMore(e6, (e7) => e7 !== o3 && p3(e7));
                  i5.push({ name: t7, value: r4 });
                }
                this.attributes.identities.push({ assertionValue: t6, extensions: i5 });
              }
              parseMsidSemantic(e6) {
                this.peekChar(e6) === o3 && this.consumeAttributeSpace(e6);
                const t6 = { semantic: this.extract(e6, this.consumeToken), identifierList: [] };
                for (; ; ) {
                  try {
                    this.consumeAttributeSpace(e6);
                  } catch (e7) {
                    break;
                  }
                  if ("*" === this.peekChar(e6)) {
                    this.extract(e6, this.consume, "*"), t6.applyForAll = true;
                    break;
                  }
                  {
                    const i5 = this.extract(e6, this.consumeTill, o3);
                    t6.identifierList.push(i5);
                  }
                }
                this.attributes.msidSemantic = t6;
              }
            }
            class R3 extends v3 {
              constructor(e6) {
                super(), _3(this, "attributes", void 0), -1 !== e6.protos.indexOf("RTP") || e6.protos.indexOf("rtp"), this.attributes = { unrecognized: [], candidates: [], extmaps: [], fingerprints: [], imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [] };
              }
              parse(e6) {
                if (this.digested)
                  throw new Error("already digested");
                try {
                  switch (e6.attField) {
                    case "extmap":
                      this.parseExtmap(e6);
                      break;
                    case "setup":
                      this.parseSetup(e6);
                      break;
                    case "ice-ufrag":
                      this.parseIceUfrag(e6);
                      break;
                    case "ice-pwd":
                      this.parseIcePwd(e6);
                      break;
                    case "ice-options":
                      this.parseIceOptions(e6);
                      break;
                    case "candidate":
                      this.parseCandidate(e6);
                      break;
                    case "remote-candidate":
                      this.parseRemoteCandidate(e6);
                      break;
                    case "end-of-candidates":
                      this.parseEndOfCandidates();
                      break;
                    case "fingerprint":
                      this.parseFingerprint(e6);
                      break;
                    case "rtpmap":
                      this.parseRtpmap(e6);
                      break;
                    case "ptime":
                      this.parsePtime(e6);
                      break;
                    case "maxptime":
                      this.parseMaxPtime(e6);
                      break;
                    case "sendrecv":
                    case "recvonly":
                    case "sendonly":
                    case "inactive":
                      this.parseDirection(e6);
                      break;
                    case "ssrc":
                      this.parseSSRC(e6);
                      break;
                    case "fmtp":
                      this.parseFmtp(e6);
                      break;
                    case "rtcp-fb":
                      this.parseRtcpFb(e6);
                      break;
                    case "rtcp-mux":
                      this.parseRTCPMux();
                      break;
                    case "rtcp-mux-only":
                      this.parseRTCPMuxOnly();
                      break;
                    case "rtcp-rsize":
                      this.parseRTCPRsize();
                      break;
                    case "rtcp":
                      this.parseRTCP(e6);
                      break;
                    case "mid":
                      this.parseMid(e6);
                      break;
                    case "msid":
                      this.parseMsid(e6);
                      break;
                    case "imageattr":
                      this.parseImageAttr(e6);
                      break;
                    case "rid":
                      this.parseRid(e6);
                      break;
                    case "simulcast":
                      this.parseSimulcast(e6);
                      break;
                    case "sctp-port":
                      this.parseSctpPort(e6);
                      break;
                    case "max-message-size":
                      this.parseMaxMessageSize(e6);
                      break;
                    case "ssrc-group":
                      this.parseSSRCGroup(e6);
                      break;
                    default:
                      e6.ignored = true, this.attributes.unrecognized.push(e6);
                  }
                } catch (t6) {
                  throw console.error("parsing media attribute ".concat(e6.attField, ' error, "a=').concat(e6.attField, ":").concat(e6.attValue, '"')), t6;
                }
                if (!e6.ignored && e6.attValue && !this.atEnd(e6))
                  throw new Error("attribute parsing error");
              }
              parseCandidate(e6) {
                const t6 = this.extractOneOrMore(e6, g3, [1, 32]);
                this.consumeAttributeSpace(e6);
                const i5 = this.extractOneOrMore(e6, a3, [1, 5]);
                this.consumeAttributeSpace(e6);
                const r4 = this.extract(e6, this.consumeToken);
                this.consumeAttributeSpace(e6);
                const n4 = this.extractOneOrMore(e6, a3, [1, 10]);
                this.consumeAttributeSpace(e6);
                const s4 = this.extract(e6, this.consumeAddress);
                this.consumeAttributeSpace(e6);
                const d4 = this.extract(e6, this.consumePort);
                this.consumeAttributeSpace(e6), this.extract(e6, this.consume, "typ"), this.consumeAttributeSpace(e6);
                const u4 = { foundation: t6, componentId: i5, transport: r4, priority: n4, connectionAddress: s4, port: d4, type: this.extract(e6, this.consumeToken), extension: {} };
                for (this.peek(e6, " raddr") && (this.extract(e6, this.consume, " raddr"), this.consumeAttributeSpace(e6), u4.relAddr = this.extract(e6, this.consumeAddress)), this.peek(e6, " rport") && (this.extract(e6, this.consume, " rport"), this.consumeAttributeSpace(e6), u4.relPort = this.extract(e6, this.consumePort)); this.peekChar(e6) === o3; ) {
                  this.consumeAttributeSpace(e6);
                  const t7 = this.extract(e6, this.consumeToken);
                  this.consumeAttributeSpace(e6), u4.extension[t7] = this.extractOneOrMore(e6, c3);
                }
                this.attributes.candidates.push(u4);
              }
              parseRemoteCandidate(e6) {
                const t6 = [];
                for (; ; ) {
                  const i5 = this.extractOneOrMore(e6, a3, [1, 5]);
                  this.consumeAttributeSpace(e6);
                  const r4 = this.extract(e6, this.consumeAddress);
                  this.consumeAttributeSpace(e6);
                  const n4 = this.extract(e6, this.consumePort);
                  t6.push({ componentId: i5, connectionAddress: r4, port: n4 });
                  try {
                    this.consumeAttributeSpace(e6);
                  } catch (e7) {
                    break;
                  }
                }
                this.attributes.remoteCandidatesList.push(t6);
              }
              parseEndOfCandidates() {
                if (this.attributes.endOfCandidates)
                  throw new Error("must be only one line of end-of-candidates");
                this.attributes.endOfCandidates = true;
              }
              parseRtpmap(e6) {
                const t6 = this.extract(e6, this.consumeToken);
                this.consumeAttributeSpace(e6);
                const i5 = this.extract(e6, this.consumeTill, "/");
                this.extract(e6, this.consume, "/");
                const r4 = { encodingName: i5, clockRate: this.extractOneOrMore(e6, a3) };
                this.atEnd(e6) || "/" !== this.peekChar(e6) || (this.extract(e6, this.consume, "/"), r4.encodingParameters = parseInt(this.extract(e6, this.consumeTill), 10));
                const n4 = this.attributes.payloads.find((e7) => e7.payloadType === parseInt(t6, 10));
                n4 ? n4.rtpMap = r4 : this.attributes.payloads.push({ payloadType: parseInt(t6, 10), rtpMap: r4, rtcpFeedbacks: [] });
              }
              parsePtime(e6) {
                if (this.attributes.ptime)
                  throw new Error("must be only one line of ptime");
                this.attributes.ptime = this.extract(e6, this.consumeTill);
              }
              parseMaxPtime(e6) {
                if (this.attributes.maxPtime)
                  throw new Error("must be only one line of ptime");
                this.attributes.maxPtime = this.extract(e6, this.consumeTill);
              }
              parseDirection(e6) {
                if (this.attributes.direction)
                  throw new Error("must be only one line of direction info");
                this.attributes.direction = e6.attField;
              }
              parseSSRC(e6) {
                const t6 = this.extractOneOrMore(e6, a3);
                this.consumeAttributeSpace(e6);
                const i5 = this.extract(e6, this.consumeTill, ":");
                let r4;
                ":" === this.peekChar(e6) && (this.extract(e6, this.consume, ":"), r4 = this.extract(e6, this.consumeTill));
                const n4 = this.attributes.ssrcs.find((e7) => e7.ssrcId === parseInt(t6, 10));
                n4 ? n4.attributes[i5] = r4 : this.attributes.ssrcs.push({ ssrcId: parseInt(t6, 10), attributes: { [i5]: r4 } });
              }
              parseFmtp(e6) {
                const t6 = this.extract(e6, this.consumeTill, o3);
                this.consumeAttributeSpace(e6);
                const i5 = this.extract(e6, this.consumeTill), r4 = {};
                i5.split(";").forEach((e7) => {
                  let [t7, i6] = e7.split("=");
                  t7 = t7.trim();
                  const n5 = "string" == typeof i6 ? i6.trim() : null;
                  "string" == typeof t7 && t7.length > 0 && (r4[t7] = n5);
                });
                const n4 = this.attributes.payloads.find((e7) => e7.payloadType === parseInt(t6, 10));
                n4 ? n4.fmtp = { parameters: r4 } : this.attributes.payloads.push({ payloadType: parseInt(t6, 10), rtcpFeedbacks: [], fmtp: { parameters: r4 } });
              }
              parseFmtParameters(e6) {
                const t6 = {}, i5 = this.extract(e6, this.consumeTill, "=");
                e6._cur++;
                const r4 = this.extract(e6, this.consumeTill, ";");
                for (t6[i5] = r4; ";" === e6.attValue[e6._cur]; ) {
                  const i6 = this.extract(e6, this.consumeTill, "=");
                  e6._cur++;
                  const r5 = this.extract(e6, this.consumeTill, ";");
                  t6[i6] = r5;
                }
                return t6;
              }
              parseRtcpFb(e6) {
                let t6 = "";
                t6 = "*" === this.peekChar(e6) ? this.extract(e6, this.consume, "*") : this.extract(e6, this.consumeTill, o3), this.consumeAttributeSpace(e6);
                const i5 = this.extract(e6, this.consumeTill, o3);
                let r4;
                switch (i5) {
                  case "trr-int":
                    r4 = { type: i5, interval: this.extract(e6, this.consumeTill) };
                    break;
                  case "ack":
                  case "nack":
                  default: {
                    const t7 = { type: i5 };
                    this.peekChar(e6) === o3 && (this.consumeAttributeSpace(e6), t7.parameter = this.extract(e6, this.consumeToken), this.peekChar(e6) === o3 && (t7.additional = this.extract(e6, this.consumeTill))), r4 = t7;
                  }
                }
                if ("*" === t6)
                  this.attributes.rtcpFeedbackWildcards.push(r4);
                else {
                  const e7 = this.attributes.payloads.find((e8) => e8.payloadType === parseInt(t6, 10));
                  e7 ? e7.rtcpFeedbacks.push(r4) : this.attributes.payloads.push({ payloadType: parseInt(t6, 10), rtcpFeedbacks: [r4] });
                }
              }
              parseRTCPMux() {
                if (this.attributes.rtcpMux)
                  throw new Error("must be single line of rtcp-mux");
                this.attributes.rtcpMux = true;
              }
              parseRTCPMuxOnly() {
                if (this.attributes.rtcpMuxOnly)
                  throw new Error("must be single line of rtcp-only");
                this.attributes.rtcpMuxOnly = true;
              }
              parseRTCPRsize() {
                if (this.attributes.rtcpRsize)
                  throw new Error("must be single line of rtcp-rsize");
                this.attributes.rtcpRsize = true;
              }
              parseRTCP(e6) {
                if (this.attributes.rtcp)
                  throw new Error("must be single line of rtcp");
                const t6 = { port: this.extract(e6, this.consumePort) };
                this.peekChar(e6) === o3 && (this.consumeAttributeSpace(e6), t6.netType = this.extractOneOrMore(e6, u3), this.consumeAttributeSpace(e6), t6.addressType = this.extractOneOrMore(e6, u3), this.consumeAttributeSpace(e6), t6.address = this.extract(e6, this.consumeAddress)), this.attributes.rtcp = t6;
              }
              parseMsid(e6) {
                const t6 = { id: this.extractOneOrMore(e6, u3, [1, 64]) };
                this.peekChar(e6) === o3 && (this.consumeAttributeSpace(e6), t6.appdata = this.extractOneOrMore(e6, u3, [1, 64])), this.attributes.msids.push(t6);
              }
              parseImageAttr(e6) {
                this.attributes.imageattr.push(e6.attValue);
              }
              parseRid(e6) {
                const t6 = this.extractOneOrMore(e6, (e7) => A3(e7) || a3(e7) || "_" === e7 || "-" === e7);
                this.consumeAttributeSpace(e6);
                const i5 = { id: t6, direction: this.extract(e6, this.consumeToken), params: [] };
                if (this.peekChar(e6) === o3) {
                  if (this.consumeAttributeSpace(e6), this.peek(e6, "pt=")) {
                    this.extract(e6, this.consume, "pt=");
                    const t7 = [];
                    for (; ; ) {
                      const i6 = this.extract(e6, this.consumeToken);
                      t7.push(i6);
                      try {
                        this.extract(e6, this.consume, ",");
                      } catch (e7) {
                        break;
                      }
                    }
                    i5.payloads = t7, this.peekChar(e6) === o3 && this.extract(e6, this.consume, o3);
                  }
                  for (; ; ) {
                    const t7 = this.extract(e6, this.consumeToken);
                    switch (t7) {
                      case "depend": {
                        const r4 = { type: t7, rids: this.extract(e6, this.consume, "=").split(",") };
                        i5.params.push(r4);
                        break;
                      }
                      case "max-width":
                      case "height-width":
                      case "max-fps":
                      case "max-fs":
                      case "max-br":
                      case "max-pps":
                      case "max-bpp":
                      default: {
                        const r4 = { type: t7 };
                        "=" === this.peekChar(e6) && (this.extract(e6, this.consume, "="), r4.val = this.extract(e6, this.consumeTill, ";")), i5.params.push(r4);
                      }
                    }
                    try {
                      this.extract(e6, this.consume, ";");
                    } catch (e7) {
                      break;
                    }
                  }
                }
                this.attributes.rids.push(i5);
              }
              parseSimulcast(e6) {
                if (this.attributes.simulcast)
                  throw new Error("must be single line of simulcast");
                this.attributes.simulcast = e6.attValue, this.extract(e6, this.consumeTill);
              }
              parseSctpPort(e6) {
                this.attributes.sctpPort = this.extractOneOrMore(e6, a3, [1, 5]);
              }
              parseMaxMessageSize(e6) {
                this.attributes.maxMessageSize = this.extractOneOrMore(e6, a3, [1, void 0]);
              }
              digest() {
                return this.digested = true, this.attributes;
              }
              parseMid(e6) {
                this.attributes.mid = this.extract(e6, this.consumeToken);
              }
              parseSSRCGroup(e6) {
                const t6 = this.extract(e6, this.consumeToken), i5 = [];
                for (; ; )
                  try {
                    this.consumeAttributeSpace(e6);
                    const t7 = this.extract(e6, this.consumeInteger);
                    i5.push(parseInt(t7, 10));
                  } catch (e7) {
                    break;
                  }
                this.attributes.ssrcGroups.push({ semantic: t6, ssrcIds: i5 });
              }
            }
            function y3(e6, t6, i5) {
              return t6 in e6 ? Object.defineProperty(e6, t6, { value: i5, enumerable: true, configurable: true, writable: true }) : e6[t6] = i5, e6;
            }
            class w3 {
              constructor() {
                y3(this, "eol", n3);
              }
              print(e6, t6) {
                let i5 = "";
                return t6 && (this.eol = t6), i5 += this.printVersion(e6.version), i5 += this.printOrigin(e6.origin), i5 += this.printSessionName(e6.sessionName), i5 += this.printInformation(e6.information), i5 += this.printUri(e6.uri), i5 += this.printEmail(e6.emails), i5 += this.printPhone(e6.phones), i5 += this.printConnection(e6.connection), i5 += this.printBandwidth(e6.bandwidths), i5 += this.printTimeFields(e6.timeFields), i5 += this.printKey(e6.key), i5 += this.printSessionAttributes(e6.attributes), i5 += this.printMediaDescription(e6.mediaDescriptions), i5;
              }
              printVersion(e6) {
                return "v=".concat(e6).concat(this.eol);
              }
              printOrigin(e6) {
                return "o=".concat(e6.username, " ").concat(e6.sessId, " ").concat(e6.sessVersion, " ").concat(e6.nettype, " ").concat(e6.addrtype, " ").concat(e6.unicastAddress).concat(this.eol);
              }
              printSessionName(e6) {
                return e6 ? "s=".concat(e6).concat(this.eol) : "";
              }
              printInformation(e6) {
                return e6 ? "i=".concat(e6).concat(this.eol) : "";
              }
              printUri(e6) {
                return e6 ? "u=".concat(e6).concat(this.eol) : "";
              }
              printEmail(e6) {
                let t6 = "";
                for (const i5 of e6)
                  t6 += "e=".concat(i5).concat(this.eol);
                return t6;
              }
              printPhone(e6) {
                let t6 = "";
                for (const i5 of e6)
                  t6 += "e=".concat(i5).concat(this.eol);
                return t6;
              }
              printConnection(e6) {
                return e6 ? "c=".concat(e6.nettype, " ").concat(e6.addrtype, " ").concat(e6.address).concat(this.eol) : "";
              }
              printBandwidth(e6) {
                let t6 = "";
                for (const i5 of e6)
                  t6 += "b=".concat(i5.bwtype, ":").concat(i5.bandwidth).concat(this.eol);
                return t6;
              }
              printTimeFields(e6) {
                let t6 = "";
                for (const i5 of e6) {
                  t6 += "t=".concat(i5.time.startTime, " ").concat(i5.time.startTime).concat(this.eol);
                  for (const e7 of i5.repeats)
                    t6 += "r=".concat(e7.repeatInterval, " ").concat(e7.typedTimes.join(" ")).concat(this.eol);
                  i5.zoneAdjustments && (t6 += "z=", t6 += "z=".concat(i5.zoneAdjustments.map((e7) => "".concat(e7.time, " ").concat(e7.back ? "-" : "", " ").concat(e7.typedTime)).join(" ")).concat(this.eol), t6 += this.eol);
                }
                return t6;
              }
              printKey(e6) {
                return e6 ? "k=".concat(e6).concat(this.eol) : "";
              }
              printAttributes(e6) {
                let t6 = "";
                for (const i5 of e6)
                  t6 += "a=".concat(i5.attField).concat(i5.attValue ? ":".concat(i5.attValue) : "").concat(this.eol);
                return t6;
              }
              printMediaDescription(e6) {
                let t6 = "";
                for (const i5 of e6)
                  t6 += this.printMedia(i5.media), t6 += this.printInformation(i5.information), t6 += this.printConnections(i5.connections), t6 += this.printBandwidth(i5.bandwidths), t6 += this.printKey(i5.key), t6 += this.printMediaAttributes(i5);
                return t6;
              }
              printConnections(e6) {
                let t6 = "";
                for (const i5 of e6)
                  t6 += this.printConnection(i5);
                return t6;
              }
              printMedia(e6) {
                return "m=".concat(e6.mediaType, " ").concat(e6.port, " ").concat(e6.protos.join("/"), " ").concat(e6.fmts.join(" ")).concat(this.eol);
              }
              printSessionAttributes(e6) {
                return new N3(this.eol).print(e6);
              }
              printMediaAttributes(e6) {
                return new O3(this.eol).print(e6);
              }
            }
            class b3 {
              constructor(e6) {
                y3(this, "eol", void 0), this.eol = e6;
              }
              printIceUfrag(e6) {
                return void 0 === e6 ? "" : "a=ice-ufrag:".concat(e6).concat(this.eol);
              }
              printIcePwd(e6) {
                return void 0 === e6 ? "" : "a=ice-pwd:".concat(e6).concat(this.eol);
              }
              printIceOptions(e6) {
                return void 0 === e6 ? "" : "a=ice-options:".concat(e6.join(o3)).concat(this.eol);
              }
              printFingerprints(e6) {
                return e6.length > 0 ? e6.map((e7) => "a=fingerprint:".concat(e7.hashFunction).concat(o3).concat(e7.fingerprint)).join(this.eol) + this.eol : "";
              }
              printExtmap(e6) {
                return e6.map((e7) => "a=extmap:".concat(e7.entry).concat(e7.direction ? "/".concat(e7.direction) : "").concat(o3).concat(e7.extensionName).concat(e7.extensionAttributes ? "".concat(o3).concat(e7.extensionAttributes) : "").concat(this.eol)).join("");
              }
              printSetup(e6) {
                return void 0 === e6 ? "" : "a=setup:".concat(e6).concat(this.eol);
              }
              printUnrecognized(e6) {
                return e6.map((e7) => "a=".concat(e7.attField).concat(e7.attValue ? ":".concat(e7.attValue) : "").concat(this.eol)).join("");
              }
            }
            class N3 extends b3 {
              print(e6) {
                let t6 = "";
                return t6 += this.printGroups(e6.groups), t6 += this.printMsidSemantic(e6.msidSemantic), t6 += this.printIceLite(e6.iceLite), t6 += this.printIceUfrag(e6.iceUfrag), t6 += this.printIcePwd(e6.icePwd), t6 += this.printIceOptions(e6.iceOptions), t6 += this.printFingerprints(e6.fingerprints), t6 += this.printSetup(e6.setup), t6 += this.printTlsId(e6.tlsId), t6 += this.printIdentity(e6.identities), t6 += this.printExtmap(e6.extmaps), t6 += this.printUnrecognized(e6.unrecognized), t6;
              }
              printGroups(e6) {
                let t6 = "";
                return e6.length > 0 && (t6 += e6.map((e7) => "a=group:".concat(e7.semantic).concat(e7.identificationTag.map((e8) => "".concat(o3).concat(e8)).join("")).concat(this.eol)).join("")), t6;
              }
              printIceLite(e6) {
                return void 0 === e6 ? "" : "a=ice-lite" + this.eol;
              }
              printTlsId(e6) {
                return e6 ? "a=tls-id:".concat(e6).concat(this.eol) : "";
              }
              printIdentity(e6) {
                return 0 === e6.length ? "" : e6.map((e7) => "a=identity:".concat(e7.assertionValue).concat(e7.extensions.map((e8) => "".concat(o3).concat(e8.name).concat(e8.value ? "=".concat(e8.value) : "")))).join(this.eol) + this.eol;
              }
              printMsidSemantic(e6) {
                if (!e6)
                  return "";
                let t6 = "a=msid-semantic:".concat(e6.semantic);
                return e6.applyForAll ? t6 += "".concat(o3, "*") : e6.identifierList.length > 0 && (t6 += e6.identifierList.map((e7) => "".concat(o3).concat(e7))), t6 + this.eol;
              }
            }
            class O3 extends b3 {
              print(e6) {
                const t6 = e6.attributes;
                let i5 = "";
                return i5 += this.printRTCP(t6.rtcp), i5 += this.printIceUfrag(t6.iceUfrag), i5 += this.printIcePwd(t6.icePwd), i5 += this.printIceOptions(t6.iceOptions), i5 += this.printCandidates(t6.candidates), i5 += this.printRemoteCandidatesList(t6.remoteCandidatesList), i5 += this.printEndOfCandidates(t6.endOfCandidates), i5 += this.printFingerprints(t6.fingerprints), i5 += this.printSetup(t6.setup), i5 += this.printMid(t6.mid), i5 += this.printExtmap(t6.extmaps), i5 += this.printRTPRelated(t6), i5 += this.printPtime(t6.ptime), i5 += this.printMaxPtime(t6.maxPtime), i5 += this.printDirection(t6.direction), i5 += this.printSSRCGroups(t6.ssrcGroups), i5 += this.printSSRC(t6.ssrcs), i5 += this.printRTCPMux(t6.rtcpMux), i5 += this.printRTCPMuxOnly(t6.rtcpMuxOnly), i5 += this.printRTCPRsize(t6.rtcpRsize), i5 += this.printMSId(t6.msids), i5 += this.printImageattr(t6.imageattr), i5 += this.printRid(t6.rids), i5 += this.printSimulcast(t6.simulcast), i5 += this.printSCTPPort(t6.sctpPort), i5 += this.printMaxMessageSize(t6.maxMessageSize), i5 += this.printUnrecognized(t6.unrecognized), i5;
              }
              printCandidates(e6) {
                return e6.map((e7) => "a=candidate:".concat(e7.foundation).concat(o3).concat(e7.componentId).concat(o3).concat(e7.transport).concat(o3).concat(e7.priority).concat(o3).concat(e7.connectionAddress).concat(o3).concat(e7.port).concat(o3, "typ").concat(o3).concat(e7.type).concat(e7.relAddr ? "".concat(o3, "raddr").concat(o3).concat(e7.relAddr) : "").concat(e7.relPort ? "".concat(o3, "rport").concat(o3).concat(e7.relPort) : "").concat(Object.keys(e7.extension).map((t6) => "".concat(o3).concat(t6).concat(o3).concat(e7.extension[t6])).join("")).concat(this.eol)).join("");
              }
              printRemoteCandidatesList(e6) {
                return e6.map((e7) => "a=remote-candidates:".concat(e7.join(o3)).concat(this.eol)).join("");
              }
              printEndOfCandidates(e6) {
                return void 0 === e6 ? "" : "a=end-of-candidates" + this.eol;
              }
              printRTPRelated(e6) {
                if (!e6.payloads)
                  return "";
                const t6 = e6.payloads;
                let i5 = "";
                i5 += e6.rtcpFeedbackWildcards.map((e7) => this.printRTCPFeedback("*", e7)).join("");
                for (const e7 of t6)
                  i5 += this.printRtpMap(e7.payloadType, e7.rtpMap), i5 += this.printFmtp(e7.payloadType, e7.fmtp), i5 += e7.rtcpFeedbacks.map((t7) => this.printRTCPFeedback(e7.payloadType, t7)).join("");
                return i5;
              }
              printFmtp(e6, t6) {
                if (!t6)
                  return "";
                const i5 = Object.keys(t6.parameters);
                return 1 === i5.length && null === t6.parameters[i5[0]] ? "a=fmtp:".concat(e6).concat(o3).concat(i5[0]).concat(this.eol) : "a=fmtp:".concat(e6).concat(o3).concat(Object.keys(t6.parameters).map((e7) => "".concat(e7, "=").concat(t6.parameters[e7])).join(";")).concat(this.eol);
              }
              printRtpMap(e6, t6) {
                return t6 ? "a=rtpmap:".concat(e6).concat(o3).concat(t6.encodingName, "/").concat(t6.clockRate).concat(t6.encodingParameters ? "/".concat(t6.encodingParameters) : "").concat(this.eol) : "";
              }
              printRTCPFeedback(e6, t6) {
                let i5 = "a=rtcp-fb:".concat(e6).concat(o3), r4 = t6;
                switch (r4.type) {
                  case "trr-int":
                    i5 += "ttr-int".concat(o3).concat(r4.interval);
                    break;
                  case "ack":
                  case "nack":
                  default:
                    r4 = r4, i5 += "".concat(r4.type), r4.parameter && (i5 += "".concat(o3).concat(r4.parameter), r4.additional && (i5 += "".concat(o3).concat(r4.additional)));
                }
                return i5 + this.eol;
              }
              printPtime(e6) {
                return void 0 === e6 ? "" : "a=ptime:".concat(e6).concat(this.eol);
              }
              printMaxPtime(e6) {
                return void 0 === e6 ? "" : "a=maxptime:".concat(e6).concat(this.eol);
              }
              printDirection(e6) {
                return void 0 === e6 ? "" : "a=".concat(e6).concat(this.eol);
              }
              printSSRC(e6) {
                return e6.map((e7) => Object.keys(e7.attributes).map((t6) => "a=ssrc:".concat(e7.ssrcId.toString(10)).concat(o3).concat(t6).concat(e7.attributes[t6] ? ":".concat(e7.attributes[t6]) : "").concat(this.eol)).join("")).join("");
              }
              printRTCPMux(e6) {
                return void 0 === e6 ? "" : "a=rtcp-mux".concat(this.eol);
              }
              printRTCPMuxOnly(e6) {
                return void 0 === e6 ? "" : "a=rtcp-mux-only".concat(this.eol);
              }
              printRTCPRsize(e6) {
                return void 0 === e6 ? "" : "a=rtcp-rsize".concat(this.eol);
              }
              printRTCP(e6) {
                if (void 0 === e6)
                  return "";
                let t6 = "a=rtcp:".concat(e6.port);
                return e6.netType && (t6 += "".concat(o3).concat(e6.netType)), e6.addressType && (t6 += "".concat(o3).concat(e6.addressType)), e6.address && (t6 += "".concat(o3).concat(e6.address)), t6 + this.eol;
              }
              printMSId(e6) {
                return e6.map((e7) => "a=msid:".concat(e7.id).concat(e7.appdata ? "".concat(o3).concat(e7.appdata) : "").concat(this.eol)).join("");
              }
              printImageattr(e6) {
                return e6.map((e7) => "a=imageattr:".concat(e7).concat(this.eol)).join("");
              }
              printRid(e6) {
                return e6.map((e7) => {
                  let t6 = "a=rid:".concat(e7.id).concat(o3).concat(e7.direction);
                  return e7.payloads && (t6 += "".concat(o3, "pt=").concat(e7.payloads.join(","))), e7.params.length > 0 && (t6 += "".concat(o3).concat(e7.params.map((e8) => "depend" === e8.type ? "depend=".concat(e8.rids.join(",")) : "".concat(e8.type, "=").concat(e8.val)).join(";"))), t6 + this.eol;
                }).join("");
              }
              printSimulcast(e6) {
                return void 0 === e6 ? "" : "a=simulcast:".concat(e6).concat(this.eol);
              }
              printSCTPPort(e6) {
                return void 0 === e6 ? "" : "a=sctp-port:".concat(e6).concat(this.eol);
              }
              printMaxMessageSize(e6) {
                return void 0 === e6 ? "" : "a=max-message-size:".concat(e6).concat(this.eol);
              }
              printMid(e6) {
                return void 0 === e6 ? "" : "a=mid:".concat(e6).concat(this.eol);
              }
              printSSRCGroups(e6) {
                return e6.map((e7) => "a=ssrc-group:".concat(e7.semantic).concat(e7.ssrcIds.map((e8) => "".concat(o3).concat(e8.toString(10))).join("")).concat(this.eol)).join("");
              }
            }
            function D3(e6) {
              return new S3().parse(e6);
            }
            function P3(e6, t6) {
              return new w3().print(e6, t6);
            }
          } }, t4 = {};
          function i3(r3) {
            if (t4[r3])
              return t4[r3].exports;
            var n3 = t4[r3] = { exports: {} };
            return e4[r3](n3, n3.exports, i3), n3.exports;
          }
          return i3.d = (e5, t5) => {
            for (var r3 in t5)
              i3.o(t5, r3) && !i3.o(e5, r3) && Object.defineProperty(e5, r3, { enumerable: true, get: t5[r3] });
          }, i3.o = (e5, t5) => Object.prototype.hasOwnProperty.call(e5, t5), i3.r = (e5) => {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e5, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e5, "__esModule", { value: true });
          }, i3(8);
        })();
      }(K$);
      class c1 {
        constructor(e3) {
          MN(this, "sessionDesc", void 0), MN(this, "localCapabilities", void 0), MN(this, "rtpCapabilities", void 0), MN(this, "candidates", void 0), MN(this, "iceParameters", void 0), MN(this, "dtlsParameters", void 0), MN(this, "setup", void 0), MN(this, "currentMidIndex", void 0), MN(this, "cname", void 0), e3 = OK(e3);
          const { remoteIceParameters: t3, remoteDtlsParameters: i3, candidates: r3, remoteRTPCapabilities: n3, remoteSetup: o3, localCapabilities: s3, sdkCodec: a3, cname: c3 } = e3, d3 = K$.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n");
          this.rtpCapabilities = n3, this.candidates = r3, this.iceParameters = t3, this.dtlsParameters = i3, this.setup = o3, this.localCapabilities = s3, this.cname = c3;
          for (let e4 = 0; e4 < d3.mediaDescriptions.length; e4++) {
            const s4 = d3.mediaDescriptions[e4];
            if (s4.attributes.iceUfrag = t3.iceUfrag, s4.attributes.icePwd = t3.icePwd, s4.attributes.fingerprints = i3.fingerprints, s4.attributes.candidates = r3, s4.attributes.setup = o3, "video" === s4.media.mediaType) {
              s4.media.fmts = n3.videoCodecs.map((e6) => e6.payloadType.toString(10));
              const e5 = n3.videoCodecs.filter((e6) => {
                var t4;
                return null === (t4 = e6.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase().includes(a3);
              });
              if (0 === e5.length)
                throw new Error("Codec ".concat(a3, " not supported by remote SDP."));
              s4.attributes.payloads = e5, s4.attributes.extmaps = n3.videoExtensions;
            }
            "audio" === s4.media.mediaType && (s4.media.fmts = n3.audioCodecs.map((e5) => e5.payloadType.toString(10)), s4.attributes.payloads = n3.audioCodecs, s4.attributes.extmaps = n3.audioExtensions), d3.mediaDescriptions[e4] = this.mungMediaDesc(s4);
          }
          this.sessionDesc = d3, this.currentMidIndex = d3.mediaDescriptions.length - 1;
        }
        toString() {
          return K$.exports.print(this.sessionDesc);
        }
        send(e3, t3, i3) {
          const { ssrcs: r3, ssrcGroups: n3 } = z$(t3, this.cname), o3 = this.sessionDesc.mediaDescriptions.find((t4) => e3 === AB.VIDEO ? "video" === t4.media.mediaType : "audio" === t4.media.mediaType), s3 = r3[0].attributes.label, a3 = r3[0].attributes.mslabel;
          return o3.attributes.ssrcs = o3.attributes.ssrcs.concat(r3), o3.attributes.ssrcGroups = o3.attributes.ssrcGroups.concat(n3), { id: s3, mslabel: a3 };
        }
        batchSend(e3) {
          return e3.map((e4) => {
            let { kind: t3, ssrcMsg: i3 } = e4;
            return this.send(t3, i3, void 0);
          });
        }
        stopSending(e3) {
          this.sessionDesc.mediaDescriptions.forEach((t3) => {
            const i3 = [], r3 = [], n3 = [];
            t3.attributes.ssrcs.forEach((t4) => {
              e3.includes(t4.attributes.label || "") ? n3.push(t4) : i3.push(t4);
            }), t3.attributes.ssrcGroups.forEach((e4) => {
              n3.map((e5) => e5.ssrcId).includes(e4.ssrcIds[0]) || r3.push(e4);
            }), t3.attributes.ssrcs = i3, t3.attributes.ssrcGroups = r3;
          });
        }
        mute(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
          if (!t3)
            throw new Error("mediaDescription not found with ".concat(e3, " in remote SDP when calling RemoteSDP.mute."));
          t3.attributes.direction = "inactive";
        }
        unmute(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
          if (!t3)
            throw new Error("mediaDescription not found with ".concat(e3, " in remote SDP when calling RemoteSDP.unmute."));
          t3.attributes.direction = "sendonly";
        }
        receive(e3, t3, i3) {
          e3.forEach((e4, t4) => {
            const i4 = e4._mediaStreamTrack, r3 = this.sessionDesc.mediaDescriptions.findIndex((e5) => e5.attributes.mid === i4.kind), n3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[r3], e4);
            this.sessionDesc.mediaDescriptions[r3] = n3;
          });
        }
        stopReceiving(e3) {
        }
        restartICE(e3) {
          e3 = OK(e3), this.iceParameters = e3, this.sessionDesc.mediaDescriptions.forEach((t3) => {
            t3.attributes.iceUfrag = e3.iceUfrag, t3.attributes.icePwd = e3.icePwd;
          });
        }
        predictReceivingMids(e3) {
          const t3 = [];
          for (let i3 = 0; i3 < e3; i3++)
            t3.push((this.currentMidIndex + i3 + 1).toString(10));
          return t3;
        }
        mungRecvMediaDsec(e3, t3) {
          const i3 = OK(e3);
          return Z$(i3, t3), e1(i3, t3), i3;
        }
        updateRecvMedia(e3, t3) {
          const i3 = this.sessionDesc.mediaDescriptions.findIndex((t4) => t4.attributes.mid === e3);
          if (-1 !== i3) {
            const e4 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i3], t3);
            this.sessionDesc.mediaDescriptions[i3] = e4;
          }
        }
        bumpMid(e3) {
          this.currentMidIndex += e3;
        }
        updateTrackLabel(e3, t3, i3) {
          const r3 = this.sessionDesc.mediaDescriptions.find((t4) => e3 === AB.VIDEO ? "video" === t4.attributes.mid : "audio" === t4.attributes.mid);
          if (r3) {
            const e4 = r3.attributes.ssrcs.find((e5) => e5.attributes.label === t3);
            var n3;
            if (e4)
              e4.attributes.label = i3, null === (n3 = e4.attributes.msid) || void 0 === n3 || n3.replace(t3, i3);
          }
        }
        mungMediaDesc(e3) {
          const t3 = OK(e3);
          return $$(t3), function(e4) {
            const t4 = e4.attributes.extmaps.find((e5) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e5.extensionName);
            t4 && e4.attributes.extmaps.splice(e4.attributes.extmaps.indexOf(t4), 1), e4.attributes.payloads.forEach((e5) => {
              const t5 = e5.rtcpFeedbacks.findIndex((e6) => "transport-cc" === e6.type);
              -1 !== t5 && e5.rtcpFeedbacks.splice(t5, 1);
            });
          }(t3), t3;
        }
        getSSRC(e3) {
          for (const t3 of this.sessionDesc.mediaDescriptions)
            for (const i3 of t3.attributes.ssrcs)
              if (i3.attributes.label === e3)
                return [i3];
        }
      }
      function d1(e3) {
        if (Array.isArray(e3))
          return e3.map(function(e4) {
            return e4;
          });
        if (!u1(e3))
          return e3;
        var t3 = {};
        for (var i3 in e3)
          u1(e3[i3]) || Array.isArray(e3[i3]) ? t3[i3] = d1(e3[i3]) : t3[i3] = e3[i3];
        return t3;
      }
      function u1(e3) {
        return !("object" != typeof e3 || Array.isArray(e3) || !e3);
      }
      var h1 = function() {
        function e3(e4) {
          this.input = [], this.size = e4;
        }
        return e3.prototype.add = function(e4) {
          this.input.push(e4), this.input.length > this.size && this.input.splice(0, 1);
        }, e3.prototype.diffMean = function() {
          return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;
        }, e3;
      }(), A1 = function(e3, t3) {
        return (A1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t4) {
          e4.__proto__ = t4;
        } || function(e4, t4) {
          for (var i3 in t4)
            t4.hasOwnProperty(i3) && (e4[i3] = t4[i3]);
        })(e3, t3);
      };
      function l1(e3, t3) {
        function i3() {
          this.constructor = e3;
        }
        A1(e3, t3), e3.prototype = null === t3 ? Object.create(t3) : (i3.prototype = t3.prototype, new i3());
      }
      var p1 = function() {
        return (p1 = Object.assign || function(e3) {
          for (var t3, i3 = 1, r3 = arguments.length; i3 < r3; i3++)
            for (var n3 in t3 = arguments[i3])
              Object.prototype.hasOwnProperty.call(t3, n3) && (e3[n3] = t3[n3]);
          return e3;
        }).apply(this, arguments);
      };
      function g1(e3, t3, i3, r3) {
        return new (i3 || (i3 = Promise))(function(n3, o3) {
          function s3(e4) {
            try {
              c3(r3.next(e4));
            } catch (e5) {
              o3(e5);
            }
          }
          function a3(e4) {
            try {
              c3(r3.throw(e4));
            } catch (e5) {
              o3(e5);
            }
          }
          function c3(e4) {
            e4.done ? n3(e4.value) : new i3(function(t4) {
              t4(e4.value);
            }).then(s3, a3);
          }
          c3((r3 = r3.apply(e3, t3 || [])).next());
        });
      }
      function E1(e3, t3) {
        var i3, r3, n3, o3, s3 = { label: 0, sent: function() {
          if (1 & n3[0])
            throw n3[1];
          return n3[1];
        }, trys: [], ops: [] };
        return o3 = { next: a3(0), throw: a3(1), return: a3(2) }, "function" == typeof Symbol && (o3[Symbol.iterator] = function() {
          return this;
        }), o3;
        function a3(o4) {
          return function(a4) {
            return function(o5) {
              if (i3)
                throw new TypeError("Generator is already executing.");
              for (; s3; )
                try {
                  if (i3 = 1, r3 && (n3 = 2 & o5[0] ? r3.return : o5[0] ? r3.throw || ((n3 = r3.return) && n3.call(r3), 0) : r3.next) && !(n3 = n3.call(r3, o5[1])).done)
                    return n3;
                  switch (r3 = 0, n3 && (o5 = [2 & o5[0], n3.value]), o5[0]) {
                    case 0:
                    case 1:
                      n3 = o5;
                      break;
                    case 4:
                      return s3.label++, { value: o5[1], done: false };
                    case 5:
                      s3.label++, r3 = o5[1], o5 = [0];
                      continue;
                    case 7:
                      o5 = s3.ops.pop(), s3.trys.pop();
                      continue;
                    default:
                      if (!(n3 = s3.trys, (n3 = n3.length > 0 && n3[n3.length - 1]) || 6 !== o5[0] && 2 !== o5[0])) {
                        s3 = 0;
                        continue;
                      }
                      if (3 === o5[0] && (!n3 || o5[1] > n3[0] && o5[1] < n3[3])) {
                        s3.label = o5[1];
                        break;
                      }
                      if (6 === o5[0] && s3.label < n3[1]) {
                        s3.label = n3[1], n3 = o5;
                        break;
                      }
                      if (n3 && s3.label < n3[2]) {
                        s3.label = n3[2], s3.ops.push(o5);
                        break;
                      }
                      n3[2] && s3.ops.pop(), s3.trys.pop();
                      continue;
                  }
                  o5 = t3.call(e3, s3);
                } catch (e4) {
                  o5 = [6, e4], r3 = 0;
                } finally {
                  i3 = n3 = 0;
                }
              if (5 & o5[0])
                throw o5[1];
              return { value: o5[0] ? o5[1] : void 0, done: true };
            }([o4, a4]);
          };
        }
      }
      var f1, m1 = { address: "unknown", candidateType: "unknown", id: "unknown", port: 0, priority: 0, protocol: "unknown", type: "unknown" }, I1 = { timestamp: 0, bitrate: { actualEncoded: 0, transmit: 0 }, sendPacketLossRate: 0, recvPacketLossRate: 0, videoRecv: [], videoSend: [], audioRecv: [], audioSend: [], selectedCandidatePair: { id: "unknown", localCandidate: m1, remoteCandidate: m1 } }, _1 = { firsCount: 0, nacksCount: 0, plisCount: 0, framesDecodeCount: 0, framesDecodeInterval: 0, framesDecodeFreezeTime: 0, decodeFrameRate: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, qpSumPerFrame: 0 }, C1 = { firsCount: 0, nacksCount: 0, plisCount: 0, frameCount: 0, bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, qpSumPerFrame: 0 }, S1 = { bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0 }, v1 = { jitterBufferMs: 0, jitterMs: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, receivedFrames: 0, droppedFrames: 0 }, T1 = function() {
        function e3(e4, t3) {
          var i3 = this;
          this.videoIsReady = false, this.videoIsReady2 = {}, this.stats = d1(I1), this.isFirstVideoReceived = {}, this.isFirstVideoDecoded = {}, this.isFirstAudioReceived = {}, this.isFirstAudioDecoded = {}, this.lossRateWindowStats = [], this.pc = e4, this.options = t3, this.intervalTimer = window.setInterval(function() {
            return g1(i3, void 0, void 0, function() {
              return E1(this, function(e5) {
                return this.updateStats(), [2];
              });
            });
          }, this.options.updateInterval);
        }
        return e3.prototype.getStats = function() {
          return this.stats;
        }, e3.prototype.setVideoIsReady = function(e4) {
          this.videoIsReady = e4;
        }, e3.prototype.setVideoIsReady2 = function(e4, t3) {
          this.videoIsReady2[e4] = t3;
        }, e3.prototype.getVideoIsReady = function(e4) {
          return this.videoIsReady2[e4] || false;
        }, e3.prototype.setIsFirstAudioDecoded = function(e4) {
        }, e3.prototype.destroy = function() {
          window.clearInterval(this.intervalTimer), this.pc = void 0;
        }, e3.prototype.calcLossRate = function(e4) {
          var t3 = this;
          this.lossRateWindowStats.push(e4), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);
          for (var i3 = this.lossRateWindowStats.length, r3 = 0, n3 = 0, o3 = 0, s3 = 0, a3 = function(a4) {
            e4[a4].forEach(function(e5, c4) {
              if (t3.lossRateWindowStats[i3 - 1][a4][c4] && t3.lossRateWindowStats[0][a4][c4]) {
                var d4 = t3.lossRateWindowStats[i3 - 1][a4][c4].packets - t3.lossRateWindowStats[0][a4][c4].packets, u3 = t3.lossRateWindowStats[i3 - 1][a4][c4].packetsLost - t3.lossRateWindowStats[0][a4][c4].packetsLost;
                "videoSend" === a4 || "audioSend" === a4 ? (r3 += d4, o3 += u3) : (n3 += d4, s3 += u3), Number.isNaN(d4) || Number.isNaN(d4) ? e5.packetLostRate = 0 : e5.packetLostRate = d4 <= 0 || u3 <= 0 ? 0 : u3 / (d4 + u3);
              }
            });
          }, c3 = 0, d3 = ["videoSend", "audioSend", "videoRecv", "audioRecv"]; c3 < d3.length; c3++) {
            a3(d3[c3]);
          }
          e4.sendPacketLossRate = r3 <= 0 || o3 <= 0 ? 0 : o3 / (r3 + o3), e4.recvPacketLossRate = n3 <= 0 || s3 <= 0 ? 0 : s3 / (n3 + s3);
        }, e3;
      }(), R1 = function(e3) {
        function t3() {
          var t4 = null !== e3 && e3.apply(this, arguments) || this;
          return t4._stats = I1, t4.lastDecodeVideoReceiverStats = /* @__PURE__ */ new Map(), t4;
        }
        return l1(t3, e3), t3.prototype.updateStats = function() {
          return g1(this, void 0, void 0, function() {
            var e4, t4, i3, r3;
            return E1(this, function(n3) {
              switch (n3.label) {
                case 0:
                  return [4, this._getStats()];
                case 1:
                  return e4 = n3.sent(), t4 = this.statsResponsesToObjects(e4), this._stats = d1(I1), i3 = t4.filter(function(e5) {
                    return "ssrc" === e5.type;
                  }), this.processSSRCStats(i3), (r3 = t4.find(function(e5) {
                    return "VideoBwe" === e5.type;
                  })) && this.processBandwidthStats(r3), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats, [2];
              }
            });
          });
        }, t3.prototype.processBandwidthStats = function(e4) {
          this._stats.bitrate = { actualEncoded: Number(e4.googActualEncBitrate), targetEncoded: Number(e4.googTargetEncBitrate), retransmit: Number(e4.googRetransmitBitrate), transmit: Number(e4.googTransmitBitrate) }, this._stats.sendBandwidth = Number(e4.googAvailableSendBandwidth);
        }, t3.prototype.processSSRCStats = function(e4) {
          var t4 = this;
          e4.forEach(function(e5) {
            var i3 = e5.id.includes("send");
            switch (e5.mediaType + "_" + (i3 ? "send" : "recv")) {
              case "video_send":
                var r3 = d1(C1);
                r3.codec = e5.googCodecName, r3.adaptionChangeReason = "none", e5.googCpuLimitedResolution && (r3.adaptionChangeReason = "cpu"), e5.googBandwidthLimitedResolution && (r3.adaptionChangeReason = "bandwidth"), r3.avgEncodeMs = Number(e5.googAvgEncodeMs), r3.inputFrame = { width: Number(e5.googFrameWidthInput) || Number(e5.googFrameWidthSent), height: Number(e5.googFrameHeightInput) || Number(e5.googFrameHeightSent), frameRate: Number(e5.googFrameRateInput) }, r3.sentFrame = { width: Number(e5.googFrameWidthSent), height: Number(e5.googFrameHeightSent), frameRate: Number(e5.googFrameRateInput) }, r3.firsCount = Number(e5.googFirReceived), r3.nacksCount = Number(e5.googNacksReceived), r3.plisCount = Number(e5.googPlisReceived), r3.frameCount = Number(e5.framesEncoded), r3.bytes = Number(e5.bytesSent), r3.packets = Number(e5.packetsSent), r3.packetsLost = Number(e5.packetsLost), r3.ssrc = Number(e5.ssrc), r3.rttMs = Number(e5.googRtt || 0), t4._stats.videoSend.push(r3), t4._stats.rtt = r3.rttMs;
                break;
              case "video_recv":
                var n3 = d1(_1), o3 = t4.lastDecodeVideoReceiverStats.get(Number(e5.ssrc));
                if (n3.codec = e5.googCodecName, n3.targetDelayMs = Number(e5.googTargetDelayMs), n3.renderDelayMs = Number(e5.googRenderDelayMs), n3.currentDelayMs = Number(e5.googCurrentDelayMs), n3.minPlayoutDelayMs = Number(e5.googMinPlayoutDelayMs), n3.decodeMs = Number(e5.googDecodeMs), n3.maxDecodeMs = Number(e5.googMaxDecodeMs), n3.receivedFrame = { width: Number(e5.googFrameWidthReceived), height: Number(e5.googFrameHeightReceived), frameRate: Number(e5.googFrameRateReceived) }, n3.decodedFrame = { width: Number(e5.googFrameWidthReceived), height: Number(e5.googFrameHeightReceived), frameRate: Number(e5.googFrameRateDecoded) }, n3.decodeFrameRate = Number(e5.googFrameRateDecoded), n3.outputFrame = { width: Number(e5.googFrameWidthReceived), height: Number(e5.googFrameHeightReceived), frameRate: Number(e5.googFrameRateOutput) }, n3.jitterBufferMs = Number(e5.googJitterBufferMs), n3.firsCount = Number(e5.googFirsSent), n3.nacksCount = Number(e5.googNacksSent), n3.plisCount = Number(e5.googPlisSent), n3.framesDecodeCount = Number(e5.framesDecoded), n3.bytes = Number(e5.bytesReceived), n3.packets = Number(e5.packetsReceived), n3.packetsLost = Number(e5.packetsLost), n3.ssrc = Number(e5.ssrc), n3.packets > 0 && !t4.isFirstVideoReceived[n3.ssrc] && (t4.onFirstVideoReceived && t4.onFirstVideoReceived(n3.ssrc), t4.isFirstVideoReceived[n3.ssrc] = true), n3.framesDecodeCount > 0 && !t4.isFirstVideoDecoded[n3.ssrc] && (t4.onFirstVideoDecoded && t4.onFirstVideoDecoded(n3.ssrc, n3.decodedFrame.width, n3.decodedFrame.height), t4.isFirstVideoDecoded[n3.ssrc] = true), o3) {
                  var s3 = o3.stats, a3 = Date.now() - o3.lts;
                  n3.framesDecodeFreezeTime = s3.framesDecodeFreezeTime, n3.framesDecodeInterval = s3.framesDecodeInterval, n3.framesDecodeCount > s3.framesDecodeCount && t4.isFirstVideoDecoded[n3.ssrc] ? (o3.lts = Date.now(), n3.framesDecodeInterval = a3, n3.framesDecodeInterval >= t4.options.freezeRateLimit && (t4.getVideoIsReady(parseInt(e5.ssrc, 10)) ? n3.framesDecodeFreezeTime += n3.framesDecodeInterval : t4.setVideoIsReady2(parseInt(e5.ssrc, 10), true))) : n3.framesDecodeCount < o3.stats.framesDecodeCount && (n3.framesDecodeInterval = 0);
                }
                t4.lastDecodeVideoReceiverStats.set(n3.ssrc, { stats: p1({}, n3), lts: Date.now() }), t4._stats.videoRecv.push(n3);
                break;
              case "audio_recv":
                var c3 = d1(v1);
                c3.codec = e5.googCodecName, c3.outputLevel = Math.abs(Number(e5.audioOutputLevel)) / 32767, c3.decodingCNG = Number(e5.googDecodingCNG), c3.decodingCTN = Number(e5.googDecodingCTN), c3.decodingCTSG = Number(e5.googDecodingCTSG), c3.decodingNormal = Number(e5.googDecodingNormal), c3.decodingPLC = Number(e5.googDecodingPLC), c3.decodingPLCCNG = Number(e5.googDecodingPLCCNG), c3.expandRate = Number(e5.googExpandRate), c3.accelerateRate = Number(e5.googAccelerateRate), c3.preemptiveExpandRate = Number(e5.googPreemptiveExpandRate), c3.secondaryDecodedRate = Number(e5.googSecondaryDecodedRate), c3.speechExpandRate = Number(e5.googSpeechExpandRate), c3.preferredJitterBufferMs = Number(e5.googPreferredJitterBufferMs), c3.jitterBufferMs = Number(e5.googJitterBufferMs), c3.jitterMs = Number(e5.googJitterReceived), c3.bytes = Number(e5.bytesReceived), c3.packets = Number(e5.packetsReceived), c3.packetsLost = Number(e5.packetsLost), c3.ssrc = Number(e5.ssrc), c3.receivedFrames = Number(e5.googDecodingCTN) || Number(e5.packetsReceived), c3.droppedFrames = Number(e5.googDecodingPLC) + Number(e5.googDecodingPLCCNG) || Number(e5.packetsLost), c3.receivedFrames > 0 && !t4.isFirstAudioReceived[c3.ssrc] && (t4.onFirstAudioReceived && t4.onFirstAudioReceived(c3.ssrc), t4.isFirstAudioReceived[c3.ssrc] = true), c3.decodingNormal > 0 && !t4.isFirstAudioDecoded[c3.ssrc] && (t4.onFirstAudioDecoded && t4.onFirstAudioDecoded(c3.ssrc), t4.isFirstAudioDecoded[c3.ssrc] = true), t4._stats.audioRecv.push(c3);
                break;
              case "audio_send":
                var d3 = d1(S1);
                d3.codec = e5.googCodecName, d3.inputLevel = Math.abs(Number(e5.audioInputLevel)) / 32767, d3.aecReturnLoss = Number(e5.googEchoCancellationReturnLoss || 0), d3.aecReturnLossEnhancement = Number(e5.googEchoCancellationReturnLossEnhancement || 0), d3.residualEchoLikelihood = Number(e5.googResidualEchoLikelihood || 0), d3.residualEchoLikelihoodRecentMax = Number(e5.googResidualEchoLikelihoodRecentMax || 0), d3.bytes = Number(e5.bytesSent), d3.packets = Number(e5.packetsSent), d3.packetsLost = Number(e5.packetsLost), d3.ssrc = Number(e5.ssrc), d3.rttMs = Number(e5.googRtt || 0), t4._stats.rtt = d3.rttMs, t4._stats.audioSend.push(d3);
            }
          });
        }, t3.prototype._getStats = function() {
          var e4 = this;
          return new Promise(function(t4, i3) {
            e4.pc.getStats(t4, i3);
          });
        }, t3.prototype.statsResponsesToObjects = function(e4) {
          var t4 = [];
          return e4.result().forEach(function(e5) {
            var i3 = { id: e5.id, timestamp: e5.timestamp.valueOf().toString(), type: e5.type };
            e5.names().forEach(function(t5) {
              i3[t5] = e5.stat(t5);
            }), t4.push(i3);
          }), t4;
        }, t3;
      }(T1);
      !function(e3) {
        e3.CERTIFICATE = "certificate", e3.CODEC = "codec", e3.CANDIDATE_PAIR = "candidate-pair", e3.LOCAL_CANDIDATE = "local-candidate", e3.REMOTE_CANDIDATE = "remote-candidate", e3.INBOUND = "inbound-rtp", e3.TRACK = "track", e3.OUTBOUND = "outbound-rtp", e3.PC = "peer-connection", e3.REMOTE_INBOUND = "remote-inbound-rtp", e3.REMOTE_OUTBOUND = "remote-outbound-rtp", e3.TRANSPORT = "transport", e3.CSRC = "csrc", e3.DATA_CHANNEL = "data-channel", e3.STREAM = "stream", e3.SENDER = "sender", e3.RECEIVER = "receiver";
      }(f1 || (f1 = {}));
      var y1, w1 = function(e3) {
        function t3() {
          var t4 = null !== e3 && e3.apply(this, arguments) || this;
          return t4._stats = I1, t4.lastDecodeVideoReceiverStats = /* @__PURE__ */ new Map(), t4.lastVideoFramesRecv = /* @__PURE__ */ new Map(), t4.lastVideoFramesSent = /* @__PURE__ */ new Map(), t4.lastVideoFramesDecode = /* @__PURE__ */ new Map(), t4.lastVideoJBDelay = /* @__PURE__ */ new Map(), t4.lastAudioJBDelay = /* @__PURE__ */ new Map(), t4.mediaBytesSent = /* @__PURE__ */ new Map(), t4.mediaBytesRetransmit = /* @__PURE__ */ new Map(), t4.mediaBytesTargetEncode = /* @__PURE__ */ new Map(), t4.lastEncoderMs = /* @__PURE__ */ new Map(), t4;
        }
        return l1(t3, e3), t3.prototype.updateStats = function() {
          return g1(this, void 0, void 0, function() {
            var e4, t4 = this;
            return E1(this, function(i3) {
              switch (i3.label) {
                case 0:
                  return e4 = this, [4, this.pc.getStats()];
                case 1:
                  return e4.report = i3.sent(), this._stats = d1(I1), this.report.forEach(function(e5) {
                    switch (e5.type) {
                      case f1.OUTBOUND:
                        "audio" === e5.mediaType ? t4.processAudioOutboundStats(e5) : "video" === e5.mediaType && t4.processVideoOutboundStats(e5);
                        break;
                      case f1.INBOUND:
                        "audio" === e5.mediaType ? t4.processAudioInboundStats(e5) : "video" === e5.mediaType && t4.processVideoInboundStats(e5);
                        break;
                      case f1.TRANSPORT:
                        var i4 = t4.report.get(e5.selectedCandidatePairId);
                        i4 && t4.processCandidatePairStats(i4);
                        break;
                      case f1.CANDIDATE_PAIR:
                        e5.selected && t4.processCandidatePairStats(e5);
                    }
                  }), this.updateSendBitrate(), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats, [2];
              }
            });
          });
        }, t3.prototype.processCandidatePairStats = function(e4) {
          if (this._stats.sendBandwidth = e4.availableOutgoingBitrate || 0, e4.currentRoundTripTime && (this._stats.rtt = 1e3 * e4.currentRoundTripTime), this._stats.videoSend.forEach(function(t5) {
            !t5.rttMs && e4.currentRoundTripTime && (t5.rttMs = 1e3 * e4.currentRoundTripTime);
          }), this._stats.audioSend.forEach(function(t5) {
            !t5.rttMs && e4.currentRoundTripTime && (t5.rttMs = 1e3 * e4.currentRoundTripTime);
          }), this._stats.selectedCandidatePair.id = e4.id, e4.localCandidateId) {
            var t4 = this.report.get(e4.localCandidateId);
            t4 && this.processCandidateStats(t4);
          }
          if (e4.remoteCandidateId) {
            var i3 = this.report.get(e4.remoteCandidateId);
            i3 && this.processCandidateStats(i3);
          }
        }, t3.prototype.processCandidateStats = function(e4) {
          var t4;
          e4.type === f1.LOCAL_CANDIDATE && (t4 = this._stats.selectedCandidatePair.localCandidate), e4.type === f1.REMOTE_CANDIDATE && (t4 = this._stats.selectedCandidatePair.remoteCandidate), t4 && (t4.type = e4.type, t4.id = e4.id, e4.address && (t4.address = e4.address), e4.candidateType && (t4.candidateType = e4.candidateType), e4.port && (t4.port = e4.port), e4.priority && (t4.priority = e4.priority), e4.protocol && (t4.protocol = e4.protocol), e4.relayProtocol && (t4.relayProtocol = e4.relayProtocol), e4.type === f1.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t4.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(p1({}, t4), p1({}, this.stats.selectedCandidatePair.localCandidate)), e4.type === f1.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t4.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(p1({}, t4), p1({}, this.stats.selectedCandidatePair.remoteCandidate)));
        }, t3.prototype.processAudioInboundStats = function(e4) {
          var t4 = this._stats.audioRecv.find(function(t5) {
            return t5.ssrc === e4.ssrc;
          });
          t4 || (t4 = d1(v1), this._stats.audioRecv.push(t4)), t4.ssrc = e4.ssrc, t4.packets = e4.packetsReceived, t4.packetsLost = e4.packetsLost, t4.bytes = e4.bytesReceived, t4.jitterMs = 1e3 * e4.jitter, e4.trackId && this.processAudioTrackReceiverStats(e4.trackId, t4), e4.codecId && (t4.codec = this.getCodecFromCodecStats(e4.codecId)), t4.receivedFrames || (t4.receivedFrames = e4.packetsReceived), t4.droppedFrames || (t4.droppedFrames = e4.packetsLost), t4.receivedFrames > 0 && !this.isFirstAudioReceived[t4.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t4.ssrc), this.isFirstAudioReceived[t4.ssrc] = true), t4.outputLevel && t4.outputLevel > 0 && !this.isFirstAudioDecoded[t4.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t4.ssrc), this.isFirstAudioDecoded[t4.ssrc] = true);
        }, t3.prototype.processVideoInboundStats = function(e4) {
          var t4 = this._stats.videoRecv.find(function(t5) {
            return t5.ssrc === e4.ssrc;
          });
          t4 || (t4 = d1(_1), this._stats.videoRecv.push(t4)), t4.ssrc = e4.ssrc, t4.packets = e4.packetsReceived, t4.packetsLost = e4.packetsLost, t4.bytes = e4.bytesReceived, t4.firsCount = e4.firCount, t4.nacksCount = e4.nackCount, t4.plisCount = e4.pliCount, t4.framesDecodeCount = e4.framesDecoded;
          var i3 = this.lastDecodeVideoReceiverStats.get(t4.ssrc), r3 = this.lastVideoFramesDecode.get(t4.ssrc), n3 = Date.now();
          if (t4.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t4.ssrc]) {
            var o3 = t4.decodedFrame ? t4.decodedFrame.width : 0, s3 = t4.decodedFrame ? t4.decodedFrame.height : 0;
            this.onFirstVideoDecoded && this.onFirstVideoDecoded(t4.ssrc, o3, s3), this.isFirstVideoDecoded[t4.ssrc] = true;
          }
          if (i3) {
            var a3 = i3.stats, c3 = n3 - i3.lts;
            t4.framesDecodeFreezeTime = a3.framesDecodeFreezeTime, t4.framesDecodeInterval = a3.framesDecodeInterval, !this.isFirstVideoDecoded[t4.ssrc] && c3 > this.options.firstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t4.ssrc), t4.framesDecodeCount > a3.framesDecodeCount && this.isFirstVideoDecoded[t4.ssrc] ? (i3.lts = Date.now(), t4.framesDecodeInterval = c3, t4.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e4.ssrc)) ? t4.framesDecodeFreezeTime += t4.framesDecodeInterval : this.setVideoIsReady2(parseInt(e4.ssrc, 10), true))) : t4.framesDecodeCount < a3.framesDecodeCount && (t4.framesDecodeInterval = 0), e4.framesDecoded && e4.qpSum && (i3.stats.framesDecodeCount > e4.framesDecoded ? t4.qpSumPerFrame = e4.qpSum / e4.framesDecoded : t4.qpSumPerFrame = (e4.qpSum - i3.qpSum) / (e4.framesDecoded - i3.stats.framesDecodeCount));
          }
          r3 && n3 - r3.lts >= 800 ? (t4.decodeFrameRate = Math.round((t4.framesDecodeCount - r3.count) / ((n3 - r3.lts) / 1e3)), this.lastVideoFramesDecode.set(t4.ssrc, { count: t4.framesDecodeCount, lts: n3, rate: t4.decodeFrameRate })) : r3 ? t4.decodeFrameRate = r3.rate : this.lastVideoFramesDecode.set(t4.ssrc, { count: t4.framesDecodeCount, lts: n3, rate: 0 }), e4.totalDecodeTime && (t4.decodeMs = 1e3 * e4.totalDecodeTime), e4.trackId && this.processVideoTrackReceiverStats(e4.trackId, t4), e4.codecId && (t4.codec = this.getCodecFromCodecStats(e4.codecId)), e4.framerateMean && (t4.framesRateFirefox = e4.framerateMean), t4.packets > 0 && !this.isFirstVideoReceived[t4.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t4.ssrc), this.isFirstVideoReceived[t4.ssrc] = true), this.lastDecodeVideoReceiverStats.set(t4.ssrc, { stats: p1({}, t4), lts: i3 ? i3.lts : Date.now(), qpSum: e4.qpSum });
        }, t3.prototype.processVideoOutboundStats = function(e4) {
          var t4 = this._stats.videoSend.find(function(t5) {
            return t5.ssrc === e4.ssrc;
          });
          t4 || (t4 = d1(C1), this._stats.videoSend.push(t4));
          var i3, r3 = this.mediaBytesSent.get(e4.ssrc);
          r3 ? r3.add(e4.bytesSent) : ((o3 = new h1(10)).add(e4.bytesSent), this.mediaBytesSent.set(e4.ssrc, o3));
          if (void 0 !== e4.retransmittedBytesSent) {
            var n3 = this.mediaBytesRetransmit.get(e4.ssrc);
            if (n3)
              n3.add(e4.retransmittedBytesSent);
            else
              (o3 = new h1(10)).add(e4.retransmittedBytesSent), this.mediaBytesRetransmit.set(e4.ssrc, o3);
          }
          if (e4.totalEncodedBytesTarget) {
            var o3, s3 = this.mediaBytesTargetEncode.get(e4.ssrc);
            if (s3)
              s3.add(e4.totalEncodedBytesTarget);
            else
              (o3 = new h1(10)).add(e4.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e4.ssrc, o3);
          }
          if (t4.ssrc = e4.ssrc, t4.bytes = e4.bytesSent, t4.packets = e4.packetsSent, t4.firsCount = e4.firCount, t4.nacksCount = e4.nackCount, t4.plisCount = e4.pliCount, t4.frameCount = e4.framesEncoded, t4.adaptionChangeReason = e4.qualityLimitationReason, e4.totalEncodeTime && e4.framesEncoded)
            if (!(i3 = this.lastEncoderMs.get(e4.ssrc)) || i3.lastFrameCount > e4.framesEncoded)
              t4.avgEncodeMs = 1e3 * e4.totalEncodeTime / e4.framesEncoded;
            else {
              var a3 = e4.framesEncoded - i3.lastFrameCount, c3 = e4.totalEncodeTime - i3.lastEncoderTime;
              t4.avgEncodeMs = 1e3 * c3 / a3;
            }
          e4.framesEncoded && e4.qpSum && (!(i3 = this.lastEncoderMs.get(e4.ssrc)) || i3.lastFrameCount > e4.framesEncoded ? t4.qpSumPerFrame = e4.qpSum / e4.framesEncoded : t4.qpSumPerFrame = (e4.qpSum - i3.lastQpSum) / (e4.framesEncoded - i3.lastFrameCount));
          if (this.lastEncoderMs.set(e4.ssrc, { lastFrameCount: e4.framesEncoded, lastEncoderTime: e4.totalEncodeTime, lastQpSum: e4.qpSum, lts: Date.now() }), e4.codecId && (t4.codec = this.getCodecFromCodecStats(e4.codecId)), e4.mediaSourceId && this.processVideoMediaSource(e4.mediaSourceId, t4), e4.trackId && this.processVideoTrackSenderStats(e4.trackId, t4), e4.remoteId)
            this.processRemoteInboundStats(e4.remoteId, t4);
          else {
            var d3 = this.findRemoteStatsId(e4.ssrc, f1.REMOTE_INBOUND);
            d3 && this.processRemoteInboundStats(d3, t4);
          }
        }, t3.prototype.processAudioOutboundStats = function(e4) {
          var t4 = this._stats.audioSend.find(function(t5) {
            return t5.ssrc === e4.ssrc;
          });
          if (t4 || (t4 = d1(S1), this._stats.audioSend.push(t4)), t4.ssrc = e4.ssrc, t4.packets = e4.packetsSent, t4.bytes = e4.bytesSent, e4.mediaSourceId && this.processAudioMediaSource(e4.mediaSourceId, t4), e4.codecId && (t4.codec = this.getCodecFromCodecStats(e4.codecId)), e4.trackId && this.processAudioTrackSenderStats(e4.trackId, t4), e4.remoteId)
            this.processRemoteInboundStats(e4.remoteId, t4);
          else {
            var i3 = this.findRemoteStatsId(e4.ssrc, f1.REMOTE_INBOUND);
            i3 && this.processRemoteInboundStats(i3, t4);
          }
        }, t3.prototype.findRemoteStatsId = function(e4, t4) {
          var i3 = Array.from(this.report.values()).find(function(i4) {
            return i4.type === t4 && i4.ssrc === e4;
          });
          return i3 ? i3.id : null;
        }, t3.prototype.processVideoMediaSource = function(e4, t4) {
          var i3 = this.report.get(e4);
          i3 && i3.width && i3.height && i3.framesPerSecond && (t4.inputFrame = { width: i3.width, height: i3.height, frameRate: i3.framesPerSecond });
        }, t3.prototype.processAudioMediaSource = function(e4, t4) {
          var i3 = this.report.get(e4);
          i3 && (t4.inputLevel = i3.audioLevel);
        }, t3.prototype.processVideoTrackSenderStats = function(e4, t4) {
          var i3 = this.report.get(e4);
          if (i3) {
            var r3 = 0, n3 = Date.now(), o3 = this.lastVideoFramesSent.get(t4.ssrc);
            o3 && n3 - o3.lts >= 800 ? (r3 = Math.round((i3.framesSent - o3.count) / ((n3 - o3.lts) / 1e3)), this.lastVideoFramesSent.set(t4.ssrc, { count: i3.framesSent, lts: n3, rate: r3 })) : o3 ? r3 = o3.rate : this.lastVideoFramesSent.set(t4.ssrc, { count: i3.framesSent, lts: n3, rate: 0 }), t4.sentFrame = { width: i3.frameWidth, height: i3.frameHeight, frameRate: r3 };
          }
        }, t3.prototype.processVideoTrackReceiverStats = function(e4, t4) {
          var i3 = this.report.get(e4);
          if (i3) {
            var r3 = this.lastVideoFramesRecv.get(t4.ssrc), n3 = Date.now();
            t4.framesReceivedCount = i3.framesReceived;
            var o3 = 0;
            if (r3 && n3 - r3.lts >= 800 ? (o3 = Math.round((i3.framesReceived - r3.count) / ((n3 - r3.lts) / 1e3)), this.lastVideoFramesRecv.set(t4.ssrc, { count: i3.framesReceived, lts: n3, rate: o3 })) : r3 ? o3 = r3.rate : this.lastVideoFramesRecv.set(t4.ssrc, { count: i3.framesReceived, lts: n3, rate: 0 }), t4.receivedFrame = { width: i3.frameWidth || 0, height: i3.frameHeight || 0, frameRate: o3 || 0 }, t4.decodedFrame = { width: i3.frameWidth || 0, height: i3.frameHeight || 0, frameRate: t4.decodeFrameRate || 0 }, t4.outputFrame = { width: i3.frameWidth || 0, height: i3.frameHeight || 0, frameRate: t4.decodeFrameRate || 0 }, i3.jitterBufferDelay && i3.jitterBufferEmittedCount) {
              var s3 = this.lastVideoJBDelay.get(t4.ssrc);
              this.lastVideoJBDelay.set(t4.ssrc, { jitterBufferDelay: i3.jitterBufferDelay, jitterBufferEmittedCount: i3.jitterBufferEmittedCount }), s3 || (s3 = { jitterBufferDelay: 0, jitterBufferEmittedCount: 0 });
              var a3 = 1e3 * (i3.jitterBufferDelay - s3.jitterBufferDelay) / (i3.jitterBufferEmittedCount - s3.jitterBufferEmittedCount);
              t4.jitterBufferMs = a3, t4.currentDelayMs = Math.round(a3);
            }
          }
        }, t3.prototype.processAudioTrackSenderStats = function(e4, t4) {
          var i3 = this.report.get(e4);
          i3 && (t4.aecReturnLoss = i3.echoReturnLoss || 0, t4.aecReturnLossEnhancement = i3.echoReturnLossEnhancement || 0);
        }, t3.prototype.processAudioTrackReceiverStats = function(e4, t4) {
          var i3 = this.report.get(e4);
          if (i3) {
            if (i3.removedSamplesForAcceleration && i3.totalSamplesReceived && (t4.accelerateRate = i3.removedSamplesForAcceleration / i3.totalSamplesReceived), i3.jitterBufferDelay && i3.jitterBufferEmittedCount) {
              var r3 = this.lastAudioJBDelay.get(t4.ssrc);
              this.lastAudioJBDelay.set(t4.ssrc, { jitterBufferDelay: i3.jitterBufferDelay, jitterBufferEmittedCount: i3.jitterBufferEmittedCount }), r3 || (r3 = { jitterBufferDelay: 0, jitterBufferEmittedCount: 0 });
              var n3 = 1e3 * (i3.jitterBufferDelay - r3.jitterBufferDelay) / (i3.jitterBufferEmittedCount - r3.jitterBufferEmittedCount);
              t4.jitterBufferMs = Math.round(n3);
            }
            t4.outputLevel = i3.audioLevel;
            var o3 = 1920;
            i3.totalSamplesDuration && i3.totalSamplesReceived && (o3 = i3.totalSamplesReceived / i3.totalSamplesDuration / 50, t4.receivedFrames = Math.round(i3.totalSamplesReceived / o3)), i3.concealedSamples && (t4.droppedFrames = Math.round(i3.concealedSamples / o3));
          }
        }, t3.prototype.processRemoteInboundStats = function(e4, t4) {
          var i3 = this.report.get(e4);
          i3 && (t4.packetsLost = i3.packetsLost, i3.roundTripTime && (t4.rttMs = 1e3 * i3.roundTripTime));
        }, t3.prototype.getCodecFromCodecStats = function(e4) {
          var t4 = this.report.get(e4);
          if (!t4)
            return "";
          var i3 = t4.mimeType.match(/\/(.*)$/);
          return i3 && i3[1] ? i3[1] : "";
        }, t3.prototype.updateSendBitrate = function() {
          var e4 = 0, t4 = null, i3 = null;
          this.mediaBytesSent.forEach(function(t5) {
            e4 += t5.diffMean();
          }), this.mediaBytesRetransmit.forEach(function(e5) {
            t4 = null === t4 ? e5.diffMean() : t4 + e5.diffMean();
          }), this.mediaBytesTargetEncode.forEach(function(e5) {
            i3 = null === i3 ? e5.diffMean() : i3 + e5.diffMean();
          });
          var r3 = null !== t4 ? e4 - t4 : e4;
          this._stats.bitrate = { actualEncoded: 8 * r3 / (this.options.updateInterval / 1e3), transmit: 8 * e4 / (this.options.updateInterval / 1e3) }, null !== t4 && (this._stats.bitrate.retransmit = 8 * t4 / (this.options.updateInterval / 1e3)), null !== i3 && (this._stats.bitrate.targetEncoded = 8 * i3 / (this.options.updateInterval / 1e3));
        }, t3;
      }(T1), b1 = function(e3) {
        function t3() {
          return null !== e3 && e3.apply(this, arguments) || this;
        }
        return l1(t3, e3), t3.prototype.updateStats = function() {
          return Promise.resolve();
        }, t3;
      }(T1);
      function N1(e3, t3, i3, r3, n3) {
        void 0 === t3 && (t3 = 250), void 0 === i3 && (i3 = 8), void 0 === r3 && (r3 = 500), void 0 === n3 && (n3 = 1e4);
        var o3, s3 = (o3 = navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i)) && o3[0] ? Number(o3[0].split("/")[1]) : null;
        return s3 ? s3 < 76 ? new R1(e3, { updateInterval: t3, lossRateInterval: i3, freezeRateLimit: r3, firstVideoDecodedTimeout: n3 }) : new w1(e3, { updateInterval: t3, lossRateInterval: i3, freezeRateLimit: r3, firstVideoDecodedTimeout: n3 }) : function(e4) {
          return !!window.RTCStatsReport && e4.getStats() instanceof Promise;
        }(e3) ? new w1(e3, { updateInterval: t3, lossRateInterval: i3, freezeRateLimit: r3, firstVideoDecodedTimeout: n3 }) : new b1(e3, { updateInterval: t3, lossRateInterval: i3, freezeRateLimit: r3, firstVideoDecodedTimeout: n3 });
      }
      function O1(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function D1(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? O1(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : O1(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      let P1 = (VV((y1 = class e3 extends RB {
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        constructor(t3, i3) {
          super(t3, i3), MN(this, "store", void 0), MN(this, "peerConnection", void 0), MN(this, "remoteSDP", void 0), MN(this, "initialOffer", void 0), MN(this, "statsFilter", void 0), MN(this, "useRTX", false), MN(this, "localCapabilities", void 0), MN(this, "localCandidateCount", 0), MN(this, "allCandidatesReceived", false), MN(this, "mutex", new fj("P2PConnection-mutex")), this.store = i3, this.peerConnection = new RTCPeerConnection(e3.resolvePCConfiguration(t3), { optional: [{ googDscp: true }] }), this.statsFilter = N1(this.peerConnection, void 0, void 0, gN() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;
        }
        async establish() {
          try {
            const e4 = await this.peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
            if (!e4.sdp)
              throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t3 = J$(e4.sdp), i3 = Y$(e4.sdp, !this.useRTX, LP("FILTER_VIDEO_FEC"), LP("FILTER_AUDIO_FEC"), ["opus"]);
            return this.localCapabilities = i3, this.initialOffer = e4, D1(D1({}, t3), {}, { rtpCapabilities: { send: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, recv: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, sendrecv: i3 }, offerSDP: e4.sdp });
          } catch (e4) {
            throw new QD(xD.GET_LOCAL_CONNECTION_PARAMS_FAILED, e4.toString());
          }
        }
        async connect(e4, t3, i3, r3, n3, o3) {
          try {
            if (!this.initialOffer)
              throw new Error("Cannot establish P2PConnection without initial offer.");
            this.remoteSDP = new c1({ remoteIceParameters: e4, remoteDtlsParameters: t3, candidates: i3, remoteRTPCapabilities: r3.send, remoteSetup: n3, localCapabilities: this.localCapabilities, sdkCodec: this.store.codec, cname: o3 });
            const s3 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s3 });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e5.toString()));
          }
        }
        send(e4, t3) {
          var i3 = this;
          return I$(function* () {
            const r3 = yield _$(i3.mutex.lock());
            try {
              if (!i3.remoteSDP)
                throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const n3 = e4.map((e5) => i3.peerConnection.addTrack(e5._mediaStreamTrack)), o3 = yield _$(i3.peerConnection.createOffer()), s3 = K$.exports.parse(o3.sdp), a3 = e4.map((e5) => {
                const t4 = e5._mediaStreamTrack, r4 = s3.mediaDescriptions.find((e6) => e6.attributes.mid === t4.kind);
                if (!r4)
                  throw new Error("Cannot extract ssrc from mediaDescription.");
                return function(e6, t5, i4) {
                  const r5 = e6.attributes.ssrcs.filter((e7) => e7.attributes.label === t5), n4 = e6.attributes.ssrcGroups;
                  if (0 === r5.length)
                    throw new Error("Cannot extract ssrc from plan-b SDP.");
                  if (n4 && r5.length > 1) {
                    const e7 = n4.find((e8) => -1 !== e8.ssrcIds.indexOf(r5[0].ssrcId));
                    return e7 ? [{ ssrcId: e7.ssrcIds[0], rtx: i4 ? e7.ssrcIds[1] : void 0 }] : [{ ssrcId: r5[0].ssrcId }];
                  }
                  return [{ ssrcId: r5[0].ssrcId }];
                }(r4, t4.id, i3.useRTX);
              });
              let c3;
              try {
                c3 = yield a3;
              } catch (e5) {
                throw n3.forEach((e6) => {
                  pN() && e6.replaceTrack(null), i3.peerConnection.removeTrack(e6);
                }), e5;
              }
              const d3 = i3.mungSendOfferSDP(o3.sdp, e4);
              i3.remoteSDP.receive(e4, t3, c3);
              const u3 = i3.remoteSDP.toString();
              return yield _$(i3.peerConnection.setLocalDescription({ type: "offer", sdp: d3 })), yield _$(i3.applySendEncodings(n3, e4)), yield _$(i3.peerConnection.setRemoteDescription({ type: "answer", sdp: u3 })), e4.map((e5, t4) => {
                const i4 = e5._mediaStreamTrack.id;
                return { localSSRC: a3[t4], id: i4 };
              });
            } catch (e5) {
              throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e5.toString()));
            } finally {
              r3();
            }
          })();
        }
        async stopSending(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t3 = this.peerConnection.getSenders().filter((t4) => {
              var i4;
              return -1 !== e4.indexOf((null === (i4 = t4.track) || void 0 === i4 ? void 0 : i4.id) || "");
            });
            if (t3.length !== e4.length)
              throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t3.map((e5) => {
              pN() && e5.replaceTrack(null), this.peerConnection.removeTrack(e5);
            });
            const i3 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(i3), this.remoteSDP.stopReceiving(e4);
            const r3 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r3 });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e5.toString()));
          }
        }
        async receive(e4, t3, i3, r3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.receive ".concat(e4, " before remoteSDP created."));
            const { id: i4, mslabel: n3 } = this.remoteSDP.send(e4, t3, r3), o3 = new l_((t4, r4) => {
              const o4 = setTimeout(() => {
                r4(new Error("Cannot receive track, id: ".concat(i4)));
              }, 1e4), s4 = (r5) => {
                const a4 = oN();
                if (("Safari" === a4.name && 11 === Number(a4.version) || EN()) && r5.track.id !== i4 && r5.streams[0].id === n3) {
                  var c3;
                  const n4 = r5.streams[0].getTracks()[0];
                  return null === (c3 = this.remoteSDP) || void 0 === c3 || c3.updateTrackLabel(e4, i4, r5.track.id), this.peerConnection.removeEventListener("track", s4), clearTimeout(o4), void t4(n4);
                }
                if (r5.track.id === i4)
                  return this.peerConnection.removeEventListener("track", s4), clearTimeout(o4), void t4(r5.track);
              };
              this.peerConnection.addEventListener("track", s4);
            }), s3 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: s3 });
            const a3 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(a3);
            return { track: await o3, id: i4 };
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e5.toString()));
          }
        }
        async stopReceiving(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e4);
            const t3 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
            const i3 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(i3);
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e5.toString()));
          }
        }
        async muteRemote(e4) {
        }
        async unmuteRemote(e4) {
        }
        async muteLocal(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t3 = this.peerConnection.getSenders().filter((t4) => {
              var i3;
              return -1 !== e4.indexOf((null === (i3 = t4.track) || void 0 === i3 ? void 0 : i3.id) || "");
            });
            if (t3.length !== e4.length)
              throw new Error("sender' length doesn't match mids' length.");
            t3.map((e5) => {
              if (pN() && e5.track)
                e5.track.enabled = false;
              else {
                const t4 = e5.getParameters();
                t4.encodings.forEach((e6) => e6.active = false), e5.setParameters(t4);
              }
            });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e5.toString()));
          }
        }
        async unmuteLocal(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t3 = this.peerConnection.getSenders().filter((t4) => {
              var i4;
              return -1 !== e4.indexOf((null === (i4 = t4.track) || void 0 === i4 ? void 0 : i4.id) || "");
            });
            if (t3.length !== e4.length)
              throw new Error("Senders' length doesn't match mids' length.");
            t3.map(async (e5) => {
              if (pN() && e5.track)
                e5.track.enabled = true;
              else {
                const t4 = e5.getParameters();
                t4.encodings.forEach((e6) => e6.active = true), await e5.setParameters(t4);
              }
            });
            const i3 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(i3);
            const r3 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r3 });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e5.toString()));
          }
        }
        restartICE() {
          var e4 = this;
          return I$(function* () {
            const t3 = yield _$(e4.mutex.lock("From P2PConnection.restartICE"));
            try {
              const i3 = yield _$(e4.peerConnection.createOffer({ iceRestart: true }));
              if (!i3.sdp)
                throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const r3 = J$(i3.sdp), { remoteIceParameters: n3 } = yield r3.iceParameters;
              if (!e4.remoteSDP)
                throw new Error("Cannot restartICE before remoteSDP created.");
              e4.remoteSDP.restartICE(n3);
              const o3 = e4.remoteSDP.toString();
              yield _$(e4.peerConnection.setLocalDescription(i3)), yield _$(e4.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 }));
            } catch (e5) {
              JD.warning("restart ICE failed, abort operation", e5);
            } finally {
              t3();
            }
          })();
        }
        close() {
          var e4;
          this.peerConnection.close(), null === (e4 = this.onConnectionStateChange) || void 0 === e4 || e4.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e4) {
          return this.statsFilter.getVideoIsReady(e4);
        }
        async updateEncoderConfig(e4, t3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const e5 = await this.peerConnection.createOffer(), i3 = this.mungSendOfferSDP(e5.sdp, [t3]);
            this.remoteSDP.updateRecvMedia(t3._mediaStreamTrack.kind, t3);
            const r3 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: i3 }), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r3 });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, e5.toString());
          }
        }
        async updateSendParameters(e4, t3) {
          const i3 = this.peerConnection.getSenders().filter((t4) => {
            var i4;
            return (null === (i4 = t4.track) || void 0 === i4 ? void 0 : i4.id) === e4;
          });
          1 === i3.length && await this.applySendEncodings(i3, [t3]);
        }
        setStatsRemoteVideoIsReady(e4, t3) {
          this.statsFilter.setVideoIsReady2(e4, t3);
        }
        async replaceTrack(e4, t3) {
          const i3 = this.peerConnection.getSenders().find((e5) => {
            var i4;
            return (null === (i4 = e5.track) || void 0 === i4 ? void 0 : i4.id) === t3;
          });
          i3 && await i3.replaceTrack(e4._mediaStreamTrack);
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e4;
            null === (e4 = this.onICEConnectionStateChange) || void 0 === e4 || e4.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e4;
            null === (e4 = this.onConnectionStateChange) || void 0 === e4 || e4.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e4) => {
            e4.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, JD.debug("[pc-".concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, JD.debug("[pc-".concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, LP("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t3) {
          const i3 = { iceServers: [], sdpSemantics: "plan-b" };
          return t3.iceServers ? i3.iceServers = t3.iceServers : t3.turnServer && "off" !== t3.turnServer.mode && (Rk(t3.turnServer.servers) ? i3.iceServers = t3.turnServer.servers : (i3.iceServers && i3.iceServers.push(...e3.turnServerConfigToIceServers(t3.turnServer.servers)), LP("USE_TURN_SERVER_OF_GATEWAY") && i3.iceServers && t3.turnServer.serversFromGateway && i3.iceServers.push(...e3.turnServerConfigToIceServers(t3.turnServer.serversFromGateway)), t3.turnServer.servers.concat(t3.turnServer.serversFromGateway || []).forEach((e4) => {
            e4.forceturn && (i3.iceTransportPolicy = "relay");
          }))), i3;
        }
        static turnServerConfigToIceServers(e4) {
          const t3 = [];
          return e4.forEach((e5) => {
            e5.security ? e5.tcpport && t3.push({ username: e5.username, credential: e5.password, credentialType: "password", urls: "turns:".concat(e5.turnServerURL, ":").concat(e5.tcpport, "?transport=tcp") }) : (e5.udpport && t3.push({ username: e5.username, credential: e5.password, credentialType: "password", urls: "turn:".concat(e5.turnServerURL, ":").concat(e5.udpport, "?transport=udp") }), e5.tcpport && t3.push({ username: e5.username, credential: e5.password, credentialType: "password", urls: "turn:".concat(e5.turnServerURL, ":").concat(e5.tcpport, "?transport=tcp") }));
          }), t3;
        }
        async applySendEncodings(e4, t3) {
          try {
            if (!wB().supportSetRtpSenderParameters)
              return;
            if (e4.length !== t3.length)
              return;
            for (let r3 = 0; r3 < e4.length; r3++) {
              var i3;
              const n3 = e4[r3], o3 = t3[r3];
              if (!o3)
                continue;
              const s3 = {}, a3 = {};
              if (o3 instanceof hz)
                switch (o3._optimizationMode) {
                  case "motion":
                    s3.degradationPreference = "maintain-framerate";
                    break;
                  case "detail":
                    s3.degradationPreference = "maintain-resolution";
                    break;
                  default:
                    s3.degradationPreference = "balanced";
                }
              if (LP("DSCP_TYPE") && yN()) {
                const e5 = LP("DSCP_TYPE");
                ["very-low", "low", "medium", "high"].includes(e5) && (a3.networkPriority = e5);
              }
              const c3 = n3.getParameters(), d3 = null === (i3 = c3.encodings) || void 0 === i3 ? void 0 : i3[0];
              d3 && Object.assign(d3, a3), Object.assign(c3, s3), await n3.setParameters(c3);
            }
          } catch (e5) {
            JD.debug("Apply RTPSendEncodings failed.");
          }
        }
        mungSendOfferSDP(e4, t3) {
          const i3 = K$.exports.parse(e4);
          return t3.forEach((e5, t4) => {
            const r3 = e5._mediaStreamTrack, n3 = i3.mediaDescriptions.find((e6) => e6.attributes.mid === r3.kind);
            n3 && Z$(n3, e5);
          }), K$.exports.print(i3);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e4) => {
            var t3;
            null === (t3 = this.onFirstAudioReceived) || void 0 === t3 || t3.call(this, e4);
          }, this.statsFilter.onFirstVideoReceived = (e4) => {
            var t3;
            null === (t3 = this.onFirstVideoReceived) || void 0 === t3 || t3.call(this, e4);
          }, this.statsFilter.onFirstAudioDecoded = (e4) => {
            var t3;
            null === (t3 = this.onFirstAudioDecoded) || void 0 === t3 || t3.call(this, e4);
          }, this.statsFilter.onFirstVideoDecoded = (e4, t3, i3) => {
            var r3;
            null === (r3 = this.onFirstVideoDecoded) || void 0 === r3 || r3.call(this, e4, t3, i3);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e4, t3) => {
            var i3;
            null === (i3 = this.onSelectedLocalCandidateChanged) || void 0 === i3 || i3.call(this, e4, t3);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e4, t3) => {
            var i3;
            null === (i3 = this.onSelectedRemoteCandidateChanged) || void 0 === i3 || i3.call(this, e4, t3);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;
        }
        async batchReceive(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const t3 = this.remoteSDP.batchSend(e4).map((t4, i4) => {
              let { id: r4, mslabel: n3 } = t4;
              const { kind: o3 } = e4[i4];
              return new l_((e5, t5) => {
                const i5 = setTimeout(() => {
                  t5(new Error("Cannot receive track, id: ".concat(r4)));
                }, 1e4), s3 = (t6) => {
                  const a3 = oN();
                  if ("Safari" === a3.name && 11 === Number(a3.version) && t6.track.id !== r4 && t6.streams[0].id === n3) {
                    var c3;
                    const n4 = t6.streams[0].getTracks()[0];
                    return null === (c3 = this.remoteSDP) || void 0 === c3 || c3.updateTrackLabel(o3, r4, t6.track.id), this.peerConnection.removeEventListener("track", s3), clearTimeout(i5), void e5({ track: n4, id: r4 });
                  }
                  if (t6.track.id === r4)
                    return this.peerConnection.removeEventListener("track", s3), clearTimeout(i5), void e5({ track: t6.track, id: r4 });
                };
                this.peerConnection.addEventListener("track", s3);
              });
            }), i3 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: i3 });
            const r3 = await this.peerConnection.createAnswer();
            return await this.peerConnection.setLocalDescription(r3), await l_.all(t3);
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e5.toString()));
          }
        }
        async getRemoteSSRC(e4) {
          if (!this.remoteSDP)
            return;
          const t3 = this.remoteSDP.getSSRC(e4);
          return null == t3 ? void 0 : t3[0].ssrcId;
        }
      }).prototype, "connect", [L1], Object.getOwnPropertyDescriptor(y1.prototype, "connect"), y1.prototype), VV(y1.prototype, "stopSending", [L1], Object.getOwnPropertyDescriptor(y1.prototype, "stopSending"), y1.prototype), VV(y1.prototype, "receive", [L1], Object.getOwnPropertyDescriptor(y1.prototype, "receive"), y1.prototype), VV(y1.prototype, "stopReceiving", [L1], Object.getOwnPropertyDescriptor(y1.prototype, "stopReceiving"), y1.prototype), VV(y1.prototype, "muteRemote", [L1], Object.getOwnPropertyDescriptor(y1.prototype, "muteRemote"), y1.prototype), VV(y1.prototype, "unmuteRemote", [L1], Object.getOwnPropertyDescriptor(y1.prototype, "unmuteRemote"), y1.prototype), VV(y1.prototype, "muteLocal", [L1], Object.getOwnPropertyDescriptor(y1.prototype, "muteLocal"), y1.prototype), VV(y1.prototype, "unmuteLocal", [L1], Object.getOwnPropertyDescriptor(y1.prototype, "unmuteLocal"), y1.prototype), VV(y1.prototype, "close", [L1], Object.getOwnPropertyDescriptor(y1.prototype, "close"), y1.prototype), VV(y1.prototype, "updateEncoderConfig", [L1], Object.getOwnPropertyDescriptor(y1.prototype, "updateEncoderConfig"), y1.prototype), VV(y1.prototype, "updateSendParameters", [L1], Object.getOwnPropertyDescriptor(y1.prototype, "updateSendParameters"), y1.prototype), VV(y1.prototype, "replaceTrack", [L1], Object.getOwnPropertyDescriptor(y1.prototype, "replaceTrack"), y1.prototype), VV(y1.prototype, "getRemoteSSRC", [L1], Object.getOwnPropertyDescriptor(y1.prototype, "getRemoteSSRC"), y1.prototype), y1);
      function L1(e3, t3, i3) {
        const r3 = e3[t3];
        if ("function" != typeof r3)
          throw new Error("Cannot use mutex on object property.");
        return i3.value = async function() {
          const e4 = this.mutex, i4 = await e4.lock("Locking from P2PConnection.".concat(t3));
          try {
            for (var n3 = arguments.length, o3 = new Array(n3), s3 = 0; s3 < n3; s3++)
              o3[s3] = arguments[s3];
            return await r3.apply(this, o3);
          } finally {
            i4();
          }
        }, i3;
      }
      var k1;
      const B1 = "9", M1 = 4e4;
      let U1 = mP("RemoteSDP")(k1 = class {
        get localCapabilities() {
          return OK(this._localCapabilities);
        }
        get rtpCapabilities() {
          return OK(this._rtpCapabilities);
        }
        get candidates() {
          return OK(this._candidates);
        }
        get iceParameters() {
          return OK(this._iceParameters);
        }
        get dtlsParameters() {
          return OK(this._dtlsParameters);
        }
        constructor(e3) {
          MN(this, "sessionDesc", void 0), MN(this, "_localCapabilities", void 0), MN(this, "_rtpCapabilities", void 0), MN(this, "_candidates", void 0), MN(this, "_iceParameters", void 0), MN(this, "_dtlsParameters", void 0), MN(this, "setup", void 0), MN(this, "currentMidIndex", void 0), MN(this, "cname", void 0), MN(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e3 = OK(e3);
          const { remoteIceParameters: t3, remoteDtlsParameters: i3, candidates: r3, remoteRTPCapabilities: n3, remoteSetup: o3, localCapabilities: s3, cname: a3 } = e3, c3 = K$.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n");
          this._rtpCapabilities = n3, this._candidates = r3, this._iceParameters = t3, this._dtlsParameters = i3, this._localCapabilities = s3, this.setup = o3, this.cname = a3;
          const d3 = this.rtpCapabilities.send;
          for (const e4 of c3.mediaDescriptions) {
            if (e4.attributes.iceUfrag = t3.iceUfrag, e4.attributes.icePwd = t3.icePwd, e4.attributes.fingerprints = i3.fingerprints, e4.attributes.candidates = r3, e4.attributes.setup = o3, "video" === e4.media.mediaType && (e4.media.fmts = d3.videoCodecs.map((e5) => e5.payloadType.toString(10)), e4.attributes.payloads = d3.videoCodecs, e4.attributes.extmaps = d3.videoExtensions, LP("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t4, ssrcGroups: i4 } = z$([{ ssrcId: M1, rtx: LP("USE_RTX") ? 40001 : void 0 }], this.cname);
              e4.attributes.ssrcs = t4, e4.attributes.ssrcGroups = i4;
            }
            if ("audio" === e4.media.mediaType && (e4.media.fmts = d3.audioCodecs.map((e5) => e5.payloadType.toString(10)), e4.attributes.payloads = d3.audioCodecs, e4.attributes.extmaps = d3.audioExtensions, a1(e4), LP("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t4, ssrcGroups: i4 } = z$([{ ssrcId: 2e4 }], this.cname);
              e4.attributes.ssrcs = t4, e4.attributes.ssrcGroups = i4;
            }
          }
          this.sessionDesc = c3, this.currentMidIndex = c3.mediaDescriptions.length - 1;
        }
        preloadRemoteMedia() {
          const e3 = LP("PRELOAD_MEDIA_COUNT");
          gP("debug", this, "preloadRemoteMedia", e3), this.rtpCapabilities;
          const t3 = this.candidates, i3 = this.dtlsParameters, r3 = this.iceParameters, n3 = this.rtpCapabilities.send;
          for (let o3 = 1; o3 < e3; o3++) {
            const e4 = 2 * o3 + 2e4, s3 = 2 * o3 + M1, { ssrcs: a3, ssrcGroups: c3 } = z$([{ ssrcId: e4 }], this.cname), { ssrcs: d3, ssrcGroups: u3 } = z$([{ ssrcId: s3, rtx: LP("USE_RTX") ? s3 + 1 : void 0 }], this.cname);
            this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: B1, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: n3.videoCodecs.map((e5) => e5.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: r3.iceUfrag, icePwd: r3.icePwd, unrecognized: [], candidates: t3, extmaps: n3.videoExtensions, fingerprints: i3.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: d3, ssrcGroups: u3, rtcpFeedbackWildcards: [], payloads: n3.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o3) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: B1, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: n3.audioCodecs.map((e5) => e5.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: r3.iceUfrag, icePwd: r3.icePwd, unrecognized: [], candidates: t3, extmaps: n3.audioExtensions, fingerprints: i3.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: a3, ssrcGroups: c3, rtcpFeedbackWildcards: [], payloads: n3.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o3 + 1) } }), this.currentMidIndex += 2;
          }
          this.updateBundleMids();
        }
        toString() {
          return K$.exports.print(this.sessionDesc);
        }
        send(e3, t3, i3, r3) {
          const { ssrcs: n3, ssrcGroups: o3 } = z$(t3, this.cname, i3), s3 = this.findPreloadMediaDesc(n3);
          if (s3) {
            if (gN() && this.firefoxSsrcMidMap.set(n3[0].ssrcId, s3.attributes.mid), r3 && (r3.tcc || r3.remb)) {
              const e4 = this.sessionDesc.mediaDescriptions.indexOf(s3);
              return this.sessionDesc.mediaDescriptions[e4] = this.mungSendMediaDesc(s3, r3), { mid: s3.attributes.mid, needExchangeSDP: true };
            }
            return { mid: s3.attributes.mid, needExchangeSDP: false };
          }
          {
            const t4 = this.findAvailableMediaIndex(e3, n3);
            if (pN() || mN() || fN()) {
              if (-1 !== t4 && 1 !== t4) {
                const e4 = OK(this.sessionDesc.mediaDescriptions[t4]);
                return e4.attributes.direction = "sendonly", e4.attributes.ssrcs = n3, e4.attributes.ssrcGroups = o3, this.sessionDesc.mediaDescriptions[t4] = this.mungSendMediaDesc(e4, r3), { mid: e4.attributes.mid, needExchangeSDP: true };
              }
              {
                const t5 = this.createOrRecycleSendMedia(e3, n3, o3, "sendonly", r3);
                return this.updateBundleMids(), { mid: t5.attributes.mid, needExchangeSDP: true };
              }
            }
            if (-1 !== t4) {
              const e4 = OK(this.sessionDesc.mediaDescriptions[t4]);
              return e4.attributes.direction = "sendonly", e4.attributes.ssrcs = n3, e4.attributes.ssrcGroups = o3, this.sessionDesc.mediaDescriptions[t4] = this.mungSendMediaDesc(e4, r3), gN() && this.firefoxSsrcMidMap.set(n3[0].ssrcId, e4.attributes.mid), { mid: e4.attributes.mid, needExchangeSDP: true };
            }
            {
              const t5 = this.createOrRecycleSendMedia(e3, n3, o3, "sendonly", r3);
              return this.updateBundleMids(), gN() && this.firefoxSsrcMidMap.set(n3[0].ssrcId, t5.attributes.mid), { mid: t5.attributes.mid, needExchangeSDP: true };
            }
          }
        }
        batchSend(e3) {
          const t3 = e3.map((e4) => {
            let { kind: t4, ssrcMsg: i4, mslabel: r4 } = e4;
            return this.send(t4, i4, r4);
          }), i3 = [];
          let r3 = false;
          return t3.forEach((e4) => {
            let { mid: t4, needExchangeSDP: n3 } = e4;
            n3 && (r3 = true), i3.push(t4);
          }), { mids: i3, needExchangeSDP: r3 };
        }
        stopSending(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => t4.attributes.mid && -1 !== e3.indexOf(t4.attributes.mid));
          if (t3.length !== e3.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
          t3.forEach((e4) => {
            "0" === e4.attributes.mid || gN() || pN() || mN() || fN() ? e4.attributes.ssrcs = [] : (e4.attributes.ssrcs = [], e4.attributes.direction = "inactive", e4.media.port = "0");
          }), this.updateBundleMids();
        }
        mute(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
          if (!t3)
            throw new Error("mediaDescription not found with ".concat(e3, " in remote SDP when calling RemoteSDP.mute."));
          t3.attributes.direction = "inactive";
        }
        unmute(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
          if (!t3)
            throw new Error("mediaDescription not found with ".concat(e3, " in remote SDP when calling RemoteSDP.unmute."));
          t3.attributes.direction = "sendonly";
        }
        muteRemote(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => e3.includes(t4.attributes.mid || ""));
          if (t3.length !== e3.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t3.forEach((e4) => {
            e4.attributes.direction = "inactive";
          });
        }
        unmuteRemote(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => e3.includes(t4.attributes.mid || ""));
          if (t3.length !== e3.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t3.forEach((e4) => {
            e4.attributes.direction = "recvonly";
          });
        }
        receive(e3, t3, i3, r3) {
          e3.forEach((e4, n3) => {
            this.createOrRecycleRecvMedia(e4, [], "recvonly", t3, i3, r3[n3]);
          }), this.updateBundleMids();
        }
        stopReceiving(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => -1 !== e3.indexOf(t4.attributes.mid));
          if (t3.length !== e3.length)
            throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
          t3.forEach((e4) => {
            e4.media.port = "0", e4.attributes.direction = "inactive";
          }), this.updateBundleMids();
        }
        restartICE(e3) {
          e3 = OK(e3), this._iceParameters = e3, this.sessionDesc.mediaDescriptions.forEach((t3) => {
            t3.attributes.iceUfrag = e3.iceUfrag, t3.attributes.icePwd = e3.icePwd;
          });
        }
        predictReceivingMids(e3) {
          const t3 = [];
          for (let i3 = 0; i3 < e3; i3++)
            t3.push((this.currentMidIndex + i3 + 1).toString(10));
          return t3;
        }
        findAvailableMediaIndex(e3, t3) {
          return this.sessionDesc.mediaDescriptions.findIndex((i3) => {
            const r3 = i3.media.mediaType === e3 && "0" !== i3.media.port && ("sendonly" === i3.attributes.direction || "sendrecv" === i3.attributes.direction) && 0 === i3.attributes.ssrcs.length;
            if (gN()) {
              if (r3) {
                const e4 = this.firefoxSsrcMidMap.get(t3[0].ssrcId);
                return !(e4 || "0" !== i3.attributes.mid && "1" !== i3.attributes.mid) || !(!e4 || e4 !== i3.attributes.mid);
              }
              return false;
            }
            return r3;
          });
        }
        createOrRecycleRecvMedia(e3, t3, i3, r3, n3, o3) {
          const s3 = e3._mediaStreamTrack.kind, a3 = this.rtpCapabilities.recv, c3 = this.localCapabilities.send;
          let d3 = [];
          if (s3 === AB.VIDEO) {
            var u3, h3;
            if (LP("H264_PROFILE_LEVEL_ID") && "h264" === r3 && (d3 = a3.videoCodecs.filter((e4) => {
              var t4, i4;
              return ((null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "").includes(r3) && (null == e4 || null === (i4 = e4.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]) === LP("H264_PROFILE_LEVEL_ID");
            })), !d3 || 0 === (null === (u3 = d3) || void 0 === u3 ? void 0 : u3.length)) {
              const e4 = c3.videoCodecs.filter((e5) => {
                var t4;
                return ((null === (t4 = e5.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "").includes(r3);
              });
              0 !== e4.length && (d3 = a3.videoCodecs.filter((t4) => e4.some((e5) => e5.payloadType === t4.payloadType)));
            }
            if (LP("USE_RTX")) {
              const e4 = d3.map((e5) => e5.payloadType.toString()), t4 = a3.videoCodecs.filter((t5) => {
                var i4, r4;
                return "rtx" === (null === (i4 = t5.rtpMap) || void 0 === i4 ? void 0 : i4.encodingName) && e4.includes((null === (r4 = t5.fmtp) || void 0 === r4 ? void 0 : r4.parameters.apt) || "");
              });
              d3 = [...d3, ...t4];
            }
            if (0 === d3.length)
              JD.warning("codec ".concat(r3, " not included in rtpCapabilities, fallback to default payloads: ").concat(null === (h3 = a3.videoCodecs[0].rtpMap) || void 0 === h3 ? void 0 : h3.encodingName)), d3 = a3.videoCodecs;
          } else
            d3 = a3.audioCodecs.filter((e4) => {
              var t4;
              return ((null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "").includes(n3);
            }), 0 === d3.length && (JD.warning("codec ".concat(n3, " not included in rtpCapabilities, fallback to opus")), d3 = a3.audioCodecs.filter((e4) => {
              var t4;
              return ((null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "").includes("opus");
            }));
          const A3 = s3 === AB.VIDEO ? a3.videoExtensions : a3.audioExtensions;
          this.currentMidIndex += 1;
          const l3 = "".concat(this.currentMidIndex);
          let p3 = { media: { mediaType: s3, port: B1, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: d3.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: A3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t3, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: d3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i3, rtcpMux: true, rtcpRsize: true, mid: "".concat(l3) } };
          p3 = this.mungRecvMediaDsec(p3, e3, o3);
          const g3 = this.findFirstClosedMedia(s3);
          if (g3) {
            const e4 = this.sessionDesc.mediaDescriptions.indexOf(g3);
            this.sessionDesc.mediaDescriptions[e4] = p3;
          } else
            this.sessionDesc.mediaDescriptions.push(p3);
          return p3;
        }
        createOrRecycleSendMedia(e3, t3, i3, r3, n3) {
          const o3 = this.rtpCapabilities.send, s3 = e3 === AB.VIDEO ? o3.videoCodecs : o3.audioCodecs, a3 = e3 === AB.VIDEO ? o3.videoExtensions : o3.audioExtensions;
          this.currentMidIndex += 1;
          const c3 = "".concat(this.currentMidIndex);
          let d3 = { media: { mediaType: e3, port: B1, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: s3.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t3, ssrcGroups: i3, rtcpFeedbackWildcards: [], payloads: s3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: r3, rtcpMux: true, rtcpRsize: true, mid: "".concat(c3) } };
          d3 = this.mungSendMediaDesc(d3, n3);
          const u3 = this.findFirstClosedMedia(e3);
          if (u3) {
            const e4 = this.sessionDesc.mediaDescriptions.indexOf(u3);
            this.sessionDesc.mediaDescriptions[e4] = d3;
          } else
            this.sessionDesc.mediaDescriptions.push(d3);
          return d3;
        }
        updateBundleMids() {
          this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e3) => "0" !== e3.media.port).map((e3) => e3.attributes.mid);
        }
        mungRecvMediaDsec(e3, t3, i3) {
          const r3 = OK(e3);
          return $$(r3), Z$(r3, t3), e1(r3, t3), t1(r3), i1(r3, i3, this.localCapabilities.send), r3;
        }
        mungSendMediaDesc(e3, t3) {
          const i3 = OK(e3);
          return i1(i3, t3, this.localCapabilities.recv), a1(i3), i3;
        }
        updateRecvMedia(e3, t3) {
          const i3 = this.sessionDesc.mediaDescriptions.findIndex((t4) => t4.attributes.mid === e3);
          if (-1 !== i3) {
            const e4 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i3], t3);
            this.sessionDesc.mediaDescriptions[i3] = e4;
          }
        }
        bumpMid(e3) {
          this.currentMidIndex += e3;
        }
        findFirstClosedMedia(e3) {
          return this.sessionDesc.mediaDescriptions.find((t3) => gN() ? "0" === t3.media.port && t3.media.mediaType === e3 : "0" === t3.media.port);
        }
        findPreloadMediaDesc(e3) {
          return this.sessionDesc.mediaDescriptions.find((t3) => {
            var i3, r3;
            return (null === (i3 = t3.attributes) || void 0 === i3 || null === (r3 = i3.ssrcs[0]) || void 0 === r3 ? void 0 : r3.ssrcId) === e3[0].ssrcId;
          });
        }
        getSSRC(e3) {
          var t3;
          return null === (t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3)) || void 0 === t3 ? void 0 : t3.attributes.ssrcs;
        }
      }) || k1;
      var x1, Q1;
      function F1(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function V1(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? F1(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : F1(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      let j1 = mP("P2PConnection", "store.p2pId")((VV((Q1 = class e3 extends RB {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        constructor(t3, i3) {
          super(t3, i3), MN(this, "store", void 0), MN(this, "peerConnection", void 0), MN(this, "remoteSDP", void 0), MN(this, "initialOffer", void 0), MN(this, "transportEventReceiver", void 0), MN(this, "statsFilter", void 0), MN(this, "useRTX", LP("USE_RTX")), MN(this, "localCapabilities", void 0), MN(this, "localCandidateCount", 0), MN(this, "allCandidatesReceived", false), MN(this, "mutex", new fj("P2PConnection-mutex")), this.store = i3, this.peerConnection = new RTCPeerConnection(e3.resolvePCConfiguration(t3), { optional: [{ googDscp: true }] }), this.statsFilter = N1(this.peerConnection, void 0, void 0, gN() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;
        }
        async establish() {
          try {
            this.peerConnection.addTransceiver("video", { direction: "recvonly" }), this.peerConnection.addTransceiver("audio", { direction: "recvonly" });
            const e4 = await this.peerConnection.createOffer();
            if (!e4.sdp)
              throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t3 = J$(e4.sdp), i3 = await n1(!this.useRTX, LP("FILTER_VIDEO_FEC"), LP("FILTER_AUDIO_FEC"));
            return this.localCapabilities = s1(i3), this.initialOffer = e4, V1(V1({}, t3), {}, { rtpCapabilities: i3, offerSDP: e4.sdp });
          } catch (e4) {
            throw new QD(xD.GET_LOCAL_CONNECTION_PARAMS_FAILED, e4.toString());
          }
        }
        async connect(e4, t3, i3, r3, n3, o3) {
          try {
            if (!this.initialOffer)
              throw new Error("Cannot establish P2PConnection without initial offer.");
            this.remoteSDP = new U1({ remoteIceParameters: e4, remoteDtlsParameters: t3, candidates: i3, remoteRTPCapabilities: r3, remoteSetup: n3, localCapabilities: this.localCapabilities, cname: o3 });
            const s3 = this.remoteSDP.toString(), a3 = K$.exports.parse(this.initialOffer.sdp), c3 = a3.mediaDescriptions.find((e5) => "audio" === e5.media.mediaType);
            c3 && a1(c3);
            const d3 = K$.exports.print(a3), u3 = this.logSDPExchange(d3 || "", "offer", "local", "connect");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: d3 }), null == u3 || u3(s3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s3 });
            const h3 = this.peerConnection.getTransceivers()[0];
            if (null != h3 && h3.receiver && this.tryBindTransportEvents(h3.receiver), LP("PRELOAD_MEDIA_COUNT") > 0) {
              this.remoteSDP.preloadRemoteMedia();
              const e5 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e5 });
              const t4 = await this.peerConnection.createAnswer();
              await this.peerConnection.setLocalDescription(t4);
            }
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e5.toString()));
          }
        }
        send(e4, t3, i3) {
          var r3 = this;
          return I$(function* () {
            const n3 = yield _$(r3.mutex.lock("From P2PConnection.send"));
            try {
              if (!r3.remoteSDP)
                throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const o3 = [];
              e4.forEach((e5) => {
                const t4 = r3.peerConnection.addTransceiver(e5._mediaStreamTrack, { direction: "sendonly" });
                o3.push(t4);
              }), gN() && true === LP("SIMULCAST") && (hP("debug", r3, "apply simulcast for firefox"), yield _$(r3.applySimulcastForFirefox(o3, e4)));
              const s3 = yield _$(r3.peerConnection.createOffer()), a3 = r3.remoteSDP.predictReceivingMids(e4.length), c3 = r3.mungSendOfferSDP(s3.sdp, e4, a3), d3 = K$.exports.parse(c3), u3 = a3.map((e5) => {
                const t4 = d3.mediaDescriptions.find((t5) => t5.attributes.mid === e5);
                if (!t4)
                  throw new Error("Cannot extract ssrc from mediaDescription.");
                return q$(t4, r3.useRTX);
              });
              let h3;
              try {
                h3 = yield u3;
              } catch (n4) {
                h3 = [], r3.remoteSDP.receive(e4, t3, i3, h3);
                const o4 = r3.remoteSDP.toString();
                throw yield _$(r3.peerConnection.setLocalDescription({ type: "offer", sdp: c3 })), yield _$(r3.peerConnection.setRemoteDescription({ type: "answer", sdp: o4 })), yield _$(r3.stopSending(a3, true)), n4;
              }
              r3.remoteSDP.receive(e4, t3, i3, h3);
              const A3 = r3.remoteSDP.toString(), l3 = r3.logSDPExchange(c3, "offer", "local", "send");
              return yield _$(r3.peerConnection.setLocalDescription({ type: "offer", sdp: c3 })), yield _$(r3.applySimulcastEncodings(o3, e4)), yield _$(r3.applySendEncodings(o3, e4)), null == l3 || l3(A3), yield _$(r3.peerConnection.setRemoteDescription({ type: "answer", sdp: A3 })), o3.map((e5, t4) => {
                const i4 = a3[t4];
                return { localSSRC: u3[t4], id: i4, transceiver: e5 };
              });
            } catch (e5) {
              throw e5 instanceof QD ? e5 : new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e5.toString()));
            } finally {
              n3();
            }
          })();
        }
        async stopSending(e4, t3) {
          const i3 = t3 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t4 = this.peerConnection.getTransceivers().filter((t5) => -1 !== e4.indexOf(t5.mid));
            if (t4.length !== e4.length)
              throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t4.map((e5) => {
              var t5;
              e5.direction = "inactive", null === (t5 = e5.stop) || void 0 === t5 || t5.call(e5);
            });
            const r3 = await this.peerConnection.createOffer(), n3 = this.logSDPExchange(r3.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(r3), this.remoteSDP.stopReceiving(e4);
            const o3 = this.remoteSDP.toString();
            null == n3 || n3(o3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e5.toString()));
          } finally {
            i3 && i3();
          }
        }
        async receive(e4, t3, i3, r3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.receive ".concat(e4, " before remoteSDP created."));
            const { mid: n3, needExchangeSDP: o3 } = this.remoteSDP.send(e4, t3, i3, r3);
            if (o3) {
              const t4 = this.remoteSDP.toString(), i4 = this.logSDPExchange(t4, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t4 });
              const r4 = await this.peerConnection.createAnswer(), o4 = this.mungReceiveAnswerSDP(r4.sdp, n3, e4);
              null == i4 || i4(o4 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o4 }), JD.debug("[P2PConnection] receive ".concat(e4, " by exchanging SDP."));
            } else
              JD.debug("[P2PConnection] receive ".concat(e4, " no need to exchange SDP."));
            const s3 = this.peerConnection.getTransceivers().find((e5) => e5.mid === n3);
            if (!s3)
              throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: s3.receiver.track, id: n3 };
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e5.toString()));
          }
        }
        async batchReceive(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const { mids: t3, needExchangeSDP: i3 } = this.remoteSDP.batchSend(e4);
            if (i3) {
              const e5 = this.remoteSDP.toString(), t4 = this.logSDPExchange(e5, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e5 });
              const i4 = await this.peerConnection.createAnswer();
              null == t4 || t4(i4.sdp || ""), await this.peerConnection.setLocalDescription(i4), JD.debug("[P2PConnection] batchReceive by exchanging SDP.");
            } else
              JD.debug("[P2PConnection] batchReceive no need to exchange SDP.");
            return t3.map((e5) => {
              const t4 = this.peerConnection.getTransceivers().find((t5) => t5.mid === e5);
              if (!t4)
                throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: t4.receiver.track, id: e5 };
            });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e5.toString()));
          }
        }
        async stopReceiving(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e4);
            const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "stopReceiving");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
            const r3 = await this.peerConnection.createAnswer();
            null == i3 || i3(r3.sdp || ""), await this.peerConnection.setLocalDescription(r3);
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e5.toString()));
          }
        }
        async muteRemote(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e4, " before remote SDP created."));
            this.remoteSDP.mute(e4);
            const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "muteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
            const r3 = await this.peerConnection.createAnswer();
            null == i3 || i3(r3.sdp || ""), await this.peerConnection.setLocalDescription(r3);
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.muteRemote failed; ".concat(e5.toString()));
          }
        }
        async unmuteRemote(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e4, " before remote SDP created."));
            this.remoteSDP.unmute(e4);
            const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "unmuteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
            const r3 = await this.peerConnection.createAnswer();
            null == i3 || i3(r3.sdp || ""), await this.peerConnection.setLocalDescription(r3);
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteRemote failed; ".concat(e5.toString()));
          }
        }
        async muteLocal(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => t4.mid && -1 !== e4.indexOf(t4.mid));
            if (t3.length !== e4.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t3.map((e5) => {
              e5.direction = "inactive";
            });
            const i3 = await this.peerConnection.createOffer(), r3 = this.logSDPExchange(i3.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i3), this.remoteSDP.muteRemote(e4);
            const n3 = this.remoteSDP.toString();
            null == r3 || r3(n3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n3 });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e5.toString()));
          }
        }
        async unmuteLocal(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => t4.mid && -1 !== e4.indexOf(t4.mid));
            if (t3.length !== e4.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t3.map(async (e5, t4) => {
              e5.direction = "sendonly";
            });
            const i3 = await this.peerConnection.createOffer(), r3 = this.logSDPExchange(i3.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i3), this.remoteSDP.unmuteRemote(e4);
            const n3 = this.remoteSDP.toString();
            null == r3 || r3(n3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n3 });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e5.toString()));
          }
        }
        restartICE() {
          var e4 = this;
          return I$(function* () {
            const t3 = yield _$(e4.mutex.lock("From P2PConnection.restartICE"));
            try {
              const i3 = yield _$(e4.peerConnection.createOffer({ iceRestart: true }));
              if (!i3.sdp)
                throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const r3 = J$(i3.sdp), { remoteIceParameters: n3 } = yield r3.iceParameters;
              if (!e4.remoteSDP)
                throw new Error("Cannot restartICE before remoteSDP created.");
              e4.remoteSDP.restartICE(n3);
              const o3 = e4.remoteSDP.toString(), s3 = e4.logSDPExchange(i3.sdp || "", "offer", "local", "restartICE");
              yield _$(e4.peerConnection.setLocalDescription(i3)), null == s3 || s3(o3), yield _$(e4.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 }));
            } catch (e5) {
              JD.warning("restart ICE failed, abort operation", e5);
            } finally {
              t3();
            }
          })();
        }
        close() {
          var e4;
          this.peerConnection.close(), null === (e4 = this.onConnectionStateChange) || void 0 === e4 || e4.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e4) {
          return this.statsFilter.getVideoIsReady(e4);
        }
        async updateEncoderConfig(e4, t3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const i3 = await this.peerConnection.createOffer(), r3 = this.mungSendOfferSDP(i3.sdp, [t3], [e4]);
            this.remoteSDP.updateRecvMedia(e4, t3);
            const n3 = this.remoteSDP.toString(), o3 = this.logSDPExchange(r3, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: r3 }), null == o3 || o3(n3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n3 });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, e5.toString());
          }
        }
        async updateSendParameters(e4, t3) {
          const i3 = this.peerConnection.getTransceivers().filter((t4) => t4.mid === e4);
          1 === i3.length && (this.isVP8Simulcast(t3) ? gN() || await this.applySimulcastEncodings(i3, [t3]) : await this.applySendEncodings(i3, [t3]));
        }
        setStatsRemoteVideoIsReady(e4, t3) {
          this.statsFilter.setVideoIsReady2(e4, t3);
        }
        async replaceTrack(e4, t3) {
          const i3 = this.peerConnection.getTransceivers().find((e5) => e5.mid === t3);
          i3 && await i3.sender.replaceTrack(e4._mediaStreamTrack);
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e4;
            null === (e4 = this.onICEConnectionStateChange) || void 0 === e4 || e4.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e4;
            null === (e4 = this.onConnectionStateChange) || void 0 === e4 || e4.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e4) => {
            e4.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, JD.debug("[pc-".concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, JD.debug("[pc-".concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, LP("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t3) {
          const i3 = { iceServers: [] };
          return t3.iceServers ? i3.iceServers = t3.iceServers : t3.turnServer && "off" !== t3.turnServer.mode && (Rk(t3.turnServer.servers) ? i3.iceServers = t3.turnServer.servers : (i3.iceServers && i3.iceServers.push(...e3.turnServerConfigToIceServers(t3.turnServer.servers)), LP("USE_TURN_SERVER_OF_GATEWAY") && i3.iceServers && t3.turnServer.serversFromGateway && i3.iceServers.push(...e3.turnServerConfigToIceServers(t3.turnServer.serversFromGateway)), LP("FORCE_TURN_TCP") ? i3.iceTransportPolicy = "relay" : t3.turnServer.servers.concat(t3.turnServer.serversFromGateway || []).forEach((e4) => {
            e4.forceturn && (i3.iceTransportPolicy = "relay");
          }))), i3;
        }
        static turnServerConfigToIceServers(e4) {
          const t3 = [];
          return e4.forEach((e5) => {
            e5.security ? e5.tcpport && t3.push({ username: e5.username, credential: e5.password, credentialType: "password", urls: "turns:".concat(rK(e5.turnServerURL), ":").concat(e5.tcpport, "?transport=tcp") }) : (e5.udpport && !LP("FORCE_TURN_TCP") && t3.push({ username: e5.username, credential: e5.password, credentialType: "password", urls: "turn:".concat(e5.turnServerURL, ":").concat(e5.udpport, "?transport=udp") }), e5.tcpport && t3.push({ username: e5.username, credential: e5.password, credentialType: "password", urls: "turn:".concat(e5.turnServerURL, ":").concat(e5.tcpport, "?transport=tcp") }));
          }), t3;
        }
        tryBindTransportEvents(e4) {
          e4.transport && (this.transportEventReceiver = e4, e4.transport.onstatechange = () => {
            var t3, i3;
            null !== (t3 = e4.transport) && void 0 !== t3 && t3.state && (null === (i3 = this.onDTLSTransportStateChange) || void 0 === i3 || i3.call(this, e4.transport.state));
          }, e4.transport.onerror = (e5) => {
            var t3;
            null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, e5.error);
          }, e4.transport.iceTransport && (e4.transport.iceTransport.onstatechange = () => {
            var t3, i3, r3;
            null !== (t3 = e4.transport) && void 0 !== t3 && t3.iceTransport.state && (null === (i3 = this.onICETransportStateChange) || void 0 === i3 || i3.call(this, null === (r3 = e4.transport) || void 0 === r3 ? void 0 : r3.iceTransport.state));
          }));
        }
        tryUnbindTransportEvents() {
          this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
        }
        async applySendEncodings(e4, t3) {
          try {
            if (!wB().supportSetRtpSenderParameters)
              return;
            if (e4.length !== t3.length)
              return;
            for (let c3 = 0; c3 < e4.length; c3++) {
              const d3 = e4[c3], u3 = t3[c3];
              if (u3 && u3 instanceof hz) {
                var i3, r3;
                if (this.isVP8Simulcast(u3))
                  continue;
                const e5 = {}, t4 = {};
                switch (u3._optimizationMode) {
                  case "motion":
                    e5.degradationPreference = "maintain-framerate";
                    break;
                  case "detail":
                    e5.degradationPreference = "maintain-resolution";
                    break;
                  default:
                    e5.degradationPreference = "balanced";
                }
                var n3, o3, s3, a3;
                if (null !== (i3 = u3._encoderConfig) && void 0 !== i3 && i3.bitrateMax)
                  t4.maxBitrate = 1e3 * (null === (n3 = u3._encoderConfig) || void 0 === n3 ? void 0 : n3.bitrateMax);
                if (u3._hints.includes($k.LOW_STREAM))
                  null !== (o3 = u3._encoderConfig) && void 0 !== o3 && o3.frameRate && (t4.maxFramerate = oK(u3._encoderConfig.frameRate)), null !== (s3 = u3._encoderConfig) && void 0 !== s3 && s3.scaleResolutionDownBy && (null === (a3 = u3._encoderConfig) || void 0 === a3 ? void 0 : a3.scaleResolutionDownBy) > 1 && (t4.scaleResolutionDownBy = u3._encoderConfig.scaleResolutionDownBy);
                if (LP("DSCP_TYPE") && yN()) {
                  const e6 = LP("DSCP_TYPE");
                  ["very-low", "low", "medium", "high"].includes(e6) && (t4.networkPriority = e6);
                }
                const c4 = d3.sender.getParameters(), h3 = null === (r3 = c4.encodings) || void 0 === r3 ? void 0 : r3[0];
                gN() && !h3 && (e5.encodings = [t4]), h3 && Object.assign(h3, t4), Object.assign(c4, e5), await d3.sender.setParameters(c4);
              }
            }
          } catch (e5) {
            JD.debug("Apply RTPSendEncodings failed.");
          }
        }
        mungSendOfferSDP(e4, t3, i3) {
          const r3 = K$.exports.parse(e4);
          return t3.forEach((e5, t4) => {
            const n3 = i3[t4], o3 = r3.mediaDescriptions.find((e6) => e6.attributes.mid === n3);
            o3 && (Z$(o3, e5), r1(o3, e5, this.store.codec));
          }), K$.exports.print(r3);
        }
        mungReceiveAnswerSDP(e4, t3, i3) {
          const r3 = K$.exports.parse(e4), n3 = r3.mediaDescriptions.find((e5) => e5.attributes.mid === t3);
          return n3 && i3 === AB.AUDIO && "audio" === n3.media.mediaType && a1(n3), K$.exports.print(r3);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e4) => {
            var t3;
            null === (t3 = this.onFirstAudioReceived) || void 0 === t3 || t3.call(this, e4);
          }, this.statsFilter.onFirstVideoReceived = (e4) => {
            var t3;
            null === (t3 = this.onFirstVideoReceived) || void 0 === t3 || t3.call(this, e4);
          }, this.statsFilter.onFirstAudioDecoded = (e4) => {
            var t3;
            null === (t3 = this.onFirstAudioDecoded) || void 0 === t3 || t3.call(this, e4);
          }, this.statsFilter.onFirstVideoDecoded = (e4, t3, i3) => {
            var r3;
            null === (r3 = this.onFirstVideoDecoded) || void 0 === r3 || r3.call(this, e4, t3, i3);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e4, t3) => {
            var i3;
            null === (i3 = this.onSelectedLocalCandidateChanged) || void 0 === i3 || i3.call(this, e4, t3);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e4, t3) => {
            var i3;
            null === (i3 = this.onSelectedRemoteCandidateChanged) || void 0 === i3 || i3.call(this, e4, t3);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e4) => {
            var t3;
            null === (t3 = this.onFirstVideoDecodedTimeout) || void 0 === t3 || t3.call(this, e4);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e4, t3) {
          if (e4.length === t3.length)
            for (let s3 = 0; s3 < e4.length; s3++) {
              var i3, r3, n3, o3;
              const a3 = e4[s3], c3 = t3[s3];
              if (c3 instanceof hz && !c3._hints.includes($k.LOW_STREAM) && null !== (i3 = c3._encoderConfig) && void 0 !== i3 && i3.bitrateMax && (null === (r3 = c3._encoderConfig) || void 0 === r3 ? void 0 : r3.bitrateMax) > 200 && null !== (n3 = c3._scalabiltyMode) && void 0 !== n3 && n3.numSpatialLayers && (null === (o3 = c3._scalabiltyMode) || void 0 === o3 ? void 0 : o3.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
                const e5 = {}, t4 = { high: 1e3 * (c3._encoderConfig.bitrateMax - 50), medium: 5e4 };
                e5.encodings = [{ rid: "m", active: true, maxBitrate: t4.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t4.high }];
                const i4 = a3.sender.getParameters();
                await a3.sender.setParameters(Object.assign(i4, e5));
              }
            }
        }
        async applySimulcastEncodings(e4, t3) {
          if (!gN() && e4.length === t3.length)
            for (let i3 = 0; i3 < e4.length; i3++) {
              const r3 = t3[i3];
              if (r3 instanceof hz && this.isVP8Simulcast(r3)) {
                const t4 = e4[i3], n3 = {}, o3 = { high: 1e3 * (r3._encoderConfig.bitrateMax - 50), medium: 5e4 };
                n3.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o3.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o3.medium, scaleResolutionDownBy: 4 }];
                const s3 = t4.sender.getParameters();
                await t4.sender.setParameters(Object.assign(s3, n3));
              }
            }
        }
        isVP8Simulcast(e4) {
          var t3, i3, r3, n3;
          return !!(e4 instanceof hz && LP("SIMULCAST") && "vp8" === this.store.codec && !e4._hints.includes($k.LOW_STREAM) && null !== (t3 = e4._encoderConfig) && void 0 !== t3 && t3.bitrateMax && (null === (i3 = e4._encoderConfig) || void 0 === i3 ? void 0 : i3.bitrateMax) > 200 && null !== (r3 = e4._scalabiltyMode) && void 0 !== r3 && r3.numSpatialLayers && (null === (n3 = e4._scalabiltyMode) || void 0 === n3 ? void 0 : n3.numSpatialLayers) > 1);
        }
        logSDPExchange(e4, t3, i3, r3) {
          if (LP("SDP_LOGGING"))
            return JD.upload("exchanging ".concat(i3, " ").concat(t3, " SDP during P2PConnection.").concat(r3, "\n"), e4), "offer" === t3 ? (e5) => {
              this.logSDPExchange(e5, "answer", "local" === i3 ? "remote" : "local", r3);
            } : void 0;
        }
        async getRemoteSSRC(e4) {
          if (!this.remoteSDP)
            return;
          const t3 = this.remoteSDP.getSSRC(e4);
          return null == t3 ? void 0 : t3[0].ssrcId;
        }
      }).prototype, "connect", [G1], Object.getOwnPropertyDescriptor(Q1.prototype, "connect"), Q1.prototype), VV(Q1.prototype, "receive", [G1], Object.getOwnPropertyDescriptor(Q1.prototype, "receive"), Q1.prototype), VV(Q1.prototype, "batchReceive", [G1], Object.getOwnPropertyDescriptor(Q1.prototype, "batchReceive"), Q1.prototype), VV(Q1.prototype, "stopReceiving", [G1], Object.getOwnPropertyDescriptor(Q1.prototype, "stopReceiving"), Q1.prototype), VV(Q1.prototype, "muteRemote", [G1], Object.getOwnPropertyDescriptor(Q1.prototype, "muteRemote"), Q1.prototype), VV(Q1.prototype, "unmuteRemote", [G1], Object.getOwnPropertyDescriptor(Q1.prototype, "unmuteRemote"), Q1.prototype), VV(Q1.prototype, "muteLocal", [G1], Object.getOwnPropertyDescriptor(Q1.prototype, "muteLocal"), Q1.prototype), VV(Q1.prototype, "unmuteLocal", [G1], Object.getOwnPropertyDescriptor(Q1.prototype, "unmuteLocal"), Q1.prototype), VV(Q1.prototype, "close", [G1], Object.getOwnPropertyDescriptor(Q1.prototype, "close"), Q1.prototype), VV(Q1.prototype, "updateEncoderConfig", [G1], Object.getOwnPropertyDescriptor(Q1.prototype, "updateEncoderConfig"), Q1.prototype), VV(Q1.prototype, "updateSendParameters", [G1], Object.getOwnPropertyDescriptor(Q1.prototype, "updateSendParameters"), Q1.prototype), VV(Q1.prototype, "replaceTrack", [G1], Object.getOwnPropertyDescriptor(Q1.prototype, "replaceTrack"), Q1.prototype), VV(Q1.prototype, "getRemoteSSRC", [G1], Object.getOwnPropertyDescriptor(Q1.prototype, "getRemoteSSRC"), Q1.prototype), x1 = Q1)) || x1;
      function G1(e3, t3, i3) {
        const r3 = e3[t3];
        if ("function" != typeof r3)
          throw new Error("Cannot use mutex on object property.");
        return i3.value = async function() {
          const e4 = this.mutex, i4 = await e4.lock("From P2PConnection.".concat(t3));
          try {
            for (var n3 = arguments.length, o3 = new Array(n3), s3 = 0; s3 < n3; s3++)
              o3[s3] = arguments[s3];
            return await r3.apply(this, o3);
          } finally {
            i4();
          }
        }, i3;
      }
      function K1(e3, t3) {
        let i3 = document.createElement("video"), r3 = document.createElement("canvas");
        i3.setAttribute("style", "display:none"), r3.setAttribute("style", "display:none"), i3.setAttribute("muted", ""), i3.muted = true, i3.setAttribute("autoplay", ""), i3.autoplay = true, i3.setAttribute("playsinline", ""), r3.width = oK(t3.width), r3.height = oK(t3.height);
        const n3 = oK(t3.framerate || 15);
        document.body.append(i3), document.body.append(r3);
        let o3 = e3._mediaStreamTrack;
        i3.srcObject = new MediaStream([o3]), i3.play();
        const s3 = r3.getContext("2d");
        if (!s3)
          throw new QD(xD.UNEXPECTED_ERROR, "can not get canvas context");
        const a3 = wB(), c3 = r3.captureStream(a3.supportRequestFrame ? 0 : n3).getVideoTracks()[0], d3 = Nj(() => (() => {
          if (i3.paused && i3.play(), i3.videoHeight > 2 && i3.videoWidth > 2) {
            const e4 = i3.videoWidth, t4 = i3.videoHeight / e4, n4 = r3.width * t4;
            Math.abs(n4 - r3.height) >= 2 && (JD.debug("adjust low stream resolution", "".concat(r3.width, "x").concat(r3.height, " -> ").concat(r3.width, "x").concat(n4)), r3.height = n4);
          }
          s3.drawImage(i3, 0, 0, r3.width, r3.height), c3.requestFrame && c3.requestFrame(), o3 !== e3._mediaStreamTrack && (o3 = e3._mediaStreamTrack, i3.srcObject = new MediaStream([o3]));
        })(), n3), u3 = c3.stop;
        return c3.stop = () => {
          u3.call(c3), d3(), i3 && (i3.remove(), i3 = null), r3 && (r3.width = 0, r3.remove(), r3 = null), JD.debug("clean low stream renderer");
        }, c3;
      }
      var H1, W1;
      function Y1(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function J1(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? Y1(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : Y1(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      class q1 extends gj {
        getUserId() {
          return this._userId;
        }
        constructor(e3, t3, i3, r3) {
          super(e3, "track-".concat(e3.kind, "-").concat(t3, "-").concat(r3.clientId, "_").concat(mK(5, ""))), MN(this, "_userId", void 0), MN(this, "_uintId", void 0), MN(this, "_isDestroyed", false), MN(this, "store", void 0), MN(this, "processor", void 0), MN(this, "processorContext", void 0), this._userId = t3, this._uintId = i3, this.store = r3;
        }
        _updateOriginMediaStreamTrack(e3) {
          this._originMediaStreamTrack = e3, this._mediaStreamTrack = e3, this._updatePlayerSource(), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext });
        }
        _destroy() {
          this._isDestroyed = true, JD.info("[".concat(this.getTrackId(), "] is destroyed")), gP("info", this, "_destroy"), this.stop(), super.close();
        }
        getProcessorStats() {
          return this.processorContext.gatherStats();
        }
        getProcessorUsage() {
          return this.processorContext.gatherUsage();
        }
      }
      let X1 = mP("RemoteVideoTrack", "getTrackId")(H1 = class extends q1 {
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== qL.PLAYING);
        }
        constructor(e3, t3, i3, r3) {
          super(e3, t3, i3, r3), MN(this, "_videoVisibleTimer", null), MN(this, "_previousVideoVisibleStatus", void 0), MN(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), MN(this, "trackMediaType", "video"), MN(this, "_videoWidth", void 0), MN(this, "_videoHeight", void 0), MN(this, "_player", void 0), MN(this, "processorDestination", void 0), MN(this, "processorContext", void 0), gP("info", this, "constructor", { userId: t3 }), this.updateMediaStreamTrackResolution(), this.processorContext = new FG(this.getTrackId(), "remote"), this.processorDestination = new QG(this.processorContext), this.bindProcessorDestinationEvents();
        }
        getStats() {
          PK(() => {
            JD.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead"), hP("warning", this, "[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");
          }, "remoteVideoTrackGetStatsWarning");
          return RK(this, Zk.GET_STATS) || J1({}, Pk);
        }
        play(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          const i3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.REMOTE_VIDEO_TRACK_PLAY, options: [this.getTrackId(), "string" == typeof e3 ? e3 : "HTMLElement", t3] });
          if ("string" == typeof e3) {
            const t4 = document.getElementById(e3);
            t4 ? e3 = t4 : (JD.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e3, '" element, use document.body')), hP("warning", this, 'can not find "#'.concat(e3, '" element, use document.body')), e3 = document.body);
          }
          JD.debug("[".concat(this.getTrackId(), "] start video playback"), JSON.stringify(t3)), gP("debug", this, "play", t3);
          const r3 = J1(J1({ fit: "cover" }, t3), {}, { trackId: this.getTrackId(), element: e3 });
          this._player ? this._player.updateConfig(r3) : (this._player = new sX(r3), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {
            this.store.subscribe(this.getUserId(), "video", void 0, void 0, Date.now()), this.emit(rB.FIRST_FRAME_DECODED);
          }), this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
            try {
              const e4 = this.getVideoElementVisibleStatus();
              this.emit(rB.VIDEO_ELEMENT_VISIBLE_STATUS, e4);
            } catch (e4) {
            }
          }, LP("CHECK_VIDEO_VISIBLE_INTERVAL")), i3.onSuccess();
        }
        stop() {
          const e3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.REMOTE_VIDEO_TRACK_STOP, options: [this.getTrackId()] });
          if (!this._player)
            return e3.onSuccess();
          this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, JD.debug("[".concat(this.getTrackId(), "] stop video playback")), gP("debug", this, "stop"), e3.onSuccess();
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        updateMediaStreamTrackResolution() {
          CK(this._originMediaStreamTrack).then((e3) => {
            let [t3, i3] = e3;
            this._videoHeight = i3, this._videoWidth = t3;
          }).catch(_K);
        }
        _updatePlayerSource() {
          JD.debug("[".concat(this.getTrackId(), "] update player source track")), gP("debug", this, "_updatePlayerSource"), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        getVideoElementVisibleStatus() {
          try {
            var e3, t3;
            const i3 = null == this || null === (e3 = this._player) || void 0 === e3 ? void 0 : e3.getContainerElement(), r3 = { track: this, element: null == this || null === (t3 = this._player) || void 0 === t3 ? void 0 : t3.getVideoElement(), slot: null == i3 ? void 0 : i3.parentElement }, { element: n3, slot: o3 } = r3;
            if (this.isPlaying && n3 instanceof HTMLVideoElement && o3 instanceof HTMLElement) {
              const e4 = cz.checkOneElementVisible(n3), t4 = Object.assign({}, e4);
              if (t4.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t4.visible;
                const e5 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t4.visible ? e5.onSuccess("Video is visible") : e5.onSuccess("Invisible because of ".concat(t4.reason));
              }
              return t4;
            }
            return;
          } catch (e4) {
            throw new QD(xD.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e4.message);
          }
        }
        pipe(e3) {
          if (this.processor === e3)
            return e3;
          if (e3._source)
            throw new QD(xD.INVALID_OPERATION, "Processor ".concat(e3.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e3, this.processor._source = this, e3.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e3;
        }
        unpipe() {
          if (!this.processor)
            return;
          const e3 = this.processor;
          this.processor._source = void 0, this.processor = void 0, e3.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(mB.ON_TRACK, async (e3) => {
            e3 ? e3 !== this._mediaStreamTrack && (this._mediaStreamTrack = e3, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(mB.ON_TRACK);
        }
        _destroy() {
          super._destroy(), this.unbindProcessorDestinationEvents();
        }
      }) || H1, z1 = mP("RemoteAudioTrack", "getTrackId")(W1 = class extends q1 {
        get isPlaying() {
          return this._useAudioElement ? zj.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        constructor(e3, t3, i3, r3) {
          super(e3, t3, i3, r3), MN(this, "trackMediaType", "audio"), MN(this, "_source", void 0), MN(this, "_useAudioElement", true), MN(this, "_volume", 100), MN(this, "processorContext", void 0), MN(this, "processorDestination", void 0), MN(this, "_played", false), gP("info", this, "constructor", { userId: t3 }), LP("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false), this._source = new kj(e3, true), this._source.once(Sk.RECEIVE_TRACK_BUFFER, () => {
            this.emit(rB.FIRST_FRAME_DECODED);
          }), this.processorContext = new jG(this._source.context, this.getTrackId(), "remote"), this.processorDestination = new VG(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(Sk.UPDATE_SOURCE, () => {
            this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
          });
        }
        setAudioFrameCallback(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
          if (!e3)
            return this._source.removeAllListeners(Sk.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t3), this._source.removeAllListeners(Sk.ON_AUDIO_BUFFER), this._source.on(Sk.ON_AUDIO_BUFFER, (t4) => e3(t4));
        }
        setVolume(e3) {
          const t3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.REMOTE_AUDIO_SET_VOLUME, options: [this.getTrackId(), e3] }, 300);
          this._volume = e3, this._useAudioElement ? zj.setVolume(this.getTrackId(), e3) : this._source.setVolume(e3 / 100), t3.onSuccess();
        }
        async setPlaybackDevice(e3) {
          const t3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.REMOTE_AUDIO_SET_OUTPUT_DEVICE, options: [this.getTrackId(), e3] });
          if (!this._useAudioElement)
            throw new QD(xD.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          try {
            await zj.setSinkID(this.getTrackId(), e3);
          } catch (e4) {
            throw t3.onError(e4), e4;
          }
          t3.onSuccess();
        }
        getVolumeLevel() {
          return this._source.getAccurateVolumeLevel();
        }
        getStats() {
          PK(() => {
            JD.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead"), hP("warning", this, "[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");
          }, "remoteAudioTrackGetStatsWarning");
          return RK(this, Zk.GET_STATS) || J1({}, Ok);
        }
        play() {
          const e3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.REMOTE_AUDIO_TRACK_PLAY, options: [this.getTrackId()] });
          JD.debug("[".concat(this.getTrackId(), "] start audio playback")), gP("debug", this, "play"), this._played = true, this._useAudioElement ? (JD.debug("[".concat(this.getTrackId(), "] use audio element to play")), hP("debug", this, "use audio element to play"), zj.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play(), e3.onSuccess();
        }
        stop() {
          const e3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.REMOTE_AUDIO_TRACK_STOP, options: [this.getTrackId()] });
          JD.debug("[".concat(this.getTrackId(), "] stop audio playback")), gP("debug", this, "stop"), this._played = false, this._useAudioElement ? zj.stop(this.getTrackId()) : this._source.stop(), e3.onSuccess();
        }
        _destroy() {
          super._destroy(), this._played = false, this.unbindProcessorDestinationEvents(), this._source.destroy();
        }
        _isFreeze() {
          return this._source.isFreeze;
        }
        _updatePlayerSource() {
          let e3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          JD.debug("[".concat(this.getTrackId(), "] update player source track")), gP("debug", this, "_updatePlayerSource"), e3 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && zj.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
        pipe(e3) {
          if (this.processor === e3)
            return e3;
          if (e3._source)
            throw new QD(xD.INVALID_OPERATION, "Processor ".concat(e3.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e3, this.processor._source = this, e3.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e3;
        }
        unpipe() {
          var e3;
          if (!this.processor)
            return;
          const t3 = this.processor;
          null === (e3 = this._source.processSourceNode) || void 0 === e3 || e3.disconnect(), this.processor._source = false, this.processor = void 0, t3.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(mB.ON_TRACK, async (e3) => {
            e3 ? e3 !== this._mediaStreamTrack && (this._mediaStreamTrack = e3, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e3)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
          }), this.processorDestination.on(mB.ON_NODE, (e3) => {
            this._source.processedNode = e3;
            const t3 = !e3;
            this._useAudioElement !== t3 && (this._played ? (this.stop(), this._useAudioElement = t3, this.play()) : this._useAudioElement = t3);
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(mB.ON_TRACK), this.processorDestination.removeAllListeners(mB.ON_NODE);
        }
      }) || W1;
      function Z1(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function $1(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? Z1(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : Z1(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      class e0 extends MD {
        constructor() {
          super(), MN(this, "uplinkStatsUploadInterval", void 0), MN(this, "uplinkStatsUploadSlowInterval", void 0), MN(this, "uplinkRelatedStatsUploadInterval", void 0), MN(this, "uplinkDenoiserStatsUploadInterval", void 0), MN(this, "transportStatsUploadInterval", void 0), MN(this, "uplinkExtensionStatsUploadInterval", void 0), MN(this, "downlinkExtensionStatsUploadInterval", void 0), MN(this, "extensionUsageStatsUploadInterval", void 0), MN(this, "downlinkStatsUploadInterval", void 0), MN(this, "downlinkStatsUploadSlowInterval", void 0), MN(this, "downlinkRelatedStatsUploadInterval", void 0), MN(this, "lastStats", void 0), MN(this, "uploadUnplinkStarted", false), MN(this, "uploadDownlinkStarted", false), MN(this, "uploadTransportStarted", false), MN(this, "uploadExtensionUsageStarted", false), MN(this, "requestStats", void 0), MN(this, "requestLocalMedia", void 0), MN(this, "requestRemoteMedia", void 0), MN(this, "requestAllTracks", void 0), MN(this, "requestVideoIsReady", void 0), MN(this, "requestUpload", void 0);
        }
        startUploadTransportStats() {
          this.uploadTransportStarted || (this.uploadTransportStarted = true, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = window.setInterval(() => {
            var e3;
            const t3 = null === (e3 = this.requestStats) || void 0 === e3 ? void 0 : e3.call(this);
            t3 && this.uploadTransportStats(t3);
          }, 6e3));
        }
        startUploadExtensionUsageStats() {
          if (this.uploadExtensionUsageStarted)
            return;
          this.uploadExtensionUsageStarted = true, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval);
          const e3 = /* @__PURE__ */ new Map();
          this.extensionUsageStatsUploadInterval = window.setInterval(async () => {
            var t3, i3, r3;
            const n3 = Date.now(), o3 = { connectionInterval: LP("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3, details: [], lts: n3 };
            let s3 = [];
            const a3 = (null === (t3 = this.requestAllTracks) || void 0 === t3 ? void 0 : t3.call(this)) || [];
            for (const e4 of a3)
              !e4.muted && e4.enabled && (s3 = s3.concat(await e4.getProcessorUsage()));
            const c3 = (null === (i3 = this.requestRemoteMedia) || void 0 === i3 ? void 0 : i3.call(this)) || [];
            for (const [e4, t4] of c3)
              t4.has(AB.VIDEO) && e4.videoTrack && (s3 = s3.concat(await e4.videoTrack.getProcessorUsage())), t4.has(AB.AUDIO) && e4.audioTrack && (s3 = s3.concat(await e4.audioTrack.getProcessorUsage()));
            if (0 === s3.length)
              return;
            o3.details = function(e4, t4) {
              const i4 = {};
              for (const { id: n4, value: o4, level: s4, direction: a4 } of e4)
                if (i4[n4])
                  2 === o4 && (i4[n4].value = o4), s4 > i4[n4].level && (i4[n4].level = s4), "remote" === a4 && (i4[n4].remoteUidCount += 1);
                else {
                  var r4;
                  const e5 = null !== (r4 = t4.get(n4)) && void 0 !== r4 ? r4 : 0;
                  i4[n4] = { value: o4, level: s4, remoteUidCount: "local" === a4 ? 0 : 1, totalTs: e5 };
                  const c4 = 2 === o4 ? e5 + LP("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3 : e5;
                  t4.set(n4, c4);
                }
              return Object.keys(i4).map((e5) => {
                const { level: t5, value: r5, totalTs: n4 } = i4[e5];
                return { id: e5, level: t5, value: r5, totalTs: n4 };
              });
            }(s3, e3);
            const d3 = Date.now(), u3 = d3 > n3 ? d3 : n3 + 1;
            null === (r3 = this.requestUpload) || void 0 === r3 || r3.call(this, Ik.EXTENSION_USAGE_STATS, { usageStats: o3, sendTs: u3 });
          }, LP("EXTENSION_USAGE_UPLOAD_INTERVAL"));
        }
        startUploadUplinkStats() {
          this.uploadUnplinkStarted || (this.uploadUnplinkStarted = true, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkStatsUploadInterval = window.setInterval(() => {
            var e3;
            const t3 = null === (e3 = this.requestStats) || void 0 === e3 ? void 0 : e3.call(this);
            t3 && (this.uploadUplinkStats(t3, this.lastStats), this.lastStats = t3);
          }, 3e3), this.uplinkStatsUploadSlowInterval && window.clearInterval(this.uplinkStatsUploadSlowInterval), this.uplinkStatsUploadSlowInterval = window.setInterval(() => {
            var e3;
            const t3 = null === (e3 = this.requestStats) || void 0 === e3 ? void 0 : e3.call(this);
            t3 && this.uploadSlowUplinkStats(t3);
          }, 6e4), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkRelatedStatsUploadInterval = window.setInterval(() => {
            var e3;
            const t3 = null === (e3 = this.requestStats) || void 0 === e3 ? void 0 : e3.call(this);
            t3 && this.uploadRelatedUplinkStats(t3, this.lastStats), this.lastStats = t3;
          }, 1e3), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval = window.setInterval(() => {
            var e3;
            const t3 = null === (e3 = this.requestAllTracks) || void 0 === e3 ? void 0 : e3.call(this);
            t3 && this.uploadDenoiserStats(t3);
          }, 2e3), this.uplinkExtensionStatsUploadInterval && window.clearInterval(this.uplinkExtensionStatsUploadInterval), this.uplinkExtensionStatsUploadInterval = window.setInterval(() => {
            var e3;
            const t3 = null === (e3 = this.requestAllTracks) || void 0 === e3 ? void 0 : e3.call(this);
            t3 && this.uploadExtensionStats(t3);
          }, 2e3));
        }
        uploadTransportStats(e3) {
          NK(() => {
            var t3;
            null === (t3 = this.requestUpload) || void 0 === t3 || t3.call(this, Ik.TRANSPORT_STATS, function(e4) {
              const t4 = { connectionType: 100 };
              if ("relay" === e4.selectedCandidatePair.localCandidate.candidateType) {
                const i3 = e4.selectedCandidatePair.localCandidate.relayProtocol;
                "udp" === i3 && (t4.connectionType = 101), "tcp" === i3 && (t4.connectionType = 103), "tls" === i3 && (t4.connectionType = 104);
              }
              return t4;
            }(e3));
          });
        }
        uploadUplinkStats(e3, t3) {
          var i3;
          ((null === (i3 = this.requestLocalMedia) || void 0 === i3 ? void 0 : i3.call(this)) || []).forEach((i4) => {
            let [r3, { track: n3, ssrcs: o3 }] = i4;
            switch (r3) {
              case lB.LocalVideoLowTrack:
              case lB.LocalVideoTrack: {
                const i5 = function(e4, t4, i6) {
                  var r4;
                  const n4 = t4.videoSend.find((t5) => t5.ssrc === e4);
                  if (!n4)
                    return null;
                  const o4 = { id: mK(10, ""), timestamp: new Date(t4.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: n4.ssrc.toString() };
                  switch (o4.A_vstd = i6._originMediaStreamTrack && !i6._originMediaStreamTrack.enabled || i6._mediaStreamTrack && !i6._mediaStreamTrack.enabled ? "1" : "0", n4.sentFrame && (o4.A_fhs = n4.sentFrame.height.toString(), o4.A_frs = n4.sentFrame.frameRate.toString(), o4.A_fws = n4.sentFrame.width.toString()), n4.adaptionChangeReason) {
                    case "none":
                      o4.A_ac = "0";
                      break;
                    case "cpu":
                      o4.A_ac = "1";
                      break;
                    case "bandwidth":
                      o4.A_ac = "2";
                      break;
                    case "other":
                      o4.A_ac = "3";
                  }
                  return o4.A_lvps = XL[i6._player ? i6._player.videoElementStatus : "uninit"].toString(), o4.A_nr = null === (r4 = n4.nacksCount) || void 0 === r4 ? void 0 : r4.toString(), n4.avgEncodeMs && (o4.A_aem = n4.avgEncodeMs.toFixed(0).toString()), o4;
                }(o3[0].ssrcId, e3, n3), s4 = aK(o3[0].ssrcId, e3, t3);
                i5 && NK(() => {
                  var e4;
                  return null === (e4 = this.requestUpload) || void 0 === e4 ? void 0 : e4.call(this, Ik.PUBLISH_STATS, { stream_type: r3 === lB.LocalVideoLowTrack ? "low" : "high", stats: $1($1({}, i5), s4) });
                });
                break;
              }
              case lB.LocalAudioTrack: {
                const t4 = function(e4, t5, i5) {
                  const r4 = t5.audioSend.find((t6) => t6.ssrc === e4);
                  if (!r4)
                    return null;
                  const n4 = { id: mK(10, ""), timestamp: new Date(t5.timestamp).toISOString(), mediaType: "audio", type: "ssrc", ssrc: r4.ssrc.toString() };
                  return n4.A_astd = i5._originMediaStreamTrack.enabled && i5._mediaStreamTrack.enabled ? "0" : "1", r4.inputLevel ? n4.A_ail = Math.round(100 * r4.inputLevel).toString() : n4.A_ail = Math.round(100 * i5._source.getAccurateVolumeLevel()).toString(), n4.A_apil = Math.round(100 * i5._source.getAccurateVolumeLevel()).toString(), r4.aecReturnLoss && (n4.A_ecrl = Math.round(r4.aecReturnLoss).toString()), r4.aecReturnLossEnhancement && (n4.A_ecrle = Math.round(r4.aecReturnLossEnhancement).toString()), n4;
                }(o3[0].ssrcId, e3, n3);
                t4 && NK(() => {
                  var e4;
                  return null === (e4 = this.requestUpload) || void 0 === e4 ? void 0 : e4.call(this, Ik.PUBLISH_STATS, { stream_type: "high", stats: t4 });
                });
                break;
              }
            }
            const s3 = function(e4) {
              const t4 = { id: "bweforvideo", timestamp: new Date(e4.timestamp).toISOString(), type: "VideoBwe" };
              return e4.bitrate.retransmit && (t4.A_rb = e4.bitrate.retransmit.toString()), e4.bitrate.targetEncoded && (t4.A_teb = e4.bitrate.targetEncoded.toString()), t4.A_aeb = e4.bitrate.actualEncoded.toString(), t4.A_tb = e4.bitrate.transmit.toString(), void 0 !== e4.sendBandwidth && (t4.A_asb = e4.sendBandwidth.toString()), t4;
            }(e3);
            s3 && NK(() => {
              var e4;
              return null === (e4 = this.requestUpload) || void 0 === e4 ? void 0 : e4.call(this, Ik.PUBLISH_STATS, { stream_type: r3 === lB.LocalVideoLowTrack ? "low" : "high", stats: s3 });
            });
          });
        }
        uploadSlowUplinkStats(e3) {
          var t3;
          ((null === (t3 = this.requestLocalMedia) || void 0 === t3 ? void 0 : t3.call(this)) || []).filter((e4) => {
            let [t4] = e4;
            return t4 === lB.LocalVideoLowTrack || t4 === lB.LocalVideoTrack;
          }).forEach((t4) => {
            let [i3, { ssrcs: r3 }] = t4;
            const n3 = aK(r3[0].ssrcId, e3);
            n3 && NK(() => {
              var e4;
              return null === (e4 = this.requestUpload) || void 0 === e4 ? void 0 : e4.call(this, Ik.PUBLISH_STATS, { stream_type: i3 === lB.LocalVideoLowTrack ? "low" : "high", stats: n3 });
            });
          });
        }
        uploadRelatedUplinkStats(e3, t3) {
          var i3;
          ((null === (i3 = this.requestLocalMedia) || void 0 === i3 ? void 0 : i3.call(this)) || []).filter((e4) => {
            let [t4] = e4;
            return t4 === lB.LocalVideoLowTrack || t4 === lB.LocalVideoTrack;
          }).forEach((t4) => {
            let [i4, { ssrcs: r3 }] = t4;
            const n3 = function(e4, t5) {
              const i5 = t5.videoSend.find((t6) => t6.ssrc === e4);
              return i5 ? { mediaType: "video", isVideoMute: false, frameRateInput: i5.inputFrame && i5.inputFrame.frameRate.toString(), frameRateSent: i5.sentFrame && i5.sentFrame.frameRate.toString(), googRtt: i5.rttMs.toString(), qpSumPerFrame: Math.floor(i5.qpSumPerFrame).toString() } : null;
            }(r3[0].ssrcId, e3);
            n3 && NK(() => {
              var e4;
              null === (e4 = this.requestUpload) || void 0 === e4 || e4.call(this, Ik.PUBLISH_RELATED_STATS, { stream_type: i4 === lB.LocalVideoLowTrack ? "low" : "high", stats: n3 });
            });
          });
        }
        uploadDenoiserStats(e3) {
          for (let n3 = 0; n3 < e3.length; n3++) {
            const o3 = e3[n3];
            if (o3 instanceof WG) {
              var t3, i3, r3;
              const e4 = null === (t3 = (i3 = o3._external).getDenoiserStats) || void 0 === t3 ? void 0 : t3.call(i3);
              return void (e4 && (null === (r3 = this.requestUpload) || void 0 === r3 || r3.call(this, Ik.DENOISER_STATS, e4)));
            }
          }
        }
        uploadExtensionStats(e3) {
          for (let t3 = 0; t3 < e3.length; t3++) {
            e3[t3].getProcessorStats().forEach((e4) => {
              var t4;
              null === (t4 = this.requestUpload) || void 0 === t4 || t4.call(this, e4.type, e4.stats);
            });
          }
        }
        stopUploadUplinkStats() {
          this.uploadUnplinkStarted && (this.uploadUnplinkStarted = false, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkStatsUploadInterval = void 0, this.uplinkRelatedStatsUploadInterval = void 0, this.uplinkDenoiserStatsUploadInterval = void 0);
        }
        startUploadDownlinkStats() {
          this.uploadDownlinkStarted || (this.uploadDownlinkStarted = true, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval), this.downlinkStatsUploadInterval = window.setInterval(() => {
            var e3;
            const t3 = null === (e3 = this.requestStats) || void 0 === e3 ? void 0 : e3.call(this);
            t3 && (this.uploadDownlinkStats(t3, this.lastStats), this.lastStats = t3);
          }, 3e3), this.downlinkStatsUploadSlowInterval && window.clearInterval(this.downlinkStatsUploadSlowInterval), this.downlinkStatsUploadSlowInterval = window.setInterval(() => {
            var e3;
            const t3 = null === (e3 = this.requestStats) || void 0 === e3 ? void 0 : e3.call(this);
            t3 && this.uploadSlowDownlinkStats(t3);
          }, 6e4), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkRelatedStatsUploadInterval = window.setInterval(() => {
            var e3;
            const t3 = null === (e3 = this.requestStats) || void 0 === e3 ? void 0 : e3.call(this);
            t3 && (this.uploadRelatedDownlinkStats(t3, this.lastStats), this.lastStats = t3);
          }, 1e3), this.downlinkExtensionStatsUploadInterval && window.clearInterval(this.downlinkExtensionStatsUploadInterval), this.downlinkExtensionStatsUploadInterval = window.setInterval(() => {
            var e3;
            const t3 = null === (e3 = this.requestRemoteMedia) || void 0 === e3 ? void 0 : e3.call(this);
            t3 && this.uploadDownlinkExtensionStats(t3);
          }, 2e3));
        }
        uploadDownlinkStats(e3, t3) {
          var i3;
          ((null === (i3 = this.requestRemoteMedia) || void 0 === i3 ? void 0 : i3.call(this)) || []).forEach((t4) => {
            let [i4, r3] = t4;
            if (r3.has(AB.VIDEO) && i4.videoTrack) {
              const t5 = i4.videoTrack ? function(e4, t6, i5) {
                const r4 = t6.videoRecv.find((t7) => t7.ssrc === e4);
                if (!r4)
                  return null;
                const n3 = { id: mK(10, ""), timestamp: new Date(t6.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: r4.ssrc.toString() };
                var o3, s3;
                return n3.bytesReceived = r4.bytes.toString(), n3.packetsLost = r4.packetsLost.toString(), n3.packetsReceived = r4.packets.toString(), r4.framesRateFirefox && (n3.A_frr = r4.framesRateFirefox.toString()), r4.receivedFrame ? (n3.A_frr = r4.receivedFrame.frameRate.toString(), n3.A_fhr = r4.receivedFrame.height.toString(), n3.A_fwr = r4.receivedFrame.width.toString()) : (n3.A_fhr = null === (o3 = i5._videoHeight) || void 0 === o3 ? void 0 : o3.toString(), n3.A_fwr = null === (s3 = i5._videoWidth) || void 0 === s3 ? void 0 : s3.toString()), n3.A_frd = r4.decodeFrameRate.toString(), r4.outputFrame && (n3.A_fro = r4.outputFrame.frameRate.toString()), void 0 !== r4.jitterBufferMs && (n3.A_jbm = Math.floor(r4.jitterBufferMs).toString()), void 0 !== r4.currentDelayMs && (n3.A_cdm = Math.floor(r4.currentDelayMs).toString()), n3.A_fs = r4.firsCount.toString(), n3.A_ns = r4.nacksCount.toString(), n3.A_ps = r4.plisCount.toString(), i5 && (n3.A_vrtd = i5._originMediaStreamTrack.enabled && i5._mediaStreamTrack.enabled ? "0" : "1"), i5._player && i5._player.freezeTimeCounterList.length > 0 && (n3.A_vrft = i5._player.freezeTimeCounterList.splice(0, 1)[0].toString()), n3.A_rvps = XL[i5._player ? i5._player.videoElementStatus : "uninit"].toString(), n3;
              }(i4._videoSSRC, e3, i4.videoTrack) : void 0;
              t5 && NK(() => {
                var e4;
                return null === (e4 = this.requestUpload) || void 0 === e4 ? void 0 : e4.call(this, Ik.SUBSCRIBE_STATS, { stream_id: i4.uid, stats: t5 });
              });
            }
            if (r3.has(AB.AUDIO) && i4.audioTrack) {
              const t5 = i4.audioTrack ? function(e4, t6, i5) {
                const r4 = t6.audioRecv.find((t7) => t7.ssrc === e4);
                if (!r4)
                  return null;
                const n3 = { id: mK(10, ""), timestamp: new Date(t6.timestamp).toISOString(), mediaType: "audio", type: "ssrc", ssrc: r4.ssrc.toString() };
                return n3.bytesReceived = r4.bytes.toString(), n3.packetsLost = r4.packetsLost.toString(), n3.packetsReceived = r4.packets.toString(), r4.outputLevel ? n3.A_aol = Math.round(100 * r4.outputLevel).toString() : n3.A_aol = Math.round(100 * i5._source.getAccurateVolumeLevel()).toString(), n3.A_apol = Math.round(100 * i5._source.getAccurateVolumeLevel()).toString(), i5 && (n3.A_artd = i5._originMediaStreamTrack.enabled && i5._mediaStreamTrack.enabled ? "0" : "1"), n3.A_jr = r4.jitterMs.toString(), n3.A_jbm = Math.floor(r4.jitterBufferMs).toString(), n3.A_cdm = Math.floor(r4.jitterBufferMs).toString(), n3.A_raps = XL[zj.getPlayerState(i5.getTrackId())].toString(), n3;
              }(i4._audioSSRC, e3, i4.audioTrack) : void 0;
              t5 && NK(() => {
                var e4;
                return null === (e4 = this.requestUpload) || void 0 === e4 ? void 0 : e4.call(this, Ik.SUBSCRIBE_STATS, { stream_id: i4.uid, stats: t5 });
              });
            }
          });
        }
        uploadSlowDownlinkStats(e3) {
        }
        uploadRelatedDownlinkStats(e3, t3) {
          var i3;
          ((null === (i3 = this.requestRemoteMedia) || void 0 === i3 ? void 0 : i3.call(this)) || []).forEach((i4) => {
            let [r3, n3] = i4;
            if (n3.has(AB.VIDEO) && r3.videoTrack) {
              var o3;
              const i5 = true === (r3._videoSSRC && (null === (o3 = this.requestVideoIsReady) || void 0 === o3 ? void 0 : o3.call(this, r3._videoSSRC)) || false), n4 = function(e4, t4, i6, r4, n5, o4) {
                const s3 = i6.videoRecv.find((t5) => t5.ssrc === e4), a3 = n5 ? n5.videoRecv.find((t5) => t5.ssrc === e4) : void 0;
                if (!s3)
                  return null;
                const c3 = eK.isRemoteVideoFreeze(o4, s3, a3) && t4, d3 = { mediaType: "video", isVideoMute: false, peerId: r4, frameRateReceived: s3.receivedFrame && s3.receivedFrame.frameRate.toString(), frameRateDecoded: s3.decodedFrame && s3.decodedFrame.frameRate.toString(), isFreeze: c3, bytesReceived: s3.bytes.toString(), packetsReceived: s3.packets.toString(), packetsLost: s3.packetsLost.toString(), qpSumPerFrame: Math.floor(s3.qpSumPerFrame).toString() };
                return s3.framesRateFirefox && (d3.frameRateDecoded = s3.framesRateFirefox.toString(), d3.frameRateReceived = s3.framesRateFirefox.toString()), d3;
              }(r3._videoSSRC, i5, e3, r3.uid, t3, r3.videoTrack);
              n4 && NK(() => {
                var e4;
                null === (e4 = this.requestUpload) || void 0 === e4 || e4.call(this, Ik.SUBSCRIBE_RELATED_STATS, { stream_id: r3.uid, stats: n4 });
              });
            }
            if (n3.has(AB.AUDIO) && r3.audioTrack) {
              const t4 = function(e4, t5, i5, r4) {
                const n4 = t5.audioRecv.find((t6) => t6.ssrc === e4);
                if (!n4)
                  return null;
                const o4 = eK.isRemoteAudioFreeze(r4);
                return { mediaType: "audio", isAudioMute: false, peerId: i5, googJitterReceived: n4.jitterMs.toString(), isFreeze: o4, bytesReceived: n4.bytes.toString(), packetsReceived: n4.packets.toString(), packetsLost: n4.packetsLost.toString(), frameReceived: n4.receivedFrames.toString(), frameDropped: n4.droppedFrames.toString() };
              }(r3._audioSSRC, e3, r3.uid, r3.audioTrack);
              t4 && NK(() => {
                var e4;
                null === (e4 = this.requestUpload) || void 0 === e4 || e4.call(this, Ik.SUBSCRIBE_RELATED_STATS, { stream_id: r3.uid, stats: t4 });
              });
            }
          });
        }
        stopUploadDownlinkStats() {
          this.uploadDownlinkStarted && (this.uploadDownlinkStarted = false, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkStatsUploadInterval = void 0, this.downlinkRelatedStatsUploadInterval = void 0);
        }
        stopUploadTransportStats() {
          this.uploadTransportStarted && (this.uploadTransportStarted = false, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = void 0);
        }
        stopUploadExtensionUsageStats() {
          this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = false, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval), this.extensionUsageStatsUploadInterval = void 0);
        }
        uploadDownlinkExtensionStats(e3) {
          e3.forEach((e4) => {
            let [t3, i3] = e4;
            if (i3.has(AB.VIDEO) && t3.videoTrack) {
              t3.videoTrack.getProcessorStats().forEach((e5) => {
                var t4;
                null === (t4 = this.requestUpload) || void 0 === t4 || t4.call(this, e5.type, e5.stats);
              });
            }
            if (i3.has(AB.AUDIO) && t3.audioTrack) {
              t3.audioTrack.getProcessorStats().forEach((e5) => {
                var t4;
                null === (t4 = this.requestUpload) || void 0 === t4 || t4.call(this, e5.type, e5.stats);
              });
            }
          });
        }
      }
      var t0;
      const i0 = "v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0\na=msid-semantic: WMS\na=ice-lite\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 127.0.0.1\na=mid:0\n", r0 = "9", n0 = 2e4, o0 = 4e4;
      let s0 = mP("RemoteSDP")(t0 = class {
        get localCapabilities() {
          return OK(this._localCapabilities);
        }
        get rtpCapabilities() {
          return OK(this._rtpCapabilities);
        }
        get candidates() {
          return OK(this._candidates);
        }
        get iceParameters() {
          return OK(this._iceParameters);
        }
        get dtlsParameters() {
          return OK(this._dtlsParameters);
        }
        constructor(e3) {
          MN(this, "sessionDesc", void 0), MN(this, "_localCapabilities", void 0), MN(this, "_rtpCapabilities", void 0), MN(this, "_candidates", void 0), MN(this, "_iceParameters", void 0), MN(this, "_dtlsParameters", void 0), MN(this, "setup", void 0), MN(this, "currentMidIndex", void 0), MN(this, "cname", void 0), MN(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e3 = OK(e3);
          const { remoteIceParameters: t3, remoteDtlsParameters: i3, candidates: r3, remoteRTPCapabilities: n3, remoteSetup: o3, localCapabilities: s3, cname: a3 } = e3, c3 = K$.exports.parse(i0);
          this._rtpCapabilities = n3, this._candidates = r3, this._iceParameters = t3, this._dtlsParameters = i3, this._localCapabilities = s3, this.setup = o3, this.cname = a3;
          const d3 = this.rtpCapabilities.send;
          for (const e4 of c3.mediaDescriptions) {
            if (e4.attributes.iceUfrag = t3.iceUfrag, e4.attributes.icePwd = t3.icePwd, e4.attributes.fingerprints = i3.fingerprints, e4.attributes.candidates = r3, e4.attributes.setup = o3, "application" === e4.media.mediaType && (e4.attributes.sctpPort = "5000"), "video" === e4.media.mediaType && (e4.media.fmts = d3.videoCodecs.map((e5) => e5.payloadType.toString(10)), e4.attributes.payloads = d3.videoCodecs, e4.attributes.extmaps = d3.videoExtensions, LP("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t4, ssrcGroups: i4 } = z$([{ ssrcId: o0, rtx: LP("USE_RTX") ? 40001 : void 0 }], this.cname);
              e4.attributes.ssrcs = t4, e4.attributes.ssrcGroups = i4;
            }
            if ("audio" === e4.media.mediaType && (e4.media.fmts = d3.audioCodecs.map((e5) => e5.payloadType.toString(10)), e4.attributes.payloads = d3.audioCodecs, e4.attributes.extmaps = d3.audioExtensions, a1(e4), LP("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t4, ssrcGroups: i4 } = z$([{ ssrcId: n0 }], this.cname);
              e4.attributes.ssrcs = t4, e4.attributes.ssrcGroups = i4;
            }
          }
          this.sessionDesc = c3, this.currentMidIndex = c3.mediaDescriptions.length - 1;
        }
        updateRemoteRTPCapabilities(e3) {
          const t3 = K$.exports.parse(i0);
          this._rtpCapabilities = e3;
          const i3 = this.rtpCapabilities.send;
          for (const e4 of t3.mediaDescriptions) {
            if (e4.attributes.iceUfrag = this._iceParameters.iceUfrag, e4.attributes.icePwd = this._iceParameters.icePwd, e4.attributes.fingerprints = this._dtlsParameters.fingerprints, e4.attributes.candidates = this._candidates, e4.attributes.setup = this.setup, "application" === e4.media.mediaType && (e4.attributes.sctpPort = "5000"), "video" === e4.media.mediaType && (e4.media.fmts = i3.videoCodecs.map((e5) => e5.payloadType.toString(10)), e4.attributes.payloads = i3.videoCodecs, e4.attributes.extmaps = i3.videoExtensions, LP("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t4, ssrcGroups: i4 } = z$([{ ssrcId: o0, rtx: LP("USE_RTX") ? 40001 : void 0 }], this.cname);
              e4.attributes.ssrcs = t4, e4.attributes.ssrcGroups = i4;
            }
            if ("audio" === e4.media.mediaType && (e4.media.fmts = i3.audioCodecs.map((e5) => e5.payloadType.toString(10)), e4.attributes.payloads = i3.audioCodecs, e4.attributes.extmaps = i3.audioExtensions, LP("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t4, ssrcGroups: i4 } = z$([{ ssrcId: n0 }], this.cname);
              e4.attributes.ssrcs = t4, e4.attributes.ssrcGroups = i4;
            }
          }
          this.sessionDesc = t3, this.currentMidIndex = t3.mediaDescriptions.length - 1;
        }
        preloadRemoteMedia(e3) {
          this.rtpCapabilities;
          const t3 = this.candidates, i3 = this.dtlsParameters, r3 = this.iceParameters, n3 = this.rtpCapabilities.send;
          for (let o3 = 1; o3 < e3; o3++) {
            const e4 = 2 * o3 + n0, s3 = 2 * o3 + o0, { ssrcs: a3, ssrcGroups: c3 } = z$([{ ssrcId: e4 }], this.cname), { ssrcs: d3, ssrcGroups: u3 } = z$([{ ssrcId: s3, rtx: LP("USE_RTX") ? s3 + 1 : void 0 }], this.cname);
            this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: r0, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: n3.videoCodecs.map((e5) => e5.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: r3.iceUfrag, icePwd: r3.icePwd, unrecognized: [], candidates: t3, extmaps: n3.videoExtensions, fingerprints: i3.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: d3, ssrcGroups: u3, rtcpFeedbackWildcards: [], payloads: n3.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o3 - 1) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: r0, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: n3.audioCodecs.map((e5) => e5.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: r3.iceUfrag, icePwd: r3.icePwd, unrecognized: [], candidates: t3, extmaps: n3.audioExtensions, fingerprints: i3.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: a3, ssrcGroups: c3, rtcpFeedbackWildcards: [], payloads: n3.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o3) } }), this.currentMidIndex += 2;
          }
          this.updateBundleMids();
        }
        toString() {
          return K$.exports.print(this.sessionDesc);
        }
        send(e3, t3, i3, r3) {
          const { ssrcs: n3, ssrcGroups: o3 } = z$(t3, this.cname, i3), s3 = this.findPreloadMediaDesc(n3);
          if (s3) {
            if (gN() && this.firefoxSsrcMidMap.set(n3[0].ssrcId, s3.attributes.mid), r3 && (r3.tcc || r3.remb)) {
              const e4 = this.sessionDesc.mediaDescriptions.indexOf(s3);
              return this.sessionDesc.mediaDescriptions[e4] = this.mungSendMediaDesc(s3, r3), { mid: s3.attributes.mid, needExchangeSDP: true };
            }
            return { mid: s3.attributes.mid, needExchangeSDP: false };
          }
          {
            const t4 = this.findAvailableMediaIndex(e3, n3);
            if (pN() || mN() || fN()) {
              if (-1 !== t4 && 2 !== t4) {
                const e4 = OK(this.sessionDesc.mediaDescriptions[t4]);
                return e4.attributes.direction = "sendonly", e4.attributes.ssrcs = n3, e4.attributes.ssrcGroups = o3, this.sessionDesc.mediaDescriptions[t4] = this.mungSendMediaDesc(e4, r3), { mid: e4.attributes.mid, needExchangeSDP: true };
              }
              {
                const t5 = this.createOrRecycleSendMedia(e3, n3, o3, "sendonly", r3);
                return this.updateBundleMids(), { mid: t5.attributes.mid, needExchangeSDP: true };
              }
            }
            if (-1 !== t4) {
              const e4 = OK(this.sessionDesc.mediaDescriptions[t4]);
              return e4.attributes.direction = "sendonly", e4.attributes.ssrcs = n3, e4.attributes.ssrcGroups = o3, this.sessionDesc.mediaDescriptions[t4] = this.mungSendMediaDesc(e4, r3), gN() && this.firefoxSsrcMidMap.set(n3[0].ssrcId, e4.attributes.mid), { mid: e4.attributes.mid, needExchangeSDP: true };
            }
            {
              const t5 = this.createOrRecycleSendMedia(e3, n3, o3, "sendonly", r3);
              return this.updateBundleMids(), gN() && this.firefoxSsrcMidMap.set(n3[0].ssrcId, t5.attributes.mid), { mid: t5.attributes.mid, needExchangeSDP: true };
            }
          }
        }
        batchSend(e3) {
          const t3 = e3.map((e4) => {
            let { kind: t4, ssrcMsg: i4, mslabel: r4 } = e4;
            return this.send(t4, i4, r4);
          }), i3 = [];
          let r3 = false;
          return t3.forEach((e4) => {
            let { mid: t4, needExchangeSDP: n3 } = e4;
            n3 && (r3 = true), i3.push(t4);
          }), { mids: i3, needExchangeSDP: r3 };
        }
        stopSending(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => t4.attributes.mid && -1 !== e3.indexOf(t4.attributes.mid));
          if (t3.length !== e3.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
          t3.forEach((e4) => {
            "0" === e4.attributes.mid || gN() || pN() || mN() || fN() ? e4.attributes.ssrcs = [] : (e4.attributes.ssrcs = [], e4.attributes.direction = "inactive", e4.media.port = "0");
          }), this.updateBundleMids();
        }
        mute(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
          if (!t3)
            throw new Error("mediaDescription not found with ".concat(e3, " in remote SDP when calling RemoteSDP.mute."));
          t3.attributes.direction = "inactive";
        }
        unmute(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
          if (!t3)
            throw new Error("mediaDescription not found with ".concat(e3, " in remote SDP when calling RemoteSDP.unmute."));
          t3.attributes.direction = "sendonly";
        }
        muteRemote(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => e3.includes(t4.attributes.mid || ""));
          if (t3.length !== e3.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t3.forEach((e4) => {
            e4.attributes.direction = "inactive";
          });
        }
        unmuteRemote(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => e3.includes(t4.attributes.mid || ""));
          if (t3.length !== e3.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t3.forEach((e4) => {
            e4.attributes.direction = "recvonly";
          });
        }
        receive(e3, t3, i3, r3) {
          e3.forEach((e4, n3) => {
            this.createOrRecycleRecvMedia(e4, [], "recvonly", t3, i3, r3[n3]);
          }), this.updateBundleMids();
        }
        stopReceiving(e3) {
          const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => -1 !== e3.indexOf(t4.attributes.mid));
          if (t3.length !== e3.length)
            throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
          t3.forEach((e4) => {
            e4.media.port = "0", e4.attributes.direction = "inactive";
          }), this.updateBundleMids();
        }
        restartICE(e3) {
          e3 = OK(e3), this._iceParameters = e3, this.sessionDesc.mediaDescriptions.forEach((t3) => {
            t3.attributes.iceUfrag = e3.iceUfrag, t3.attributes.icePwd = e3.icePwd;
          });
        }
        predictReceivingMids(e3) {
          const t3 = [];
          for (let i3 = 0; i3 < e3; i3++)
            t3.push((this.currentMidIndex + i3 + 1).toString(10));
          return t3;
        }
        findAvailableMediaIndex(e3, t3) {
          return this.sessionDesc.mediaDescriptions.findIndex((i3) => {
            const r3 = i3.media.mediaType === e3 && "0" !== i3.media.port && ("sendonly" === i3.attributes.direction || "sendrecv" === i3.attributes.direction) && 0 === i3.attributes.ssrcs.length;
            if (gN()) {
              if (r3) {
                const e4 = this.firefoxSsrcMidMap.get(t3[0].ssrcId);
                return !(e4 || "0" !== i3.attributes.mid && "1" !== i3.attributes.mid) || !(!e4 || e4 !== i3.attributes.mid);
              }
              return false;
            }
            return r3;
          });
        }
        createOrRecycleRecvMedia(e3, t3, i3, r3, n3, o3) {
          const s3 = e3._mediaStreamTrack.kind, a3 = this.rtpCapabilities.recv, c3 = this.localCapabilities.send;
          let d3 = [];
          if (s3 === AB.VIDEO) {
            var u3, h3;
            if (LP("H264_PROFILE_LEVEL_ID") && "h264" === r3 && (d3 = a3.videoCodecs.filter((e4) => {
              var t4, i4;
              return ((null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "").includes(r3) && (null == e4 || null === (i4 = e4.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]) === LP("H264_PROFILE_LEVEL_ID");
            })), !d3 || 0 === (null === (u3 = d3) || void 0 === u3 ? void 0 : u3.length)) {
              const e4 = c3.videoCodecs.filter((e5) => {
                var t4;
                return ((null === (t4 = e5.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "").includes(r3);
              });
              0 !== e4.length && (d3 = a3.videoCodecs.filter((t4) => e4.some((e5) => e5.payloadType === t4.payloadType)));
            }
            if (LP("USE_RTX")) {
              const e4 = d3.map((e5) => e5.payloadType.toString()), t4 = a3.videoCodecs.filter((t5) => {
                var i4, r4;
                return "rtx" === (null === (i4 = t5.rtpMap) || void 0 === i4 ? void 0 : i4.encodingName) && e4.includes((null === (r4 = t5.fmtp) || void 0 === r4 ? void 0 : r4.parameters.apt) || "");
              });
              d3 = [...d3, ...t4];
            }
            if (0 === d3.length)
              JD.warning("codec ".concat(r3, " not included in rtpCapabilities, fallback to default payloads: ").concat(null === (h3 = a3.videoCodecs[0].rtpMap) || void 0 === h3 ? void 0 : h3.encodingName)), d3 = a3.videoCodecs;
          } else
            d3 = a3.audioCodecs.filter((e4) => {
              var t4;
              return ((null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "").includes(n3);
            }), 0 === d3.length && (JD.warning("codec ".concat(n3, " not included in rtpCapabilities, fallback to opus")), d3 = a3.audioCodecs.filter((e4) => {
              var t4;
              return ((null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "").includes("opus");
            }));
          const A3 = s3 === AB.VIDEO ? a3.videoExtensions : a3.audioExtensions;
          this.currentMidIndex += 1;
          const l3 = "".concat(this.currentMidIndex);
          let p3 = { media: { mediaType: s3, port: r0, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: d3.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: A3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t3, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: d3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i3, rtcpMux: true, rtcpRsize: true, mid: "".concat(l3) } };
          p3 = this.mungRecvMediaDsec(p3, e3, o3);
          const g3 = this.findFirstClosedMedia(s3);
          if (g3) {
            const e4 = this.sessionDesc.mediaDescriptions.indexOf(g3);
            this.sessionDesc.mediaDescriptions[e4] = p3;
          } else
            this.sessionDesc.mediaDescriptions.push(p3);
          return p3;
        }
        createOrRecycleSendMedia(e3, t3, i3, r3, n3) {
          const o3 = this.rtpCapabilities.send, s3 = e3 === AB.VIDEO ? o3.videoCodecs : o3.audioCodecs, a3 = e3 === AB.VIDEO ? o3.videoExtensions : o3.audioExtensions;
          this.currentMidIndex += 1;
          const c3 = "".concat(this.currentMidIndex);
          let d3 = { media: { mediaType: e3, port: r0, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: s3.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t3, ssrcGroups: i3, rtcpFeedbackWildcards: [], payloads: s3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: r3, rtcpMux: true, rtcpRsize: true, mid: "".concat(c3) } };
          d3 = this.mungSendMediaDesc(d3, n3);
          const u3 = this.findFirstClosedMedia(e3);
          if (u3) {
            const e4 = this.sessionDesc.mediaDescriptions.indexOf(u3);
            this.sessionDesc.mediaDescriptions[e4] = d3;
          } else
            this.sessionDesc.mediaDescriptions.push(d3);
          return d3;
        }
        updateBundleMids() {
          this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e3) => "0" !== e3.media.port).map((e3) => e3.attributes.mid);
        }
        mungRecvMediaDsec(e3, t3, i3) {
          const r3 = OK(e3);
          return $$(r3), Z$(r3, t3), e1(r3, t3), t1(r3), i1(r3, i3, this.localCapabilities.send), r3;
        }
        mungSendMediaDesc(e3, t3) {
          const i3 = OK(e3);
          return i1(i3, t3, this.localCapabilities.recv), a1(i3), i3;
        }
        updateRecvMedia(e3, t3) {
          const i3 = this.sessionDesc.mediaDescriptions.findIndex((t4) => t4.attributes.mid === e3);
          if (-1 !== i3) {
            const e4 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i3], t3);
            this.sessionDesc.mediaDescriptions[i3] = e4;
          }
        }
        bumpMid(e3) {
          this.currentMidIndex += e3;
        }
        findFirstClosedMedia(e3) {
          return this.sessionDesc.mediaDescriptions.find((t3) => gN() ? "0" === t3.media.port && t3.media.mediaType === e3 : "0" === t3.media.port);
        }
        findPreloadMediaDesc(e3) {
          return this.sessionDesc.mediaDescriptions.find((t3) => {
            var i3, r3;
            return (null === (i3 = t3.attributes) || void 0 === i3 || null === (r3 = i3.ssrcs[0]) || void 0 === r3 ? void 0 : r3.ssrcId) === e3[0].ssrcId;
          });
        }
        getSSRC(e3) {
          var t3;
          return null === (t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3)) || void 0 === t3 ? void 0 : t3.attributes.ssrcs;
        }
      }) || t0;
      var a0, c0;
      function d0(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function u0(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? d0(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : d0(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      let h0 = mP("NVExtentionsConnection", "store.p2pId")((VV((c0 = class e3 extends RB {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        constructor(e4, t3, i3) {
          super(e4, t3), MN(this, "store", void 0), MN(this, "peerConnection", void 0), MN(this, "remoteSDP", void 0), MN(this, "initialOffer", void 0), MN(this, "transportEventReceiver", void 0), MN(this, "statsFilter", void 0), MN(this, "useRTX", LP("USE_RTX")), MN(this, "localCapabilities", void 0), MN(this, "localCandidateCount", 0), MN(this, "allCandidatesReceived", false), MN(this, "mutex", new fj("NVExtentionsConnection-mutex")), MN(this, "rtcMedia", void 0), this.store = t3, this.peerConnection = i3, this.statsFilter = N1(this.peerConnection, void 0, void 0, gN() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;
        }
        async establish(e4) {
          try {
            const e5 = await this.peerConnection.createOffer();
            if (!e5.sdp)
              throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t3 = J$(e5.sdp), i3 = await n1(!this.useRTX, LP("FILTER_VIDEO_FEC"), LP("FILTER_AUDIO_FEC"));
            return this.localCapabilities = i3, this.initialOffer = e5, u0(u0({}, t3), {}, { rtpCapabilities: i3, offerSDP: e5.sdp });
          } catch (e5) {
            throw new QD(xD.GET_LOCAL_CONNECTION_PARAMS_FAILED, e5.toString());
          }
        }
        async connect(e4, t3, i3, r3, n3, o3) {
          try {
            if (!this.initialOffer)
              throw new Error("Cannot establish NVConnection without initial offer.");
            this.remoteSDP = new s0({ remoteIceParameters: e4, remoteDtlsParameters: t3, candidates: i3, remoteRTPCapabilities: r3, remoteSetup: n3, localCapabilities: s1(this.localCapabilities), cname: o3 });
            const s3 = this.remoteSDP.toString(), a3 = K$.exports.parse(this.initialOffer.sdp), c3 = a3.mediaDescriptions.find((e5) => "audio" === e5.media.mediaType);
            c3 && a1(c3);
            const d3 = K$.exports.print(a3), u3 = this.logSDPExchange(d3 || "", "offer", "local", "connect");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: d3 }), null == u3 || u3(s3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s3 });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "NV.connect failed; ".concat(e5.toString()));
          }
        }
        async updateRemoteConnect(e4) {
          var t3, i3, r3;
          null === (t3 = this.remoteSDP) || void 0 === t3 || t3.updateRemoteRTPCapabilities(e4), null === (i3 = this.remoteSDP) || void 0 === i3 || i3.preloadRemoteMedia(2);
          const n3 = null === (r3 = this.remoteSDP) || void 0 === r3 ? void 0 : r3.toString();
          await this.peerConnection.setRemoteDescription({ type: "offer", sdp: n3 });
          const o3 = await this.peerConnection.createAnswer();
          await this.peerConnection.setLocalDescription(o3), JD.debug("[NVExtentionsConnection] updateRemoteRTPCapabilities by exchanging SDP.");
        }
        send(e4, t3, i3) {
          var r3 = this;
          return I$(function* () {
            const n3 = yield _$(r3.mutex.lock("From NVExtentionsConnection.send"));
            try {
              if (!r3.remoteSDP)
                throw new Error("Cannot call NVExtentionsConnection.send before remote SDP created");
              const o3 = [];
              e4.forEach((e5) => {
                const t4 = r3.peerConnection.addTransceiver(e5._mediaStreamTrack, { direction: "sendonly" });
                o3.push(t4);
              }), gN() && true === LP("SIMULCAST") && (hP("debug", r3, "apply simulcast for firefox"), yield _$(r3.applySimulcastForFirefox(o3, e4)));
              const s3 = yield _$(r3.peerConnection.createOffer()), a3 = r3.remoteSDP.predictReceivingMids(e4.length), c3 = r3.mungSendOfferSDP(s3.sdp, e4, a3), d3 = K$.exports.parse(c3), u3 = a3.map((e5) => {
                const t4 = d3.mediaDescriptions.find((t5) => t5.attributes.mid === e5);
                if (!t4)
                  throw new Error("Cannot extract ssrc from mediaDescription.");
                return q$(t4, r3.useRTX);
              });
              let h3;
              try {
                h3 = yield u3;
              } catch (n4) {
                h3 = [], r3.remoteSDP.receive(e4, t3, i3, h3);
                const o4 = r3.remoteSDP.toString();
                throw yield _$(r3.peerConnection.setLocalDescription({ type: "offer", sdp: c3 })), yield _$(r3.peerConnection.setRemoteDescription({ type: "answer", sdp: o4 })), yield _$(r3.stopSending(a3, true)), n4;
              }
              r3.remoteSDP.receive(e4, t3, i3, h3);
              const A3 = r3.remoteSDP.toString(), l3 = r3.logSDPExchange(c3, "offer", "local", "send");
              return yield _$(r3.peerConnection.setLocalDescription({ type: "offer", sdp: c3 })), yield _$(r3.applySimulcastEncodings(o3, e4)), yield _$(r3.applySendEncodings(o3, e4)), null == l3 || l3(A3), yield _$(r3.peerConnection.setRemoteDescription({ type: "answer", sdp: A3 })), o3.map((e5, t4) => {
                const i4 = a3[t4];
                return { localSSRC: u3[t4], id: i4, transceiver: e5 };
              });
            } catch (e5) {
              throw e5 instanceof QD ? e5 : new QD(xD.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.send failed; ".concat(e5.toString()));
            } finally {
              n3();
            }
          })();
        }
        async stopSending(e4, t3) {
          const i3 = t3 ? void 0 : await this.mutex.lock("From NVExtentionsConnection.stopSending");
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.stopSending before remote SDP created");
            const t4 = this.peerConnection.getTransceivers().filter((t5) => -1 !== e4.indexOf(t5.mid));
            if (t4.length !== e4.length)
              throw new Error("Transceivers' length doesn't match mids' length when trying to call NVExtentionsConnection.stopSending.");
            t4.map((e5) => {
              var t5;
              e5.direction = "inactive", null === (t5 = e5.stop) || void 0 === t5 || t5.call(e5);
            });
            const r3 = await this.peerConnection.createOffer(), n3 = this.logSDPExchange(r3.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(r3), this.remoteSDP.stopReceiving(e4);
            const o3 = this.remoteSDP.toString();
            null == n3 || n3(o3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.stopSending failed; ".concat(e5.toString()));
          } finally {
            i3 && i3();
          }
        }
        async receive(e4, t3, i3, r3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.receive ".concat(e4, " before remoteSDP created."));
            const { mid: n3, needExchangeSDP: o3 } = this.remoteSDP.send(e4, t3, i3, r3);
            if (o3) {
              const t4 = this.remoteSDP.toString(), i4 = this.logSDPExchange(t4, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t4 });
              const r4 = await this.peerConnection.createAnswer(), o4 = this.mungReceiveAnswerSDP(r4.sdp, n3, e4);
              null == i4 || i4(o4 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o4 }), JD.debug("[NVExtentionsConnection] receive ".concat(e4, " by exchanging SDP."));
            } else
              JD.debug("[NVExtentionsConnection] receive ".concat(e4, " no need to exchange SDP."));
            const s3 = this.peerConnection.getTransceivers().find((e5) => e5.mid === n3);
            if (!s3)
              throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: s3.receiver.track, id: n3 };
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e5.toString()));
          }
        }
        async batchReceive(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.batchReceive before remoteSDP created.");
            const { mids: t3, needExchangeSDP: i3 } = this.remoteSDP.batchSend(e4);
            if (i3) {
              const e5 = this.remoteSDP.toString(), t4 = this.logSDPExchange(e5, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e5 });
              const i4 = await this.peerConnection.createAnswer();
              null == t4 || t4(i4.sdp || ""), await this.peerConnection.setLocalDescription(i4), JD.debug("[NVExtentionsConnection] batchReceive by exchanging SDP.");
            } else
              JD.debug("[NVExtentionsConnection] batchReceive no need to exchange SDP.");
            return t3.map((e5) => {
              const t4 = this.peerConnection.getTransceivers().find((t5) => t5.mid === e5);
              if (!t4)
                throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: t4.receiver.track, id: e5 };
            });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e5.toString()));
          }
        }
        async stopReceiving(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e4);
            const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "stopReceiving");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
            const r3 = await this.peerConnection.createAnswer();
            null == i3 || i3(r3.sdp || ""), await this.peerConnection.setLocalDescription(r3);
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "NVExtentionsConnection stopReceiving failed; ".concat(e5.toString()));
          }
        }
        async muteRemote(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.muteRemote mid=".concat(e4, " before remote SDP created."));
            this.remoteSDP.mute(e4);
            const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "muteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
            const r3 = await this.peerConnection.createAnswer();
            null == i3 || i3(r3.sdp || ""), await this.peerConnection.setLocalDescription(r3);
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteRemote failed; ".concat(e5.toString()));
          }
        }
        async unmuteRemote(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.unmuteRemote mid=".concat(e4, " before remote SDP created."));
            this.remoteSDP.unmute(e4);
            const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "unmuteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
            const r3 = await this.peerConnection.createAnswer();
            null == i3 || i3(r3.sdp || ""), await this.peerConnection.setLocalDescription(r3);
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteRemote failed; ".concat(e5.toString()));
          }
        }
        async muteLocal(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.muteLocal before remote SDP created.");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => t4.mid && -1 !== e4.indexOf(t4.mid));
            if (t3.length !== e4.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t3.map((e5) => {
              e5.direction = "inactive";
            });
            const i3 = await this.peerConnection.createOffer(), r3 = this.logSDPExchange(i3.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i3), this.remoteSDP.muteRemote(e4);
            const n3 = this.remoteSDP.toString();
            null == r3 || r3(n3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n3 });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteLocal failed; ".concat(e5.toString()));
          }
        }
        async unmuteLocal(e4) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.unmuteLocal before remote SDP created.");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => t4.mid && -1 !== e4.indexOf(t4.mid));
            if (t3.length !== e4.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t3.map(async (e5, t4) => {
              e5.direction = "sendonly";
            });
            const i3 = await this.peerConnection.createOffer(), r3 = this.logSDPExchange(i3.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i3), this.remoteSDP.unmuteRemote(e4);
            const n3 = this.remoteSDP.toString();
            null == r3 || r3(n3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n3 });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteLocal failed; ".concat(e5.toString()));
          }
        }
        restartICE() {
          var e4 = this;
          return I$(function* () {
            const t3 = yield _$(e4.mutex.lock("From NVExtentionsConnection.restartICE"));
            try {
              const i3 = yield _$(e4.peerConnection.createOffer({ iceRestart: true }));
              if (!i3.sdp)
                throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const r3 = J$(i3.sdp), { remoteIceParameters: n3 } = yield r3.iceParameters;
              if (!e4.remoteSDP)
                throw new Error("Cannot restartICE before remoteSDP created.");
              e4.remoteSDP.restartICE(n3);
              const o3 = e4.remoteSDP.toString(), s3 = e4.logSDPExchange(i3.sdp || "", "offer", "local", "restartICE");
              yield _$(e4.peerConnection.setLocalDescription(i3)), null == s3 || s3(o3), yield _$(e4.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 }));
            } catch (e5) {
              JD.warning("restart ICE failed, abort operation", e5);
            } finally {
              t3();
            }
          })();
        }
        close() {
          var e4;
          null === (e4 = this.onConnectionStateChange) || void 0 === e4 || e4.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e4) {
          return this.statsFilter.getVideoIsReady(e4);
        }
        async updateEncoderConfig(e4, t3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.updateEncoderConfig before remote SDP created.");
            const i3 = await this.peerConnection.createOffer(), r3 = this.mungSendOfferSDP(i3.sdp, [t3], [e4]);
            this.remoteSDP.updateRecvMedia(e4, t3);
            const n3 = this.remoteSDP.toString(), o3 = this.logSDPExchange(r3, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: r3 }), null == o3 || o3(n3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n3 });
          } catch (e5) {
            throw new QD(xD.EXCHANGE_SDP_FAILED, e5.toString());
          }
        }
        async updateSendParameters(e4, t3) {
          const i3 = this.peerConnection.getTransceivers().filter((t4) => t4.mid === e4);
          1 === i3.length && (this.isVP8Simulcast(t3) ? gN() || await this.applySimulcastEncodings(i3, [t3]) : await this.applySendEncodings(i3, [t3]));
        }
        setStatsRemoteVideoIsReady(e4, t3) {
          this.statsFilter.setVideoIsReady2(e4, t3);
        }
        async replaceTrack(e4, t3) {
          const i3 = this.peerConnection.getTransceivers().find((e5) => e5.mid === t3);
          i3 && await i3.sender.replaceTrack(e4._mediaStreamTrack);
        }
        getP2PConnectionParams() {
          var e4;
          if (null === (e4 = this.peerConnection.currentLocalDescription) || void 0 === e4 || !e4.sdp || !this.localCapabilities)
            throw new Error();
          return u0(u0({}, J$(this.peerConnection.currentLocalDescription.sdp)), {}, { rtpCapabilities: this.localCapabilities });
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e4;
            null === (e4 = this.onICEConnectionStateChange) || void 0 === e4 || e4.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e4;
            null === (e4 = this.onConnectionStateChange) || void 0 === e4 || e4.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e4) => {
            e4.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, JD.debug("[pc-".concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, JD.debug("[pc-".concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, LP("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t3) {
          const i3 = { iceServers: [] };
          return t3.iceServers ? i3.iceServers = t3.iceServers : t3.turnServer && "off" !== t3.turnServer.mode && (Rk(t3.turnServer.servers) ? i3.iceServers = t3.turnServer.servers : (i3.iceServers && i3.iceServers.push(...e3.turnServerConfigToIceServers(t3.turnServer.servers)), LP("USE_TURN_SERVER_OF_GATEWAY") && i3.iceServers && t3.turnServer.serversFromGateway && i3.iceServers.push(...e3.turnServerConfigToIceServers(t3.turnServer.serversFromGateway)), LP("FORCE_TURN_TCP") ? i3.iceTransportPolicy = "relay" : t3.turnServer.servers.concat(t3.turnServer.serversFromGateway || []).forEach((e4) => {
            e4.forceturn && (i3.iceTransportPolicy = "relay");
          }))), i3;
        }
        static turnServerConfigToIceServers(e4) {
          const t3 = [];
          return e4.forEach((e5) => {
            e5.security ? e5.tcpport && t3.push({ username: e5.username, credential: e5.password, credentialType: "password", urls: "turns:".concat(rK(e5.turnServerURL), ":").concat(e5.tcpport, "?transport=tcp") }) : (e5.udpport && !LP("FORCE_TURN_TCP") && t3.push({ username: e5.username, credential: e5.password, credentialType: "password", urls: "turn:".concat(e5.turnServerURL, ":").concat(e5.udpport, "?transport=udp") }), e5.tcpport && t3.push({ username: e5.username, credential: e5.password, credentialType: "password", urls: "turn:".concat(e5.turnServerURL, ":").concat(e5.tcpport, "?transport=tcp") }));
          }), t3;
        }
        async applySendEncodings(e4, t3) {
          try {
            if (!wB().supportSetRtpSenderParameters)
              return;
            if (e4.length !== t3.length)
              return;
            for (let c3 = 0; c3 < e4.length; c3++) {
              const d3 = e4[c3], u3 = t3[c3];
              if (u3 && u3 instanceof hz) {
                var i3, r3;
                if (this.isVP8Simulcast(u3))
                  continue;
                const e5 = {}, t4 = {};
                switch (u3._optimizationMode) {
                  case "motion":
                    e5.degradationPreference = "maintain-framerate";
                    break;
                  case "detail":
                    e5.degradationPreference = "maintain-resolution";
                    break;
                  default:
                    e5.degradationPreference = "balanced";
                }
                var n3, o3, s3, a3;
                if (null !== (i3 = u3._encoderConfig) && void 0 !== i3 && i3.bitrateMax)
                  t4.maxBitrate = 1e3 * (null === (n3 = u3._encoderConfig) || void 0 === n3 ? void 0 : n3.bitrateMax);
                if (u3._hints.includes($k.LOW_STREAM))
                  null !== (o3 = u3._encoderConfig) && void 0 !== o3 && o3.frameRate && (t4.maxFramerate = oK(u3._encoderConfig.frameRate)), null !== (s3 = u3._encoderConfig) && void 0 !== s3 && s3.scaleResolutionDownBy && (null === (a3 = u3._encoderConfig) || void 0 === a3 ? void 0 : a3.scaleResolutionDownBy) > 1 && (t4.scaleResolutionDownBy = u3._encoderConfig.scaleResolutionDownBy);
                if (LP("DSCP_TYPE") && yN()) {
                  const e6 = LP("DSCP_TYPE");
                  ["very-low", "low", "medium", "high"].includes(e6) && (t4.networkPriority = e6);
                }
                const c4 = d3.sender.getParameters(), h3 = null === (r3 = c4.encodings) || void 0 === r3 ? void 0 : r3[0];
                gN() && !h3 && (e5.encodings = [t4]), h3 && Object.assign(h3, t4), Object.assign(c4, e5), await d3.sender.setParameters(c4);
              }
            }
          } catch (e5) {
            JD.debug("Apply RTPSendEncodings failed.");
          }
        }
        mungSendOfferSDP(e4, t3, i3) {
          const r3 = K$.exports.parse(e4);
          return t3.forEach((e5, t4) => {
            const n3 = i3[t4], o3 = r3.mediaDescriptions.find((e6) => e6.attributes.mid === n3);
            o3 && (Z$(o3, e5), r1(o3, e5, this.store.codec));
          }), K$.exports.print(r3);
        }
        mungReceiveAnswerSDP(e4, t3, i3) {
          const r3 = K$.exports.parse(e4), n3 = r3.mediaDescriptions.find((e5) => e5.attributes.mid === t3);
          return n3 && i3 === AB.AUDIO && "audio" === n3.media.mediaType && a1(n3), K$.exports.print(r3);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e4) => {
            var t3;
            null === (t3 = this.onFirstAudioReceived) || void 0 === t3 || t3.call(this, e4);
          }, this.statsFilter.onFirstVideoReceived = (e4) => {
            var t3;
            null === (t3 = this.onFirstVideoReceived) || void 0 === t3 || t3.call(this, e4);
          }, this.statsFilter.onFirstAudioDecoded = (e4) => {
            var t3;
            null === (t3 = this.onFirstAudioDecoded) || void 0 === t3 || t3.call(this, e4);
          }, this.statsFilter.onFirstVideoDecoded = (e4, t3, i3) => {
            var r3;
            null === (r3 = this.onFirstVideoDecoded) || void 0 === r3 || r3.call(this, e4, t3, i3);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e4, t3) => {
            var i3;
            null === (i3 = this.onSelectedLocalCandidateChanged) || void 0 === i3 || i3.call(this, e4, t3);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e4, t3) => {
            var i3;
            null === (i3 = this.onSelectedRemoteCandidateChanged) || void 0 === i3 || i3.call(this, e4, t3);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e4) => {
            var t3;
            null === (t3 = this.onFirstVideoDecodedTimeout) || void 0 === t3 || t3.call(this, e4);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e4, t3) {
          if (e4.length === t3.length)
            for (let s3 = 0; s3 < e4.length; s3++) {
              var i3, r3, n3, o3;
              const a3 = e4[s3], c3 = t3[s3];
              if (c3 instanceof hz && !c3._hints.includes($k.LOW_STREAM) && null !== (i3 = c3._encoderConfig) && void 0 !== i3 && i3.bitrateMax && (null === (r3 = c3._encoderConfig) || void 0 === r3 ? void 0 : r3.bitrateMax) > 200 && null !== (n3 = c3._scalabiltyMode) && void 0 !== n3 && n3.numSpatialLayers && (null === (o3 = c3._scalabiltyMode) || void 0 === o3 ? void 0 : o3.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
                const e5 = {}, t4 = { high: 1e3 * (c3._encoderConfig.bitrateMax - 50), medium: 5e4 };
                e5.encodings = [{ rid: "m", active: true, maxBitrate: t4.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t4.high }];
                const i4 = a3.sender.getParameters();
                await a3.sender.setParameters(Object.assign(i4, e5));
              }
            }
        }
        async applySimulcastEncodings(e4, t3) {
          if (!gN() && e4.length === t3.length)
            for (let i3 = 0; i3 < e4.length; i3++) {
              const r3 = t3[i3];
              if (r3 instanceof hz && this.isVP8Simulcast(r3)) {
                const t4 = e4[i3], n3 = {}, o3 = { high: 1e3 * (r3._encoderConfig.bitrateMax - 50), medium: 5e4 };
                n3.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o3.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o3.medium, scaleResolutionDownBy: 4 }];
                const s3 = t4.sender.getParameters();
                await t4.sender.setParameters(Object.assign(s3, n3));
              }
            }
        }
        isVP8Simulcast(e4) {
          var t3, i3, r3, n3;
          return !!(e4 instanceof hz && LP("SIMULCAST") && "vp8" === this.store.codec && !e4._hints.includes($k.LOW_STREAM) && null !== (t3 = e4._encoderConfig) && void 0 !== t3 && t3.bitrateMax && (null === (i3 = e4._encoderConfig) || void 0 === i3 ? void 0 : i3.bitrateMax) > 200 && null !== (r3 = e4._scalabiltyMode) && void 0 !== r3 && r3.numSpatialLayers && (null === (n3 = e4._scalabiltyMode) || void 0 === n3 ? void 0 : n3.numSpatialLayers) > 1);
        }
        logSDPExchange(e4, t3, i3, r3) {
          if (LP("SDP_LOGGING"))
            return JD.upload("exchanging ".concat(i3, " ").concat(t3, " SDP during NVExtentionsConnection.").concat(r3, "\n"), e4), "offer" === t3 ? (e5) => {
              this.logSDPExchange(e5, "answer", "local" === i3 ? "remote" : "local", r3);
            } : void 0;
        }
        async getRemoteSSRC(e4) {
          if (!this.remoteSDP)
            return;
          const t3 = this.remoteSDP.getSSRC(e4);
          return null == t3 ? void 0 : t3[0].ssrcId;
        }
      }).prototype, "connect", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "connect"), c0.prototype), VV(c0.prototype, "updateRemoteConnect", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "updateRemoteConnect"), c0.prototype), VV(c0.prototype, "receive", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "receive"), c0.prototype), VV(c0.prototype, "batchReceive", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "batchReceive"), c0.prototype), VV(c0.prototype, "stopReceiving", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "stopReceiving"), c0.prototype), VV(c0.prototype, "muteRemote", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "muteRemote"), c0.prototype), VV(c0.prototype, "unmuteRemote", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "unmuteRemote"), c0.prototype), VV(c0.prototype, "muteLocal", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "muteLocal"), c0.prototype), VV(c0.prototype, "unmuteLocal", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "unmuteLocal"), c0.prototype), VV(c0.prototype, "close", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "close"), c0.prototype), VV(c0.prototype, "updateEncoderConfig", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "updateEncoderConfig"), c0.prototype), VV(c0.prototype, "updateSendParameters", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "updateSendParameters"), c0.prototype), VV(c0.prototype, "replaceTrack", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "replaceTrack"), c0.prototype), VV(c0.prototype, "getRemoteSSRC", [A0], Object.getOwnPropertyDescriptor(c0.prototype, "getRemoteSSRC"), c0.prototype), a0 = c0)) || a0;
      function A0(e3, t3, i3) {
        const r3 = e3[t3];
        if ("function" != typeof r3)
          throw new Error("Cannot use mutex on object property.");
        return i3.value = async function() {
          const e4 = this.mutex, i4 = await e4.lock("From NVExtentionsConnection.".concat(t3));
          try {
            for (var n3 = arguments.length, o3 = new Array(n3), s3 = 0; s3 < n3; s3++)
              o3[s3] = arguments[s3];
            return await r3.apply(this, o3);
          } finally {
            i4();
          }
        }, i3;
      }
      var l0, p0;
      function g0(e3) {
        var t3, i3, r3, n3 = 2;
        for ("undefined" != typeof Symbol && (i3 = v$, r3 = Symbol.iterator); n3--; ) {
          if (i3 && null != (t3 = e3[i3]))
            return t3.call(e3);
          if (r3 && null != (t3 = e3[r3]))
            return new E0(t3.call(e3));
          i3 = "@@asyncIterator", r3 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function E0(e3) {
        function t3(e4) {
          if (Object(e4) !== e4)
            return l_.reject(new TypeError(e4 + " is not an object."));
          var t4 = e4.done;
          return l_.resolve(e4.value).then(function(e5) {
            return { value: e5, done: t4 };
          });
        }
        return (E0 = function(e4) {
          this.s = e4, this.n = e4.next;
        }).prototype = { s: null, n: null, next: function() {
          return t3(this.n.apply(this.s, arguments));
        }, return: function(e4) {
          var i3 = this.s.return;
          return void 0 === i3 ? l_.resolve({ value: e4, done: true }) : t3(i3.apply(this.s, arguments));
        }, throw: function(e4) {
          var i3 = this.s.return;
          return void 0 === i3 ? l_.reject(e4) : t3(i3.apply(this.s, arguments));
        } }, new E0(e3);
      }
      let f0 = mP("DataChannelConnection", "store.dcId")((VV((p0 = class e3 extends RB {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        constructor(t3, i3) {
          super(t3, i3), MN(this, "store", void 0), MN(this, "peerConnection", void 0), MN(this, "cname", void 0), MN(this, "mutex", new fj("DataChannelConnection-mutex")), MN(this, "dataChannel", void 0), MN(this, "_p2pConnection", void 0), MN(this, "_nvMedia", void 0), this.store = i3, this.store.dcId = this.store.dcId + 1, this.peerConnection = new RTCPeerConnection(e3.resolvePCConfiguration(t3), { optional: [{ googDscp: true }] }), this.dataChannel = this.peerConnection.createDataChannel("agora-signal", { ordered: false, maxPacketLifeTime: 50 }), this.dataChannel.binaryType = "arraybuffer", this._p2pConnection = new h0(t3, i3, this.peerConnection), this.bindPCEvents();
        }
        async establish() {
          var e4;
          const t3 = null === (e4 = this._nvMedia) || void 0 === e4 ? void 0 : e4.getLocalRtpCapabilities();
          return await this._p2pConnection.establish(t3);
        }
        getP2PConnectionParams() {
          return this._p2pConnection.getP2PConnectionParams();
        }
        async connect(e4, t3, i3, r3, n3, o3) {
          return this.cname = o3, await this._p2pConnection.connect(e4, t3, i3, r3, n3, o3), await new l_((e5, t4) => {
            const r4 = setTimeout(() => {
              this.closeSignal(), t4(new QD(xD.DATACHANNEL_CONNECTION_TIMEOUT, "Datachannel connection timed out, candidates: ".concat(JSON.stringify(i3))));
            }, 2e3);
            this.dataChannel.onopen = () => {
              if ("open" === this.dataChannel.readyState)
                return clearTimeout(r4), void e5();
            }, this.dataChannel.onerror = (e6) => {
              this.closeSignal(), t4(e6);
            };
          }), { transmitter: this.dataChannel, close: this.closeSignal.bind(this) };
        }
        send(e4, t3, i3) {
          var r3 = this;
          return I$(function* () {
            const n3 = yield _$(r3.mutex.lock("From DataChannelConnection.send"));
            try {
              return yield* S$(g0(r3._p2pConnection.send(e4, t3, i3)), _$);
            } finally {
              n3();
            }
          })();
        }
        async stopSending(e4, t3) {
          return this._p2pConnection.stopSending(e4, t3);
        }
        async receive(e4, t3, i3, r3) {
          return this._nvMedia ? (JD.debug("[DataChannelConnection] receive ".concat(e4, " by DataChannel.")), await this._nvMedia.reveiveByRTCMedia(e4, t3, this.cname)) : (JD.debug("[DataChannelConnection] receive ".concat(e4, " by WebRTC.")), await this._p2pConnection.receive(e4, t3, i3, r3));
        }
        async batchReceive(e4) {
          return [...await this._p2pConnection.batchReceive(e4)];
        }
        async stopReceiving(e4) {
          return await this._p2pConnection.stopReceiving(e4);
        }
        async muteRemote(e4) {
          return await this._p2pConnection.muteRemote(e4);
        }
        async unmuteRemote(e4) {
          return await this._p2pConnection.unmuteRemote(e4);
        }
        async muteLocal(e4) {
          return await this._p2pConnection.muteLocal(e4);
        }
        async unmuteLocal(e4) {
          return await this._p2pConnection.unmuteLocal(e4);
        }
        restartICE() {
          var e4 = this;
          return I$(function* () {
            return yield* S$(g0(e4._p2pConnection.restartICE()), _$);
          })();
        }
        close() {
          var e4;
          null === (e4 = this._nvMedia) || void 0 === e4 || e4.close(), this._p2pConnection.close(), this.unbindConnectionEvents(this._p2pConnection);
        }
        getStats() {
          return this._p2pConnection.getStats();
        }
        getRemoteVideoIsReady(e4) {
          return this._p2pConnection.getRemoteVideoIsReady(e4);
        }
        updateRemoteConnect(e4) {
          var t3;
          null === (t3 = this._nvMedia) || void 0 === t3 || t3.setRemoteRtpCapabilities(e4), this._p2pConnection.updateRemoteConnect(e4);
        }
        async updateEncoderConfig(e4, t3) {
          return await this._p2pConnection.updateEncoderConfig(e4, t3);
        }
        async updateSendParameters(e4, t3) {
          return await this._p2pConnection.updateSendParameters(e4, t3);
        }
        setStatsRemoteVideoIsReady(e4, t3) {
          this._p2pConnection.setStatsRemoteVideoIsReady(e4, t3);
        }
        async replaceTrack(e4, t3) {
          return await this._p2pConnection.replaceTrack(e4, t3);
        }
        async getRemoteSSRC(e4) {
          return this._p2pConnection.getRemoteSSRC(e4);
        }
        logSDPExchange(e4, t3, i3, r3) {
          if (LP("SDP_LOGGING"))
            return JD.upload("exchanging ".concat(i3, " ").concat(t3, " SDP during DataChannelConnection.").concat(r3, "\n"), e4), "offer" === t3 ? (e5) => {
              this.logSDPExchange(e5, "answer", "local" === i3 ? "remote" : "local", r3);
            } : void 0;
        }
        static resolvePCConfiguration(t3) {
          const i3 = { iceServers: [] };
          return t3.iceServers ? i3.iceServers = t3.iceServers : t3.turnServer && "off" !== t3.turnServer.mode && (Rk(t3.turnServer.servers) ? i3.iceServers = t3.turnServer.servers : (i3.iceServers && i3.iceServers.push(...e3.turnServerConfigToIceServers(t3.turnServer.servers)), LP("USE_TURN_SERVER_OF_GATEWAY") && i3.iceServers && t3.turnServer.serversFromGateway && i3.iceServers.push(...e3.turnServerConfigToIceServers(t3.turnServer.serversFromGateway)), LP("FORCE_TURN_TCP") ? i3.iceTransportPolicy = "relay" : t3.turnServer.servers.concat(t3.turnServer.serversFromGateway || []).forEach((e4) => {
            e4.forceturn && (i3.iceTransportPolicy = "relay");
          }))), i3;
        }
        static turnServerConfigToIceServers(e4) {
          const t3 = [];
          return e4.forEach((e5) => {
            e5.security ? e5.tcpport && t3.push({ username: e5.username, credential: e5.password, credentialType: "password", urls: "turns:".concat(rK(e5.turnServerURL), ":").concat(e5.tcpport, "?transport=tcp") }) : (e5.udpport && !LP("FORCE_TURN_TCP") && t3.push({ username: e5.username, credential: e5.password, credentialType: "password", urls: "turn:".concat(e5.turnServerURL, ":").concat(e5.udpport, "?transport=udp") }), e5.tcpport && t3.push({ username: e5.username, credential: e5.password, credentialType: "password", urls: "turn:".concat(e5.turnServerURL, ":").concat(e5.tcpport, "?transport=tcp") }));
          }), t3;
        }
        bindPCEvents() {
          this._p2pConnection.onICEConnectionStateChange = (e4) => {
            var t3;
            return null === (t3 = this.onICEConnectionStateChange) || void 0 === t3 ? void 0 : t3.call(this, e4);
          }, this._p2pConnection.onConnectionStateChange = (e4) => {
            var t3;
            return null === (t3 = this.onConnectionStateChange) || void 0 === t3 ? void 0 : t3.call(this, e4);
          }, this._p2pConnection.onDTLSTransportStateChange = (e4) => {
            var t3;
            return null === (t3 = this.onDTLSTransportStateChange) || void 0 === t3 ? void 0 : t3.call(this, e4);
          }, this._p2pConnection.onDTLSTransportError = (e4) => {
            var t3;
            return null === (t3 = this.onDTLSTransportError) || void 0 === t3 ? void 0 : t3.call(this, e4);
          }, this._p2pConnection.onICETransportStateChange = (e4) => {
            var t3;
            return null === (t3 = this.onICETransportStateChange) || void 0 === t3 ? void 0 : t3.call(this, e4);
          }, this._p2pConnection.onFirstAudioReceived = (e4) => {
            var t3;
            return null === (t3 = this.onFirstAudioReceived) || void 0 === t3 ? void 0 : t3.call(this, e4);
          }, this._p2pConnection.onFirstVideoReceived = (e4) => {
            var t3;
            return null === (t3 = this.onFirstVideoReceived) || void 0 === t3 ? void 0 : t3.call(this, e4);
          }, this._p2pConnection.onFirstAudioDecoded = (e4) => {
            var t3;
            return null === (t3 = this.onFirstAudioDecoded) || void 0 === t3 ? void 0 : t3.call(this, e4);
          }, this._p2pConnection.onFirstVideoDecoded = (e4, t3, i3) => {
            var r3;
            return null === (r3 = this.onFirstVideoDecoded) || void 0 === r3 ? void 0 : r3.call(this, e4, t3, i3);
          }, this._p2pConnection.onFirstVideoDecodedTimeout = (e4) => {
            var t3;
            return null === (t3 = this.onFirstVideoDecodedTimeout) || void 0 === t3 ? void 0 : t3.call(this, e4);
          }, this._p2pConnection.onSelectedLocalCandidateChanged = (e4, t3) => {
            var i3;
            return null === (i3 = this.onSelectedLocalCandidateChanged) || void 0 === i3 ? void 0 : i3.call(this, e4, t3);
          }, this._p2pConnection.onSelectedRemoteCandidateChanged = (e4, t3) => {
            var i3;
            return null === (i3 = this.onSelectedRemoteCandidateChanged) || void 0 === i3 ? void 0 : i3.call(this, e4, t3);
          };
        }
        closeSignal() {
          this.dataChannel.close(), this.peerConnection.close();
        }
        unbindConnectionEvents(e4) {
          e4.onConnectionStateChange = void 0, e4.onICEConnectionStateChange = void 0, e4.onICETransportStateChange = void 0, e4.onDTLSTransportStateChange = void 0, e4.onDTLSTransportError = void 0, e4.onFirstAudioDecoded = void 0, e4.onFirstAudioReceived = void 0, e4.onFirstVideoDecoded = void 0, e4.onFirstVideoReceived = void 0, e4.onSelectedLocalCandidateChanged = void 0, e4.onSelectedRemoteCandidateChanged = void 0, e4.onFirstVideoDecodedTimeout = void 0;
        }
      }).prototype, "connect", [m0], Object.getOwnPropertyDescriptor(p0.prototype, "connect"), p0.prototype), VV(p0.prototype, "receive", [m0], Object.getOwnPropertyDescriptor(p0.prototype, "receive"), p0.prototype), VV(p0.prototype, "stopReceiving", [m0], Object.getOwnPropertyDescriptor(p0.prototype, "stopReceiving"), p0.prototype), VV(p0.prototype, "muteRemote", [m0], Object.getOwnPropertyDescriptor(p0.prototype, "muteRemote"), p0.prototype), VV(p0.prototype, "unmuteRemote", [m0], Object.getOwnPropertyDescriptor(p0.prototype, "unmuteRemote"), p0.prototype), VV(p0.prototype, "muteLocal", [m0], Object.getOwnPropertyDescriptor(p0.prototype, "muteLocal"), p0.prototype), VV(p0.prototype, "unmuteLocal", [m0], Object.getOwnPropertyDescriptor(p0.prototype, "unmuteLocal"), p0.prototype), VV(p0.prototype, "close", [m0], Object.getOwnPropertyDescriptor(p0.prototype, "close"), p0.prototype), VV(p0.prototype, "updateEncoderConfig", [m0], Object.getOwnPropertyDescriptor(p0.prototype, "updateEncoderConfig"), p0.prototype), VV(p0.prototype, "updateSendParameters", [m0], Object.getOwnPropertyDescriptor(p0.prototype, "updateSendParameters"), p0.prototype), VV(p0.prototype, "replaceTrack", [m0], Object.getOwnPropertyDescriptor(p0.prototype, "replaceTrack"), p0.prototype), VV(p0.prototype, "getRemoteSSRC", [m0], Object.getOwnPropertyDescriptor(p0.prototype, "getRemoteSSRC"), p0.prototype), l0 = p0)) || l0;
      function m0(e3, t3, i3) {
        const r3 = e3[t3];
        if ("function" != typeof r3)
          throw new Error("Cannot use mutex on object property.");
        return i3.value = async function() {
          const e4 = this.mutex, i4 = await e4.lock("From DataChannelConnection.".concat(t3));
          try {
            for (var n3 = arguments.length, o3 = new Array(n3), s3 = 0; s3 < n3; s3++)
              o3[s3] = arguments[s3];
            return await r3.apply(this, o3);
          } finally {
            i4();
          }
        }, i3;
      }
      var I0, _0;
      function C0(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function S0(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? C0(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : C0(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      function v0(e3) {
        var t3, i3, r3, n3 = 2;
        for ("undefined" != typeof Symbol && (i3 = v$, r3 = Symbol.iterator); n3--; ) {
          if (i3 && null != (t3 = e3[i3]))
            return t3.call(e3);
          if (r3 && null != (t3 = e3[r3]))
            return new T0(t3.call(e3));
          i3 = "@@asyncIterator", r3 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function T0(e3) {
        function t3(e4) {
          if (Object(e4) !== e4)
            return l_.reject(new TypeError(e4 + " is not an object."));
          var t4 = e4.done;
          return l_.resolve(e4.value).then(function(e5) {
            return { value: e5, done: t4 };
          });
        }
        return (T0 = function(e4) {
          this.s = e4, this.n = e4.next;
        }).prototype = { s: null, n: null, next: function() {
          return t3(this.n.apply(this.s, arguments));
        }, return: function(e4) {
          var i3 = this.s.return;
          return void 0 === i3 ? l_.resolve({ value: e4, done: true }) : t3(i3.apply(this.s, arguments));
        }, throw: function(e4) {
          var i3 = this.s.return;
          return void 0 === i3 ? l_.reject(e4) : t3(i3.apply(this.s, arguments));
        } }, new T0(e3);
      }
      let R0 = mP("P2PChannel", "store.p2pId")((VV((_0 = class extends MD {
        get state() {
          return this._state;
        }
        set state(e3) {
          const t3 = this._state;
          this._state = e3, this.emit(gB.StateChange, t3, this._state);
        }
        constructor(e3, t3) {
          super(), MN(this, "store", void 0), MN(this, "statsUploader", void 0), MN(this, "connection", void 0), MN(this, "localTrackMap", /* @__PURE__ */ new Map()), MN(this, "remoteUserMap", /* @__PURE__ */ new Map()), MN(this, "pendingLocalTracks", []), MN(this, "pendingRemoteTracks", []), MN(this, "statsCollector", void 0), MN(this, "isPlanB", false), MN(this, "iceFailedCount", 0), MN(this, "dtlsFailedCount", 0), MN(this, "mutex", new fj("P2PChannel-mutex")), MN(this, "_state", pB.Disconnected), MN(this, "handleMuteLocalTrack", async (e4, t4, i3) => {
            const r3 = await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");
            try {
              if (!this.connection)
                return void i3(new QD(xD.INVALID_OPERATION, "Cannot call P2PChannel.handleMuteLocalTrack before connection established."));
              gP("debug", this, "handleMuteLocalTrack", e4.getTrackId()), await this.waitTillConnected();
              const n3 = this.filterTobeMutedTracks(e4);
              if (0 === n3.length)
                return void t4();
              const o3 = n3.find((e5) => "videoLowTrack" === e5[0]);
              if (o3) {
                o3[1].track._originMediaStreamTrack.stop();
              }
              await this.connection.muteLocal(n3.map((e5) => {
                let [, { id: t5 }] = e5;
                return t5;
              }));
              const s3 = this.createMuteMessage(n3);
              await TK(this, gB.RequestMuteLocal, s3), t4();
            } catch (e5) {
              i3(e5);
            } finally {
              r3();
            }
          }), MN(this, "handleUnmuteLocalTrack", async (e4, t4, i3) => {
            const r3 = await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");
            try {
              if (!this.connection)
                return void i3(new QD(xD.INVALID_OPERATION, "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));
              gP("debug", this, "handleUnmuteLocalTrack", e4.getTrackId()), await this.waitTillConnected();
              const n3 = this.filterTobeUnmutedTracks(e4);
              if (0 === n3.length)
                return void t4();
              const o3 = n3.find((e5) => "videoLowTrack" === e5[0]);
              if (o3) {
                const t5 = o3[1];
                if (t5.track._originMediaStreamTrack.stop(), wB().supportDualStreamEncoding) {
                  const i4 = e4._mediaStreamTrack.clone();
                  t5.track._mediaStreamTrack = i4, t5.track._originMediaStreamTrack = i4;
                } else {
                  const i4 = K1(e4, yK(this, gB.RequestLowStreamParameter));
                  t5.track._mediaStreamTrack = i4, t5.track._originMediaStreamTrack = i4;
                }
                await new l_((e5, i4) => {
                  this.handleReplaceTrack(t5.track, e5, i4, true);
                });
              }
              await this.connection.unmuteLocal(n3.map((e5) => {
                let [, { id: t5 }] = e5;
                return t5;
              }));
              const s3 = this.createUnmuteMessage(n3);
              await TK(this, gB.RequestUnmuteLocal, s3), t4();
            } catch (e5) {
              i3(e5);
            } finally {
              r3();
            }
          }), MN(this, "handleUpdateVideoEncoder", async (e4, t4, i3) => {
            const r3 = await this.mutex.lock("Locking from P2PChannel.handleSetVideoEncoder");
            try {
              const i4 = this.localTrackMap.get(lB.LocalVideoTrack);
              if (!this.connection || !i4 || i4.track !== e4)
                return void t4();
              await this.waitTillConnected();
              const { id: n3, track: o3 } = i4;
              await this.connection.updateSendParameters(n3, o3), await this.connection.updateEncoderConfig(n3, o3), this.emit(gB.UpdateVideoEncoder, o3), t4();
            } catch (e5) {
              i3(e5);
            } finally {
              r3();
            }
          }), MN(this, "handleSetOptimizationMode", async (e4, t4, i3) => {
            const r3 = await this.mutex.lock("Locking from P2PChannel.handleSetOptimizationMode");
            try {
              const i4 = this.localTrackMap.get(lB.LocalVideoTrack);
              if (!this.connection || !i4 || i4.track !== e4)
                return;
              await this.waitTillConnected();
              const { id: n3, track: o3 } = i4;
              await this.connection.updateSendParameters(n3, o3), t4();
            } catch (e5) {
              i3(e5);
            } finally {
              r3();
            }
          }), MN(this, "handleReplaceTrack", async (e4, t4, i3, r3) => {
            let n3;
            JD.debug("P2PChannel handleReplaceTrack for [track-id-".concat(e4.getTrackId(), "]")), "boolean" == typeof r3 && r3 || (n3 = await this.mutex.lock("From P2PChannel.handleReplaceTrack"));
            try {
              var o3;
              const i4 = Array.from(this.localTrackMap.entries()).find((t5) => {
                let [, { track: i5 }] = t5;
                return e4 === i5;
              });
              if (!this.connection || !i4)
                return void t4();
              if (await this.waitTillConnected(), await (null === (o3 = this.connection) || void 0 === o3 ? void 0 : o3.replaceTrack(e4, i4[1].id)), this.isPlanB) {
                const t5 = i4[1];
                t5.id = e4._mediaStreamTrack.id, this.localTrackMap.set(i4[0], t5);
              }
              if (i4[0] === lB.LocalVideoTrack && wB().supportDualStreamEncoding) {
                const t5 = this.localTrackMap.get(lB.LocalVideoLowTrack);
                if (t5) {
                  const i5 = e4._mediaStreamTrack.clone();
                  t5.track._originMediaStreamTrack.stop(), t5.track._mediaStreamTrack = i5, t5.track._originMediaStreamTrack = i5, await new l_((e5, i6) => {
                    this.handleReplaceTrack(t5.track, e5, i6, true);
                  });
                }
              }
              t4();
            } catch (e5) {
              i3(e5);
            } finally {
              var s3;
              null === (s3 = n3) || void 0 === s3 || s3();
            }
          }), MN(this, "handleGetLocalVideoStats", (e4) => {
            e4(this.statsCollector.getLocalVideoTrackStats());
          }), MN(this, "handleGetLocalAudioStats", (e4) => {
            e4(this.statsCollector.getLocalAudioTrackStats());
          }), MN(this, "handleGetRemoteVideoStats", (e4) => this.statsCollector.getRemoteVideoTrackStats(e4.uid)[e4.uid]), MN(this, "handleGetRemoteAudioStats", (e4) => this.statsCollector.getRemoteAudioTrackStats(e4.uid)[e4.uid]), this.store = e3, this.statsCollector = t3, this.statsCollector.addP2PChannel(this), this.statsUploader = new e0(), this.bindStatsUploaderEvents(), this.isPlanB = !wB().supportUnifiedPlan || LP("CHROME_FORCE_PLAN_B") && yN();
        }
        async startP2PConnection(e3, t3) {
          return this.state = pB.New, this.connection = t3 ? new f0(e3, this.store) : this.isPlanB ? new P1(e3, this.store) : new j1(e3, this.store), this.bindConnectionEvents(this.connection), this.connection.establish();
        }
        async connect(e3, t3, i3, r3, n3, o3) {
          if (!this.connection)
            throw new QD(xD.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
          this.connection instanceof f0 ? this.connection.updateRemoteConnect(r3) : (this.store.peerConnectionStart(), await this.connection.connect(e3, t3, i3, r3, n3, o3), this.statsUploader.startUploadTransportStats(), this.state = pB.Connected);
        }
        async preConnect(e3, t3, i3, r3, n3, o3) {
          if (!this.connection)
            throw new QD(xD.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
          this.store.peerConnectionStart();
          const s3 = await this.connection.connect(e3, t3, i3, r3, n3, o3);
          return this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = pB.Connected, s3;
        }
        getEstablishParams() {
          if (this.connection instanceof f0)
            return this.connection.getP2PConnectionParams();
          throw new Error("Only DataChannelConnection needs to obtain establishParams");
        }
        publish(e3, t3, i3) {
          var r3 = this;
          return I$(function* () {
            const n3 = yield _$(r3.mutex.lock("From P2PChannel.publish"));
            try {
              if (!r3.connection) {
                if (r3.state === pB.Disconnected)
                  throw new QD(xD.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
                r3.throwIfTrackTypeNotMatch(e3);
                const t4 = e3.filter((e4) => -1 === r3.pendingLocalTracks.indexOf(e4));
                return void (r3.pendingLocalTracks = r3.pendingLocalTracks.concat(t4));
              }
              r3.store.pubId = r3.store.pubId + 1, zG.markPublishStart(r3.store.clientId, r3.store.pubId), yield _$(r3.waitTillConnected());
              const o3 = r3.filterTobePublishedTracks(e3, t3, i3);
              if (0 === o3.length)
                return void (yield _$(r3.tryToUnmuteAudio(e3)));
              yield* S$(v0(r3.doPublish(r3.connection, o3)), _$);
            } finally {
              n3();
            }
          })();
        }
        doPublish(e3, t3) {
          var i3 = this;
          return I$(function* () {
            t3.forEach((e4) => {
              let { track: t4, type: r4 } = e4;
              const n4 = Date.now();
              i3.store.publish(t4.getTrackId(), r4 === lB.LocalAudioTrack ? "audio" : "video", n4);
            }), i3.bindLocalTrackEvents(t3);
            const r3 = yield _$(e3.send(t3.map((e4) => {
              let { track: t4 } = e4;
              return t4;
            }), i3.store.codec, i3.store.audioCodec)), n3 = (yield _$(r3.next())).value, o3 = i3.createGatewayPublishMessage(t3, n3);
            let s3;
            try {
              s3 = yield o3;
            } catch (e4) {
              throw hP("error", i3, "doPublish yield error: ".concat(e4.toString())), r3.throw(e4), (null == e4 ? void 0 : e4.code) === xD.WS_ABORT && t3.forEach((e5) => {
                let { track: t4 } = e5;
                -1 === i3.pendingLocalTracks.indexOf(t4) && i3.pendingLocalTracks.push(t4);
              }), i3.unbindLocalTrackEvents(t3), e4;
            }
            const a3 = i3.mapPubResToRemoteConfig(o3, s3);
            gP("debug", i3, "doPublish", { remoteConfigs: a3, tracks: t3.map((e4) => {
              let { track: t4 } = e4;
              return t4.getTrackId();
            }), pubMsg: o3, pubAns: s3 });
            const c3 = (yield _$(r3.next(a3))).value;
            t3.forEach((e4) => {
              let { type: t4 } = e4;
              i3.statsCollector.addLocalStats(t4);
            }), i3.assignLocalTracks(t3, c3), i3.statsUploader.startUploadUplinkStats(), t3.forEach((e4) => {
              let { track: t4, type: r4 } = e4;
              const n4 = Date.now();
              i3.store.publish(t4.getTrackId(), r4 === lB.LocalAudioTrack ? "audio" : "video", void 0, n4);
            });
          })();
        }
        publishLowStream(e3) {
          var t3 = this;
          return I$(function* () {
            if (!t3.connection)
              return;
            gP("debug", t3, "publishLowStream", e3);
            const i3 = yield _$(t3.mutex.lock("Locking from P2PChannel.publishLowStream"));
            try {
              const n3 = t3.localTrackMap.get(lB.LocalVideoTrack);
              if (!n3)
                throw new QD(xD.UNEXPECTED_ERROR, "Could not find high stream");
              if (t3.localTrackMap.has(lB.LocalVideoLowTrack))
                throw new QD(xD.UNEXPECTED_ERROR, "[".concat(t3.store.clientId, "] Can't publish low stream when stream already publish"));
              yield _$(t3.waitTillConnected());
              const o3 = [{ track: t3.getLowVideoTrack(n3.track, e3), type: lB.LocalVideoLowTrack }];
              if (yield* S$(v0(t3.doPublish(t3.connection, o3)), _$), n3.track.muted || !n3.track.enabled) {
                var r3;
                const e4 = null === (r3 = t3.localTrackMap.get(lB.LocalVideoLowTrack)) || void 0 === r3 ? void 0 : r3.id;
                void 0 !== e4 && (yield _$(t3.connection.muteLocal([e4])));
              }
            } finally {
              i3();
            }
          })();
        }
        async republish() {
          this.pendingLocalTracks.length > 0 && (JD.debug("Emit P2PChannelEvents.RequestRePublish to republish tracks."), gP("debug", this, "republish", this.pendingLocalTracks.map((e3) => e3.getTrackId())), await vK(this, gB.RequestRePublish, this.pendingLocalTracks), this.emit(gB.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []);
        }
        async reSubscribe(e3) {
          gP("debug", this, "reSubscribe", this.pendingRemoteTracks.map((e4) => {
            let { user: t3 } = e4;
            return t3.uid;
          }));
          for (let e4 = this.pendingRemoteTracks.length - 1; e4 >= 0; e4--) {
            const { user: t3, kind: i3 } = this.pendingRemoteTracks[e4];
            (i3 !== AB.AUDIO || t3._audio_added_ && t3._audioSSRC) && (i3 !== AB.VIDEO || t3._video_added_ && t3._videoSSRC) || this.pendingRemoteTracks.splice(e4, 1);
          }
          if (e3)
            await vK(this, gB.RequestReSubscribe, this.pendingRemoteTracks);
          else
            for (const { user: e4, kind: t3 } of this.pendingRemoteTracks)
              await this.subscribe(e4, t3, t3 === AB.VIDEO ? e4._videoSSRC : e4._audioSSRC);
          this.pendingRemoteTracks.forEach((e4) => {
            let { user: t3 } = e4;
            this.emit(gB.MediaReconnectEnd, t3.uid);
          }), this.pendingRemoteTracks = [];
        }
        async unpublish(e3) {
          if (!this.connection)
            return void e3.forEach((e4) => {
              const t4 = this.pendingLocalTracks.indexOf(e4);
              -1 !== t4 && this.pendingLocalTracks.splice(t4, 1);
            });
          await this.waitTillConnected();
          const t3 = this.filterTobeUnpublishedTracks(e3);
          if (0 === t3.length)
            return;
          const i3 = t3.find((e4) => "videoLowTrack" === e4[0]);
          if (i3) {
            i3[1].track.close();
          }
          return gP("debug", this, "unpublish"), this.doUnpublish(this.connection, t3);
        }
        async unpublishLowStream() {
          if (!this.connection)
            return;
          gP("debug", this, "unpublishLowStream");
          const e3 = this.localTrackMap.get(lB.LocalVideoLowTrack);
          if (!e3)
            return;
          await this.waitTillConnected(), e3.track.close();
          const t3 = [[lB.LocalVideoLowTrack, e3]];
          return this.doUnpublish(this.connection, t3);
        }
        async doUnpublish(e3, t3) {
          const i3 = this.createGatewayUnpublishMessage(t3);
          return await e3.stopSending(t3.map((e4) => {
            let [, { id: t4 }] = e4;
            return t4;
          })), this.withdrawLocalTracks(t3), this.unbindLocalTrackEvents(t3.map((e4) => {
            let [t4, { track: i4 }] = e4;
            return { type: t4, track: i4 };
          })), t3.forEach((e4) => {
            let [t4] = e4;
            this.statsCollector.removeLocalStats(t4);
          }), 0 === this.localTrackMap.size && this.statsUploader.stopUploadUplinkStats(), i3;
        }
        async subscribe(e3, t3, i3, r3, n3) {
          var o3;
          if (!this.connection)
            throw new QD(xD.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
          if (gP("debug", this, "subscribe", { uid: e3.uid, mediaType: t3, ssrcId: i3 }), null !== (o3 = this.remoteUserMap.get(e3)) && void 0 !== o3 && o3.has(t3))
            return;
          let s3, a3;
          if (await this.waitTillConnected(), n3) {
            const i4 = n3.find((e4) => {
              let { stream_type: i5 } = e4;
              return i5 === t3;
            });
            if (!i4)
              throw new QD(xD.UNEXPECTED_ERROR, "Cannot subscribe to remote ".concat(t3, " for user: ").concat(e3.uid, " because subscribe answer from gateway does not contain stream_type: ").concat(t3, "."));
            const r4 = await this.connection.receive(t3, i4.ssrcs, String(e3._uintid), i4.attributes);
            s3 = r4.track, a3 = r4.id;
          } else {
            const n4 = await this.connection.receive(t3, [{ ssrcId: i3, rtx: r3 }], String(e3._uintid), void 0);
            s3 = n4.track, a3 = n4.id;
          }
          t3 === AB.AUDIO ? (e3._audioTrack ? e3._audioTrack._updateOriginMediaStreamTrack(s3) : (e3._audioTrack = new z1(s3, e3.uid, e3._uintid, this.store), JD.info("[".concat(this.store.p2pId, "] create remote audio track: ").concat(e3._audioTrack.getTrackId()))), this.bindRemoteTrackEvents(e3, e3._audioTrack)) : (e3._videoTrack ? e3._videoTrack._updateOriginMediaStreamTrack(s3) : (e3._videoTrack = new X1(s3, e3.uid, e3._uintid, this.store), JD.info("[".concat(this.store.p2pId, "] create remote video track: ").concat(e3._videoTrack.getTrackId()))), this.bindRemoteTrackEvents(e3, e3._videoTrack));
          const c3 = this.remoteUserMap.get(e3);
          c3 ? c3.set(t3, a3) : this.remoteUserMap.set(e3, /* @__PURE__ */ new Map([[t3, a3]])), this.statsCollector.addRemoteStats(e3.uid), this.statsUploader.startUploadDownlinkStats();
          const d3 = this.pendingRemoteTracks.findIndex((i4) => {
            let { user: r4, kind: n4 } = i4;
            return r4.uid === e3.uid && t3 === n4;
          });
          -1 !== d3 && (this.pendingRemoteTracks.splice(d3, 1), this.emit(gB.MediaReconnectEnd, e3.uid));
        }
        async massSubscribe(e3) {
          return this.massSubscribeNoLock(e3);
        }
        async massSubscribeNoLock(e3) {
          if (!this.connection)
            throw new QD(xD.INVALID_OPERATION, "Cannot subscribeAll remote users when peerConnection disconnected.");
          gP("debug", this, "subscribeAll", e3.map((e4) => {
            let { user: t4, mediaType: i3, ssrcId: r3 } = e4;
            return { uid: t4.uid, mediaType: i3, ssrcId: r3 };
          })), e3 = e3.filter((e4) => {
            var t4;
            let { user: i3, mediaType: r3 } = e4;
            return !(null !== (t4 = this.remoteUserMap.get(i3)) && void 0 !== t4 && t4.has(r3));
          }), await this.waitTillConnected();
          const t3 = await this.connection.batchReceive(e3.map((e4) => {
            let { user: t4, mediaType: i3, ssrcId: r3, rtxSsrcId: n3 } = e4;
            return { kind: i3, ssrcMsg: [{ ssrcId: r3, rtx: n3 }], mslabel: String(t4._uintid) };
          }));
          e3.forEach((e4, i3) => {
            let { user: r3, mediaType: n3 } = e4;
            const { track: o3, id: s3 } = t3[i3];
            n3 === AB.AUDIO ? (r3._audioTrack ? r3._audioTrack._updateOriginMediaStreamTrack(o3) : (r3._audioTrack = new z1(o3, r3.uid, r3._uintid, this.store), JD.info("[".concat(this.store.p2pId, "] create remote audio track: ").concat(r3._audioTrack.getTrackId()))), this.bindRemoteTrackEvents(r3, r3._audioTrack)) : (r3._videoTrack ? r3._videoTrack._updateOriginMediaStreamTrack(o3) : (r3._videoTrack = new X1(o3, r3.uid, r3._uintid, this.store), JD.info("[".concat(this.store.p2pId, "] create remote video track: ").concat(r3._videoTrack.getTrackId()))), this.bindRemoteTrackEvents(r3, r3._videoTrack));
            const a3 = this.remoteUserMap.get(r3);
            a3 ? a3.set(n3, s3) : this.remoteUserMap.set(r3, /* @__PURE__ */ new Map([[n3, s3]])), this.statsCollector.addRemoteStats(r3.uid), this.statsUploader.startUploadDownlinkStats();
            const c3 = this.pendingRemoteTracks.findIndex((e5) => {
              let { user: t4, kind: i4 } = e5;
              return t4.uid === r3.uid && n3 === i4;
            });
            -1 !== c3 && (this.pendingRemoteTracks.splice(c3, 1), this.emit(gB.MediaReconnectEnd, r3.uid));
          });
        }
        async unsubscribe(e3, t3, i3) {
          const r3 = this.pendingRemoteTracks.filter((i4) => {
            let { user: r4, kind: n4 } = i4;
            return void 0 !== t3 ? r4.uid === e3.uid && t3 === n4 : r4.uid === e3.uid;
          });
          if (r3.forEach((e4) => {
            const t4 = this.pendingRemoteTracks.indexOf(e4);
            this.pendingRemoteTracks.splice(t4, 1);
          }), this.connection || i3 || r3.forEach((t4) => {
            let { kind: i4 } = t4;
            var r4;
            if (i4 === AB.AUDIO)
              null === (r4 = e3._audioTrack) || void 0 === r4 || r4._destroy(), e3._audioTrack = void 0;
            else if (i4 === AB.VIDEO) {
              var n4;
              null === (n4 = e3._videoTrack) || void 0 === n4 || n4._destroy(), e3._videoTrack = void 0;
            }
          }), !this.connection)
            return;
          gP("debug", this, "unsubscribe", { uid: e3.uid, mediaType: t3 });
          const n3 = this.filterTobeUnSubscribedTracks(e3, t3);
          if (0 === n3.length)
            return;
          await this.connection.stopReceiving(n3.map((e4) => {
            let [, { id: t4 }] = e4;
            return t4;
          }));
          const o3 = this.createUnsubscribeMessage(n3);
          return this.withdrawRemoteTracks(n3), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), n3.forEach((e4) => {
            let [t4, { kind: r4 }] = e4;
            var n4, o4;
            r4 === AB.VIDEO && t4._videoSSRC && (null === (n4 = this.connection) || void 0 === n4 || n4.setStatsRemoteVideoIsReady(t4._videoSSRC, false));
            if (r4 === AB.VIDEO)
              this.unbindRemoteTrackEvents(t4._videoTrack), i3 || (null === (o4 = t4._videoTrack) || void 0 === o4 || o4._destroy(), t4._videoTrack = void 0);
            else if (r4 === AB.AUDIO) {
              var s3;
              if (this.unbindRemoteTrackEvents(t4._audioTrack), !i3)
                null === (s3 = t4._audioTrack) || void 0 === s3 || s3._destroy(), t4._audioTrack = void 0;
            }
          }), o3;
        }
        async massUnsubscribe(e3) {
          return this.massUnsubscribeNoLock(e3);
        }
        async massUnsubscribeNoLock(e3) {
          let t3 = [];
          for (const { user: i4, mediaType: r4 } of e3) {
            const e4 = this.pendingRemoteTracks.filter((e5) => {
              let { user: t4, kind: n3 } = e5;
              return void 0 !== r4 ? t4.uid === i4.uid && r4 === n3 : t4.uid === i4.uid;
            });
            e4.forEach((e5) => {
              const t4 = this.pendingRemoteTracks.indexOf(e5);
              this.pendingRemoteTracks.splice(t4, 1);
            }), t3 = t3.concat(e4);
          }
          if (!this.connection)
            return void t3.forEach((e4) => {
              let { user: t4, kind: i4 } = e4;
              var r4;
              if (i4 === AB.AUDIO)
                null === (r4 = t4._audioTrack) || void 0 === r4 || r4._destroy(), t4._audioTrack = void 0;
              else if (i4 === AB.VIDEO) {
                var n3;
                null === (n3 = t4._videoTrack) || void 0 === n3 || n3._destroy(), t4._videoTrack = void 0;
              }
            });
          gP("debug", this, "batchUnsubscribe", e3.map((e4) => {
            let { user: t4, mediaType: i4 } = e4;
            return { uid: t4.uid, mediaType: i4 };
          }));
          const i3 = cc(e3).call(e3, (e4, t4) => {
            let { user: i4, mediaType: r4 } = t4;
            const n3 = this.filterTobeUnSubscribedTracks(i4, r4);
            return e4.concat(n3);
          }, []);
          if (0 === i3.length)
            return;
          await this.connection.stopReceiving(i3.map((e4) => {
            let [, { id: t4 }] = e4;
            return t4;
          }));
          const r3 = this.createUnsubscribeAllMessage(i3);
          return this.withdrawRemoteTracks(i3), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), i3.forEach((e4) => {
            let [t4, { kind: i4 }] = e4;
            var r4, n3;
            i4 === AB.VIDEO && t4._videoSSRC && (null === (r4 = this.connection) || void 0 === r4 || r4.setStatsRemoteVideoIsReady(t4._videoSSRC, false));
            if (i4 === AB.VIDEO)
              this.unbindRemoteTrackEvents(t4._videoTrack), null === (n3 = t4._videoTrack) || void 0 === n3 || n3._destroy(), t4._videoTrack = void 0;
            else if (i4 === AB.AUDIO) {
              var o3;
              this.unbindRemoteTrackEvents(t4._audioTrack), null === (o3 = t4._audioTrack) || void 0 === o3 || o3._destroy(), t4._audioTrack = void 0;
            }
          }), r3;
        }
        async muteRemote(e3, t3) {
          if (!this.connection)
            return;
          gP("debug", this, "muteRemote", { uid: e3.uid, kind: t3 });
          const i3 = this.remoteUserMap.get(e3);
          if (!i3)
            return JD.warning("P2PChannel.muteRemote has no remote user ".concat(e3.uid, ".")), void hP("warning", this, "P2PChannel.muteRemote has no remote user ".concat(e3.uid, "."));
          if (!i3.get(t3))
            return JD.warning("P2PChannel.muteRemote has no remote user ".concat(e3.uid, " media type ").concat(t3, ".")), void hP("warning", this, "P2PChannel.muteRemote has no remote user ".concat(e3.uid, " media type ").concat(t3, "."));
          const r3 = t3 === AB.VIDEO ? e3._videoSSRC : e3._audioSSRC;
          void 0 !== r3 && this.connection.setStatsRemoteVideoIsReady(r3, false);
        }
        async unmuteRemote(e3, t3) {
          return this.unmuteRemoteNoLock(e3, t3);
        }
        async unmuteRemoteNoLock(e3, t3) {
          if (!this.connection)
            return;
          gP("debug", this, "unmuteRemote", { uid: e3.uid, kind: t3 });
          const i3 = this.remoteUserMap.get(e3);
          if (!i3)
            return JD.warning("P2PChannel.unmuteRemote has no remote user ".concat(e3.uid, ".")), void hP("warning", this, "unmuteRemote has no remote user ".concat(e3.uid));
          return i3.get(t3) ? void 0 : (JD.warning("P2PChannel.unmuteRemote has no remote user ".concat(e3.uid, " media type ").concat(t3, ".")), void hP("warning", this, "unmuteRemote has no remote user ".concat(e3.uid, " media type ").concat(t3)));
        }
        getAllTracks(e3) {
          const t3 = this.localTrackMap.get(lB.LocalAudioTrack);
          if ((null == t3 ? void 0 : t3.track) instanceof JG) {
            const i3 = t3.track;
            return Array.from(this.localTrackMap.entries()).filter((e4) => {
              let [t4] = e4;
              return t4 !== lB.LocalAudioTrack;
            }).filter((t4) => {
              let [i4] = t4;
              return !(e3 && i4 === lB.LocalVideoLowTrack);
            }).map((e4) => {
              let [, { track: t4 }] = e4;
              return t4;
            }).concat(i3.trackList);
          }
          return Array.from(this.localTrackMap.entries()).filter((t4) => {
            let [i3] = t4;
            return !(e3 && i3 === lB.LocalVideoLowTrack);
          }).map((e4) => {
            let [, { track: t4 }] = e4;
            return t4;
          });
        }
        reportPublishEvent(e3, t3, i3, r3, n3) {
          if (e3) {
            const i4 = this.localTrackMap.get(lB.LocalAudioTrack), o4 = r3 ? this.localTrackMap.get(lB.LocalVideoLowTrack) : this.localTrackMap.get(lB.LocalVideoTrack);
            pj.publish(this.store.sessionId, { eventElapse: zG.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e3, ec: t3, audioName: null == i4 ? void 0 : i4.track.getTrackLabel(), videoName: null == o4 ? void 0 : o4.track.getTrackLabel(), screenshare: -1 !== (null == o4 ? void 0 : o4.track._hints.indexOf($k.SCREEN_TRACK)), audio: !!i4, video: !!o4, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: n3 });
          } else {
            var o3;
            i3 || (i3 = []);
            const s3 = i3.find((e4) => e4 instanceof HG), a3 = r3 ? null === (o3 = this.localTrackMap.get(lB.LocalVideoTrack)) || void 0 === o3 ? void 0 : o3.track : i3.find((e4) => e4 instanceof hz);
            pj.publish(this.store.sessionId, { eventElapse: zG.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e3, ec: t3, audioName: null == s3 ? void 0 : s3.getTrackLabel(), videoName: null == a3 ? void 0 : a3.getTrackLabel(), screenshare: -1 !== (null == a3 ? void 0 : a3._hints.indexOf($k.SCREEN_TRACK)), audio: !!s3, video: !!a3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: n3 });
          }
        }
        reportSubscribeEvent(e3, t3, i3, r3) {
          const n3 = r3 === AB.VIDEO ? i3._videoSSRC : i3._audioSSRC;
          n3 && pj.subscribe(this.store.sessionId, { succ: e3, ec: t3, video: r3 === AB.VIDEO, audio: r3 === AB.AUDIO, peerid: i3.uid, subscribeRequestid: r3 === AB.VIDEO ? i3._videoSSRC : i3._audioSSRC, p2pid: this.store.p2pId, eventElapse: zG.measureFromSubscribeStart(this.store.clientId, n3) });
        }
        reset() {
          JD.debug("P2PChannel.reset"), this.mutex = new fj("P2PChannel-mutex"), this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.state = pB.Disconnected;
        }
        getStats() {
          var e3;
          return null === (e3 = this.connection) || void 0 === e3 ? void 0 : e3.getStats();
        }
        getRemoteVideoIsReady(e3) {
          var t3;
          return (null === (t3 = this.connection) || void 0 === t3 ? void 0 : t3.getRemoteVideoIsReady(e3)) || false;
        }
        getLocalAudioVolume() {
          const e3 = this.localTrackMap.get(lB.LocalAudioTrack);
          if (e3)
            return e3.track.getVolumeLevel();
        }
        getLocalVideoSize() {
          const e3 = this.localTrackMap.get(lB.LocalVideoTrack);
          if (e3)
            return { width: e3.track._videoWidth || 0, height: e3.track._videoHeight || 0 };
        }
        getEncoderConfig(e3) {
          const t3 = this.localTrackMap.get(e3);
          return t3 && t3.track instanceof hz || t3 && t3.track instanceof HG ? t3.track._encoderConfig : void 0;
        }
        getLocalMedia(e3) {
          return this.localTrackMap.get(e3);
        }
        hasLocalMedia() {
          return this.localTrackMap.size > 0;
        }
        hasRemoteMedia(e3, t3) {
          if (!e3)
            return this.remoteUserMap.size > 0;
          const i3 = this.remoteUserMap.get(e3);
          return !!i3 && (!t3 || i3.has(t3));
        }
        async hasRemoteMediaWithLock(e3, t3) {
          if (!e3)
            return this.remoteUserMap.size > 0;
          const i3 = this.remoteUserMap.get(e3);
          return !!i3 && (!t3 || i3.has(t3));
        }
        getRemoteMedia(e3) {
          var t3;
          const i3 = Array.from(qV(t3 = this.remoteUserMap).call(t3)).find((t4) => t4.uid === e3);
          return i3 ? { audioTrack: i3.audioTrack, audioSSRC: i3._audioSSRC, videoTrack: i3.videoTrack, videoSSRC: i3._videoSSRC } : {};
        }
        getAudioLevels() {
          let e3 = Array.from(this.remoteUserMap.entries()).map((e4) => {
            let [t4] = e4;
            return { uid: t4.uid, level: t4.audioTrack ? 100 * t4.audioTrack._source.getAccurateVolumeLevel() : 0 };
          });
          const t3 = this.localTrackMap.get(lB.LocalAudioTrack);
          return t3 && e3.push({ level: 100 * t3.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e3 = kL(e3).call(e3, (e4, t4) => e4.level - t4.level), e3;
        }
        async disconnectForReconnect() {
          this.connection && (gP("debug", this, "disconnectForReconnect"), JD.debug("P2PChannel.disconnectForReconnect closing P2PConnection"), this.state = pB.Reconnecting, this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0, 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e3) => {
            let [t3, { track: i3 }] = e3;
            switch (t3) {
              case lB.LocalVideoTrack:
                i3._hints.includes($k.LOW_STREAM) ? i3.close() : this.pendingLocalTracks.push(i3);
                break;
              case lB.LocalAudioTrack:
                i3 instanceof JG ? this.pendingLocalTracks = this.pendingLocalTracks.concat(i3.trackList) : this.pendingLocalTracks.push(i3);
                break;
              case lB.LocalVideoLowTrack:
            }
          }), this.emit(gB.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e3) => {
            let [t3, i3] = e3;
            Array.from(qV(i3).call(i3)).forEach((e4) => {
              this.setPendingRemoteMedia(t3, e4);
            }), this.emit(gB.MediaReconnectStart, t3.uid);
          }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), JD.debug("P2PChannel disconnected, waiting to reconnect."));
        }
        hasPendingRemoteMedia(e3, t3) {
          for (const i3 of this.pendingRemoteTracks) {
            const { user: r3, kind: n3 } = i3;
            if ((e3 instanceof lz ? e3.uid : e3) === r3.uid && t3 === n3)
              return true;
          }
          return false;
        }
        setPendingRemoteMedia(e3, t3) {
          this.hasPendingRemoteMedia(e3, t3) || this.pendingRemoteTracks.push({ user: e3, kind: t3 });
        }
        restartICE() {
          var e3 = this;
          return I$(function* () {
            if (!e3.connection)
              throw new Error();
            const t3 = yield _$(e3.mutex.lock("From P2PChannel.restartICE"));
            try {
              yield* S$(v0(e3.connection.restartICE()), _$);
            } finally {
              t3();
            }
          })();
        }
        getUplinkNetworkQuality() {
          if (!this.connection)
            return 0;
          const e3 = this.connection.getStats(), t3 = this.localTrackMap.get(lB.LocalVideoTrack), i3 = this.localTrackMap.get(lB.LocalAudioTrack), r3 = e3.videoSend.find((e4) => e4.ssrc === (null == t3 ? void 0 : t3.ssrcs[0].ssrcId)), n3 = e3.audioSend.find((e4) => e4.ssrc === (null == i3 ? void 0 : i3.ssrcs[0].ssrcId));
          if (!r3 || !n3)
            return 1;
          const o3 = RK(this, gB.NeedSignalRTT), s3 = r3 ? r3.rttMs : void 0, a3 = n3 ? n3.rttMs : void 0, c3 = s3 && a3 ? (s3 + a3) / 2 : s3 || a3, d3 = (c3 && o3 ? (c3 + o3) / 2 : c3 || o3) || 0, u3 = 100 * e3.sendPacketLossRate * 0.7 / 50 + 0.3 * d3 / 1500, h3 = u3 < 0.17 ? 1 : u3 < 0.36 ? 2 : u3 < 0.59 ? 3 : u3 < 0.1 ? 4 : 5, A3 = null == t3 ? void 0 : t3.track;
          if (A3 && A3._encoderConfig && -1 === A3._hints.indexOf($k.SCREEN_TRACK)) {
            const t4 = A3._encoderConfig.bitrateMax, i4 = e3.bitrate.actualEncoded;
            if (t4 && i4) {
              const e4 = (1e3 * t4 - i4) / (1e3 * t4);
              return FP[e4 < 0.15 ? 0 : e4 < 0.3 ? 1 : e4 < 0.45 ? 2 : e4 < 0.6 ? 3 : 4][h3];
            }
          }
          return h3;
        }
        getDownlinkNetworkQuality() {
          if (!this.connection)
            return 0;
          const e3 = this.connection.getStats();
          let t3 = 0;
          return Array.from(this.remoteUserMap.entries()).forEach((i3) => {
            let [r3] = i3;
            const n3 = r3._audioSSRC, o3 = r3._videoSSRC, s3 = e3.audioRecv.find((e4) => e4.ssrc === n3), a3 = e3.videoRecv.find((e4) => e4.ssrc === o3);
            if (!s3 && !a3)
              return void (t3 += 1);
            const c3 = RK(this, gB.NeedSignalRTT), d3 = e3.rtt, u3 = (d3 && c3 ? (d3 + c3) / 2 : d3 || c3) || 0, h3 = s3 ? s3.jitterMs : void 0, A3 = e3.recvPacketLossRate;
            let l3 = 0.7 * A3 * 100 / 50 + 0.3 * u3 / 1500;
            h3 && (l3 = 0.6 * A3 * 100 / 50 + 0.2 * u3 / 1500 + 0.2 * h3 / 400);
            t3 += l3 < 0.1 ? 1 : l3 < 0.17 ? 2 : l3 < 0.36 ? 3 : l3 < 0.59 ? 4 : 5;
          }), this.remoteUserMap.size > 0 ? Math.round(t3 / this.remoteUserMap.size) : t3;
        }
        async muteLocalTrack(e3) {
          return new l_((t3, i3) => {
            this.handleMuteLocalTrack(e3, t3, i3);
          });
        }
        filterTobePublishedTracks(e3, t3, i3) {
          const r3 = [], n3 = wB(), o3 = this.getAllTracks();
          e3 = bK(e3 = e3.filter((e4) => -1 === o3.indexOf(e4)));
          let s3 = false, a3 = false;
          for (const o4 of e3) {
            if (o4 instanceof hz && (this.localTrackMap.has(lB.LocalVideoTrack) || s3 ? new QD(xD.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (r3.push({ track: o4, type: lB.LocalVideoTrack }), s3 = true), t3)) {
              const e4 = this.getLowVideoTrack(o4, i3);
              r3.push({ track: e4, type: lB.LocalVideoLowTrack });
            }
            if (o4 instanceof HG) {
              const e4 = this.localTrackMap.get(lB.LocalAudioTrack);
              if (e4) {
                if (!(e4.track instanceof JG))
                  throw new QD(xD.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (o4._bypassWebAudio)
                  throw new QD(xD.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e4.track.addAudioTrack(o4), this.bindLocalAudioTrackEvents(o4, true);
              } else if (a3) {
                const e5 = r3.find((e6) => {
                  let { type: t4 } = e6;
                  return t4 === lB.LocalAudioTrack;
                });
                if (!(e5.track instanceof JG))
                  throw new QD(xD.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (o4._bypassWebAudio)
                  throw new QD(xD.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e5.track.addAudioTrack(o4);
              } else {
                if (!n3.webAudioMediaStreamDest || o4 instanceof JG || o4._bypassWebAudio)
                  r3.push({ track: o4, type: lB.LocalAudioTrack });
                else {
                  const e5 = new JG();
                  e5.addAudioTrack(o4), r3.push({ track: e5, type: lB.LocalAudioTrack });
                }
                a3 = true;
              }
            }
          }
          return r3;
        }
        filterTobeUnpublishedTracks(e3) {
          const t3 = [], i3 = this.getAllTracks();
          e3 = bK(e3 = e3.filter((e4) => -1 !== i3.indexOf(e4)));
          for (const i4 of e3) {
            if (i4 instanceof HG) {
              const e4 = this.localTrackMap.get(lB.LocalAudioTrack);
              if (!e4)
                continue;
              e4.track instanceof JG ? (e4.track.removeAudioTrack(i4), this.unbindLocalAudioTrackEvents(i4), 0 === e4.track.trackList.length && (t3.push([lB.LocalAudioTrack, e4]), e4.track.close())) : t3.push([lB.LocalAudioTrack, e4]);
            }
            if (i4 instanceof hz) {
              const e4 = this.localTrackMap.get(lB.LocalVideoTrack);
              if (!e4)
                continue;
              t3.push([lB.LocalVideoTrack, e4]);
              const i5 = this.localTrackMap.get(lB.LocalVideoLowTrack);
              i5 && t3.push([lB.LocalVideoLowTrack, i5]);
            }
          }
          return t3;
        }
        bindLocalTrackEvents(e3) {
          e3.forEach((e4) => {
            let { track: t3, type: i3 } = e4;
            switch (i3) {
              case lB.LocalVideoTrack:
                t3.addListener(Zk.GET_STATS, this.handleGetLocalVideoStats), t3.addListener(Zk.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t3.addListener(Zk.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t3.addListener(Zk.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t3.addListener(Zk.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t3.addListener(Zk.NEED_REPLACE_TRACK, this.handleReplaceTrack), t3.addListener(Zk.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t3.addListener(Zk.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case lB.LocalAudioTrack:
                this.bindLocalAudioTrackEvents(t3);
                break;
              case lB.LocalVideoLowTrack:
            }
          });
        }
        bindLocalAudioTrackEvents(e3, t3) {
          e3 instanceof JG ? e3.trackList.forEach((e4) => {
            e4.addListener(Zk.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e4.addListener(Zk.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e4.addListener(Zk.GET_STATS, this.handleGetLocalAudioStats), e4.addListener(Zk.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e4.addListener(Zk.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e3.addListener(Zk.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(Zk.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(Zk.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(Zk.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(Zk.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t3 || e3.addListener(Zk.NEED_REPLACE_TRACK, this.handleReplaceTrack));
        }
        unbindLocalTrackEvents(e3) {
          e3 || (e3 = Array.from(this.localTrackMap.entries()).map((e4) => {
            let [t3, { track: i3 }] = e4;
            return { track: i3, type: t3 };
          })), e3.forEach((e4) => {
            let { track: t3, type: i3 } = e4;
            switch (i3) {
              case lB.LocalVideoTrack:
                t3.off(Zk.GET_STATS, this.handleGetLocalVideoStats), t3.off(Zk.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t3.off(Zk.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t3.off(Zk.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t3.off(Zk.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t3.off(Zk.NEED_REPLACE_TRACK, this.handleReplaceTrack), t3.off(Zk.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t3.off(Zk.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case lB.LocalAudioTrack:
                this.unbindLocalAudioTrackEvents(t3);
                break;
              case lB.LocalVideoLowTrack:
            }
          });
        }
        unbindLocalAudioTrackEvents(e3) {
          e3 instanceof JG ? e3.trackList.forEach((e4) => {
            e4.off(Zk.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e4.off(Zk.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e4.off(Zk.GET_STATS, this.handleGetLocalAudioStats), e4.off(Zk.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e4.off(Zk.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e3.off(Zk.GET_STATS, this.handleGetLocalAudioStats), e3.off(Zk.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(Zk.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(Zk.NEED_REPLACE_TRACK, this.handleReplaceTrack), e3.off(Zk.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(Zk.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
        }
        bindRemoteTrackEvents(e3, t3) {
          t3 instanceof X1 && t3.addListener(Zk.GET_STATS, (t4) => {
            t4(this.handleGetRemoteVideoStats(e3));
          }), t3 instanceof z1 && t3.addListener(Zk.GET_STATS, (t4) => {
            t4(this.handleGetRemoteAudioStats(e3));
          });
        }
        unbindRemoteTrackEvents(e3) {
          e3 && e3.removeAllListeners(Zk.GET_STATS);
        }
        unbindAllRemoteTrackEvents() {
          Array.from(this.remoteUserMap.entries()).forEach((e3) => {
            let [t3, i3] = e3;
            i3.has(AB.AUDIO) && this.unbindRemoteTrackEvents(t3._audioTrack), i3.has(AB.VIDEO) && this.unbindRemoteTrackEvents(t3._videoTrack);
          });
        }
        createGatewayPublishMessage(e3, t3) {
          return e3.map((e4, i3) => {
            let r3, n3, { track: o3, type: s3 } = e4;
            switch (s3) {
              case lB.LocalAudioTrack:
                r3 = qk.Audio, n3 = { dtx: o3 instanceof WG && o3._config.DTX, hq: false, lq: false, stereo: false, speech: false };
                break;
              case lB.LocalVideoTrack:
                r3 = o3._hints.includes($k.SCREEN_TRACK) ? qk.Screen : qk.High, n3 = S0(S0({}, sK(o3)), {}, { codec: this.store.codec });
                break;
              case lB.LocalVideoLowTrack:
                r3 = qk.Low, n3 = S0(S0({}, sK(o3)), {}, { codec: this.store.codec });
            }
            return { stream_type: r3, attributes: n3, ssrcs: t3[i3] };
          });
        }
        createGatewayUnpublishMessage(e3) {
          return e3.map((e4) => {
            let t3, [i3, { track: r3, ssrcs: n3, id: o3 }] = e4;
            switch (i3) {
              case lB.LocalVideoTrack:
                t3 = r3._hints.includes($k.SCREEN_TRACK) ? qk.Screen : qk.High;
                break;
              case lB.LocalAudioTrack:
                t3 = qk.Audio;
                break;
              case lB.LocalVideoLowTrack:
                t3 = qk.Low;
            }
            return { stream_type: t3, ssrcs: n3, mid: o3 };
          });
        }
        assignLocalTracks(e3, t3) {
          e3.forEach((e4, i3) => {
            let { track: r3, type: n3 } = e4;
            this.localTrackMap.set(n3, { track: r3, id: t3[i3].id, ssrcs: t3[i3].localSSRC });
          });
        }
        withdrawLocalTracks(e3) {
          e3.forEach((e4) => {
            let [t3] = e4;
            this.localTrackMap.delete(t3);
          });
        }
        async waitTillConnected() {
          return new l_((e3, t3) => {
            switch (this.state) {
              case pB.New:
              case pB.Reconnecting: {
                const i3 = (r3, n3) => n3 === pB.Disconnected ? (this.off(gB.StateChange, i3), void t3(new QD(xD.UNEXPECTED_ERROR, "PeerConnection already disconnected."))) : n3 === pB.Connected ? (this.off(gB.StateChange, i3), void e3(void 0)) : void 0;
                this.on(gB.StateChange, i3);
                break;
              }
              case pB.Connected:
                e3(void 0);
                break;
              case pB.Disconnected:
                t3(new QD(xD.UNEXPECTED_ERROR, "PeerConnection already disconnected."));
            }
          });
        }
        bindConnectionEvents(e3) {
          e3.onConnectionStateChange = async (t3) => {
            if (JD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(t3, ")")), AP("info", this, "connectionStateChange", t3), this.emit(gB.PeerConnectionStateChange, t3), "connected" !== t3 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "disconnected" === t3 && "disconnected" === e3.iceConnectionState)
              return setTimeout(() => {
                if ("disconnected" === e3.iceConnectionState && LP("ICE_RESTART")) {
                  "CONNECTED" === RK(this, gB.QueryClientConnectionState) && this.emit(gB.RequestRestartICE);
                }
              }, 800), void setTimeout(() => {
                "disconnected" === e3.peerConnectionState && (JD.debug("P2PConnection disconnected timeout 4000ms, force reconnect"), setTimeout(() => this.emit(gB.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
              }, 4e3);
            "failed" === t3 && (JD.debug("P2PConnection state failed, force reconnect"), setTimeout(() => this.emit(gB.P2PLost), 0), this.iceFailedCount += 1, await this.requestReconnect());
          }, e3.onICEConnectionStateChange = (e4) => {
            "connected" !== e4 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), JD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e4, ")")), AP("info", this, "iceConnectionStateChange", e4), pj.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e4, tag: nk.TRACER }).onSuccess(), this.emit(gB.IceConnectionStateChange, e4);
          }, e3.onICETransportStateChange = (e4) => {
            JD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e4, ")")), AP("info", this, "ICETransportStateChange", e4);
          }, e3.onDTLSTransportStateChange = (e4) => {
            JD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e4, ")")), AP("info", this, "DTLSTransportStateChange", e4);
          }, e3.onDTLSTransportError = (e4) => {
            JD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e4, ")")), AP("info", this, "DTLSTransportError", e4);
          }, e3.onFirstAudioDecoded = (e4) => {
            var t3;
            const i3 = Array.from(qV(t3 = this.remoteUserMap).call(t3)).find((t4) => t4._audioSSRC === e4);
            var r3;
            i3 && (this.store.subscribe(i3.uid, "audio", void 0, void 0, void 0, Date.now()), null === (r3 = i3.audioTrack) || void 0 === r3 || r3.emit(rB.FIRST_FRAME_DECODED), pj.firstRemoteFrame(this.store.sessionId, $L.FIRST_AUDIO_DECODE, ek.FIRST_AUDIO_DECODE, { peer: i3._uintid, subscribeElapse: zG.measureFromSubscribeStart(this.store.clientId, e4), subscribeRequestid: e4, p2pid: this.store.p2pId }));
          }, e3.onFirstAudioReceived = (e4) => {
            var t3;
            const i3 = Array.from(qV(t3 = this.remoteUserMap).call(t3)).find((t4) => t4._audioSSRC === e4);
            i3 && pj.firstRemoteFrame(this.store.sessionId, $L.FIRST_AUDIO_RECEIVED, ek.FIRST_AUDIO_RECEIVED, { peer: i3._uintid, subscribeElapse: zG.measureFromSubscribeStart(this.store.clientId, e4), subscribeRequestid: e4, p2pid: this.store.p2pId });
          }, e3.onFirstVideoDecoded = (e4, t3, i3) => {
            this.reportVideoFirstFrameDecoded(e4, t3, i3);
          }, e3.onFirstVideoReceived = (e4) => {
            var t3;
            const i3 = Array.from(qV(t3 = this.remoteUserMap).call(t3)).find((t4) => t4._videoSSRC === e4);
            i3 && pj.firstRemoteFrame(this.store.sessionId, $L.FIRST_VIDEO_RECEIVED, ek.FIRST_VIDEO_RECEIVED, { peer: i3._uintid, subscribeElapse: zG.measureFromSubscribeStart(this.store.clientId, e4), subscribeRequestid: e4, p2pid: this.store.p2pId });
          }, e3.onSelectedLocalCandidateChanged = (e4, t3) => {
            const i3 = "relay" === e4.candidateType, r3 = "relay" === t3.candidateType;
            "unknown" !== t3.candidateType && i3 === r3 || this.emit(gB.ConnectionTypeChange, i3), JD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(AK(t3)), " -> ").concat(JSON.stringify(AK(e4)), ")")), AP("info", this, "SelectedLocalCandidateChanged", "".concat(JSON.stringify(AK(t3)), " -> ").concat(JSON.stringify(AK(e4))));
          }, e3.onSelectedRemoteCandidateChanged = (e4, t3) => {
            JD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(AK(t3)), " -> ").concat(JSON.stringify(AK(e4)), ")")), AP("info", this, "SelectedRemoteCandidateChanged", "".concat(JSON.stringify(AK(t3)), " -> ").concat(JSON.stringify(AK(e4))));
          }, e3.onFirstVideoDecodedTimeout = (e4) => {
            this.reportVideoFirstFrameDecoded(e4, void 0, void 0, true);
          };
        }
        unbindConnectionEvents(e3) {
          e3.onConnectionStateChange = void 0, e3.onICEConnectionStateChange = void 0, e3.onICETransportStateChange = void 0, e3.onDTLSTransportStateChange = void 0, e3.onDTLSTransportError = void 0, e3.onFirstAudioDecoded = void 0, e3.onFirstAudioReceived = void 0, e3.onFirstVideoDecoded = void 0, e3.onFirstVideoReceived = void 0, e3.onSelectedLocalCandidateChanged = void 0, e3.onSelectedRemoteCandidateChanged = void 0, e3.onFirstVideoDecodedTimeout = void 0;
        }
        filterTobeMutedTracks(e3) {
          const t3 = [];
          if (-1 === this.getAllTracks().indexOf(e3))
            return t3;
          const i3 = this.localTrackMap.get(lB.LocalAudioTrack);
          if (e3 instanceof HG && (null == i3 ? void 0 : i3.track) instanceof JG)
            return i3.track.isActive || t3.push([lB.LocalAudioTrack, i3]), t3;
          const r3 = Array.from(this.localTrackMap.entries()).find((t4) => {
            let [, { track: i4 }] = t4;
            return e3 === i4;
          });
          if (r3 && (t3.push(r3), r3[0] === lB.LocalVideoTrack)) {
            const e4 = this.localTrackMap.get(lB.LocalVideoLowTrack);
            e4 && t3.push([lB.LocalVideoLowTrack, e4]);
          }
          return t3;
        }
        filterTobeUnmutedTracks(e3) {
          const t3 = [], i3 = this.localTrackMap.get(lB.LocalAudioTrack);
          if (e3 instanceof HG && (null == i3 ? void 0 : i3.track) instanceof JG)
            return i3.track.isActive && t3.push([lB.LocalAudioTrack, i3]), t3;
          const r3 = Array.from(this.localTrackMap.entries()).find((t4) => {
            let [, { track: i4 }] = t4;
            return e3 === i4;
          });
          if (r3)
            if (r3[0] === lB.LocalVideoTrack) {
              t3.push(r3);
              const e4 = this.localTrackMap.get(lB.LocalVideoLowTrack);
              e4 && t3.push([lB.LocalVideoLowTrack, e4]);
            } else
              t3.push(r3);
          return t3;
        }
        createMuteMessage(e3) {
          return e3.map((e4) => {
            let t3, [i3, { track: r3, ssrcs: n3, id: o3 }] = e4;
            switch (i3) {
              case lB.LocalAudioTrack:
                t3 = qk.Audio;
                break;
              case lB.LocalVideoTrack:
                t3 = r3._hints.includes($k.SCREEN_TRACK) ? qk.Screen : qk.High;
                break;
              case lB.LocalVideoLowTrack:
                t3 = qk.Low;
            }
            return { stream_type: t3, ssrcs: n3, mid: o3 };
          });
        }
        createUnmuteMessage(e3) {
          return e3.map((e4) => {
            let t3, [i3, { track: r3, ssrcs: n3, id: o3 }] = e4;
            switch (i3) {
              case lB.LocalAudioTrack:
                t3 = qk.Audio;
                break;
              case lB.LocalVideoTrack:
                t3 = r3._hints.includes($k.SCREEN_TRACK) ? qk.Screen : qk.High;
                break;
              case lB.LocalVideoLowTrack:
                t3 = qk.Low;
            }
            return { stream_type: t3, ssrcs: n3, mid: o3 };
          });
        }
        filterTobeUnSubscribedTracks(e3, t3) {
          const i3 = [], r3 = this.remoteUserMap.get(e3);
          if (!r3)
            return i3;
          if (t3) {
            const n3 = r3.get(t3);
            if (!n3)
              return i3;
            i3.push([e3, { kind: t3, id: n3 }]);
          } else
            Array.from(r3.entries()).forEach((t4) => {
              let [r4, n3] = t4;
              i3.push([e3, { kind: r4, id: n3 }]);
            });
          return i3;
        }
        createUnsubscribeMessage(e3) {
          const t3 = [];
          return e3.forEach((e4) => {
            let [i3, { kind: r3, id: n3 }] = e4;
            switch (r3) {
              case AB.VIDEO:
                return void (i3._videoSSRC && t3.push({ stream_type: AB.VIDEO, ssrcId: i3._videoSSRC }));
              case AB.AUDIO:
                return void (i3._audioSSRC && t3.push({ stream_type: AB.AUDIO, ssrcId: i3._audioSSRC }));
            }
          }), t3;
        }
        createUnsubscribeAllMessage(e3) {
          const t3 = /* @__PURE__ */ new Map();
          return e3.forEach((e4) => {
            let [i3, { kind: r3 }] = e4;
            if (t3.has(i3)) {
              let e5 = t3.get(i3);
              r3 === AB.VIDEO ? e5 |= zk.Video : e5 |= zk.Audio, t3.set(i3, e5);
            } else
              r3 === AB.VIDEO ? t3.set(i3, zk.Video) : t3.set(i3, zk.Audio);
          }), { users: Array.from(t3.entries()).map((e4) => {
            let [t4, i3] = e4;
            return { stream_id: t4.uid, stream_type: i3 };
          }) };
        }
        withdrawRemoteTracks(e3) {
          e3.forEach((e4) => {
            let [t3, { kind: i3 }] = e4;
            const r3 = this.remoteUserMap.get(t3);
            r3 && (r3.delete(i3), 0 === Array.from(r3.entries()).length && this.remoteUserMap.delete(t3));
          });
        }
        async updateBitrateLimit(e3) {
          const t3 = this.localTrackMap.get(lB.LocalVideoTrack), i3 = this.localTrackMap.get(lB.LocalVideoLowTrack);
          t3 && await t3.track.setBitrateLimit(e3.uplink), i3 && e3.low_stream_uplink && await i3.track.setBitrateLimit({ max_bitrate: e3.low_stream_uplink.bitrate, min_bitrate: e3.low_stream_uplink.bitrate || 0 });
        }
        isP2PDisconnected() {
          if (this.connection) {
            return "connected" !== this.connection.peerConnectionState;
          }
          return true;
        }
        mapPubResToRemoteConfig(e3, t3) {
          return e3.map((e4, i3) => {
            var r3;
            let { stream_type: n3 } = e4;
            return null === (r3 = t3.find((e5) => {
              let { stream_type: t4 } = e5;
              return n3 === t4;
            })) || void 0 === r3 ? void 0 : r3.attributes;
          });
        }
        async tryToUnmuteAudio(e3) {
          for (let i3 = 0; i3 < e3.length; i3++)
            if (e3[i3] instanceof HG) {
              var t3;
              const r3 = this.filterTobeUnmutedTracks(e3[i3]);
              if (0 === r3.length)
                continue;
              await (null === (t3 = this.connection) || void 0 === t3 ? void 0 : t3.unmuteLocal(r3.map((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              })));
              const n3 = this.createUnmuteMessage(r3);
              return void await TK(this, gB.RequestUnmuteLocal, n3);
            }
        }
        bindStatsUploaderEvents() {
          this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e3) => {
            var t3;
            return !(null === (t3 = this.connection) || void 0 === t3 || !t3.getRemoteVideoIsReady(e3));
          }, this.statsUploader.requestUpload = (e3, t3) => this.emit(gB.RequestUploadStats, e3, t3), this.statsUploader.requestAllTracks = () => this.getAllTracks();
        }
        unbindStatsUploaderEvents() {
          this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
        }
        async requestReconnect() {
          this.dtlsFailedCount += 1, await EK(VD(this.dtlsFailedCount, FD)), this.emit(gB.RequestReconnect);
        }
        async reconnectP2P() {
          const e3 = Array.from(this.localTrackMap.entries()), t3 = this.createGatewayUnpublishMessage(e3);
          Array.from(this.remoteUserMap.entries()), t3.length > 0 && await vK(this, gB.RequestUnpublishForReconnectPC, t3), this.disconnectForReconnect(), this.emit(gB.RequestReconnectPC);
        }
        canPublishLowStream() {
          return this.localTrackMap.has(lB.LocalVideoTrack) || this.pendingLocalTracks.some((e3) => e3 instanceof hz);
        }
        throwIfTrackTypeNotMatch(e3) {
          if (e3.filter((e4) => e4 instanceof hz).length > 1)
            throw new QD(xD.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
          if (e3.filter((e4) => e4 instanceof HG).length > 1 && (e3.some((e4) => e4 instanceof HG && e4._bypassWebAudio) || !wB().webAudioMediaStreamDest))
            throw new QD(xD.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          for (const t3 of e3) {
            if (t3 instanceof hz && this.pendingLocalTracks.some((e4) => e4 instanceof hz))
              throw new QD(xD.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
            if (t3 instanceof HG && this.pendingLocalTracks.some((e4) => e4 instanceof HG) && (!wB().webAudioMediaStreamDest || t3._bypassWebAudio || this.pendingLocalTracks.some((e4) => e4 instanceof HG && e4._bypassWebAudio)))
              throw new QD(xD.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          }
        }
        getLowVideoTrack(e3, t3) {
          const i3 = wB().supportDualStreamEncoding, r3 = S0(S0({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t3);
          let n3;
          n3 = i3 ? e3._mediaStreamTrack.clone() : K1(e3, r3);
          const o3 = new hz(n3, S0(S0({}, i3 && { scaleResolutionDownBy: hK(r3, e3) }), {}, { frameRate: r3.framerate, bitrateMax: r3.bitrate, bitrateMin: r3.bitrate }));
          return o3._hints.push($k.LOW_STREAM), e3.addListener(Zk.NEED_CLOSE, () => {
            o3.close();
          }), o3;
        }
        async globalLock() {
          return this.mutex.lock("From P2PChannel.globalLock");
        }
        reportVideoFirstFrameDecoded(e3, t3, i3, r3) {
          var n3;
          const o3 = Array.from(qV(n3 = this.remoteUserMap).call(n3)).find((t4) => t4._videoSSRC === e3);
          if (o3) {
            r3 || this.store.subscribe(o3.uid, "video", void 0, void 0, void 0, void 0, Date.now());
            const n4 = this.store.keyMetrics, s3 = n4.subscribe.find((e4) => e4.userId === o3.uid && "video" === e4.type);
            pj.firstRemoteVideoDecode(this.store.sessionId, $L.FIRST_VIDEO_DECODE, ek.FIRST_VIDEO_DECODE, { peer: o3._uintid, videowidth: t3, videoheight: i3, subscribeElapse: zG.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId, apEnd: n4.requestAPEnd || 0, apStart: n4.requestAPStart || 0, joinGwEnd: n4.joinGatewayEnd || 0, joinGwStart: n4.joinGatewayStart || 0, pcEnd: n4.peerConnectionEnd || 0, pcStart: n4.peerConnectionStart || 0, subscriberEnd: (null == s3 ? void 0 : s3.subscribeEnd) || 0, subscriberStart: (null == s3 ? void 0 : s3.subscribeStart) || 0, videoAddNotify: (null == s3 ? void 0 : s3.streamAdded) || 0, state: r3 ? 1 : 0 });
          }
        }
        async remoteMediaSsrcChanged(e3, t3, i3) {
          if (!this.connection)
            return false;
          const r3 = this.remoteUserMap.get(e3);
          if (!r3)
            return false;
          const n3 = r3.get(t3);
          if (!n3)
            return false;
          const o3 = await this.connection.getRemoteSSRC(n3);
          return void 0 !== o3 && o3 !== i3;
        }
      }).prototype, "startP2PConnection", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "startP2PConnection"), _0.prototype), VV(_0.prototype, "connect", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "connect"), _0.prototype), VV(_0.prototype, "preConnect", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "preConnect"), _0.prototype), VV(_0.prototype, "unpublish", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "unpublish"), _0.prototype), VV(_0.prototype, "unpublishLowStream", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "unpublishLowStream"), _0.prototype), VV(_0.prototype, "subscribe", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "subscribe"), _0.prototype), VV(_0.prototype, "massSubscribe", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "massSubscribe"), _0.prototype), VV(_0.prototype, "unsubscribe", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "unsubscribe"), _0.prototype), VV(_0.prototype, "massUnsubscribe", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "massUnsubscribe"), _0.prototype), VV(_0.prototype, "muteRemote", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "muteRemote"), _0.prototype), VV(_0.prototype, "unmuteRemote", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "unmuteRemote"), _0.prototype), VV(_0.prototype, "hasRemoteMediaWithLock", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "hasRemoteMediaWithLock"), _0.prototype), VV(_0.prototype, "disconnectForReconnect", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "disconnectForReconnect"), _0.prototype), VV(_0.prototype, "updateBitrateLimit", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "updateBitrateLimit"), _0.prototype), VV(_0.prototype, "remoteMediaSsrcChanged", [y0], Object.getOwnPropertyDescriptor(_0.prototype, "remoteMediaSsrcChanged"), _0.prototype), I0 = _0)) || I0;
      function y0(e3, t3, i3) {
        const r3 = e3[t3];
        if ("function" != typeof r3)
          throw new Error("Cannot use mutex on object property.");
        return i3.value = async function() {
          const e4 = this.mutex, i4 = await e4.lock("From P2PChannel.".concat(t3));
          try {
            for (var n3 = arguments.length, o3 = new Array(n3), s3 = 0; s3 < n3; s3++)
              o3[s3] = arguments[s3];
            return await r3.apply(this, o3);
          } finally {
            i4();
          }
        }, i3;
      }
      function w0(e3) {
        return "Minified Redux error #" + e3 + "; visit https://redux.js.org/Errors?code=" + e3 + " for the full message or use the non-minified dev environment for full errors. ";
      }
      var b0, N0 = "function" == typeof Symbol && Symbol.observable || "@@observable", O0 = function() {
        return Math.random().toString(36).substring(7).split("").join(".");
      }, D0 = { INIT: "@@redux/INIT" + O0(), REPLACE: "@@redux/REPLACE" + O0(), PROBE_UNKNOWN_ACTION: function() {
        return "@@redux/PROBE_UNKNOWN_ACTION" + O0();
      } };
      function P0(e3) {
        if ("object" != typeof e3 || null === e3)
          return false;
        for (var t3 = e3; null !== Object.getPrototypeOf(t3); )
          t3 = Object.getPrototypeOf(t3);
        return Object.getPrototypeOf(e3) === t3;
      }
      function L0(e3, t3, i3) {
        var r3;
        if ("function" == typeof t3 && "function" == typeof i3 || "function" == typeof i3 && "function" == typeof arguments[3])
          throw new Error(w0(0));
        if ("function" == typeof t3 && void 0 === i3 && (i3 = t3, t3 = void 0), void 0 !== i3) {
          if ("function" != typeof i3)
            throw new Error(w0(1));
          return i3(L0)(e3, t3);
        }
        if ("function" != typeof e3)
          throw new Error(w0(2));
        var n3 = e3, o3 = t3, s3 = [], a3 = s3, c3 = false;
        function d3() {
          a3 === s3 && (a3 = s3.slice());
        }
        function u3() {
          if (c3)
            throw new Error(w0(3));
          return o3;
        }
        function h3(e4) {
          if ("function" != typeof e4)
            throw new Error(w0(4));
          if (c3)
            throw new Error(w0(5));
          var t4 = true;
          return d3(), a3.push(e4), function() {
            if (t4) {
              if (c3)
                throw new Error(w0(6));
              t4 = false, d3();
              var i4 = a3.indexOf(e4);
              a3.splice(i4, 1), s3 = null;
            }
          };
        }
        function A3(e4) {
          if (!P0(e4))
            throw new Error(w0(7));
          if (void 0 === e4.type)
            throw new Error(w0(8));
          if (c3)
            throw new Error(w0(9));
          try {
            c3 = true, o3 = n3(o3, e4);
          } finally {
            c3 = false;
          }
          for (var t4 = s3 = a3, i4 = 0; i4 < t4.length; i4++) {
            (0, t4[i4])();
          }
          return e4;
        }
        function l3(e4) {
          if ("function" != typeof e4)
            throw new Error(w0(10));
          n3 = e4, A3({ type: D0.REPLACE });
        }
        function p3() {
          var e4, t4 = h3;
          return (e4 = { subscribe: function(e5) {
            if ("object" != typeof e5 || null === e5)
              throw new Error(w0(11));
            function i4() {
              e5.next && e5.next(u3());
            }
            return i4(), { unsubscribe: t4(i4) };
          } })[N0] = function() {
            return this;
          }, e4;
        }
        return A3({ type: D0.INIT }), (r3 = { dispatch: A3, subscribe: h3, getState: u3, replaceReducer: l3 })[N0] = p3, r3;
      }
      function k0(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function B0(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? k0(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : k0(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      !function(e3) {
        e3.SET_SESSION_ID = "SET_SESSION_ID", e3.SET_P2P_ID = "SET_P2P_id", e3.SET_DC_ID = "SET_DC_id", e3.SET_UID = "SET_UID", e3.SET_PUB_ID = "SET_PUB_ID", e3.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE", e3.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED", e3.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START", e3.AVOID_JOIN_START = "AVOID_JOIN_START", e3.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END", e3.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START", e3.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END", e3.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START", e3.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END", e3.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START", e3.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END", e3.KEY_METRIC_ICE_CONNECTION_END = "KEY_METRIC_ICE_CONNECTION_END", e3.KEY_METRIC_SIGNAL_CHANNEL_OPEN = "KEY_METRIC_SIGNAL_CHANNEL_OPEN", e3.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH", e3.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE", e3.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE", e3.RESET_JOIN_CHANNEL_SERVICE_RECORDS = "RESET_JOIN_CHANNEL_SERVICE_RECORDS", e3.RESET_KEY_METRICS = "RESET_KEY_METRICS";
      }(b0 || (b0 = {}));
      class M0 {
        constructor(e3, t3, i3, r3) {
          MN(this, "store", void 0), MN(this, "reducer", void 0);
          const n3 = { codec: e3, audioCodec: t3, mode: i3, clientId: r3, sessionId: null, p2pId: 0, dcId: 0, pubId: 0, subId: 0, avoidJoinStart: 0, keyMetrics: { publish: [], subscribe: [] }, joinChannelServiceRecords: [], cloudProxyServerMode: "disabled" };
          this.reducer = function() {
            let e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : n3, t4 = arguments.length > 1 ? arguments[1] : void 0;
            switch (t4.type) {
              case b0.SET_SESSION_ID:
                return B0(B0({}, e4), {}, { sessionId: t4.sessionId });
              case b0.SET_P2P_ID:
                return B0(B0({}, e4), {}, { p2pId: t4.p2pId });
              case b0.SET_UID:
                return B0(B0({}, e4), {}, { uid: t4.uid });
              case b0.SET_PUB_ID:
                return B0(B0({}, e4), {}, { pubId: t4.pubId });
              case b0.KEY_METRIC_CLIENT_CREATED:
                return B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { clientCreated: t4.metric }) });
              case b0.KEY_METRIC_JOIN_START:
                return B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { joinStart: t4.metric }) });
              case b0.AVOID_JOIN_START:
                return B0(B0({}, e4), {}, { avoidJoinStart: t4.avoidJoinStart });
              case b0.KEY_METRIC_JOIN_END:
                return B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { joinEnd: t4.metric }) });
              case b0.KEY_METRIC_REQUEST_AP_START:
                return B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { requestAPStart: t4.metric }) });
              case b0.KEY_METRIC_REQUEST_AP_END:
                return B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { requestAPEnd: t4.metric }) });
              case b0.KEY_METRIC_JOIN_GATEWAY_START:
                return B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { joinGatewayStart: t4.metric }) });
              case b0.KEY_METRIC_JOIN_GATEWAY_END:
                return B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { joinGatewayEnd: t4.metric }) });
              case b0.KEY_METRIC_PEER_CONNECTION_START:
                return B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { peerConnectionStart: t4.metric }) });
              case b0.KEY_METRIC_PEER_CONNECTION_END:
                return B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { peerConnectionEnd: t4.metric }) });
              case b0.KEY_METRIC_SIGNAL_CHANNEL_OPEN:
                return B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { signalChannelOpen: t4.metric }) });
              case b0.KEY_METRIC_ICE_CONNECTION_END:
                return B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { iceConnectionEnd: t4.metric }) });
              case b0.KEY_METRIC_PUBLISH: {
                const i4 = e4.keyMetrics.publish, r4 = i4.findIndex((e5) => e5.trackId === t4.metric.trackId);
                return -1 !== r4 ? (i4[r4] = B0(B0({}, i4[r4]), t4.metric), B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { publish: [...i4] }) })) : B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { publish: [...e4.keyMetrics.publish, t4.metric] }) });
              }
              case b0.KEY_METRIC_SUBSCRIBE: {
                const i4 = e4.keyMetrics.subscribe, r4 = i4.findIndex((e5) => e5.userId === t4.metric.userId && e5.type === t4.metric.type);
                return -1 !== r4 ? (i4[r4] = B0(B0({}, i4[r4]), t4.metric), B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { subscribe: [...i4] }) })) : B0(B0({}, e4), {}, { keyMetrics: B0(B0({}, e4.keyMetrics), {}, { subscribe: [...e4.keyMetrics.subscribe, t4.metric] }) });
              }
              case b0.SET_CLOUD_PROXY_SERVER_MODE:
                return e4.cloudProxyServerMode = t4.mode, e4;
              case b0.RECORD_JOIN_CHANNEL_SERVICE:
                return "number" != typeof t4.index ? e4.joinChannelServiceRecords = [...e4.joinChannelServiceRecords, t4.record] : (e4.joinChannelServiceRecords[t4.index] = B0(B0({}, e4.joinChannelServiceRecords[t4.index]), t4.record), e4.joinChannelServiceRecords = [...e4.joinChannelServiceRecords]), e4;
              case b0.RESET_JOIN_CHANNEL_SERVICE_RECORDS:
                return e4.joinChannelServiceRecords = [], e4;
              case b0.RESET_KEY_METRICS:
                return e4.keyMetrics = { publish: [], subscribe: [] }, e4;
              default:
                return e4;
            }
          }, this.store = L0(this.reducer);
        }
        set sessionId(e3) {
          this.store.dispatch({ type: b0.SET_SESSION_ID, sessionId: e3 });
        }
        get sessionId() {
          return this.store.getState().sessionId;
        }
        get codec() {
          return this.store.getState().codec;
        }
        get audioCodec() {
          return this.store.getState().audioCodec;
        }
        get clientId() {
          return this.store.getState().clientId;
        }
        set p2pId(e3) {
          this.store.dispatch({ type: b0.SET_P2P_ID, p2pId: e3 });
        }
        get p2pId() {
          return this.store.getState().p2pId;
        }
        set dcId(e3) {
          this.store.dispatch({ type: b0.SET_DC_ID, dcId: e3 });
        }
        get dcId() {
          return this.store.getState().dcId;
        }
        set uid(e3) {
          this.store.dispatch({ type: b0.SET_UID, uid: e3 });
        }
        get uid() {
          return this.store.getState().uid;
        }
        set pubId(e3) {
          this.store.dispatch({ type: b0.SET_PUB_ID, pubId: e3 });
        }
        get pubId() {
          return this.store.getState().pubId;
        }
        set cloudProxyServerMode(e3) {
          this.store.dispatch({ type: b0.SET_CLOUD_PROXY_SERVER_MODE, mode: e3 });
        }
        get cloudProxyServerMode() {
          return this.store.getState().cloudProxyServerMode;
        }
        clientCreated() {
          this.store.dispatch({ type: b0.KEY_METRIC_CLIENT_CREATED, metric: Date.now() });
        }
        joinStart() {
          this.store.dispatch({ type: b0.KEY_METRIC_JOIN_START, metric: Date.now() });
        }
        joinEnd() {
          this.store.dispatch({ type: b0.KEY_METRIC_JOIN_END, metric: Date.now() });
        }
        requestAPStart() {
          this.store.dispatch({ type: b0.KEY_METRIC_REQUEST_AP_START, metric: Date.now() });
        }
        requestAPEnd() {
          this.store.dispatch({ type: b0.KEY_METRIC_REQUEST_AP_END, metric: Date.now() });
        }
        joinGatewayStart() {
          this.store.dispatch({ type: b0.KEY_METRIC_JOIN_GATEWAY_START, metric: Date.now() });
        }
        joinGatewayEnd() {
          this.store.dispatch({ type: b0.KEY_METRIC_JOIN_GATEWAY_END, metric: Date.now() });
        }
        peerConnectionStart() {
          this.store.dispatch({ type: b0.KEY_METRIC_PEER_CONNECTION_START, metric: Date.now() });
        }
        peerConnectionEnd() {
          this.store.dispatch({ type: b0.KEY_METRIC_PEER_CONNECTION_END, metric: Date.now() });
        }
        signalChannelOpen() {
          this.store.dispatch({ type: b0.KEY_METRIC_SIGNAL_CHANNEL_OPEN, metric: Date.now() });
        }
        iceConnectionEnd() {
          this.store.dispatch({ type: b0.KEY_METRIC_ICE_CONNECTION_END, metric: Date.now() });
        }
        publish(e3, t3, i3, r3) {
          this.store.dispatch({ type: b0.KEY_METRIC_PUBLISH, metric: B0(B0({ trackId: e3, type: t3 }, i3 && { publishStart: i3 }), r3 && { publishEnd: r3 }) });
        }
        subscribe(e3, t3, i3, r3, n3, o3, s3) {
          this.store.dispatch({ type: b0.KEY_METRIC_SUBSCRIBE, metric: B0(B0(B0(B0(B0({ userId: e3, type: t3 }, i3 && { subscribeStart: i3 }), r3 && { subscribeEnd: r3 }), n3 && { firstFrame: n3 }), o3 && { streamAdded: o3 }), s3 && { firstDecoded: s3 }) });
        }
        massSubscribe(e3, t3, i3, r3) {
          e3.forEach((e4) => {
            this.store.dispatch({ type: b0.KEY_METRIC_SUBSCRIBE, metric: B0(B0(B0({ userId: e4.userId, type: e4.type }, t3 && { subscribeStart: t3 }), i3 && { subscribeEnd: i3 }), r3 && { firstFrame: r3 }) });
          });
        }
        get keyMetrics() {
          return this.store.getState().keyMetrics;
        }
        recordJoinChannelService(e3, t3) {
          "gateway" === e3.service && Array.isArray(e3.urls) && (e3.urls = e3.urls.map((e4) => e4.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2")));
          try {
            return "number" != typeof t3 ? (this.store.dispatch({ type: b0.RECORD_JOIN_CHANNEL_SERVICE, record: B0(B0({}, e3), {}, { sessionId: this.sessionId, cloudProxyMode: this.cloudProxyServerMode, uid: this.uid }) }), this.store.getState().joinChannelServiceRecords.length - 1) : (t3 < 0 || t3 >= this.store.getState().joinChannelServiceRecords.length || this.store.dispatch({ type: b0.RECORD_JOIN_CHANNEL_SERVICE, record: e3, index: t3 }), t3);
          } catch (e4) {
            return 0;
          }
        }
        resetJoinChannelServiceRecords() {
          this.store.dispatch({ type: b0.RESET_JOIN_CHANNEL_SERVICE_RECORDS });
        }
        resetKeyMetrics() {
          this.store.dispatch({ type: b0.RESET_KEY_METRICS });
        }
        get joinChannelServiceRecords() {
          try {
            return this.store.getState().joinChannelServiceRecords;
          } catch (e3) {
            return [];
          }
        }
        get avoidJoinStart() {
          return this.store.getState().avoidJoinStart;
        }
        set avoidJoinStart(e3) {
          this.store.dispatch({ type: b0.AVOID_JOIN_START, avoidJoinStart: e3 });
        }
      }
      let U0;
      const x0 = () => "HTTPS" === (U0 || U0 || (U0 = (window.location.protocol.split(":")[0] || "").toUpperCase(), U0)), Q0 = () => void 0 !== window.isSecureContext;
      function F0(e3) {
        let t3 = z0();
        return function(e4, t4) {
          let i3 = e4.appId;
          void 0 !== i3 && (h2(t4, 10), n2(t4, i3));
          let r3 = e4.cid;
          void 0 !== r3 && (h2(t4, 16), h2(t4, r3));
          let n3 = e4.cname;
          void 0 !== n3 && (h2(t4, 26), n2(t4, n3));
          let o3 = e4.deviceId;
          void 0 !== o3 && (h2(t4, 34), n2(t4, o3));
          let s3 = e4.elapse;
          void 0 !== s3 && (h2(t4, 40), A2(t4, s3));
          let a3 = e4.fileSize;
          void 0 !== a3 && (h2(t4, 48), A2(t4, q0(a3)));
          let c3 = e4.height;
          void 0 !== c3 && (h2(t4, 56), A2(t4, q0(c3)));
          let d3 = e4.jpg;
          void 0 !== d3 && (h2(t4, 66), h2(t4, d3.length), function(e5, t5) {
            let i4 = t2(e5, t5.length);
            e5.bytes.set(t5, i4);
          }(t4, d3));
          let u3 = e4.networkType;
          void 0 !== u3 && (h2(t4, 72), A2(t4, q0(u3)));
          let h3 = e4.osType;
          void 0 !== h3 && (h2(t4, 80), A2(t4, q0(h3)));
          let A3 = e4.requestId;
          void 0 !== A3 && (h2(t4, 90), n2(t4, A3));
          let l3 = e4.sdkVersion;
          void 0 !== l3 && (h2(t4, 98), n2(t4, l3));
          let p3 = e4.sequence;
          void 0 !== p3 && (h2(t4, 104), A2(t4, q0(p3)));
          let g3 = e4.sid;
          void 0 !== g3 && (h2(t4, 114), n2(t4, g3));
          let E3 = e4.timestamp;
          void 0 !== E3 && (h2(t4, 120), A2(t4, E3));
          let f3 = e4.uid;
          void 0 !== f3 && (h2(t4, 128), h2(t4, f3));
          let m3 = e4.vid;
          void 0 !== m3 && (h2(t4, 136), h2(t4, m3));
          let I3 = e4.width;
          void 0 !== I3 && (h2(t4, 144), A2(t4, q0(I3)));
          let _3 = e4.service;
          void 0 !== _3 && (h2(t4, 152), h2(t4, _3));
          let C3 = e4.callbackData;
          void 0 !== C3 && (h2(t4, 162), n2(t4, C3));
          let S3 = e4.jpgEncryption;
          void 0 !== S3 && (h2(t4, 168), h2(t4, S3));
          let v3 = e4.requestType;
          void 0 !== v3 && (h2(t4, 176), h2(t4, v3));
          let T3 = e4.scorePorn;
          void 0 !== T3 && (h2(t4, 185), d2(t4, T3));
          let R3 = e4.scoreSexy;
          void 0 !== R3 && (h2(t4, 193), d2(t4, R3));
          let y3 = e4.scoreNeutral;
          void 0 !== y3 && (h2(t4, 201), d2(t4, y3));
          let w3 = e4.scene;
          void 0 !== w3 && (h2(t4, 208), h2(t4, w3));
          let b3 = e4.ossFilePrefix;
          void 0 !== b3 && (h2(t4, 218), n2(t4, b3));
          let N3 = e4.serviceVendor;
          if (void 0 !== N3)
            for (let e5 of N3) {
              h2(t4, 226);
              let i4 = z0();
              G0(e5, i4), h2(t4, i4.limit), o2(t4, i4), Z0(i4);
            }
        }(e3, t3), function(e4) {
          let t4 = e4.bytes, i3 = e4.limit;
          return t4.length === i3 ? t4 : t4.subarray(0, i3);
        }(t3);
      }
      function V0(e3) {
        return function(e4) {
          let t4 = {};
          e:
            for (; !e2(e4); ) {
              let i3 = u2(e4);
              switch (i3 >>> 3) {
                case 0:
                  break e;
                case 1:
                  t4.code = u2(e4);
                  break;
                case 2:
                  t4.msg = r2(e4, u2(e4));
                  break;
                case 3: {
                  let i4 = K0(e4);
                  t4.data = j0(e4), e4.limit = i4;
                  break;
                }
                default:
                  H0(e4, 7 & i3);
              }
            }
          return t4;
        }({ bytes: t3 = e3, offset: 0, limit: t3.length });
        var t3;
      }
      function j0(e3) {
        let t3 = {};
        e:
          for (; !e2(e3); ) {
            let i3 = u2(e3);
            switch (i3 >>> 3) {
              case 0:
                break e;
              case 1:
                t3.requestId = r2(e3, u2(e3));
                break;
              case 2:
                t3.requestType = u2(e3) >>> 0;
                break;
              case 3:
                t3.scorePorn = c2(e3);
                break;
              case 4:
                t3.scoreSexy = c2(e3);
                break;
              case 5:
                t3.scoreNeutral = c2(e3);
                break;
              case 6:
                t3.requestScene = u2(e3) >>> 0;
                break;
              case 7:
                t3.scene = u2(e3) >>> 0;
                break;
              default:
                H0(e3, 7 & i3);
            }
          }
        return t3;
      }
      function G0(e3, t3) {
        let i3 = e3.service;
        void 0 !== i3 && (h2(t3, 8), h2(t3, i3));
        let r3 = e3.vendor;
        void 0 !== r3 && (h2(t3, 16), h2(t3, r3));
        let n3 = e3.token;
        void 0 !== n3 && (h2(t3, 26), n2(t3, n3));
        let o3 = e3.callbackUrl;
        void 0 !== o3 && (h2(t3, 34), n2(t3, o3));
      }
      function K0(e3) {
        let t3 = u2(e3), i3 = e3.limit;
        return e3.limit = e3.offset + t3, i3;
      }
      function H0(e3, t3) {
        switch (t3) {
          case 0:
            for (; 128 & s2(e3); )
              ;
            break;
          case 2:
            $0(e3, u2(e3));
            break;
          case 5:
            $0(e3, 4);
            break;
          case 1:
            $0(e3, 8);
            break;
          default:
            throw new Error("Unimplemented type: " + t3);
        }
      }
      let W0 = new Float32Array(1);
      new Uint8Array(W0.buffer);
      let Y0 = new Float64Array(1), J0 = new Uint8Array(Y0.buffer);
      function q0(e3) {
        return { low: e3 |= 0, high: e3 >> 31, unsigned: e3 >= 0 };
      }
      let X0 = [];
      function z0() {
        const e3 = X0.pop();
        return e3 ? (e3.offset = e3.limit = 0, e3) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
      }
      function Z0(e3) {
        X0.push(e3);
      }
      function $0(e3, t3) {
        if (e3.offset + t3 > e3.limit)
          throw new Error("Skip past limit");
        e3.offset += t3;
      }
      function e2(e3) {
        return e3.offset >= e3.limit;
      }
      function t2(e3, t3) {
        let i3 = e3.bytes, r3 = e3.offset, n3 = e3.limit, o3 = r3 + t3;
        if (o3 > i3.length) {
          let t4 = new Uint8Array(2 * o3);
          t4.set(i3), e3.bytes = t4;
        }
        return e3.offset = o3, o3 > n3 && (e3.limit = o3), r3;
      }
      function i2(e3, t3) {
        let i3 = e3.offset;
        if (i3 + t3 > e3.limit)
          throw new Error("Read past limit");
        return e3.offset += t3, i3;
      }
      function r2(e3, t3) {
        let i3 = i2(e3, t3), r3 = String.fromCharCode, n3 = e3.bytes, o3 = "\uFFFD", s3 = "";
        for (let e4 = 0; e4 < t3; e4++) {
          let a3, c3, d3, u3, h3 = n3[e4 + i3];
          0 == (128 & h3) ? s3 += r3(h3) : 192 == (224 & h3) ? e4 + 1 >= t3 ? s3 += o3 : (a3 = n3[e4 + i3 + 1], 128 != (192 & a3) ? s3 += o3 : (u3 = (31 & h3) << 6 | 63 & a3, u3 < 128 ? s3 += o3 : (s3 += r3(u3), e4++))) : 224 == (240 & h3) ? e4 + 2 >= t3 ? s3 += o3 : (a3 = n3[e4 + i3 + 1], c3 = n3[e4 + i3 + 2], 32896 != (49344 & (a3 | c3 << 8)) ? s3 += o3 : (u3 = (15 & h3) << 12 | (63 & a3) << 6 | 63 & c3, u3 < 2048 || u3 >= 55296 && u3 <= 57343 ? s3 += o3 : (s3 += r3(u3), e4 += 2))) : 240 == (248 & h3) ? e4 + 3 >= t3 ? s3 += o3 : (a3 = n3[e4 + i3 + 1], c3 = n3[e4 + i3 + 2], d3 = n3[e4 + i3 + 3], 8421504 != (12632256 & (a3 | c3 << 8 | d3 << 16)) ? s3 += o3 : (u3 = (7 & h3) << 18 | (63 & a3) << 12 | (63 & c3) << 6 | 63 & d3, u3 < 65536 || u3 > 1114111 ? s3 += o3 : (u3 -= 65536, s3 += r3(55296 + (u3 >> 10), 56320 + (1023 & u3)), e4 += 3))) : s3 += o3;
        }
        return s3;
      }
      function n2(e3, t3) {
        let i3 = t3.length, r3 = 0;
        for (let e4 = 0; e4 < i3; e4++) {
          let n4 = t3.charCodeAt(e4);
          n4 >= 55296 && n4 <= 56319 && e4 + 1 < i3 && (n4 = (n4 << 10) + t3.charCodeAt(++e4) - 56613888), r3 += n4 < 128 ? 1 : n4 < 2048 ? 2 : n4 < 65536 ? 3 : 4;
        }
        h2(e3, r3);
        let n3 = t2(e3, r3), o3 = e3.bytes;
        for (let e4 = 0; e4 < i3; e4++) {
          let r4 = t3.charCodeAt(e4);
          r4 >= 55296 && r4 <= 56319 && e4 + 1 < i3 && (r4 = (r4 << 10) + t3.charCodeAt(++e4) - 56613888), r4 < 128 ? o3[n3++] = r4 : (r4 < 2048 ? o3[n3++] = r4 >> 6 & 31 | 192 : (r4 < 65536 ? o3[n3++] = r4 >> 12 & 15 | 224 : (o3[n3++] = r4 >> 18 & 7 | 240, o3[n3++] = r4 >> 12 & 63 | 128), o3[n3++] = r4 >> 6 & 63 | 128), o3[n3++] = 63 & r4 | 128);
        }
      }
      function o2(e3, t3) {
        let i3 = t2(e3, t3.limit), r3 = e3.bytes, n3 = t3.bytes;
        for (let e4 = 0, o3 = t3.limit; e4 < o3; e4++)
          r3[e4 + i3] = n3[e4];
      }
      function s2(e3) {
        return e3.bytes[i2(e3, 1)];
      }
      function a2(e3, t3) {
        let i3 = t2(e3, 1);
        e3.bytes[i3] = t3;
      }
      function c2(e3) {
        let t3 = i2(e3, 8), i3 = e3.bytes;
        return J0[0] = i3[t3++], J0[1] = i3[t3++], J0[2] = i3[t3++], J0[3] = i3[t3++], J0[4] = i3[t3++], J0[5] = i3[t3++], J0[6] = i3[t3++], J0[7] = i3[t3++], Y0[0];
      }
      function d2(e3, t3) {
        let i3 = t2(e3, 8), r3 = e3.bytes;
        Y0[0] = t3, r3[i3++] = J0[0], r3[i3++] = J0[1], r3[i3++] = J0[2], r3[i3++] = J0[3], r3[i3++] = J0[4], r3[i3++] = J0[5], r3[i3++] = J0[6], r3[i3++] = J0[7];
      }
      function u2(e3) {
        let t3, i3 = 0, r3 = 0;
        do {
          t3 = s2(e3), i3 < 32 && (r3 |= (127 & t3) << i3), i3 += 7;
        } while (128 & t3);
        return r3;
      }
      function h2(e3, t3) {
        for (t3 >>>= 0; t3 >= 128; )
          a2(e3, 127 & t3 | 128), t3 >>>= 7;
        a2(e3, t3);
      }
      function A2(e3, t3) {
        let i3 = t3.low >>> 0, r3 = (t3.low >>> 28 | t3.high << 4) >>> 0, n3 = t3.high >>> 24, o3 = 0 === n3 ? 0 === r3 ? i3 < 16384 ? i3 < 128 ? 1 : 2 : i3 < 1 << 21 ? 3 : 4 : r3 < 16384 ? r3 < 128 ? 5 : 6 : r3 < 1 << 21 ? 7 : 8 : n3 < 128 ? 9 : 10, s3 = t2(e3, o3), a3 = e3.bytes;
        switch (o3) {
          case 10:
            a3[s3 + 9] = n3 >>> 7 & 1;
          case 9:
            a3[s3 + 8] = 9 !== o3 ? 128 | n3 : 127 & n3;
          case 8:
            a3[s3 + 7] = 8 !== o3 ? r3 >>> 21 | 128 : r3 >>> 21 & 127;
          case 7:
            a3[s3 + 6] = 7 !== o3 ? r3 >>> 14 | 128 : r3 >>> 14 & 127;
          case 6:
            a3[s3 + 5] = 6 !== o3 ? r3 >>> 7 | 128 : r3 >>> 7 & 127;
          case 5:
            a3[s3 + 4] = 5 !== o3 ? 128 | r3 : 127 & r3;
          case 4:
            a3[s3 + 3] = 4 !== o3 ? i3 >>> 21 | 128 : i3 >>> 21 & 127;
          case 3:
            a3[s3 + 2] = 3 !== o3 ? i3 >>> 14 | 128 : i3 >>> 14 & 127;
          case 2:
            a3[s3 + 1] = 2 !== o3 ? i3 >>> 7 | 128 : i3 >>> 7 & 127;
          case 1:
            a3[s3] = 1 !== o3 ? 128 | i3 : 127 & i3;
        }
      }
      var l2 = {};
      Object.defineProperty(l2, "__esModule", { value: true });
      var p2 = function() {
        function e3() {
          this._dataLength = 0, this._bufferLength = 0, this._state = new Int32Array(4), this._buffer = new ArrayBuffer(68), this._buffer8 = new Uint8Array(this._buffer, 0, 68), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start();
        }
        return e3.hashStr = function(e4, t3) {
          return void 0 === t3 && (t3 = false), this.onePassHasher.start().appendStr(e4).end(t3);
        }, e3.hashAsciiStr = function(e4, t3) {
          return void 0 === t3 && (t3 = false), this.onePassHasher.start().appendAsciiStr(e4).end(t3);
        }, e3._hex = function(t3) {
          var i3, r3, n3, o3, s3 = e3.hexChars, a3 = e3.hexOut;
          for (o3 = 0; o3 < 4; o3 += 1)
            for (r3 = 8 * o3, i3 = t3[o3], n3 = 0; n3 < 8; n3 += 2)
              a3[r3 + 1 + n3] = s3.charAt(15 & i3), i3 >>>= 4, a3[r3 + 0 + n3] = s3.charAt(15 & i3), i3 >>>= 4;
          return a3.join("");
        }, e3._md5cycle = function(e4, t3) {
          var i3 = e4[0], r3 = e4[1], n3 = e4[2], o3 = e4[3];
          r3 = ((r3 += ((n3 = ((n3 += ((o3 = ((o3 += ((i3 = ((i3 += (r3 & n3 | ~r3 & o3) + t3[0] - 680876936 | 0) << 7 | i3 >>> 25) + r3 | 0) & r3 | ~i3 & n3) + t3[1] - 389564586 | 0) << 12 | o3 >>> 20) + i3 | 0) & i3 | ~o3 & r3) + t3[2] + 606105819 | 0) << 17 | n3 >>> 15) + o3 | 0) & o3 | ~n3 & i3) + t3[3] - 1044525330 | 0) << 22 | r3 >>> 10) + n3 | 0, r3 = ((r3 += ((n3 = ((n3 += ((o3 = ((o3 += ((i3 = ((i3 += (r3 & n3 | ~r3 & o3) + t3[4] - 176418897 | 0) << 7 | i3 >>> 25) + r3 | 0) & r3 | ~i3 & n3) + t3[5] + 1200080426 | 0) << 12 | o3 >>> 20) + i3 | 0) & i3 | ~o3 & r3) + t3[6] - 1473231341 | 0) << 17 | n3 >>> 15) + o3 | 0) & o3 | ~n3 & i3) + t3[7] - 45705983 | 0) << 22 | r3 >>> 10) + n3 | 0, r3 = ((r3 += ((n3 = ((n3 += ((o3 = ((o3 += ((i3 = ((i3 += (r3 & n3 | ~r3 & o3) + t3[8] + 1770035416 | 0) << 7 | i3 >>> 25) + r3 | 0) & r3 | ~i3 & n3) + t3[9] - 1958414417 | 0) << 12 | o3 >>> 20) + i3 | 0) & i3 | ~o3 & r3) + t3[10] - 42063 | 0) << 17 | n3 >>> 15) + o3 | 0) & o3 | ~n3 & i3) + t3[11] - 1990404162 | 0) << 22 | r3 >>> 10) + n3 | 0, r3 = ((r3 += ((n3 = ((n3 += ((o3 = ((o3 += ((i3 = ((i3 += (r3 & n3 | ~r3 & o3) + t3[12] + 1804603682 | 0) << 7 | i3 >>> 25) + r3 | 0) & r3 | ~i3 & n3) + t3[13] - 40341101 | 0) << 12 | o3 >>> 20) + i3 | 0) & i3 | ~o3 & r3) + t3[14] - 1502002290 | 0) << 17 | n3 >>> 15) + o3 | 0) & o3 | ~n3 & i3) + t3[15] + 1236535329 | 0) << 22 | r3 >>> 10) + n3 | 0, r3 = ((r3 += ((n3 = ((n3 += ((o3 = ((o3 += ((i3 = ((i3 += (r3 & o3 | n3 & ~o3) + t3[1] - 165796510 | 0) << 5 | i3 >>> 27) + r3 | 0) & n3 | r3 & ~n3) + t3[6] - 1069501632 | 0) << 9 | o3 >>> 23) + i3 | 0) & r3 | i3 & ~r3) + t3[11] + 643717713 | 0) << 14 | n3 >>> 18) + o3 | 0) & i3 | o3 & ~i3) + t3[0] - 373897302 | 0) << 20 | r3 >>> 12) + n3 | 0, r3 = ((r3 += ((n3 = ((n3 += ((o3 = ((o3 += ((i3 = ((i3 += (r3 & o3 | n3 & ~o3) + t3[5] - 701558691 | 0) << 5 | i3 >>> 27) + r3 | 0) & n3 | r3 & ~n3) + t3[10] + 38016083 | 0) << 9 | o3 >>> 23) + i3 | 0) & r3 | i3 & ~r3) + t3[15] - 660478335 | 0) << 14 | n3 >>> 18) + o3 | 0) & i3 | o3 & ~i3) + t3[4] - 405537848 | 0) << 20 | r3 >>> 12) + n3 | 0, r3 = ((r3 += ((n3 = ((n3 += ((o3 = ((o3 += ((i3 = ((i3 += (r3 & o3 | n3 & ~o3) + t3[9] + 568446438 | 0) << 5 | i3 >>> 27) + r3 | 0) & n3 | r3 & ~n3) + t3[14] - 1019803690 | 0) << 9 | o3 >>> 23) + i3 | 0) & r3 | i3 & ~r3) + t3[3] - 187363961 | 0) << 14 | n3 >>> 18) + o3 | 0) & i3 | o3 & ~i3) + t3[8] + 1163531501 | 0) << 20 | r3 >>> 12) + n3 | 0, r3 = ((r3 += ((n3 = ((n3 += ((o3 = ((o3 += ((i3 = ((i3 += (r3 & o3 | n3 & ~o3) + t3[13] - 1444681467 | 0) << 5 | i3 >>> 27) + r3 | 0) & n3 | r3 & ~n3) + t3[2] - 51403784 | 0) << 9 | o3 >>> 23) + i3 | 0) & r3 | i3 & ~r3) + t3[7] + 1735328473 | 0) << 14 | n3 >>> 18) + o3 | 0) & i3 | o3 & ~i3) + t3[12] - 1926607734 | 0) << 20 | r3 >>> 12) + n3 | 0, r3 = ((r3 += ((n3 = ((n3 += ((o3 = ((o3 += ((i3 = ((i3 += (r3 ^ n3 ^ o3) + t3[5] - 378558 | 0) << 4 | i3 >>> 28) + r3 | 0) ^ r3 ^ n3) + t3[8] - 2022574463 | 0) << 11 | o3 >>> 21) + i3 | 0) ^ i3 ^ r3) + t3[11] + 1839030562 | 0) << 16 | n3 >>> 16) + o3 | 0) ^ o3 ^ i3) + t3[14] - 35309556 | 0) << 23 | r3 >>> 9) + n3 | 0, r3 = ((r3 += ((n3 = ((n3 += ((o3 = ((o3 += ((i3 = ((i3 += (r3 ^ n3 ^ o3) + t3[1] - 1530992060 | 0) << 4 | i3 >>> 28) + r3 | 0) ^ r3 ^ n3) + t3[4] + 1272893353 | 0) << 11 | o3 >>> 21) + i3 | 0) ^ i3 ^ r3) + t3[7] - 155497632 | 0) << 16 | n3 >>> 16) + o3 | 0) ^ o3 ^ i3) + t3[10] - 1094730640 | 0) << 23 | r3 >>> 9) + n3 | 0, r3 = ((r3 += ((n3 = ((n3 += ((o3 = ((o3 += ((i3 = ((i3 += (r3 ^ n3 ^ o3) + t3[13] + 681279174 | 0) << 4 | i3 >>> 28) + r3 | 0) ^ r3 ^ n3) + t3[0] - 358537222 | 0) << 11 | o3 >>> 21) + i3 | 0) ^ i3 ^ r3) + t3[3] - 722521979 | 0) << 16 | n3 >>> 16) + o3 | 0) ^ o3 ^ i3) + t3[6] + 76029189 | 0) << 23 | r3 >>> 9) + n3 | 0, r3 = ((r3 += ((n3 = ((n3 += ((o3 = ((o3 += ((i3 = ((i3 += (r3 ^ n3 ^ o3) + t3[9] - 640364487 | 0) << 4 | i3 >>> 28) + r3 | 0) ^ r3 ^ n3) + t3[12] - 421815835 | 0) << 11 | o3 >>> 21) + i3 | 0) ^ i3 ^ r3) + t3[15] + 530742520 | 0) << 16 | n3 >>> 16) + o3 | 0) ^ o3 ^ i3) + t3[2] - 995338651 | 0) << 23 | r3 >>> 9) + n3 | 0, r3 = ((r3 += ((o3 = ((o3 += (r3 ^ ((i3 = ((i3 += (n3 ^ (r3 | ~o3)) + t3[0] - 198630844 | 0) << 6 | i3 >>> 26) + r3 | 0) | ~n3)) + t3[7] + 1126891415 | 0) << 10 | o3 >>> 22) + i3 | 0) ^ ((n3 = ((n3 += (i3 ^ (o3 | ~r3)) + t3[14] - 1416354905 | 0) << 15 | n3 >>> 17) + o3 | 0) | ~i3)) + t3[5] - 57434055 | 0) << 21 | r3 >>> 11) + n3 | 0, r3 = ((r3 += ((o3 = ((o3 += (r3 ^ ((i3 = ((i3 += (n3 ^ (r3 | ~o3)) + t3[12] + 1700485571 | 0) << 6 | i3 >>> 26) + r3 | 0) | ~n3)) + t3[3] - 1894986606 | 0) << 10 | o3 >>> 22) + i3 | 0) ^ ((n3 = ((n3 += (i3 ^ (o3 | ~r3)) + t3[10] - 1051523 | 0) << 15 | n3 >>> 17) + o3 | 0) | ~i3)) + t3[1] - 2054922799 | 0) << 21 | r3 >>> 11) + n3 | 0, r3 = ((r3 += ((o3 = ((o3 += (r3 ^ ((i3 = ((i3 += (n3 ^ (r3 | ~o3)) + t3[8] + 1873313359 | 0) << 6 | i3 >>> 26) + r3 | 0) | ~n3)) + t3[15] - 30611744 | 0) << 10 | o3 >>> 22) + i3 | 0) ^ ((n3 = ((n3 += (i3 ^ (o3 | ~r3)) + t3[6] - 1560198380 | 0) << 15 | n3 >>> 17) + o3 | 0) | ~i3)) + t3[13] + 1309151649 | 0) << 21 | r3 >>> 11) + n3 | 0, r3 = ((r3 += ((o3 = ((o3 += (r3 ^ ((i3 = ((i3 += (n3 ^ (r3 | ~o3)) + t3[4] - 145523070 | 0) << 6 | i3 >>> 26) + r3 | 0) | ~n3)) + t3[11] - 1120210379 | 0) << 10 | o3 >>> 22) + i3 | 0) ^ ((n3 = ((n3 += (i3 ^ (o3 | ~r3)) + t3[2] + 718787259 | 0) << 15 | n3 >>> 17) + o3 | 0) | ~i3)) + t3[9] - 343485551 | 0) << 21 | r3 >>> 11) + n3 | 0, e4[0] = i3 + e4[0] | 0, e4[1] = r3 + e4[1] | 0, e4[2] = n3 + e4[2] | 0, e4[3] = o3 + e4[3] | 0;
        }, e3.prototype.start = function() {
          return this._dataLength = 0, this._bufferLength = 0, this._state.set(e3.stateIdentity), this;
        }, e3.prototype.appendStr = function(t3) {
          var i3, r3, n3 = this._buffer8, o3 = this._buffer32, s3 = this._bufferLength;
          for (r3 = 0; r3 < t3.length; r3 += 1) {
            if ((i3 = t3.charCodeAt(r3)) < 128)
              n3[s3++] = i3;
            else if (i3 < 2048)
              n3[s3++] = 192 + (i3 >>> 6), n3[s3++] = 63 & i3 | 128;
            else if (i3 < 55296 || i3 > 56319)
              n3[s3++] = 224 + (i3 >>> 12), n3[s3++] = i3 >>> 6 & 63 | 128, n3[s3++] = 63 & i3 | 128;
            else {
              if ((i3 = 1024 * (i3 - 55296) + (t3.charCodeAt(++r3) - 56320) + 65536) > 1114111)
                throw new Error("Unicode standard supports code points up to U+10FFFF");
              n3[s3++] = 240 + (i3 >>> 18), n3[s3++] = i3 >>> 12 & 63 | 128, n3[s3++] = i3 >>> 6 & 63 | 128, n3[s3++] = 63 & i3 | 128;
            }
            s3 >= 64 && (this._dataLength += 64, e3._md5cycle(this._state, o3), s3 -= 64, o3[0] = o3[16]);
          }
          return this._bufferLength = s3, this;
        }, e3.prototype.appendAsciiStr = function(t3) {
          for (var i3, r3 = this._buffer8, n3 = this._buffer32, o3 = this._bufferLength, s3 = 0; ; ) {
            for (i3 = Math.min(t3.length - s3, 64 - o3); i3--; )
              r3[o3++] = t3.charCodeAt(s3++);
            if (o3 < 64)
              break;
            this._dataLength += 64, e3._md5cycle(this._state, n3), o3 = 0;
          }
          return this._bufferLength = o3, this;
        }, e3.prototype.appendByteArray = function(t3) {
          for (var i3, r3 = this._buffer8, n3 = this._buffer32, o3 = this._bufferLength, s3 = 0; ; ) {
            for (i3 = Math.min(t3.length - s3, 64 - o3); i3--; )
              r3[o3++] = t3[s3++];
            if (o3 < 64)
              break;
            this._dataLength += 64, e3._md5cycle(this._state, n3), o3 = 0;
          }
          return this._bufferLength = o3, this;
        }, e3.prototype.getState = function() {
          var e4 = this._state;
          return { buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)), buflen: this._bufferLength, length: this._dataLength, state: [e4[0], e4[1], e4[2], e4[3]] };
        }, e3.prototype.setState = function(e4) {
          var t3, i3 = e4.buffer, r3 = e4.state, n3 = this._state;
          for (this._dataLength = e4.length, this._bufferLength = e4.buflen, n3[0] = r3[0], n3[1] = r3[1], n3[2] = r3[2], n3[3] = r3[3], t3 = 0; t3 < i3.length; t3 += 1)
            this._buffer8[t3] = i3.charCodeAt(t3);
        }, e3.prototype.end = function(t3) {
          void 0 === t3 && (t3 = false);
          var i3 = this._bufferLength, r3 = this._buffer8, n3 = this._buffer32, o3 = 1 + (i3 >> 2);
          this._dataLength += i3;
          var s3 = 8 * this._dataLength;
          if (r3[i3] = 128, r3[i3 + 1] = r3[i3 + 2] = r3[i3 + 3] = 0, n3.set(e3.buffer32Identity.subarray(o3), o3), i3 > 55 && (e3._md5cycle(this._state, n3), n3.set(e3.buffer32Identity)), s3 <= 4294967295)
            n3[14] = s3;
          else {
            var a3 = s3.toString(16).match(/(.*?)(.{0,8})$/);
            if (null === a3)
              return;
            var c3 = parseInt(a3[2], 16), d3 = parseInt(a3[1], 16) || 0;
            n3[14] = c3, n3[15] = d3;
          }
          return e3._md5cycle(this._state, n3), t3 ? this._state : e3._hex(this._state);
        }, e3.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]), e3.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e3.hexChars = "0123456789abcdef", e3.hexOut = [], e3.onePassHasher = new e3(), e3;
      }(), g2 = l2.Md5 = p2;
      if ("5d41402abc4b2a76b9719d911017c592" !== p2.hashStr("hello"))
        throw new Error("Md5 self test failed.");
      const E2 = async (e3, t3, i3) => await (async (e4, t4, i4) => {
        const r3 = "" + t4 + i4, n3 = new Uint8Array(g2.hashStr(r3, true).buffer).slice(0, 16), o3 = n3.slice(0, 12), s3 = await window.crypto.subtle.importKey("raw", n3, "AES-GCM", true, ["encrypt"]);
        return new Uint8Array(await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: o3 }, s3, e4));
      })(e3.buffer, t3, i3);
      function f2(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      const m2 = /* @__PURE__ */ new Map([["moderation", 1], ["supervise", 2]]);
      class I2 extends MD {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e3) {
          if (this._connectionState === e3)
            return;
          const t3 = this._connectionState;
          this._connectionState = e3, this.emit(SB.CONNECTION_STATE_CHANGE, t3, e3);
        }
        get inspectType() {
          return this._inspectType;
        }
        set inspectType(e3) {
          var t3;
          this._inspectMode = cc(t3 = e3.map((e4) => m2.get(e4) || 0)).call(t3, (e4, t4) => e4 + t4), this._inspectType = e3;
        }
        get quality() {
          return this._quality;
        }
        set quality(e3) {
          this._quality = e3 > 1 ? 1 : e3 < 0.1 ? 0.1 : e3, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout(() => {
            this.quality = this._quality / this.qualityRatio;
          }, 6e4));
        }
        constructor(e3) {
          super(), MN(this, "name", "AgoraRTCVideoContentInspect"), MN(this, "_connectionState", _B.CONNECTING), MN(this, "_innerConnectionState", void 0), MN(this, "sequence", 0), MN(this, "inspectStartTime", void 0), MN(this, "workerManagerConnection", void 0), MN(this, "workerConnection", void 0), MN(this, "workerMessageLengthLimit", void 0), MN(this, "inspectIntervalMinimum", void 0), MN(this, "qualityRatio", void 0), MN(this, "_connectInfo", void 0), MN(this, "_cancelTokenSource", kD.CancelToken.source()), MN(this, "_retryConfig", void 0), MN(this, "wmSequence", 0), MN(this, "inspectInterval", void 0), MN(this, "inspectTimer", null), MN(this, "ossFilePrefix", void 0), MN(this, "extraInfo", void 0), MN(this, "_inspectType", void 0), MN(this, "_inspectMode", void 0), MN(this, "_quality", 1), MN(this, "qualityTimer", null), MN(this, "_inspectId", void 0), MN(this, "_needWorkUrlOnly", false), MN(this, "inspectImage", () => {
            if (this.connectionState !== _B.CONNECTED)
              throw new QD(xD.OPERATION_ABORTED, "content inspect service connection status is ".concat(this.connectionState));
            this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval(() => {
              if (this.connectionState !== _B.CONNECTED)
                return JD.debug("[".concat(this._inspectId, "] Inspect State is not connected , "), this.connectionState), void hP("debug", this, "Inspect State is not connected , ".concat(this.connectionState));
              this.requestToInspectImage();
            }, this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage();
          }), this._inspectId = mK(5, "inspect-"), this.workerMessageLengthLimit = LP("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"), this.inspectIntervalMinimum = LP("VIDEO_INSPECT_INTERVAL_MINIMUM"), this.qualityRatio = LP("VIDEO_INSPECT_QUALITY_RATIO"), this.inspectInterval = e3.interval, this.ossFilePrefix = e3.ossFilePrefix, this.extraInfo = e3.extraInfo, this.inspectType = e3.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new qJ("worker-manager-" + this._inspectId, FD), this.on(SB.STATE_CHANGE, (e4, t3) => {
            this._innerConnectionState = e4, JD.debug("[".concat(this._inspectId, "] Inspect operation :").concat(CB[e4], " ").concat(t3 || "")), pP("debug", ["Inspect", this._inspectId], SB.STATE_CHANGE, "".concat(CB[e4], " ").concat(t3 || ""));
          }), this.handleWorkerManagerEvents(), this.workerConnection = new qJ("worker-" + this._inspectId, FD), this.handleWorkerEvents();
        }
        async init(e3, t3) {
          this.emit(SB.STATE_CHANGE, CB.CONNECT_AP), this._connectInfo = e3;
          const i3 = this._cancelTokenSource.token;
          return this._retryConfig = t3, new l_((r3, n3) => {
            this.on(SB.CONNECTION_STATE_CHANGE, (e4, t4) => {
              t4 === _B.CONNECTED && r3();
            }), this.requestAP(e3, i3, t3).then((e4) => {
              this.connectWorkerManager(e4);
            }).catch((e4) => {
              n3(e4);
            });
          });
        }
        async requestAP(e3, t3, i3) {
          const r3 = LP("WEBCS_DOMAIN").map((e4) => "https://".concat(e4, "/api/v1")), n3 = await function(e4, t4, i4, r4) {
            let { appId: n4, areaCode: o4, cname: s3, sid: a3, token: c3, uid: d3 } = t4;
            wq++;
            const u3 = "image_moderation_api", h3 = { service_name: u3, json_body: JSON.stringify({ appId: n4, areaCode: o4, cname: s3, command: "allocateEdge", requestId: wq, seq: wq, sid: a3, token: c3, ts: Date.now(), uid: d3 + "" }) };
            let A3, l3, p3 = e4[0];
            return jD(async () => {
              A3 = Date.now();
              const e5 = await ej(p3, { data: h3, cancelToken: i4, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
              if (l3 = Date.now() - A3, 0 !== e5.code) {
                const t6 = new QD(xD.UNEXPECTED_RESPONSE, "image inspect ap error, code" + e5.code, { retry: true, responseTime: l3 });
                throw JD.error(t6.toString()), gP("error", ["AjaxAPI"], "requestImageInspectAP", void 0, t6.toString()), t6;
              }
              const t5 = JSON.parse(e5.json_body);
              if (200 !== t5.code) {
                const e6 = new QD(xD.UNEXPECTED_RESPONSE, "image inspect ap error, code: ".concat(t5.code, ", reason: ").concat(t5.reason), { code: t5.code, responseTime: l3 });
                throw JD.error(e6.toString()), gP("error", ["AjaxAPI"], "requestImageInspectAP", void 0, e6.toString()), e6;
              }
              if (!t5.servers || !Array.isArray(t5.servers) || 0 === t5.servers.length) {
                const e6 = new QD(xD.UNEXPECTED_RESPONSE, "image inspect ap empty server", { code: t5.code, responseTime: l3 });
                throw JD.error(e6.toString()), gP("error", ["AjaxAPI"], "requestImageInspectAP", void 0, e6.toString()), e6;
              }
              const r5 = LP("VIDEO_INSPECT_WORKER_MANAGER_HOST"), n5 = LP("VIDEO_INSPECT_WORKER_MANAGER_PORT");
              return { addressList: t5.servers.map((e6) => {
                let { address: t6, wss: i5 } = e6;
                if (t6 && i5)
                  return "wss://".concat(t6.replace(/\./g, "-"), ".").concat(r5, ":").concat(n5 || i5);
              }).filter((e6) => !!e6), workerToken: t5.workerToken, vid: t5.vid, responseTime: l3 };
            }, (t5, i5) => (pj.apworkerEvent(a3, { success: true, sc: 200, serviceName: u3, responseDetail: JSON.stringify(t5.addressList), firstSuccess: 0 === i5, responseTime: l3, serverIp: e4[i5 % e4.length] }), false), (t5, i5) => (pj.apworkerEvent(a3, { success: false, sc: t5.data && t5.data.code || 200, serviceName: u3, responseTime: l3, serverIp: e4[i5 % e4.length] }), !!(t5.code !== xD.OPERATION_ABORTED && t5.code !== xD.UNEXPECTED_RESPONSE || t5.data && t5.data.retry) && (p3 = e4[(i5 + 1) % e4.length], true)), r4);
          }(r3, e3, t3, i3);
          this.emit(SB.STATE_CHANGE, CB.AP_CONNECTED);
          const { addressList: o3 } = n3;
          return this.wmSequence++, o3;
        }
        async connectWorkerManager(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          this._needWorkUrlOnly = t3, this.emit(SB.STATE_CHANGE, CB.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e3, 1e4);
        }
        async connectWorker(e3) {
          await this.workerConnection.init([e3]);
        }
        handleWorkerManagerEvents() {
          this.workerManagerConnection.on(Lk.CONNECTED, async () => {
            this.emit(SB.STATE_CHANGE, CB.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({ appId: this._connectInfo.appId, cname: this._connectInfo.cname, uid: this._connectInfo.uid + "", sdkVersion: "4.15.0", sid: this._connectInfo.sid, seq: this.wmSequence, ts: Number(Date.now()), requestId: Math.floor(1e12 * Math.random()), allocate: true, clientRequest: { command: "join" } }, true);
          }), this.workerManagerConnection.on(Lk.CLOSED, () => {
            this._innerConnectionState < CB.GET_WORKER_MANAGER_RESPONSE && (JD.debug("[".concat(this._inspectId, "] Inspect worker manager is closed before connecting worker")), pP("debug", ["Inspect", this._inspectId], "workerManagerConnectionClosed"));
          }), this.workerManagerConnection.on(Lk.FAILED, () => {
            this._innerConnectionState < CB.GET_WORKER_MANAGER_RESPONSE && (JD.debug("[".concat(this._inspectId, "] Connecting inspect worker manager is failed before connecting worker")), pP("debug", ["Inspect", this._inspectId], "workerManagerConnectionFailed"));
          }), this.workerManagerConnection.on(Lk.RECONNECTING, () => {
            this._innerConnectionState < CB.GET_WORKER_MANAGER_RESPONSE && (JD.debug("[".concat(this._inspectId, "] Inspect worker manager is reconnecting before connecting worker")), pP("debug", ["Inspect", this._inspectId], "workerManagerConnectionReconnecting"));
          }), this.workerManagerConnection.on(Lk.ON_MESSAGE, async (e3) => {
            this.emit(SB.STATE_CHANGE, CB.GET_WORKER_MANAGER_RESPONSE);
            const t3 = this.workerManagerConnection.url;
            this.workerManagerConnection.close();
            const i3 = JSON.parse(e3.data);
            if (200 !== i3.code)
              throw JD.error("[".concat(this._inspectId, "] Unexpected code ").concat(i3.code, " from worker manager")), hP("error", this, "Unexpected code ".concat(i3.code, " from worker manager")), new QD(xD.UNEXPECTED_RESPONSE, "response code of worker is unexpected", i3);
            if (!(i3.serverResponse && i3.serverResponse.portWss && t3))
              throw JD.error("[".concat(this._inspectId, "] Unexpected content from worker manager : ").concat(JSON.stringify(i3))), hP("error", this, "Unexpected content from worker manager : " + JSON.stringify(i3)), new QD(xD.UNEXPECTED_RESPONSE, "response content of worker is unexpected", i3);
            {
              const e4 = LP("VIDEO_INSPECT_WORKER_PORT") || i3.serverResponse.portWss, r3 = t3.replace(/:\d+\/?$/, ":".concat(e4));
              this.emit(SB.STATE_CHANGE, CB.CONNECT_WORKER, r3), this._needWorkUrlOnly ? this.emit(SB.REQUEST_NEW_WORKER_URL, r3) : await this.connectWorker(r3);
            }
          }), this.workerManagerConnection.on(Lk.WILL_RECONNECT, (e3, t3) => {
            t3(e3);
          }), this.workerManagerConnection.on(Lk.REQUEST_NEW_URLS, (e3, t3) => {
            this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e3).catch(t3);
          });
        }
        handleWorkerEvents() {
          this.workerConnection.on(Lk.CONNECTED, async () => {
            this.emit(SB.STATE_CHANGE, CB.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = _B.CONNECTED;
          }), this.workerConnection.on(Lk.ON_MESSAGE, async (e3) => {
            if (e3.data instanceof ArrayBuffer) {
              const i3 = V0(new Uint8Array(e3.data));
              if (LP("SHOW_VIDEO_INSPECT_WORKER_MESSAGE") && JD.debug("[".concat(this._inspectId, "] Response message for worker of inspect content "), JSON.stringify(i3)), 200 === i3.code) {
                if (Array.isArray(this.inspectType) && 1 === this.inspectType.length && "supervise" === this.inspectType[0])
                  return void this.emit(SB.INSPECT_RESULT, void 0, void 0);
                if (i3.data && i3.data.scorePorn && i3.data.scoreSexy && i3.data.scoreNeutral) {
                  var t3;
                  const e4 = { porn: i3.data.scorePorn, sexy: i3.data.scoreSexy, neutral: i3.data.scoreNeutral }, r3 = cc(t3 = Object.keys(e4)).call(t3, (t4, i4) => e4[t4] > e4[i4] ? t4 : i4, "porn"), n3 = Object.keys(e4).find((e5) => e5 === r3);
                  this.emit(SB.INSPECT_RESULT, n3);
                } else
                  this.emit(SB.INSPECT_RESULT, void 0, new QD(xD.UNEXPECTED_RESPONSE, i3.code + "", "There is an unexpected data on message"));
              } else
                this.emit(SB.INSPECT_RESULT, void 0, new QD(xD.UNEXPECTED_RESPONSE, i3.code + "", i3.msg));
            } else
              JD.error("[".concat(this._inspectId, "] Unexpected message type from worker")), hP("error", this, "Unexpected message type from worker"), this.emit(SB.INSPECT_RESULT, void 0, new QD(xD.UNEXPECTED_RESPONSE, "invalid worker message type"));
          }), this.workerConnection.on(Lk.CLOSED, () => {
            this.connectionState = _B.CLOSED;
          }), this.workerConnection.on(Lk.FAILED, () => {
            this.connectionState = _B.CLOSED;
          }), this.workerConnection.on(Lk.RECONNECTING, () => {
            this.connectionState = this.connectionState === _B.CONNECTED ? _B.RECONNECTING : _B.CONNECTING;
          }), this.workerConnection.on(Lk.WILL_RECONNECT, (e3, t3) => {
            "recover" === e3 && t3(e3), t3("tryNext");
          }), this.workerConnection.on(Lk.REQUEST_NEW_URLS, (e3, t3) => {
            this.workerManagerConnection.close(), this.once(SB.REQUEST_NEW_WORKER_URL, (t4) => {
              e3([t4]);
            }), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then((e4) => {
              this.connectWorkerManager(e4, true);
            }).catch((e4) => {
              t3(e4);
            });
          });
        }
        static intToLong(e3) {
          return { low: e3 |= 0, high: e3 >> 31, unsigned: e3 >= 0 };
        }
        async requestToInspectImage() {
          this.sequence++;
          const e3 = RK(this, SB.CLIENT_LOCAL_VIDEO_TRACK), t3 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
          if (e3) {
            if (!e3.isPlaying)
              return void this.emit(SB.INSPECT_RESULT, void 0, new QD(xD.INVALID_OPERATION, "Only the track being played can be inspected"));
            const i3 = await this.generateRequestData(e3, t3);
            this.workerConnection.sendMessage(i3, true, true);
          } else
            this.emit(SB.INSPECT_RESULT, void 0, new QD(xD.INVALID_OPERATION, "Only the track being published can be inspected"));
        }
        async generateRequestData(e3, t3) {
          let { appId: i3, cname: r3, cid: n3, vid: o3, sid: s3, uid: a3 } = t3;
          const c3 = Date.now(), d3 = await e3.getCurrentFrameImage("image/jpeg", this.quality), u3 = await E2(d3, i3, r3), h3 = this.sequence + "-" + n3 + "-" + a3 + "-" + c3 + "-" + mK(12, ""), A3 = { appId: i3, cid: n3, cname: r3, deviceId: "", elapse: I2.intToLong(Number(c3 - this.inspectStartTime)), fileSize: u3.byteLength, jpgEncryption: 2, height: d3.height, width: d3.width, jpg: u3, networkType: 6, osType: 7, requestId: h3, sdkVersion: "4.15.0", sequence: this.sequence, sid: s3, timestamp: I2.intToLong(c3), uid: a3, vid: o3, service: this._inspectMode, callbackData: this.extraInfo, ossFilePrefix: this.ossFilePrefix };
          void 0 === this.extraInfo && delete A3.callbackData, void 0 === this.ossFilePrefix && delete A3.ossFilePrefix;
          const l3 = F0(A3);
          if (l3.byteLength < this.workerMessageLengthLimit) {
            if (LP("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")) {
              const e4 = function(e5) {
                for (var t4 = 1; t4 < arguments.length; t4++) {
                  var i4 = null != arguments[t4] ? arguments[t4] : {};
                  t4 % 2 ? f2(Object(i4), true).forEach(function(t5) {
                    MN(e5, t5, i4[t5]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(i4)) : f2(Object(i4)).forEach(function(t5) {
                    Object.defineProperty(e5, t5, Object.getOwnPropertyDescriptor(i4, t5));
                  });
                }
                return e5;
              }({}, A3);
              delete e4.jpg, JD.debug("[".concat(this._inspectId, "] Request message for worker of inspect content "), JSON.stringify(e4)), hP("debug", this, "Request message for worker of inspect content ".concat(JSON.stringify(e4)));
            }
            return l3;
          }
          {
            const t4 = this.quality * this.qualityRatio;
            return this.quality = t4, await this.generateRequestData(e3, { appId: i3, cname: r3, cid: n3, vid: o3, sid: s3, uid: a3 });
          }
        }
        close() {
          this._cancelTokenSource.cancel(), this._cancelTokenSource = kD.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = _B.CLOSED, this.emit(SB.STATE_CHANGE, CB.CLOSED);
        }
      }
      var _2, C2, S2, v2, T2, R2, y2, w2, b2, N2, O2, D2, P2, L2;
      function k2(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function B2(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? k2(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : k2(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      let M2 = (_2 = mP("AgoraRTCClient", "store.clientId"), C2 = Aj({ report: pj }), S2 = Aj(), v2 = Aj(), T2 = Aj({ report: pj }), R2 = Aj({ report: pj }), y2 = lj(), w2 = lj({ report: pj }), b2 = lj({ report: pj }), N2 = lj({ report: pj }), O2 = Aj({ reportResult: true, report: pj }), D2 = lj(), _2((VV((L2 = class extends MD {
        get connectionState() {
          return this._gateway.state;
        }
        get remoteUsers() {
          return this._users;
        }
        get localTracks() {
          return this._p2pChannel.getAllTracks(true);
        }
        get uid() {
          return this._uid;
        }
        get channelName() {
          return this._channelName;
        }
        get isStringUID() {
          return !!this._joinInfo && !!this._joinInfo.stringUid;
        }
        constructor(e3) {
          let t3;
          if (super(), MN(this, "store", void 0), MN(this, "_uid", void 0), MN(this, "_channelName", void 0), MN(this, "_uintUid", void 0), MN(this, "_users", []), MN(this, "_codec", void 0), MN(this, "_mode", void 0), MN(this, "_config", void 0), MN(this, "_clientId", void 0), MN(this, "_appId", void 0), MN(this, "_sessionId", null), MN(this, "_key", void 0), MN(this, "_joinInfo", void 0), MN(this, "_gateway", void 0), MN(this, "_statsCollector", void 0), MN(this, "_configDistribute", void 0), MN(this, "_leaveMutex", new fj("client-leave")), MN(this, "_publishMutex", new fj("client-publish")), MN(this, "_renewTokenMutex", new fj("client-renewtoken")), MN(this, "_subscribeMutex", new fj("client-subscribe")), MN(this, "_encryptionMode", "none"), MN(this, "_encryptionSecret", null), MN(this, "_encryptionSalt", null), MN(this, "_proxyServer", void 0), MN(this, "_turnServer", { servers: [], mode: "auto" }), MN(this, "_cloudProxyServerMode", "disabled"), MN(this, "_isDualStreamEnabled", false), MN(this, "_defaultStreamFallbackType", void 0), MN(this, "_lowStreamParameter", void 0), MN(this, "_streamFallbackTypeCacheMap", /* @__PURE__ */ new Map()), MN(this, "_remoteStreamTypeCacheMap", /* @__PURE__ */ new Map()), MN(this, "_axiosCancelSource", kD.CancelToken.source()), MN(this, "_audioVolumeIndicationInterval", void 0), MN(this, "_networkQualityInterval", void 0), MN(this, "_userOfflineTimeout", void 0), MN(this, "_streamRemovedTimeout", void 0), MN(this, "_injectStreamingClient", void 0), MN(this, "_liveTranscodeStreamingClient", void 0), MN(this, "_liveRawStreamingClient", void 0), MN(this, "_channelMediaRelayClient", void 0), MN(this, "_networkQualitySensitivity", "normal"), MN(this, "_p2pChannel", void 0), MN(this, "_useLocalAccessPoint", false), MN(this, "_setLocalAPVersion", void 0), MN(this, "_joinAndNotLeaveYet", false), MN(this, "_numberOfJoinCount", 0), MN(this, "_remoteDefaultVideoStreamType", void 0), MN(this, "_inspect", void 0), MN(this, "_license", void 0), MN(this, "_handleLocalTrackEnable", (e4, t4, i3) => {
            this.publish(e4, false).then(t4).catch(i3);
          }), MN(this, "_handleLocalTrackDisable", (e4, t4, i3) => {
            this.unpublish(e4).then(t4).catch(i3);
          }), MN(this, "_handleUserOnline", (e4) => {
            this.isStringUID && "string" != typeof e4.uid && (JD.error("[".concat(this._clientId, "] StringUID is Mixed with UintUID")), hP("error", this, "StringUID is Mixed with UintUID"));
            const t4 = this._users.find((t5) => t5.uid === e4.uid);
            if (t4)
              t4._trust_in_room_ = true;
            else {
              const t5 = new lz(e4.uid, e4.uint_id || e4.uid);
              this._users.push(t5), JD.debug("[".concat(this._clientId, "] user online"), e4.uid), lP("info", this, "user-joined", { uid: e4.uid }), this.emit(pk.USER_JOINED, t5);
            }
          }), MN(this, "_handleUserOffline", (e4) => {
            const t4 = this._users.find((t5) => t5.uid === e4.uid);
            t4 && (this._handleRemoveStream(e4), wK(this._users, t4), this._remoteStreamTypeCacheMap.delete(t4.uid), this._streamFallbackTypeCacheMap.delete(t4.uid), JD.debug("[".concat(this._clientId, "] user offline"), e4.uid, "reason:", e4.reason), lP("info", this, "user-left", { reason: e4.reason, uid: e4.uid }), this.emit(pk.USER_LEAVED, t4, e4.reason));
          }), MN(this, "_handleAddAudioOrVideoStream", (e4, t4, i3, r3, n3, o3, s3) => {
            const a3 = this._users.find((e5) => e5.uid === t4);
            if (!a3)
              return JD.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)")), void AP("error", ["AgoraRTCGateway", this._clientId], "add_".concat(e4, "_stream"), "can not find target user!");
            JD.debug("[".concat(this._clientId, "] stream added with uid ").concat(t4, ", type ").concat(e4)), AP("debug", ["AgoraRTCGateway", this._clientId], "add_".concat(e4, "_stream"), { uid: t4, mediaType: e4 }), this.store.subscribe(a3.uid, e4, void 0, void 0, void 0, Date.now());
            const c3 = "audio" === e4 ? a3.hasAudio : a3.hasVideo;
            a3._uintid || (a3._uintid = n3 || t4), "audio" === e4 ? a3._trust_audio_stream_added_state_ = true : a3._trust_video_stream_added_state_ = true, "audio" === e4 ? (a3._audio_added_ = true, void 0 !== i3 && (a3._audioSSRC = i3), void 0 !== r3 && (a3._cname = r3), o3 && (a3._audioOrtc = o3)) : (a3._video_added_ = true, void 0 !== i3 && (a3._videoSSRC = i3), void 0 !== r3 && (a3._cname = r3), void 0 !== s3 && (a3._rtxSsrcId = s3), o3 && (a3._videoOrtc = o3)), ("audio" === e4 ? a3.hasAudio : a3.hasVideo) && !c3 && (JD.info("[".concat(this._clientId, "] remote user ").concat(a3.uid, " published ").concat(e4)), hP("info", this, "remote user ".concat(a3.uid, " published ").concat(e4)), lP("info", this, "user-published", { uid: a3.uid, mediaType: e4 }), this.emit(pk.USER_PUBLISHED, a3, e4)), "video" === e4 ? pj.onGatewayStream(this._sessionId, $L.ON_ADD_VIDEO_STREAM, ek.ON_ADD_VIDEO_STREAM, { peer: n3 || t4 }) : pj.onGatewayStream(this._sessionId, $L.ON_ADD_AUDIO_STREAM, ek.ON_ADD_AUDIO_STREAM, { peer: n3 || t4 }), this._p2pChannel.remoteMediaSsrcChanged(a3, e4, i3).then((t5) => {
              if (t5)
                return JD.debug("[".concat(this._clientId, "] resubscribe ").concat(e4, " for user ").concat(a3.uid, " after rejoin because SSRC id changed.")), this._p2pChannel.unsubscribe(a3, e4, true).then(() => this._subscribe(a3, e4, true).catch((e5) => {
                  JD.error("[".concat(this._clientId, "] resubscribe error"), e5.toString()), hP("error", this, "resubscribe error: ".concat(e5.toString()));
                }));
            }), this._p2pChannel.hasPendingRemoteMedia(a3, e4) && (JD.debug("[".concat(this._clientId, "] resubscribe ").concat(e4, " for user ").concat(a3.uid, " after reconnect.")), this._subscribe(a3, e4, true).catch((e5) => {
              JD.error("[".concat(this._clientId, "] resubscribe error"), e5.toString()), hP("error", this, "resubscribe error: ".concat(e5.toString()));
            }));
          }), MN(this, "_handleRemoveStream", (e4) => {
            const t4 = this._users.find((t5) => t5.uid === e4.uid);
            if (!t4)
              return JD.warning("[".concat(this._clientId, "] can not find target user!(on_remove_stream)")), void AP("warning", ["AgoraRTCGateway", this._clientId], "remove_stream", { uid: e4.uid, info: "can not find target user!" });
            JD.debug("[".concat(this._clientId, "] stream removed with uid ").concat(e4.uid)), AP("debug", ["AgoraRTCGateway", this._clientId], "remove_stream", { uid: e4.uid });
            let i3 = () => {
            };
            t4.hasAudio && t4.hasVideo ? i3 = () => {
              JD.info("[".concat(this._clientId, "] remote user ").concat(t4.uid, " unpublished audio track")), lP("info", this, "user-unpublished", { uid: t4.uid, mediaType: "audio" }), this.emit(pk.USER_UNPUBLISHED, t4, "audio"), JD.info("[".concat(this._clientId, "] remote user ").concat(t4.uid, " unpublished video track")), lP("info", this, "user-unpublished", { uid: t4.uid, mediaType: "video" }), this.emit(pk.USER_UNPUBLISHED, t4, "video");
            } : t4.hasVideo ? i3 = () => {
              JD.info("[".concat(this._clientId, "] remote user ").concat(t4.uid, " unpublished video track")), lP("info", this, "user-unpublished", { uid: t4.uid, mediaType: "video" }), this.emit(pk.USER_UNPUBLISHED, t4, "video");
            } : t4.hasAudio && (i3 = () => {
              JD.info("[".concat(this._clientId, "] remote user ").concat(t4.uid, " unpublished audio track")), lP("info", this, "user-unpublished", { uid: t4.uid, mediaType: "audio" }), this.emit(pk.USER_UNPUBLISHED, t4, "audio");
            }), t4._trust_audio_stream_added_state_ = true, t4._trust_video_stream_added_state_ = true, t4._audio_added_ = false, t4._video_added_ = false, this._p2pChannel.unsubscribe(t4).then((e5) => {
              if (e5)
                return this._gateway.unsubscribe(e5, t4.uid);
            }), t4._audioSSRC = void 0, t4._videoSSRC = void 0, t4._audioOrtc = void 0, t4._videoOrtc = void 0, t4._rtxSsrcId = void 0, pj.onGatewayStream(this._sessionId, $L.ON_REMOVE_STREAM, ek.ON_REMOVE_STREAM, { peer: e4.uint_id || e4.uid }), i3();
          }), MN(this, "_handleSetStreamLocalEnable", (e4, t4, i3) => {
            const r3 = this._users.find((e5) => e5.uid === t4);
            if (!r3)
              return JD.error("[".concat(this._clientId, "] can not find target user!(disable_local)")), void AP("error", this, "disable_local_video", "can not find target user!(disable_local)");
            JD.debug("[".concat(this._clientId, "] local ").concat(e4, " ").concat(i3 ? "enabled" : "disabled", " with uid ").concat(t4)), AP("debug", this, "disable_local_video", "local ".concat(e4, " ").concat(i3 ? "enabled" : "disabled", " with uid ").concat(t4));
            const n3 = "audio" === e4 ? r3.hasAudio : r3.hasVideo;
            if ("audio" === e4) {
              r3._trust_audio_enabled_state_ = true;
              const e5 = r3._audio_enabled_;
              if (r3._audio_enabled_ = i3, r3._audio_enabled_ === e5)
                return;
              {
                const e6 = r3._audio_enabled_ ? "enable-local-audio" : "disable-local-audio";
                JD.debug("[".concat(this._clientId, "] user-info-updated, uid: ").concat(t4, ", msg: ").concat(e6)), fP("debug", this, "user-info-updated", { uid: t4, msg: e6 }), this.emit(pk.USER_INFO_UPDATED, t4, e6);
              }
            } else {
              r3._trust_video_enabled_state_ = true;
              const e5 = r3._video_enabled_;
              if (r3._video_enabled_ = i3, r3._video_enabled_ === e5)
                return;
              {
                const e6 = r3._video_enabled_ ? "enable-local-video" : "disable-local-video";
                JD.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(t4, ", msg: ").concat(e6)), fP("debug", this, "user-info-updated", { uid: t4, msg: e6 }), this.emit(pk.USER_INFO_UPDATED, t4, e6);
              }
            }
            const o3 = "audio" === e4 ? r3.hasAudio : r3.hasVideo;
            return n3 !== o3 ? !n3 && o3 ? (JD.info("[".concat(this._clientId, "] remote user ").concat(t4, " published ").concat(e4)), lP("info", this, "user-published", { uid: t4, mediaType: e4 }), void this.emit(pk.USER_PUBLISHED, r3, e4)) : ("video" === e4 && r3._videoTrack && r3._videoTrack._destroy(), "audio" === e4 && r3._audioTrack, this._p2pChannel.muteRemote(r3, e4), JD.info("[".concat(this._clientId, "] remote user ").concat(t4, " unpublished ").concat(e4)), lP("info", this, "user-unpublished", { uid: t4, mediaType: e4 }), void this.emit(pk.USER_UNPUBLISHED, r3, e4)) : void 0;
          }), MN(this, "_handleMuteStream", (e4, t4, i3) => {
            JD.debug("[".concat(this._clientId, "] receive mute message"), e4, t4, i3), AP("debug", this, "mute_".concat(t4), i3);
            const r3 = this._users.find((t5) => t5.uid === e4);
            if (!r3)
              return JD.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(e4)), void AP("warning", this, "mute_".concat(t4), "can not find remote user, ignore mute event, uid: ".concat(e4));
            const n3 = "audio" === t4 ? r3.hasAudio : r3.hasVideo;
            if ("audio" === t4) {
              r3._trust_audio_mute_state_ = true;
              const t5 = r3._audio_muted_;
              if (r3._audio_muted_ = i3, r3._audio_muted_ === t5)
                return;
              {
                const t6 = r3._audio_muted_ ? "mute-audio" : "unmute-audio";
                JD.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e4, ", msg: ").concat(t6)), fP("debug", this, "user-info-updated", { uid: e4, msg: t6 }), this.emit(pk.USER_INFO_UPDATED, e4, t6);
              }
            } else {
              r3._trust_video_mute_state_ = true;
              const t5 = r3._video_muted_;
              if (r3._video_muted_ = i3, r3._video_muted_ === t5)
                return;
              {
                const t6 = r3._video_muted_ ? "mute-video" : "unmute-video";
                JD.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e4, ", msg: ").concat(t6)), fP("debug", this, "user-info-updated", { uid: e4, msg: t6 }), this.emit(pk.USER_INFO_UPDATED, e4, t6);
              }
            }
            const o3 = "audio" === t4 ? r3.hasAudio : r3.hasVideo;
            if (n3 !== o3) {
              if (!n3 && o3) {
                return ("audio" === t4 ? r3._audioSSRC : r3._videoSSRC) ? (JD.info("[".concat(this._clientId, "] remote user ").concat(e4, " published ").concat(t4)), lP("info", this, "user-published", { uid: r3.uid, mediaType: t4 }), void this.emit(pk.USER_PUBLISHED, r3, t4)) : void JD.warning("[".concat(this._clientId, "] remote user ").concat(e4, " receive ").concat(t4, " unmute message  before add stream message, ").concat(t4, " SSRC doesn't exist yet."));
              }
              "video" === t4 && r3._videoTrack && r3._videoTrack._destroy(), "audio" === t4 && r3._audioTrack, this._p2pChannel.muteRemote(r3, t4), JD.info("[".concat(this._clientId, "] remote user ").concat(e4, " unpublished ").concat(t4)), lP("info", this, "user-unpublished", { uid: e4, mediaType: t4 }), this.emit(pk.USER_UNPUBLISHED, r3, t4);
            }
          }), MN(this, "_handleP2PLost", async (e4) => {
            if (JD.debug("[".concat(this._clientId, "] receive p2p lost"), e4), AP("debug", this, "p2p_lost", e4), parseInt(e4.p2pid, 10) !== this.store.p2pId)
              return JD.warning("P2PLost stream not found", e4), void AP("warning", this, "p2p_lost", "P2PLost stream not found, ".concat(e4));
            await this._p2pChannel.requestReconnect();
          }), MN(this, "_handleTokenWillExpire", () => {
            JD.debug("[".concat(this._clientId, "] received message onTokenPrivilegeWillExpire")), AP("debug", this, "token_privilege_will_expire"), this.emit(pk.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);
          }), MN(this, "_handleBeforeUnload", (e4) => {
            "beforeunload" === e4.type && void 0 !== e4.returnValue && "" !== e4.returnValue || (this.leave(), JD.info("[".concat(this._clientId, "] auto leave onbeforeunload or pagehide")), pP("info", ["window", this.store.clientId], pN() ? "beforeunload" : "pagehide"));
          }), MN(this, "_handleUpdateNetworkQuality", () => {
            if ("normal" === this._networkQualitySensitivity)
              return;
            if (navigator && void 0 !== navigator.onLine && !navigator.onLine)
              return void this.emit(pk.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 });
            const e4 = { downlinkNetworkQuality: 0, uplinkNetworkQuality: 0 };
            e4.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e4.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.emit(pk.NETWORK_QUALITY, e4);
          }), this._codec = e3.codec, this._mode = e3.mode, this._clientId = mK(5, "client-"), this.store = new M0(e3.codec, e3.audioCodec, e3.mode, this._clientId), this.store.clientCreated(), e3.proxyServer && this.setProxyServer(e3.proxyServer, true), e3.turnServer && this.setTurnServer(e3.turnServer, true), JD.info("[".concat(this._clientId, "] Initializing AgoraRTC client v").concat(CP, " build: ").concat(_P, ", mode: ").concat(this._mode, ", codec: ").concat(this._codec)), fP("info", this, "constructor", { version: CP, build: _P, mode: this._mode, codec: this._codec }), e3.clientRoleOptions)
            try {
              wk(e3.clientRoleOptions), t3 = Object.assign({}, e3.clientRoleOptions);
            } catch (e4) {
              JD.warning("[".concat(this._clientId, "] ").concat(e4.toString())), hP("warning", this, e4.toString());
            }
          this._statsCollector = new eK(this.store), this._statsCollector.onStatsException = (e4, t4, i3) => {
            JD.debug("[".concat(this._clientId, "] receive exception msg, code: ").concat(e4, ", msg: ").concat(t4, ", uid: ").concat(i3)), lP("debug", this, pk.EXCEPTION, { code: e4, message: t4, uid: i3 }), this.emit(pk.EXCEPTION, { code: e4, msg: t4, uid: i3 });
          }, this._statsCollector.onUploadPublishDuration = (e4, t4, i3, r3) => {
            const n3 = this._users.find((t5) => t5.uid === e4);
            n3 && pj.peerPublishStatus(this._sessionId, { subscribeElapse: r3, audioPublishDuration: t4, videoPublishDuration: i3, peer: n3._uintid });
          }, this._gateway = new pq(this.store, { clientId: this._clientId, mode: this._mode, codec: this._codec, websocketRetryConfig: e3.websocketRetryConfig || FD, httpRetryConfig: e3.httpRetryConfig || FD, forceWaitGatewayResponse: void 0 === e3.forceWaitGatewayResponse || e3.forceWaitGatewayResponse, statsCollector: this._statsCollector, role: e3.role, clientRoleOptions: t3 }), this._config = e3, this._configDistribute = new Hq(), this._p2pChannel = new R0(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents();
        }
        async join(e3, t3, i3, r3, n3) {
          const o3 = ++this._numberOfJoinCount;
          this.store.joinStart(), r3 && (this.store.uid = r3);
          const s3 = x0(), a3 = Q0() ? window.isSecureContext : "Browser Not Support";
          if (!Q0() && !s3 || !window.isSecureContext) {
            const e4 = "The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";
            JD.warning(e4), gP("warning", this, e4);
          }
          const c3 = IK();
          "DISCONNECTED" === this.connectionState && (this.store.avoidJoinStart = Math.round(Date.now()), JD.debug("[".concat(this._clientId, "] set avoidJoinStart to ").concat(this.store.avoidJoinStart)), gP("debug", this, "join", void 0, "[".concat(this._clientId, "] set avoidJoinStart to ").concat(this.store.avoidJoinStart)));
          const d3 = pj.reportApiInvoke(c3, { name: rk.JOIN, options: [e3, t3, i3, r3], states: { isHttps: s3, isSecureContext: a3 }, tag: nk.TRACER });
          pj.setAppId(e3);
          try {
            if (!i3 && null !== i3)
              throw new QD(xD.INVALID_PARAMS, "Invalid token: ".concat(i3, ". If you don not use token, set it to null"));
            i3 && QL(i3, "token", 1, 2047), QL(e3, "appid", 1, 2047), VL(t3), r3 && jL(r3), n3 && QL(n3, "optionalInfo", 1, 2047);
          } catch (e4) {
            throw d3.onError(e4), e4;
          }
          if (JD.info("[".concat(this._clientId, "] start join channel ").concat(t3, ", join number: ").concat(o3)), fP("info", this, "join", { channel: t3 }), this._leaveMutex.isLocked) {
            JD.debug("[".concat(this._clientId, "] join: waiting leave operation")), hP("debug", this, "join: waiting leave operation");
            (await this._leaveMutex.lock())(), JD.debug("[".concat(this._clientId, "] join: continue")), hP("debug", this, "join: continue");
          }
          if (this._joinAndNotLeaveYet = true, "DISCONNECTED" !== this.connectionState) {
            const e4 = new QD(xD.INVALID_OPERATION, "[".concat(this._clientId, "] Client already in connecting/connected state"));
            throw d3.onError(e4), e4;
          }
          this._sessionId || (this._sessionId = c3, this.store.sessionId = this._sessionId), this._gateway.state = "CONNECTING";
          const u3 = B2({ clientId: this._clientId, appId: e3, sid: this._sessionId, cname: t3, uid: "string" != typeof r3 ? r3 : null, turnServer: this._turnServer, proxyServer: this._proxyServer, token: i3 || e3, cloudProxyServer: this._cloudProxyServerMode, optionalInfo: n3, license: this._license, useLocalAccessPoint: this._useLocalAccessPoint }, void 0 !== this._remoteDefaultVideoStreamType && { defaultVideoStream: this._remoteDefaultVideoStreamType });
          if (this._useLocalAccessPoint && (u3.setLocalAPVersion = this._setLocalAPVersion), "string" == typeof r3 && (u3.stringUid = r3, this._uintUid ? (u3.uid = this._uintUid, this._uintUid = void 0) : u3.uid = 0), "none" !== this._encryptionMode && this._encryptionSecret) {
            if (u3.aesmode = this._encryptionMode, u3.aespassword = await (async (e4) => {
              const t4 = LK("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"), i4 = await window.crypto.subtle.importKey("spki", t4, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]), r4 = sj(e4), n4 = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, i4, r4);
              return kK(new Uint8Array(n4));
            })(this._encryptionSecret), !this._joinAndNotLeaveYet)
              throw new QD(xD.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            this._encryptionSalt && (u3.aessalt = this._encryptionSalt);
          }
          this._startSession(this._sessionId, { channel: t3, appId: e3 });
          const h3 = this._sessionId;
          setTimeout(() => {
            "CONNECTING" === this.connectionState && h3 === this._sessionId && pj.joinChannelTimeout(this._sessionId, 5);
          }, 5e3);
          try {
            let r4;
            const n4 = u3.cloudProxyServer;
            if (["proxy3", "proxy4", "proxy5"].includes(n4)) {
              const e4 = LP("PROXY_SERVER_TYPE3");
              Array.isArray(e4) ? u3.proxyServer = e4[0] : u3.proxyServer = e4;
            }
            if (pj.setProxyServer(u3.proxyServer), JD.setProxyServer(u3.proxyServer), uP(u3.proxyServer), this.store.requestAPStart(), u3.stringUid && !u3.uid) {
              const e4 = await Mq(u3.stringUid, u3, this._axiosCancelSource.token, this._config.httpRetryConfig || FD, this.store);
              JD.debug("getUserAccount Success ".concat(u3.stringUid, " => ").concat(e4)), hP("debug", this, "getUserAccount Success ".concat(u3.stringUid, " => ").concat(e4)), u3.uid = e4, r4 = await Bq(u3, this._axiosCancelSource.token, this._config.httpRetryConfig || FD, true, this.store);
            } else
              r4 = await Bq(u3, this._axiosCancelSource.token, this._config.httpRetryConfig || FD, true, this.store);
            if (!this._joinAndNotLeaveYet)
              throw new QD(xD.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            this.store.requestAPEnd(), setTimeout(() => {
              this._configDistribute.startGetConfigDistribute(u3, this._axiosCancelSource.token), this._configDistribute.on(uB.UPDATE_BITRATE_LIMIT, (e4) => {
                this._p2pChannel.updateBitrateLimit(e4);
              });
            }, 0), this._key = i3 || e3;
            const o4 = r4.gatewayInfo;
            this._joinInfo = B2(B2({}, u3), {}, { cid: o4.cid, uid: u3.uid ? u3.uid : o4.uid, vid: o4.vid, apResponse: o4.res, uni_lbs_ip: o4.uni_lbs_ip, gatewayAddrs: o4.gatewayAddrs });
            const s4 = await this._joinGateway();
            if (!this._joinAndNotLeaveYet)
              throw new QD(xD.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            return d3.onSuccess(s4), this._appId = e3, this._channelName = u3.cname, this._uid = s4, this.store.uid = s4, setTimeout(() => {
              this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener(pN() ? "beforeunload" : "pagehide", this._handleBeforeUnload);
            }, 0), JD.info("[".concat(this._clientId, "] Joining channel success: ").concat(t3)), fP("info", this, "join", t3, "success"), setTimeout(() => {
              LP("USE_NEW_LOG") ? IP() : JD.startUpload();
            }, 5e3), this.store.joinEnd(), A3 = this, VP.includes(A3) || VP.push(A3), s4;
          } catch (e4) {
            const i4 = Array.isArray(e4) ? e4[0] : e4;
            throw JD.error("[".concat(this._clientId, "] join number: ").concat(o3, ", Joining channel failed, rollback"), i4), fP("error", this, "join", t3, i4.toString()), i4.code !== xD.OPERATION_ABORTED && this._numberOfJoinCount === o3 && (this._gateway.state = "DISCONNECTED", this._reset()), d3.onError(i4), i4;
          }
          var A3;
        }
        _joinGateway() {
          if (!this._joinInfo || !this._key)
            throw new QD(xD.INVALID_OPERATION);
          return this._gateway.join(this._joinInfo, this._key, !("disabled" !== this._joinInfo.cloudProxyServer || this._joinInfo.proxyServer || !LP("JOIN_WITH_FALLBACK_SIGNAL_PROXY"))).then((e3) => e3).catch((e3) => {
            if (e3.code === xD.INIT_WEBSOCKET_TIMEOUT)
              return this._gateway.leave(true, lk.FALLBACK), e3;
            if (e3.code === xD.INIT_DATACHANNEL_TIMEOUT)
              return this._gateway.leave(true, lk.FALLBACK), e3;
            throw e3;
          }).then((e3) => {
            if (e3 instanceof QD) {
              if (e3.code === xD.INIT_WEBSOCKET_TIMEOUT) {
                if (JD.info("[".concat(this._clientId, "] join timeout, fallback to proxy")), !this._joinInfo || !this._key)
                  throw new QD(xD.INVALID_OPERATION);
                this._joinInfo.cloudProxyServer = "fallback", this._cloudProxyServerMode = "fallback", this.store.cloudProxyServerMode = "fallback";
                const e4 = LP("PROXY_SERVER_TYPE3");
                if (Array.isArray(e4))
                  if (this._joinInfo.apUrl) {
                    const t4 = new NJ(this._joinInfo.apUrl).host.split("."), i3 = t4.slice(t4.length - 2).join(".");
                    e4.forEach((e5) => {
                      this._joinInfo && e5.includes(i3) && (this._joinInfo.proxyServer = e5);
                    }), this._joinInfo.proxyServer || (this._joinInfo.proxyServer = e4[0]);
                  } else
                    this._joinInfo.proxyServer = e4[0];
                else
                  this._joinInfo.proxyServer = e4;
                const t3 = LP("LOG_UPLOAD_SERVER").match(/.+:(\d{1,5})$/);
                t3 && t3[1] && "443" !== t3[1] && (JD.setProxyServer(this._joinInfo.proxyServer), uP(this._joinInfo.proxyServer)), "443" !== LP("STATS_COLLECTOR_PORT").toString() && pj.setProxyServer(this._joinInfo.proxyServer);
                return pj.reportApiInvoke(this._sessionId, { name: rk.JOIN_FALLBACK_TO_PROXY, options: [this._joinInfo.proxyServer], tag: nk.TRACER }).onSuccess(), this.emit(pk.JOIN_FALLBACK_TO_PROXY, this._joinInfo.proxyServer), this._gateway.join(this._joinInfo, this._key);
              }
              if (JD.info("[".concat(this._clientId, "] join by datachannel timeout, fallback to websocket")), !this._joinInfo || !this._key)
                throw new QD(xD.INVALID_OPERATION);
              return pj.reportApiInvoke(this._sessionId, { name: rk.DATACHANNEL_FAILBACK, options: [this.store.clientId], tag: nk.TRACER }).onSuccess(), this._joinGateway();
            }
            return e3;
          }).then((e3) => e3);
        }
        async leave() {
          const e3 = pj.reportApiInvoke(this._sessionId, { name: rk.LEAVE, options: [], tag: nk.TRACER });
          JD.info("[".concat(this._clientId, "] Leaving channel")), fP("info", this, "leave"), window.removeEventListener(pN() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._reset(), function(e4) {
            const t4 = VP.indexOf(e4);
            -1 !== t4 && VP.splice(t4, 1);
          }(this);
          const t3 = await this._leaveMutex.lock();
          if ("DISCONNECTED" === this.connectionState)
            return JD.info("[".concat(this._clientId, "] Leaving channel repeated, success")), t3(), e3.onSuccess();
          await this._gateway.leave("CONNECTED" !== this.connectionState), JD.info("[".concat(this._clientId, "] Leaving channel success")), fP("info", this, "leave", void 0, "success"), this._joinAndNotLeaveYet = false, this.store.resetJoinChannelServiceRecords(), t3(), e3.onSuccess();
        }
        async publish(e3) {
          let t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          Array.isArray(e3) || (e3 = [e3]);
          const i3 = pj.reportApiInvoke(this._sessionId, { name: rk.PUBLISH, options: e3.map((e4) => e4 ? Object(e4).toString() : "null"), tag: nk.TRACER });
          if (0 === e3.length) {
            const e4 = new QD(xD.INVALID_PARAMS, "track list is empty");
            return i3.onError(e4), e4.throw();
          }
          if ("audience" === this._gateway.role) {
            const e4 = new QD(xD.INVALID_OPERATION, "audience can not publish stream");
            return i3.onError(e4), e4.throw();
          }
          for (const r4 of e3) {
            if (!(r4 instanceof Ij)) {
              const e4 = new QD(xD.INVALID_PARAMS, "parameter is not local track");
              return i3.onError(e4), e4.throw();
            }
            if (!r4._enabled && t3) {
              const e4 = new QD(xD.TRACK_IS_DISABLED, "can not publish a disabled track: ".concat(r4.getTrackId()));
              return i3.onError(e4), e4.throw();
            }
          }
          JD.info("[".concat(this._clientId, "] Publishing tracks, id ").concat(e3.map((e4) => "".concat(e4.getTrackId(), " ")))), fP("info", this, "publish", e3.map((e4) => "".concat(e4.getTrackId()))), await this._configDistribute.awaitConfigDistributeComplete(), t3 && e3.forEach((e4) => {
            const t4 = this._configDistribute.getBitrateLimit();
            e4 instanceof hz && t4 && e4.setBitrateLimit(t4.uplink);
          });
          const r3 = await this._publishMutex.lock();
          try {
            await this._publishHighStream(e3), i3.onSuccess(e3.map((e4) => e4.trackMediaType + ":" + e4.getTrackLabel()).toString()), JD.info("[".concat(this._clientId, "] Publish success, id ").concat(e3.map((e4) => "".concat(e4.getTrackId(), " ")))), fP("info", this, "publish", e3.map((e4) => "".concat(e4.getTrackId())), "success");
          } catch (e4) {
            throw i3.onError(e4), JD.error("[".concat(this._clientId, "] publish error"), e4.toString()), fP("error", this, "publish", void 0, e4.toString()), e4;
          } finally {
            r3();
          }
        }
        async unpublish(e3) {
          if (!this._joinInfo || void 0 === this._uid)
            throw new QD(xD.INVALID_OPERATION, "Can't unpublish stream, haven't joined yet!");
          e3 ? Array.isArray(e3) || (e3 = [e3]) : e3 = this._p2pChannel.getAllTracks(true);
          const t3 = pj.reportApiInvoke(this._sessionId, { name: rk.UNPUBLISH, options: e3.map((e4) => e4.getTrackId()), tag: nk.TRACER });
          JD.info("[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(e3.map((e4) => "".concat(e4.getTrackId(), " ")), " ")), fP("info", this, "unpublish", e3.map((e4) => "".concat(e4.getTrackId())));
          const i3 = await this._publishMutex.lock();
          try {
            const r3 = await this._p2pChannel.unpublish(e3);
            r3 && await this._gateway.unpublish(r3, this._uid), JD.info("[".concat(this._clientId, "] Unpublish success,tracks ").concat(e3.map((e4) => "".concat(e4.getTrackId())))), fP("info", this, "unpublish", e3.map((e4) => "".concat(e4.getTrackId())), "success"), t3.onSuccess();
          } catch (e4) {
            throw t3.onError(e4), JD.error("[".concat(this._clientId, "] unpublish error"), e4.toString()), fP("error", this, "unpublish", void 0, e4.toString()), e4;
          } finally {
            i3 && i3();
          }
        }
        async subscribe(e3, t3) {
          return this._subscribe(e3, t3);
        }
        async _subscribe(e3, t3, i3) {
          ML(t3, "mediaType", ["audio", "video"]);
          const r3 = pj.reportApiInvoke(this._sessionId, { name: rk.SUBSCRIBE, options: [e3.uid, t3], tag: nk.TRACER });
          if (!this._joinInfo) {
            const e4 = new QD(xD.INVALID_OPERATION, "Can't subscribe stream, not joined");
            throw r3.onError(e4), e4;
          }
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) {
            const e4 = new QD(xD.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
            throw r3.onError(e4), e4;
          }
          if (!this._users.find((t4) => t4 === e3)) {
            const t4 = new QD(xD.INVALID_REMOTE_USER, "user is not in the channel");
            throw JD.error("[".concat(this._clientId, "] can not subscribe ").concat(e3.uid, ", this user is not in the channel")), fP("error", this, "subscribe", e3.uid, "this user is not in the channel"), r3.onError(t4), t4;
          }
          if (!e3.hasAudio && !e3.hasVideo) {
            const t4 = new QD(xD.INVALID_REMOTE_USER, "user is not published");
            throw JD.error("[".concat(this._clientId, "] can not subscribe ").concat(e3.uid, ", user is not published")), fP("error", this, "subscribe", e3.uid, "this user is not published"), r3.onError(t4), t4;
          }
          if (!(i3 || ("audio" !== t3 || e3.hasAudio && void 0 !== e3._audioSSRC) && ("video" !== t3 || e3.hasVideo && void 0 !== e3._videoSSRC))) {
            const i4 = new QD(xD.REMOTE_USER_IS_NOT_PUBLISHED);
            throw JD.error("[".concat(this._clientId, "] can not subscribe ").concat(e3.uid, " with mediaType ").concat(t3, ", remote track is not published")), fP("error", this, "subscribe", e3.uid, "mediaType ".concat(t3, ", remote track is not published")), r3.onError(i4), i4;
          }
          const n3 = "audio" === t3 ? e3._audioSSRC : e3._videoSSRC, o3 = "audio" === t3 ? e3._audioOrtc : e3._videoOrtc, s3 = "video" === t3 ? e3._rtxSsrcId : void 0, a3 = { stream_type: "audio" === t3 ? AB.AUDIO : AB.VIDEO, ssrcId: n3 }, c3 = await this._subscribeMutex.lock();
          JD.info("[".concat(this._clientId, "] subscribe user ").concat(e3.uid, ", mediaType: ").concat(t3)), fP("info", this, "subscribe", { uid: e3.uid, mediaType: t3 });
          try {
            if (await this._p2pChannel.hasRemoteMediaWithLock(e3, t3))
              await this._p2pChannel.unmuteRemote(e3, t3);
            else
              try {
                zG.markSubscribeStart(this.store.clientId, n3), this.store.subscribe(e3.uid, t3, Date.now()), await this._p2pChannel.subscribe(e3, t3, n3, s3, o3);
                try {
                  await this._gateway.subscribe(e3.uid, a3, true);
                } catch (i5) {
                  if ((null == i5 ? void 0 : i5.code) !== xD.WS_ABORT)
                    throw await this._p2pChannel.unsubscribe(e3, t3), i5;
                  await this._p2pChannel.unsubscribe(e3, t3, true), this._p2pChannel.setPendingRemoteMedia(e3, t3);
                }
                this.store.subscribe(e3.uid, t3, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(true, null, e3, t3);
              } catch (i5) {
                throw this._p2pChannel.reportSubscribeEvent(false, null == i5 ? void 0 : i5.code, e3, t3), i5;
              }
            JD.info("[".concat(this._clientId, "] subscribe success user ").concat(e3.uid, ", mediaType: ").concat(t3)), fP("info", this, "subscribe", { uid: e3.uid, mediaType: t3 }, "success"), this._defaultStreamFallbackType && this.setStreamFallbackOption(e3.uid, this._defaultStreamFallbackType).catch((e4) => {
              JD.warning("[".concat(this._clientId, "] auto set fallback failed"), e4), hP("warning", this, "auto set fallback failed, ".concat(e4.toString()));
            });
            const i4 = "audio" === t3 ? e3._audioTrack : e3._videoTrack;
            if (!i4) {
              const e4 = new QD(xD.UNEXPECTED_ERROR, "can not find remote track in user object");
              return r3.onError(e4), e4.throw();
            }
            return r3.onSuccess(i4.getTrackId()), i4;
          } catch (i4) {
            throw r3.onError(i4), JD.error("[".concat(this._clientId, "] subscribe user ").concat(e3.uid, " error"), i4), fP("error", this, "subscribe", { uid: e3.uid, mediaType: t3 }, i4.toString()), i4;
          } finally {
            c3();
          }
        }
        async massSubscribe(e3) {
          FL(e3, "subscribeList");
          const t3 = pj.reportApiInvoke(this._sessionId, { name: rk.MASS_SUBSCRIBE, options: e3.map((e4) => {
            let { user: t4, mediaType: i4 } = e4;
            return [null == t4 ? void 0 : t4.uid, i4];
          }), tag: nk.TRACER });
          if (!this._joinInfo) {
            const e4 = new QD(xD.INVALID_OPERATION, "Can't subscribe stream, not joined");
            throw t3.onError(e4), e4;
          }
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) {
            const e4 = new QD(xD.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
            throw t3.onError(e4), e4;
          }
          const i3 = Date.now(), r3 = /* @__PURE__ */ new Map(), n3 = await this._subscribeMutex.lock();
          JD.info("[".concat(this._clientId, "]start massSubscribe user ").concat(e3.map((e4) => {
            let { user: t4, mediaType: i4 } = e4;
            return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i4);
          }).join("; "))), fP("info", this, "massSubscribe", e3);
          const o3 = (e3 = [...e3]).map((e4) => {
            let { user: t4, mediaType: i4 } = e4;
            return { user: t4, mediaType: i4 };
          }), s3 = await this._p2pChannel.globalLock();
          try {
            var a3;
            for (let i4 = e3.length - 1; i4 >= 0; i4--) {
              const n4 = e3[i4], { user: s4, mediaType: a4 } = n4;
              if (ML(a4, "mediaType", ["audio", "video"]), !s4) {
                const e4 = new QD(xD.INVALID_PARAMS, "user property does not exist in subscribeList item");
                throw JD.error("[".concat(this._clientId, "] user property does not exist in subscribeList item")), t3.onError(e4), e4;
              }
              if (!this._users.find((e4) => e4 === s4)) {
                const t4 = new QD(xD.INVALID_REMOTE_USER, "user is not in the channel");
                JD.error("[".concat(this._clientId, "] can not massSubscribe ").concat(s4.uid, ", this user is not in the channel")), fP("error", this, "massSubscribe", s4.uid, "this user is not in the channel"), o3[i4].error = t4, e3.splice(i4, 1);
                continue;
              }
              if ("audio" === a4 && (!s4.hasAudio || void 0 === s4._audioSSRC) || "video" === a4 && (!s4.hasVideo || void 0 === s4._videoSSRC)) {
                const t4 = new QD(xD.REMOTE_USER_IS_NOT_PUBLISHED);
                JD.error("[".concat(this._clientId, "] can not subscribe ").concat(s4.uid, " with mediaType ").concat(a4, ", remote user is not published")), fP("error", this, "subscribe", s4.uid, "mediaType ".concat(a4, ", remote user is not published")), o3[i4].error = t4, e3.splice(i4, 1);
                continue;
              }
              const c4 = zk.Video | zk.LwoVideo, d3 = r3.get(s4);
              if (d3) {
                if ("video" === a4 ? d3 & c4 : d3 & zk.Audio) {
                  e3.splice(i4, 1), JD.warning("repeat massSubscribe user:".concat(s4.uid, ", mediaType:").concat(a4, " twice"));
                  continue;
                }
                r3.set(s4, d3 | ("video" === a4 ? c4 : zk.Audio));
              } else
                r3.set(s4, "video" === a4 ? c4 : zk.Audio);
            }
            for (let t4 = e3.length - 1; t4 >= 0; t4--) {
              const i4 = e3[t4], { user: n4, mediaType: o4 } = i4, s4 = zk.Video | zk.LwoVideo;
              if (this._p2pChannel.hasRemoteMedia(n4, o4)) {
                await this._p2pChannel.unmuteRemoteNoLock(n4, o4);
                const i5 = r3.get(n4);
                r3.set(n4, "video" === o4 ? i5 ^ s4 : i5 ^ zk.Audio), e3.splice(t4, 1);
              }
            }
            this.store.massSubscribe(e3.map((e4) => ({ userId: e4.user.uid, type: e4.mediaType })), i3);
            const c3 = cc(a3 = Array.from(r3.entries())).call(a3, (e4, t4) => {
              let [i4, r4] = t4;
              if (0 === r4)
                return e4;
              const n4 = { stream_id: i4.uid, stream_type: r4 };
              return r4 & zk.Audio && (n4.audio_ssrc = i4._audioSSRC), r4 & zk.Video && (n4.video_ssrc = i4._videoSSRC), e4.push(n4), e4;
            }, []);
            try {
              e3.length > 0 && await this._p2pChannel.massSubscribeNoLock(e3.map((e4) => {
                let { user: t4, mediaType: i4 } = e4;
                return { user: t4, mediaType: i4, ssrcId: i4 === AB.VIDEO ? t4._videoSSRC : t4._audioSSRC, rtxSsrcId: t4._rtxSsrcId };
              }));
              const r4 = /* @__PURE__ */ new Map();
              if (c3.length > 0) {
                const e4 = await this._gateway.subscribeAll(c3, true);
                ((null == e4 ? void 0 : e4.users) || []).forEach((e5) => {
                  let { stream_id: t4, video_error_code: i4, audio_error_code: n4, error_code: o4 } = e5;
                  (i4 || n4 || o4) && r4.set(t4, { video_error_code: i4, audio_error_code: n4, error_code: o4 });
                });
              }
              if (Array.from(r4.entries()).length > 0) {
                const e4 = Array.from(r4.entries()).map((e5) => {
                  let t4, [i4, r5] = e5;
                  r5.error_code || r5.video_error_code && r5.audio_error_code ? t4 = void 0 : r5.video_error_code ? t4 = AB.VIDEO : r5.audio_error_code && (t4 = AB.AUDIO);
                  return { user: this.remoteUsers.find((e6) => e6.uid === i4), mediaType: t4 };
                });
                await this._p2pChannel.massUnsubscribeNoLock(e4);
              }
              for (const e4 of o3) {
                const t4 = r4.get(e4.user.uid);
                if (t4) {
                  const i4 = t4.error_code || "audio" === e4.mediaType && t4.audio_error_code || "video" === e4.mediaType && t4.video_error_code;
                  if (i4) {
                    const t5 = LJ(i4);
                    JD.error("user:".concat(e4.user.uid, " mediaType:").concat(e4.mediaType, " has massSubscribe error ").concat(t5.desc)), e4.error = new QD(xD.SUBSCRIBE_FAILED, "code ".concat(i4, ": ").concat(t5.desc));
                  }
                }
                e4.error || ("video" === e4.mediaType ? e4.track = e4.user.videoTrack : e4.track = e4.user.audioTrack);
              }
              return this.store.massSubscribe(o3.filter((e4) => !e4.error).map((e4) => ({ userId: e4.user.uid, type: e4.mediaType })), void 0, Date.now()), o3.forEach((e4) => {
                var t4;
                pj.subscribe(this.store.sessionId, { succ: !!e4.error, ec: (null === (t4 = e4.error) || void 0 === t4 ? void 0 : t4.code) || null, video: e4.mediaType === AB.VIDEO, audio: e4.mediaType === AB.AUDIO, peerid: e4.user.uid, subscribeRequestid: e4.mediaType === AB.VIDEO ? e4.user._videoSSRC : e4.user._audioSSRC, p2pid: this.store.p2pId, eventElapse: Math.floor(performance.now() - i3) }, true);
              }), t3.onSuccess(), JD.info("[".concat(this._clientId, "] massSubscribe success ").concat(e3.map((e4) => {
                let { user: t4, mediaType: i4 } = e4;
                return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i4);
              }).join("; "))), fP("info", this, "massSubscribe", e3, "success"), o3;
            } catch (i4) {
              throw await this._p2pChannel.massUnsubscribeNoLock(e3), t3.onError(i4), i4;
            }
          } finally {
            s3(), n3();
          }
        }
        async unsubscribe(e3, t3) {
          if (t3 && ML(t3, "mediaType", ["audio", "video"]), !this._joinInfo)
            throw new QD(xD.INVALID_OPERATION, "Can't unsubscribe stream, haven't joined yet!");
          const i3 = pj.reportApiInvoke(this._sessionId, { name: rk.UNSUBSCRIBE, options: [e3.uid, t3], tag: nk.TRACER });
          if (!this._users.find((t4) => t4 === e3)) {
            const r3 = new QD(xD.INVALID_REMOTE_USER, "user is not in the channel");
            throw JD.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e3.uid, ", user is not in the channel")), fP("error", this, "unsubscribe", { uid: e3.uid, mediaType: t3 }, "user is not in the channel"), i3.onError(r3), r3;
          }
          JD.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e3.uid, ", mediaType: ").concat(t3)), fP("info", this, "unsubscribe", { uid: e3.uid, mediaType: t3 });
          try {
            const r3 = await this._p2pChannel.unsubscribe(e3, t3);
            r3 && await this._gateway.unsubscribe(r3, e3.uid), JD.info("[".concat(this._clientId, "] unsubscribe success uid: ").concat(e3.uid, ", mediaType: ").concat(t3)), fP("info", this, "unsubscribe", { uid: e3.uid, mediaType: t3 }, "success"), i3.onSuccess();
          } catch (r3) {
            if (r3.code === xD.DISCONNECT_P2P)
              return JD.warning("disconnecting p2p, abort unsubscribe request."), void i3.onSuccess();
            throw JD.error("[".concat(this._clientId, "] unsubscribe user ").concat(e3.uid, " error"), r3.toString()), fP("error", this, "unsubscribe", { uid: e3.uid, mediaType: t3 }, r3.toString()), i3.onError(r3), r3;
          }
        }
        async massUnsubscribe(e3) {
          FL(e3, "unsubscribeList");
          const t3 = pj.reportApiInvoke(this._sessionId, { name: rk.UNSUBSCRIBE, options: e3.map((e4) => {
            let { user: t4, mediaType: i4 } = e4;
            return { uid: null == t4 ? void 0 : t4.uid, mediaType: i4 };
          }), tag: nk.TRACER });
          if (!this._joinInfo) {
            const e4 = new QD(xD.INVALID_OPERATION, "Can't unsubscribeAll stream, haven't joined yet!");
            throw t3.onError(e4), e4;
          }
          JD.info("[".concat(this._clientId, "] start massUnsubscribe ").concat(e3.map((e4) => {
            let { user: t4, mediaType: i4 } = e4;
            return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i4, ";");
          }).join())), fP("info", this, "massUnsubscribe", e3), e3 = [...e3];
          const i3 = /* @__PURE__ */ new Map();
          for (let r3 = e3.length - 1; r3 >= 0; r3--) {
            const { user: n3, mediaType: o3 } = e3[r3];
            if (!n3) {
              const e4 = new QD(xD.INVALID_PARAMS, "user property does not exist in unsubscribeList item");
              throw JD.error("[".concat(this._clientId, "] user property does not exist in unsubscribeList item")), t3.onError(e4), e4;
            }
            ML(o3, "mediaType", ["video", "audio", void 0]);
            if (!this._users.find((e4) => e4 === n3)) {
              JD.warning("[".concat(this._clientId, "] can not unsubscribe ").concat(n3.uid, ", user is not in the channel")), fP("error", this, "unsubscribe", { uid: n3.uid, mediaType: o3 }, "user is not in the channel"), e3.splice(r3, 1);
              continue;
            }
            const s3 = zk.Video | zk.LwoVideo;
            if (i3.has(n3)) {
              const t4 = i3.get(n3);
              let a3;
              switch (o3) {
                case "video":
                  a3 = t4 & s3;
                  break;
                case "audio":
                  a3 = t4 & zk.Audio;
                  break;
                default:
                  a3 = t4 & (zk.Audio | s3);
              }
              if (a3) {
                JD.warning("repeat massUnsubscribe user:".concat(n3.uid, ",mediaType:").concat(o3, " twice.")), e3.splice(r3, 1);
                continue;
              }
              o3 ? "audio" === o3 ? i3.set(n3, t4 | zk.Audio) : "video" === o3 && i3.set(n3, t4 | s3) : i3.set(n3, t4 | zk.Audio | s3);
            } else
              o3 ? "audio" === o3 ? i3.set(n3, zk.Audio) : "video" === o3 && i3.set(n3, s3) : i3.set(n3, zk.Audio | s3);
          }
          try {
            const i4 = await this._p2pChannel.massUnsubscribe(e3);
            i4 && await this._gateway.massUnsubscribe(i4), JD.info("[".concat(this._clientId, "] massUnsubscribe success ").concat(e3.map((e4) => {
              let { user: t4, mediaType: i5 } = e4;
              return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i5, ";");
            }).join())), fP("info", this, "massUnsubscribe", e3, "success"), t3.onSuccess();
          } catch (i4) {
            if (i4.code === xD.DISCONNECT_P2P)
              return JD.warning("disconnecting p2p, abort unsubscribe request."), void t3.onSuccess();
            throw JD.error("[".concat(this._clientId, "] massUnsubscribe error"), i4.toString()), fP("error", this, "massUnsubscribe", e3, i4.toString()), t3.onError(i4), i4;
          }
        }
        setLowStreamParameter(e3) {
          !function(e4) {
            if (!e4)
              throw new QD(xD.INVALID_PARAMS);
            GL(e4.width) || xL(e4.width, "streamParameter.width"), GL(e4.height) || xL(e4.height, "streamParameter.height"), GL(e4.framerate) || xL(e4.framerate, "streamParameter.framerate"), GL(e4.bitrate) || UL(e4.bitrate, "streamParameter.bitrate");
          }(e3);
          const t3 = pj.reportApiInvoke(this._sessionId, { name: rk.SET_LOW_STREAM_PARAMETER, options: [e3], tag: nk.TRACER });
          (!e3.width && e3.height || e3.width && !e3.height) && (JD.warning("[".concat(this._clientId, "] The width and height parameters take effect only when both are set")), hP("warning", this, "The width and height parameters take effect only when both are set")), JD.info("[".concat(this._clientId, "] set low stream parameter to"), JSON.stringify(e3)), fP("info", this, "setLowStreamParameter", e3);
          const i3 = this._configDistribute.getLowStreamConfigDistribute();
          i3 && i3.bitrate && e3.bitrate && i3.bitrate < e3.bitrate && (e3.bitrate = i3.bitrate), this._lowStreamParameter = e3, t3.onSuccess();
        }
        async enableDualStream() {
          const e3 = pj.reportApiInvoke(this._sessionId, { name: rk.ENABLE_DUAL_STREAM, options: [], tag: nk.TRACER });
          if (!wB().supportDualStream) {
            pj.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false });
            const t3 = new QD(xD.NOT_SUPPORTED, "Your browser is not support dual stream");
            throw e3.onError(t3), t3;
          }
          if (this._isDualStreamEnabled) {
            const t3 = new QD(xD.INVALID_OPERATION, "Dual stream is already enabled");
            throw e3.onError(t3), t3;
          }
          if (this._p2pChannel.canPublishLowStream())
            try {
              await this._publishLowStream();
            } catch (t3) {
              throw pj.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), e3.onError(t3), t3;
            }
          this._isDualStreamEnabled = true, pj.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: true }), JD.info("[".concat(this._clientId, "] enable dual stream")), fP("info", this, "enableDualStream"), e3.onSuccess();
        }
        async disableDualStream() {
          if (!this._isDualStreamEnabled)
            return;
          if (!this._joinInfo)
            throw new QD(xD.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          const e3 = pj.reportApiInvoke(this._sessionId, { name: rk.DISABLE_DUAL_STREAM, options: [], tag: nk.TRACER });
          if (this._p2pChannel.getLocalMedia(lB.LocalVideoLowTrack))
            try {
              const e4 = await this._p2pChannel.unpublishLowStream();
              e4 && await this._gateway.unpublish(e4, this._joinInfo.stringUid || this._joinInfo.uid);
            } catch (t3) {
              throw pj.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: false }), e3.onError(t3), t3;
            }
          this._isDualStreamEnabled = false, pj.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: true }), JD.info("[".concat(this._clientId, "] disable dual stream")), fP("info", this, "disableDualStream"), e3.onSuccess();
        }
        async setClientRole(e3, t3) {
          !function(e4) {
            ML(e4, "role", ["audience", "host"]);
          }(e3), t3 && wk(t3);
          const i3 = pj.reportApiInvoke(this._sessionId, { name: rk.SET_CLIENT_ROLE, options: [e3, t3], tag: nk.TRACER });
          if ("rtc" === this._mode) {
            JD.warning("[".concat(this._clientId, "]rtc mode can not use setClientRole")), fP("warning", this, "setClientRole", e3, "rtc mode can not use setClientRole");
            const t4 = new QD(xD.INVALID_OPERATION, "rtc mode can not use setClientRole");
            return i3.onError(t4), t4.throw();
          }
          if (t3 && t3.level && "host" === e3) {
            const e4 = new QD(xD.INVALID_OPERATION, "host mode can not set audience latency level");
            return i3.onError(e4), e4.throw();
          }
          try {
            if ("audience" === e3 && this._p2pChannel.hasLocalMedia()) {
              const e4 = new QD(xD.INVALID_OPERATION, "can not set client role to audience when publishing stream");
              return i3.onError(e4), e4.throw();
            }
            await this._gateway.setClientRole(e3, t3), JD.info("[".concat(this._clientId, "] set client role to ").concat(e3, ", level: ").concat(t3 && t3.level)), fP("info", this, "setClientRole", { role: e3, level: t3 && t3.level }), i3.onSuccess();
          } catch (e4) {
            throw i3.onError(e4), e4;
          }
        }
        setProxyServer(e3, t3) {
          if (QL(e3, "proxyServer"), !t3) {
            if ("DISCONNECTED" !== this.connectionState)
              throw new QD(xD.INVALID_OPERATION, "Set proxy server before join channel");
            if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint)
              throw new QD(xD.INVALID_OPERATION, "You have already set the proxy");
          }
          this._proxyServer = e3, pj.setProxyServer(this._proxyServer), JD.setProxyServer(this._proxyServer), uP(this._proxyServer), JD.info("[".concat(this._clientId, "] Set proxy server ").concat(t3 ? "by initialize call" : "", " success.")), fP("info", this, "setProxyServer", [...arguments], "success");
        }
        setTurnServer(e3, t3) {
          if (Array.isArray(e3) || (e3 = [e3]), !t3) {
            if ("DISCONNECTED" !== this.connectionState)
              throw new QD(xD.INVALID_OPERATION, "Set turn server before join channel");
            if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint)
              throw new QD(xD.INVALID_OPERATION, "You have already set the proxy");
          }
          if (Rk(e3))
            return this._turnServer = { servers: e3, mode: "original-manual" }, JD.info("[".concat(this._clientId, "] Set original turnserver ").concat(t3 ? "by initialize call" : "", " success: ").concat(e3.map((e4) => e4.urls).join(","), ".")), void fP("info", this, "setOriginalTurnServer", [...arguments], "success");
          e3.forEach((e4) => yk(e4)), this._turnServer = { servers: e3, mode: "manual" }, JD.info("[".concat(this._clientId, "] Set turnserver ").concat(t3 ? "by initialize call" : "", " success.")), fP("info", this, "setTurnServer", [...arguments], "success");
        }
        setLicense(e3) {
          if ("DISCONNECTED" !== this.connectionState) {
            throw new QD(xD.INVALID_OPERATION, "you should set license before join channel");
          }
          if (QL(e3, "license", 32, 32), !/^[A-Za-z\d]+$/.test(e3))
            throw new QD(xD.INVALID_PARAMS, "license should only contains characters from A-Z a-z 0-9");
          this._license = e3, JD.info("[".concat(this._clientId, "] set license success"), e3);
        }
        startProxyServer(e3) {
          const t3 = pj.reportApiInvoke(this._sessionId, { name: rk.START_PROXY_SERVER, options: [], tag: nk.TRACER });
          if ("DISCONNECTED" !== this.connectionState) {
            const e4 = new QD(xD.INVALID_OPERATION, "Start proxy server before join channel");
            throw t3.onError(e4), e4;
          }
          if (this._proxyServer || "manual" === this._turnServer.mode || this._useLocalAccessPoint) {
            const e4 = new QD(xD.INVALID_OPERATION, "You have already set the proxy");
            throw t3.onError(e4), e4;
          }
          const i3 = [3, 4, 5];
          let r3;
          switch (void 0 === e3 && (e3 = 3), e3) {
            case 1:
            case 2:
              throw new QD(xD.NOT_SUPPORTED, "proxy mode 1/2 has been deprecated and not supported.");
            case 3:
              r3 = "proxy3";
              break;
            case 4:
              r3 = "proxy4";
              break;
            case 5:
              r3 = "proxy5";
              break;
            default: {
              const e4 = new QD(xD.INVALID_PARAMS, "proxy server mode must be ".concat(i3.join("|")));
              throw t3.onError(e4), e4;
            }
          }
          this._cloudProxyServerMode = r3, this.store.cloudProxyServerMode = r3, JD.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), fP("info", this, "startProxyServer", this._cloudProxyServerMode), t3.onSuccess();
        }
        stopProxyServer() {
          const e3 = pj.reportApiInvoke(this._sessionId, { name: rk.STOP_PROXY_SERVER, options: [], tag: nk.TRACER });
          if ("DISCONNECTED" !== this.connectionState)
            throw new QD(xD.INVALID_OPERATION, "Stop proxy server after leave channel");
          pj.setProxyServer(), JD.setProxyServer(), uP(), this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled", JD.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), fP("info", this, "stopProxyServer", this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = { mode: "auto", servers: [] }, e3.onSuccess();
        }
        setLocalAccessPointsV2(e3) {
          if (!e3.accessPoints)
            throw new QD(xD.INVALID_PARAMS, "accessPoints is required.");
          FL(e3.accessPoints.serverList, "accessPoints.serverList"), QL(e3.accessPoints.domain, "accessPoints.domain");
          const t3 = (e4, t4) => {
            UL(e4, t4, 0, 65535, true);
          };
          let i3 = 443;
          if (e3.accessPoints.port && (t3(e3.accessPoints.port, "accessPoints.port"), i3 = e3.accessPoints.port), this._proxyServer || "disabled" !== this._cloudProxyServerMode)
            throw new QD(xD.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
          LP("CLOSE_AFB_FOR_LOCAL_AP") && (PP("JOIN_WITH_FALLBACK_SIGNAL_PROXY", false), PP("JOIN_WITH_FALLBACK_MEDIA_PROXY", false));
          const r3 = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/, n3 = e3.accessPoints.domain, o3 = e3.accessPoints.serverList.map((e4) => r3.test(e4) ? "".concat(e4.replace(/\./g, "-"), ".").concat(n3) : e4), s3 = o3.map((e4) => "".concat(e4, ":").concat(i3));
          this._useLocalAccessPoint = true, this._setLocalAPVersion = 2, PP("WEBCS_DOMAIN", s3), PP("WEBCS_DOMAIN_BACKUP_LIST", s3), PP("GATEWAY_DOMAINS", [n3]), e3.report && e3.report.hostname && Array.isArray(e3.report.hostname) && e3.report.hostname.length ? (FL(e3.report.hostname, "report.hostname"), PP("EVENT_REPORT_DOMAIN", e3.report.hostname[0]), PP("EVENT_REPORT_BACKUP_DOMAIN", e3.report.hostname[1] || e3.report.hostname[0])) : (PP("EVENT_REPORT_DOMAIN", o3[0]), PP("EVENT_REPORT_BACKUP_DOMAIN", o3[1] || o3[0]));
          let a3 = 6443;
          e3.report && e3.report.port && (t3(e3.report.port, "report.port"), a3 = e3.report.port), PP("STATS_COLLECTOR_PORT", a3), e3.report ? PP("ENABLE_EVENT_REPORT", true) : PP("ENABLE_EVENT_REPORT", false);
          let c3 = "";
          e3.log && e3.log.hostname && Array.isArray(e3.log.hostname) && e3.log.hostname.length ? (FL(e3.log.hostname, "log.hostname"), c3 = e3.log.hostname[0]) : c3 = o3[0];
          let d3 = 6444;
          e3.log && e3.log.port && (t3(e3.log.port, "log.port"), d3 = e3.log.port), PP("LOG_UPLOAD_SERVER", "".concat(c3, ":").concat(d3));
          let u3 = [];
          e3.cds && e3.cds.hostname && Array.isArray(e3.cds.hostname) && e3.cds.hostname.length ? (FL(e3.cds.hostname, "cds.hostname"), u3 = e3.cds.hostname) : u3 = o3;
          let h3 = 443;
          e3.cds && e3.cds.port && (t3(e3.cds.port, "cds.port"), h3 = e3.cds.port), PP("CDS_AP", u3.map((e4) => "".concat(e4, ":").concat(h3))), e3.cds ? PP("ENABLE_CONFIG_DISTRIBUTE", true) : PP("ENABLE_CONFIG_DISTRIBUTE", false), JD.info("set local access point v2 success"), fP("info", this, "setLocalAccessPointsV2");
        }
        setLocalAccessPoints(e3, t3) {
          if (FL(e3, "serverList"), QL(t3, "domain"), this._proxyServer || "disabled" !== this._cloudProxyServerMode)
            throw new QD(xD.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
          const i3 = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
          e3 = e3.map((e4) => i3.test(e4) ? "".concat(e4.replace(/\./g, "-"), ".").concat(t3) : e4), this._useLocalAccessPoint = true, this._setLocalAPVersion = 1, PP("WEBCS_DOMAIN", e3), PP("WEBCS_DOMAIN_BACKUP_LIST", e3), PP("GATEWAY_DOMAINS", [t3]), PP("EVENT_REPORT_DOMAIN", e3[0]), PP("EVENT_REPORT_BACKUP_DOMAIN", e3[1] || e3[0]), PP("LOG_UPLOAD_SERVER", "".concat(e3[0], ":6444")), JD.info("set local access point success"), fP("info", this, "setLocalAccessPoints");
        }
        async setRemoteDefaultVideoStreamType(e3) {
          if (ML(e3, "streamType", [0, 1]), this._remoteDefaultVideoStreamType = e3, this._joinInfo)
            try {
              await this._gateway.setDefaultRemoteVideoStreamType(e3), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType;
            } catch (e4) {
              throw JD.error("[".concat(this._clientId, "] set default remote video stream type error"), e4.toString()), e4;
            }
          else
            JD.debug("haven't joined yet, cache remoteDefaultVideoStreamType ".concat(e3));
        }
        async setRemoteVideoStreamType(e3, t3) {
          ML(t3, "streamType", [0, 1]);
          const i3 = pj.reportApiInvoke(this._sessionId, { name: rk.SET_REMOTE_VIDEO_STREAM_TYPE, options: [e3, t3], tag: nk.TRACER });
          try {
            await this._gateway.setRemoteVideoStreamType(e3, t3), setTimeout(() => {
              const t4 = this._users.find((t5) => t5.uid === e3);
              t4 && t4.videoTrack && t4.videoTrack.updateMediaStreamTrackResolution();
            }, 2e3);
          } catch (e4) {
            throw i3.onError(e4), JD.error("[".concat(this._clientId, "] set remote video stream type error"), e4.toString()), fP("error", this, "setRemoteVideoStreamType", void 0, e4.toString()), e4;
          }
          JD.info("[".concat(this._clientId, "] set remote ").concat(e3, " video stream type to ").concat(t3)), fP("info", this, "setRemoteVideoStreamType", { uid: e3, streamType: t3 }), this._remoteStreamTypeCacheMap.set(e3, t3), i3.onSuccess();
        }
        async setStreamFallbackOption(e3, t3) {
          ML(t3, "fallbackType", [0, 1, 2]);
          const i3 = pj.reportApiInvoke(this._sessionId, { name: rk.SET_STREAM_FALLBACK_OPTION, options: ["too long to show", t3], tag: nk.TRACER });
          try {
            await this._gateway.setStreamFallbackOption(e3, t3);
          } catch (e4) {
            throw i3.onError(e4), JD.error("[".concat(this._clientId, "] set stream fallback option"), e4.toString()), fP("error", this, "setStreamFallbackOption", void 0, e4.toString()), e4;
          }
          JD.info("[".concat(this._clientId, "] set remote ").concat(e3, " stream fallback type to ").concat(t3)), fP("info", this, "setStreamFallbackOption", { uid: e3, fallbackType: t3 }), this._streamFallbackTypeCacheMap.set(e3, t3), i3.onSuccess();
        }
        setEncryptionConfig(e3, t3, i3) {
          const r3 = pj.reportApiInvoke(this._sessionId, { name: rk.SET_ENCRYPTION_CONFIG, options: [e3], tag: nk.TRACER });
          try {
            !function(e4) {
              ML(e4, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "aes-128-gcm", "aes-256-gcm", "aes-128-gcm2", "aes-256-gcm2", "none"]);
            }(e3), QL(t3, "secret");
            if (["aes-128-gcm2", "aes-256-gcm2"].includes(e3)) {
              if (!i3 || !(i3 instanceof Uint8Array && 32 === i3.length))
                throw new QD(xD.INVALID_PARAMS, "salt must be an Uint8Array and exactly equal to 32 bytes");
            } else if (i3)
              throw new QD(xD.INVALID_PARAMS, "current encrypt mode does not need salt");
            new RegExp(`^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'"|{}\\[\\]])(?=.{8,})`).test(t3) || (JD.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "), hP("warning", this, "The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      ")), this._encryptionMode = e3, this._encryptionSecret = t3, i3 && (this._encryptionSalt = kK(i3)), r3.onSuccess();
          } catch (e4) {
            throw r3.onError(e4), e4;
          }
        }
        async renewToken(e3) {
          QL(e3, "token", 1, 2047);
          const t3 = pj.reportApiInvoke(this._sessionId, { name: rk.RENEW_TOKEN, options: [e3], tag: nk.TRACER });
          if (!this._key || !this._joinInfo) {
            const e4 = new QD(xD.INVALID_OPERATION, "renewToken should not be called before user join");
            return t3.onError(e4), e4.throw();
          }
          const i3 = this._key;
          this._key = e3, this._joinInfo && (this._joinInfo.token = e3);
          const r3 = await this._renewTokenMutex.lock();
          try {
            if (LP("USE_NEW_TOKEN")) {
              JD.debug("start renew token with ticket from unilbs"), fP("debug", this, "renewToken", "unilbs");
              const t4 = await Vq(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || FD);
              JD.debug("[".concat(this._clientId, "] get ticket from unilbs success")), fP("debug", this, "renewToken", "unilbs", "success"), await this._gateway.renewToken({ token: e3, ticket: t4 });
            } else
              JD.debug("start renew token without ticket"), fP("debug", this, "renewToken"), await this._gateway.renewToken({ token: e3 });
            JD.debug("[".concat(this._clientId, "] renewToken success")), fP("debug", this, "renewToken", void 0, "success"), t3.onSuccess();
          } catch (e4) {
            throw this._key = i3, this._joinInfo.token = i3, t3.onError(e4), JD.error("[".concat(this._clientId, "] renewToken failed"), e4.toString()), fP("error", this, "renewToken", void 0, e4.toString()), e4;
          } finally {
            r3();
          }
        }
        enableAudioVolumeIndicator() {
          const e3 = pj.reportApiInvoke(this._sessionId, { name: rk.ENABLE_AUDIO_VOLUME_INDICATOR, options: [], tag: nk.TRACER });
          if (this._audioVolumeIndicationInterval)
            return JD.warning("you have already enabled audio volume indicator!"), fP("warning", this, "enableAudioVolumeIndicator", "you have already enabled audio volume indicator!"), e3.onSuccess();
          this._audioVolumeIndicationInterval = window.setInterval(() => {
            const e4 = this._p2pChannel.getAudioLevels();
            this.emit(pk.VOLUME_INDICATOR, e4);
          }, LP("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3), e3.onSuccess();
        }
        getRTCStats() {
          const e3 = this._statsCollector.getRTCStats(), t3 = this._gateway.getInChannelInfo();
          return e3.Duration = Math.round(t3.duration / 1e3), e3;
        }
        startLiveStreaming(e3, t3) {
          const i3 = pj.reportApiInvoke(this._sessionId, { name: rk.START_LIVE_STREAMING, options: [e3, t3], tag: nk.TRACER });
          if (!t3) {
            if ("h264" !== this._codec) {
              const e4 = new QD(xD.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264");
              return i3.onError(e4), l_.reject(e4);
            }
            if (!this._p2pChannel.hasLocalMedia()) {
              const e4 = new QD(xD.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming");
              return i3.onError(e4), l_.reject(e4);
            }
          }
          if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e3) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e3)) {
            const e4 = new QD(xD.LIVE_STREAMING_TASK_CONFLICT);
            return i3.onError(e4), l_.reject(e4);
          }
          const r3 = t3 ? kk.TRANSCODE : kk.RAW;
          return this._createLiveStreamingClient(r3).startLiveStreamingTask(e3, r3).then(() => i3.onSuccess()).catch((e4) => {
            throw i3.onError(e4), e4;
          });
        }
        setLiveTranscoding(e3) {
          const t3 = pj.reportApiInvoke(this._sessionId, { name: rk.SET_LIVE_TRANSCODING, options: [e3], tag: nk.TRACER });
          return this._createLiveStreamingClient(kk.TRANSCODE).setTranscodingConfig(e3).then(() => t3.onSuccess()).catch((e4) => {
            throw t3.onError(e4), e4;
          });
        }
        stopLiveStreaming(e3) {
          const t3 = pj.reportApiInvoke(this._sessionId, { name: rk.STOP_LIVE_STREAMING, options: [e3], tag: nk.TRACER }), i3 = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter((t4) => t4 && t4.hasUrl(e3));
          if (!i3.length) {
            const e4 = new QD(xD.INVALID_PARAMS, "can not find live streaming url to stop");
            return t3.onError(e4), l_.reject(e4);
          }
          return l_.all(i3.map((t4) => t4 && t4.stopLiveStreamingTask(e3))).then(() => t3.onSuccess()).catch((e4) => {
            throw t3.onError(e4), e4;
          });
        }
        async addInjectStreamUrl(e3, t3) {
          const i3 = pj.reportApiInvoke(this._sessionId, { name: rk.ADD_INJECT_STREAM_URL, options: [e3, t3], tag: nk.TRACER });
          try {
            if (!this._joinInfo)
              throw new QD(xD.INVALID_OPERATION, "can not addInjectStreamUrl, no joininfo");
            const i4 = this._createLiveStreamingClient(kk.INJECT);
            i4.setInjectStreamConfig(t3, 0), await i4.startLiveStreamingTask(e3, kk.INJECT);
          } catch (e4) {
            throw i3.onError(e4), e4;
          }
          i3.onSuccess();
        }
        async removeInjectStreamUrl() {
          const e3 = pj.reportApiInvoke(this._sessionId, { name: rk.REMOVE_INJECT_STREAM_URL, options: [], tag: nk.TRACER });
          try {
            var t3;
            const e4 = this._createLiveStreamingClient(kk.INJECT), i3 = Array.from(MG(t3 = e4.streamingTasks).call(t3)).find((e5) => e5.mode === kk.INJECT);
            if (!this._joinInfo || !i3)
              throw new QD(xD.INVALID_OPERATION, "can remove addInjectStreamUrl, no joininfo or inject task");
            await e4.stopLiveStreamingTask(i3.url);
          } catch (t4) {
            throw e3.onError(t4), t4;
          }
          e3.onSuccess();
        }
        async startChannelMediaRelay(e3) {
          const t3 = pj.reportApiInvoke(this._sessionId, { name: rk.START_CHANNEL_MEDIA_RELAY, options: [e3], tag: nk.TRACER });
          try {
            $q(e3);
            const t4 = this._createChannelMediaRelayClient();
            await t4.startChannelMediaRelay(e3);
          } catch (e4) {
            return t3.onError(e4), e4.throw();
          }
          t3.onSuccess();
        }
        async updateChannelMediaRelay(e3) {
          const t3 = pj.reportApiInvoke(this._sessionId, { name: rk.UPDATE_CHANNEL_MEDIA_RELAY, options: [e3], tag: nk.TRACER });
          try {
            $q(e3);
            const t4 = this._createChannelMediaRelayClient();
            await t4.updateChannelMediaRelay(e3);
          } catch (e4) {
            return t3.onError(e4), e4.throw();
          }
          t3.onSuccess();
        }
        async stopChannelMediaRelay() {
          const e3 = pj.reportApiInvoke(this._sessionId, { name: rk.STOP_CHANNEL_MEDIA_RELAY, options: [], tag: nk.TRACER });
          try {
            const e4 = this._createChannelMediaRelayClient();
            await e4.stopChannelMediaRelay();
          } catch (t3) {
            return e3.onError(t3), t3.throw();
          }
          e3.onSuccess();
        }
        sendStreamMessage(e3) {
          let t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (!this._joinInfo)
            throw new QD(xD.INVALID_OPERATION, "can not send data stream, not joined");
          if ("string" == typeof e3) {
            e3 = new TextEncoder().encode(e3);
          }
          if (new Blob([e3]).size > 1024)
            throw new QD(xD.INVALID_PARAMS, "stream message out of range.");
          return this._gateway.signal.request(mk.DATA_STREAM, { payload: kK(e3) }, !t3);
        }
        sendMetadata(e3) {
          if (!this._joinInfo)
            throw new QD(xD.INVALID_OPERATION, "can not send metadata, not joined");
          if (new Blob([e3]).size > 1024)
            throw new QD(xD.METADATA_OUT_OF_RANGE);
          return this._gateway.signal.request(mk.SEND_METADATA, { session_id: this._joinInfo.sid, metadata: kK(e3) });
        }
        async sendCustomReportMessage(e3) {
          Array.isArray(e3) || (e3 = [e3]), e3.forEach(zL);
          const t3 = pj.reportApiInvoke(this._sessionId, { name: rk.SEND_CUSTOM_REPORT_MESSAGE, options: [JSON.stringify(e3)], tag: nk.TRACER });
          if (!this._joinInfo) {
            const e4 = new QD(xD.INVALID_OPERATION, "can not send custom report, not joined");
            return t3.onError(e4), e4.throw();
          }
          await pj.sendCustomReportMessage(this._joinInfo.sid, e3), t3.onSuccess();
        }
        getLocalAudioStats() {
          return this._statsCollector.getLocalAudioTrackStats();
        }
        getRemoteAudioStats() {
          return this._statsCollector.getRemoteAudioTrackStats();
        }
        getLocalVideoStats() {
          return this._statsCollector.getLocalVideoTrackStats();
        }
        getRemoteVideoStats() {
          return this._statsCollector.getRemoteVideoTrackStats();
        }
        getRemoteNetworkQuality() {
          return this._statsCollector.getRemoteNetworkQualityStats();
        }
        async pickSVCLayer(e3, t3) {
          ML(t3.spatialLayer, "spatialLayer", [0, 1, 2, 3]), ML(t3.temporalLayer, "temporalLayer", [0, 1, 2, 3]);
          try {
            await this._gateway.pickSVCLayer(e3, t3);
          } catch (e4) {
            throw JD.error("[".concat(this._clientId, "] pick SVC layer failed"), e4.toString()), gP("error", this, "pickSVCLayer", t3, e4.toString()), e4;
          }
        }
        _reset() {
          if (JD.debug("[".concat(this._clientId, "] reset client")), gP("debug", this, "_reset"), this._axiosCancelSource.cancel(), this._axiosCancelSource = kD.CancelToken.source(), this._streamFallbackTypeCacheMap = /* @__PURE__ */ new Map(), this._remoteStreamTypeCacheMap = /* @__PURE__ */ new Map(), this._configDistribute.stopGetConfigDistribute(), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId = null, this.store.sessionId = null, this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = "none", this._encryptionSecret = null, this._encryptionSalt = null, this._users.forEach((e3) => {
            e3._audioTrack && e3._audioTrack._destroy(), e3._videoTrack && e3._videoTrack._destroy();
          }), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), "fallback" === this._cloudProxyServerMode && (this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled"), this._p2pChannel.reset(), this._publishMutex = new fj("client-publish"), this._subscribeMutex = new fj("client-subscribe"), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._injectStreamingClient && (this._injectStreamingClient.terminate(), this._injectStreamingClient.removeAllListeners(), this._injectStreamingClient = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect)
            try {
              this._inspect.close(), this._inspect = void 0;
            } catch (e3) {
            }
        }
        _startSession(e3, t3) {
          const i3 = e3 || IK();
          e3 ? JD.debug("[".concat(this._clientId, "] new Session ").concat(i3)) : JD.debug("[".concat(this._clientId, "] renewSession ").concat(this._sessionId, " => ").concat(i3)), gP("debug", this, "_startSession", { newSid: i3, sid: this._sessionId }), this._sessionId = i3, this.store.sessionId = i3, t3 ? pj.sessionInit(this._sessionId, { lts: new Date().getTime(), cname: t3.channel, appid: t3.appId, mode: this._mode }) : this._joinInfo ? pj.sessionInit(this._sessionId, { lts: new Date().getTime(), cname: this._joinInfo.cname, appid: this._joinInfo.appId, mode: this._mode }) : this._gateway.joinInfo && pj.sessionInit(this._sessionId, { lts: new Date().getTime(), cname: this._gateway.joinInfo.cname, appid: this._gateway.joinInfo.appId, mode: this._mode }), this._joinInfo && (this._joinInfo.sid = i3), this._gateway.joinInfo && (this._gateway.joinInfo.sid = i3);
        }
        async _publishHighStream(e3) {
          if (!this._joinInfo || void 0 === this._uid)
            throw new QD(xD.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
            throw new QD(xD.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          if ("auto" === this._turnServer.mode && LP("FORCE_TURN") && !LP("TURN_ENABLE_TCP") && !LP("TURN_ENABLE_UDP"))
            throw new QD(xD.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
          JD.debug("[".concat(this._clientId, "] publish high stream")), gP("debug", this, "_publishHighStream");
          try {
            const i3 = await this._p2pChannel.publish(e3, this._isDualStreamEnabled, this._lowStreamParameter), r3 = (await i3.next()).value;
            if (r3) {
              var t3;
              let e4;
              try {
                e4 = await this._gateway.publish(this._uid, r3, true);
              } catch (e5) {
                if (e5.code !== xD.DISCONNECT_P2P)
                  throw i3.throw(e5), e5;
              }
              await i3.next((null === (t3 = e4) || void 0 === t3 ? void 0 : t3.ortc) || []);
            }
            this._p2pChannel.reportPublishEvent(true, null);
            for (const t4 of e3)
              t4 instanceof hz && t4._encoderConfig && this._gateway.setVideoProfile(t4._encoderConfig), !t4.muted && t4.enabled || await this._p2pChannel.muteLocalTrack(t4);
          } catch (t4) {
            if (this._p2pChannel.reportPublishEvent(false, null == t4 ? void 0 : t4.code, e3), (null == t4 ? void 0 : t4.code) === xD.WS_ABORT)
              return;
            throw t4;
          }
        }
        async _publishLowStream() {
          if (!this._joinInfo || void 0 === this._uid)
            throw new QD(xD.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
            throw new QD(xD.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          JD.debug("[".concat(this._clientId, "] publish low stream")), gP("debug", this, "_publishLowStream");
          const e3 = this._configDistribute.getLowStreamConfigDistribute();
          e3 && e3.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = { width: 160, height: 120, framerate: 15, bitrate: 50 }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e3.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e3.bitrate));
          try {
            const e4 = await this._p2pChannel.publishLowStream(this._lowStreamParameter), i3 = (await e4.next()).value;
            if (i3) {
              var t3;
              let r3;
              try {
                r3 = await this._gateway.publish(this._uid, i3, true);
              } catch (t4) {
                if (t4.code !== xD.DISCONNECT_P2P)
                  throw e4.throw(t4), t4;
              }
              e4.next((null === (t3 = r3) || void 0 === t3 ? void 0 : t3.ortc) || []), this._p2pChannel.reportPublishEvent(true, null, void 0, true);
            }
          } catch (e4) {
            if (this._p2pChannel.reportPublishEvent(false, null == e4 ? void 0 : e4.code, void 0, true), (null == e4 ? void 0 : e4.code) === xD.WS_ABORT)
              return;
            throw e4;
          }
        }
        _createLiveStreamingClient(e3) {
          if (!this._joinInfo || !this._appId) {
            return new QD(xD.INVALID_OPERATION, "can not create live streaming client, please join channel first").throw();
          }
          const t3 = () => new zq(this._joinInfo, this._config.websocketRetryConfig || FD, this._config.httpRetryConfig || FD), i3 = (e4) => {
            e4.onLiveStreamError = (e5, t4) => {
              pj.reportApiInvoke(this._sessionId, { name: rk.ON_LIVE_STREAM_ERROR, options: [e5, t4], tag: nk.TRACER }).onSuccess(), this.emit(pk.LIVE_STREAMING_ERROR, e5, t4);
            }, e4.onLiveStreamWarning = (e5, t4) => {
              pj.reportApiInvoke(this._sessionId, { name: rk.ON_LIVE_STREAM_WARNING, options: [e5, t4], tag: nk.TRACER }).onSuccess(), this.emit(pk.LIVE_STREAMING_WARNING, e5, t4);
            }, e4.on(jk.REQUEST_WORKER_MANAGER_LIST, (e5, t4, i4) => {
              if (!this._joinInfo)
                return i4(new QD(xD.INVALID_OPERATION, "can not find join info to get worker manager"));
              Qq(e5, this._joinInfo, this._axiosCancelSource.token, FD).then(t4).catch(i4);
            });
          };
          switch (e3) {
            case kk.RAW:
              return this._liveRawStreamingClient || (this._liveRawStreamingClient = t3(), i3(this._liveRawStreamingClient)), this._liveRawStreamingClient;
            case kk.TRANSCODE:
              return this._liveTranscodeStreamingClient || (this._liveTranscodeStreamingClient = t3(), i3(this._liveTranscodeStreamingClient)), this._liveTranscodeStreamingClient;
            case kk.INJECT:
              return this._injectStreamingClient || (this._injectStreamingClient = t3(), this._injectStreamingClient.on(jk.REQUEST_WORKER_MANAGER_LIST, (e4, t4, i4) => {
                if (!this._joinInfo)
                  return i4(new QD(xD.INVALID_OPERATION, "can not find join info to get worker manager"));
                Qq(e4, this._joinInfo, this._axiosCancelSource.token, FD).then(t4).catch(i4);
              }), this._injectStreamingClient.onInjectStatusChange = (e4, t4, i4) => {
                this.emit(pk.INJECT_STREAM_STATUS, e4, t4, i4);
              }), this._injectStreamingClient;
          }
        }
        _createChannelMediaRelayClient() {
          if (!this._joinInfo) {
            return new QD(xD.INVALID_OPERATION, "can not create channel media relay client, please join channel first").throw();
          }
          return this._channelMediaRelayClient || (this._channelMediaRelayClient = new tX(this._joinInfo, this._clientId, this._config.websocketRetryConfig || FD, this._config.httpRetryConfig || FD), this._channelMediaRelayClient.on("state", (e3) => {
            e3 === Yk.RELAY_STATE_FAILURE && this._channelMediaRelayClient && this._channelMediaRelayClient.dispose(), this.emit(pk.CHANNEL_MEDIA_RELAY_STATE, e3);
          }), this._channelMediaRelayClient.on("event", (e3) => {
            this.emit(pk.CHANNEL_MEDIA_RELAY_EVENT, e3);
          })), this._channelMediaRelayClient;
        }
        _handleGatewayEvents() {
          this._gateway.on(Xk.DISCONNECT_P2P, async () => {
            await this._p2pChannel.disconnectForReconnect();
          }), this._gateway.on(Xk.CONNECTION_STATE_CHANGE, (e3, t3, i3) => {
            var r3;
            if (i3 === lk.FALLBACK)
              return;
            const n3 = () => {
              this.emit(pk.CONNECTION_STATE_CHANGE, e3, t3, i3);
            };
            if (pj.reportApiInvoke(this._sessionId || (null === (r3 = this._gateway.joinInfo) || void 0 === r3 ? void 0 : r3.sid) || null, { name: rk.CONNECTION_STATE_CHANGE, options: [e3, t3, i3], tag: nk.TRACER }).onSuccess(JSON.stringify({ cur: e3, prev: t3, reason: i3 })), JD.info("[".concat(this._clientId, "] connection state change: ").concat(t3, " -> ").concat(e3)), AP("info", this, "connection-state-change", "".concat(t3, " -> ").concat(e3)), "DISCONNECTED" === e3)
              return this._reset(), void n3();
            if ("RECONNECTING" === e3)
              this._users.forEach((e4) => {
                e4._trust_in_room_ = false, e4._trust_audio_enabled_state_ = false, e4._trust_video_enabled_state_ = false, e4._trust_audio_mute_state_ = false, e4._trust_video_mute_state_ = false, e4._trust_audio_stream_added_state_ = false, e4._trust_video_stream_added_state_ = false, e4._audioSSRC = void 0, e4._videoSSRC = void 0, e4._videoOrtc = void 0, e4._audioOrtc = void 0, e4._cname = void 0, e4._rtxSsrcId = void 0;
              }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0;
            else if ("CONNECTED" === e3) {
              var o3;
              this._streamFallbackTypeCacheMap.forEach((e4, t4) => {
                this._gateway.setStreamFallbackOption(t4, e4).catch((e5) => {
                  JD.warning("[".concat(this._clientId, "] auto set stream fallback option failed"), e5), hP("warning", this, "auto set stream fallback option failed, ".concat(e5.toString()));
                });
              }), this._remoteStreamTypeCacheMap.forEach((e4, t4) => {
                this._gateway.setRemoteVideoStreamType(t4, e4).catch((e5) => {
                  JD.warning("[".concat(this._clientId, "] auto set remote stream type failed"), e5), hP("warning", this, "auto set remote stream type failed, ".concat(e5.toString()));
                });
              }), void 0 !== this._remoteDefaultVideoStreamType && void 0 === (null === (o3 = this._joinInfo) || void 0 === o3 ? void 0 : o3.defaultVideoStream) && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(() => {
                JD.debug("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway connected"));
              }).catch((e4) => {
                JD.error("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e4));
              }), this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout(() => {
                if ("CONNECTED" !== this.connectionState)
                  return;
                this._userOfflineTimeout = void 0;
                this._users.filter((e4) => !e4._trust_in_room_).forEach((e4) => {
                  JD.debug("[".concat(this._clientId, "] user offline timeout, emit user offline ").concat(e4.uid)), hP("debug", this, "user offline timeout, emit user offline ".concat(e4.uid)), this._handleUserOffline({ uid: e4.uid });
                });
              }, 3e3), this._streamRemovedTimeout = window.setTimeout(() => {
                "CONNECTED" === this.connectionState && (this._streamRemovedTimeout = void 0, this._users.forEach((e4) => {
                  e4._trust_audio_mute_state_ || (JD.debug("[".concat(this._clientId, "] auto dispatch audio unmute event ").concat(e4.uid)), hP("debug", this, "auto dispatch audio unmute event ".concat(e4.uid)), this._handleMuteStream(e4.uid, "audio", false)), e4._trust_video_mute_state_ || (JD.debug("[".concat(this._clientId, "] auto dispatch video unmute event ").concat(e4.uid)), hP("debug", this, "auto dispatch video unmute event ".concat(e4.uid)), this._handleMuteStream(e4.uid, "video", false)), e4._trust_audio_enabled_state_ || (JD.debug("[".concat(this._clientId, "] auto dispatch enable local audio ").concat(e4.uid)), hP("debug", this, "auto dispatch enable local audio ".concat(e4.uid)), this._handleSetStreamLocalEnable("audio", e4.uid, true)), e4._trust_video_enabled_state_ || (JD.debug("[".concat(this._clientId, "] auto dispatch enable local video ").concat(e4.uid)), hP("debug", this, "auto dispatch enable local video ".concat(e4.uid)), this._handleSetStreamLocalEnable("video", e4.uid, true)), e4._trust_video_stream_added_state_ || (JD.debug("[".concat(this._clientId, "] auto dispatch reset video stream added ").concat(e4.uid)), this._handleResetAddStream(e4, "video")), e4._trust_audio_stream_added_state_ || (JD.debug("[".concat(this._clientId, "] auto dispatch reset audio stream added ").concat(e4.uid)), this._handleResetAddStream(e4, "audio")), e4._video_added_ || e4._audio_added_ || (JD.debug("[".concat(this._clientId, "] auto dispatch stream remove ").concat(e4.uid)), hP("debug", this, "auto dispatch stream remove ".concat(e4.uid)), this._handleRemoveStream({ uid: e4.uid, uint_id: e4._uintid }));
                }));
              }, 1e3);
            }
            n3();
          }), this._gateway.on(Xk.REQUEST_NEW_GATEWAY_LIST, (e3, t3) => {
            if (!this._joinInfo)
              return t3(new QD(xD.UNEXPECTED_ERROR, "can not recover, no join info"));
            kq(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || FD, this.store).then((t4) => {
              this._joinInfo && (this._joinInfo.apResponse = t4.gatewayInfo.res, this._joinInfo.gatewayAddrs = t4.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t4.gatewayInfo.uni_lbs_ip), e3(t4.gatewayInfo.gatewayAddrs.map((e4) => {
                if (this._joinInfo && this._joinInfo.proxyServer) {
                  const t5 = e4.address.split(":");
                  return "wss://".concat(this._joinInfo.proxyServer, "/ws/?h=").concat(t5[0], "&p=").concat(t5[1]);
                }
                return "wss://".concat(e4.address);
              }));
            }).catch(t3);
          }), this._gateway.on(Xk.NETWORK_QUALITY, (e3) => {
            "normal" === this._networkQualitySensitivity && this.emit(pk.NETWORK_QUALITY, e3);
          }), this._gateway.on(Xk.STREAM_TYPE_CHANGE, (e3, t3) => {
            this.emit(pk.STREAM_TYPE_CHANGED, e3, t3);
            pj.reportApiInvoke(this._sessionId, { name: rk.STREAM_TYPE_CHANGE, options: [e3, t3], tag: nk.TRACER }).onSuccess(JSON.stringify({ uid: e3, streamType: t3 }));
          }), this._gateway.on(Xk.IS_P2P_DISCONNECTED, (e3) => {
            this._p2pChannel.isP2PDisconnected() ? e3(true) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e3(false) : e3(true);
          }), this._gateway.on(Xk.NEED_RENEW_SESSION, () => {
            this._startSession();
          }), this._gateway.on(Xk.REQUEST_P2P_CONNECTION_PARAMS, async (e3, t3, i3) => {
            try {
              t3(await this._p2pChannel.startP2PConnection(e3));
            } catch (e4) {
              i3(e4);
            }
          }), this._gateway.on(Xk.JOIN_RESPONSE, (e3, t3) => {
            const { dtlsParameters: i3, iceParameters: r3, candidates: n3, rtpCapabilities: o3, setup: s3, cname: a3 } = X$(e3.ortc, t3);
            this._p2pChannel.connect(r3, i3, n3, o3, s3, a3);
          }), this._gateway.on(Xk.REQUEST_DC_CONNECTION_PARAMS, (e3) => {
            e3(this._p2pChannel.getEstablishParams());
          }), this._gateway.on(Xk.RESET_CONNECTION_EVENTS, () => {
            this._handleGatewaySignalEvents();
          }), this._gateway.on(Xk.DATACHANNEL_FAILBACK, () => {
            this._joinGateway();
          }), this._gateway.on(Xk.DATACHANNEL_PRECONNECT, async (e3, t3, i3, r3) => {
            var n3, o3, s3, a3, c3, d3;
            await this._p2pChannel.startP2PConnection({ turnServer: null === (n3 = this._joinInfo) || void 0 === n3 ? void 0 : n3.turnServer }, true);
            const u3 = function(e4, t4) {
              let i4;
              return t4 && t4.ip && "number" == typeof t4.port ? (i4 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t4.ip, port: t4.port.toString(), type: "host", extension: {} }], JD.debug("Using remote candidate from AP ".concat(t4.ip, ":").concat(t4.port)), hP("debug", [], "Using remote candidate from AP ".concat(t4.ip, ":").concat(t4.port)), t4.ip6 && (i4.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t4.ip6, port: t4.port.toString(), type: "host", extension: {} }), JD.debug("Using IPV6 remote candidate from AP ".concat(t4.ip6, ":").concat(t4.port)), hP("debug", [], "Using IPV6 remote candidate from AP ".concat(t4.ip6, ":").concat(t4.port)))) : i4 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e4.ip, port: e4.port.toString(), type: "host", extension: {} }], i4;
            }(e3, t3);
            return this._p2pChannel.preConnect({ iceUfrag: "".concat(null === (o3 = this._joinInfo) || void 0 === o3 ? void 0 : o3.apResponse.cid, "_").concat(null === (s3 = this._joinInfo) || void 0 === s3 ? void 0 : s3.apResponse.cert), icePwd: "".concat(null === (a3 = this._joinInfo) || void 0 === a3 ? void 0 : a3.apResponse.cid, "_").concat(null === (c3 = this._joinInfo) || void 0 === c3 ? void 0 : c3.apResponse.cert) }, { fingerprints: [{ hashFunction: "sha-256", fingerprint: null !== (d3 = LP("FINGERPRINT")) && void 0 !== d3 ? d3 : e3.fingerprint }] }, u3, { send: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, recv: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] } }, "active", "o/i14u9pJrxRKAsu").then(i3).catch(r3);
          });
        }
        _handleGatewaySignalEvents() {
          this._gateway.signal.on(_k.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(_k.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(_k.ON_ADD_AUDIO_STREAM, (e3) => this._handleAddAudioOrVideoStream("audio", e3.uid, e3.ssrcId, e3.cname, e3.uint_id, e3.ortc)), this._gateway.signal.on(_k.ON_ADD_VIDEO_STREAM, (e3) => this._handleAddAudioOrVideoStream("video", e3.uid, e3.ssrcId, e3.cname, e3.uint_id, e3.ortc, e3.rtxSsrcId)), this._gateway.signal.on(_k.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(_k.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(_k.MUTE_AUDIO, (e3) => (AP("debug", ["AgoraRTCGateway", this._clientId], "mute_audio", { uid: e3.uid }), this._handleMuteStream(e3.uid, "audio", true))), this._gateway.signal.on(_k.UNMUTE_AUDIO, (e3) => (AP("debug", ["AgoraRTCGateway", this._clientId], "unmute_audio", { uid: e3.uid }), this._handleMuteStream(e3.uid, "audio", false))), this._gateway.signal.on(_k.MUTE_VIDEO, (e3) => (AP("debug", ["AgoraRTCGateway", this._clientId], "mute_video", { uid: e3.uid }), this._handleMuteStream(e3.uid, "video", true))), this._gateway.signal.on(_k.UNMUTE_VIDEO, (e3) => (AP("debug", ["AgoraRTCGateway", this._clientId], "unmute_video", { uid: e3.uid }), this._handleMuteStream(e3.uid, "video", false))), this._gateway.signal.on(_k.RECEIVE_METADATA, (e3) => {
            const t3 = LK(e3.metadata);
            this.emit(pk.RECEIVE_METADATA, e3.uid, t3);
          }), this._gateway.signal.on(_k.ON_DATA_STREAM, (e3) => {
            e3.seq && delete e3.seq, e3.payload = LK(e3.payload), this.emit(pk.STREAM_MESSAGE, e3.uid, e3.payload), this.onStreamMessage && this.onStreamMessage(e3);
          }), this._gateway.signal.on(_k.ON_CRYPT_ERROR, () => {
            PK(() => {
              JD.warning("[".concat(this._clientId, "] on crypt error")), AP("warning", this, "crypt_error"), this.emit(pk.CRYPT_ERROR);
            }, this._sessionId);
          }), this._gateway.signal.on(_k.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(_k.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            JD.warning("[".concat(this._clientId, "] received message onTokenPrivilegeDidExpire, please get new token and join again")), AP("warning", this, "token_privilege_did_expire"), this._gateway.leave(true), this.emit(pk.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset();
          }), this._gateway.signal.on(_k.ON_STREAM_FALLBACK_UPDATE, (e3) => {
            JD.debug("[".concat(this._clientId, "] stream fallback peerId: ").concat(e3.stream_id, ", attr: ").concat(e3.stream_type)), AP("debug", this, "stream_fallback_update", { peerId: e3.stream_id, attr: e3.stream_type }), this.emit(pk.STREAM_FALLBACK, e3.stream_id, 1 === e3.stream_type ? "fallback" : "recover");
          }), this._gateway.signal.on(_k.ON_PUBLISH_STREAM, (e3) => {
            this.uid === this._uid && (this._p2pChannel.reportPublishEvent(true, null, void 0, false, JSON.stringify({ proxy: e3.proxy })), JD.info("[".concat(this._clientId, "] on publish stream, ").concat(JSON.stringify(e3))), AP("info", this, "publish_stream", e3));
          }), this._gateway.signal.on(_k.ENABLE_LOCAL_VIDEO, (e3) => {
            this._handleSetStreamLocalEnable("video", e3.uid, true);
          }), this._gateway.signal.on(_k.DISABLE_LOCAL_VIDEO, (e3) => {
            this._handleSetStreamLocalEnable("video", e3.uid, false);
          }), this._gateway.signal.on(fk.REQUEST_TIMEOUT, (e3, t3) => {
            if (this._joinInfo)
              switch (e3) {
                case mk.PUBLISH: {
                  if (!t3)
                    return;
                  const e4 = (t3 = t3).ortc;
                  if (e4) {
                    var i3, r3, n3, o3;
                    const s3 = e4.some((e5) => {
                      let { stream_type: t4 } = e5;
                      return t4 === qk.Audio;
                    }), a3 = e4.some((e5) => {
                      let { stream_type: t4 } = e5;
                      return t4 !== qk.Audio;
                    }), c3 = e4.some((e5) => {
                      let { stream_type: t4 } = e5;
                      return t4 === qk.Screen || t4 === qk.ScreenLow;
                    });
                    "offer" === t3.state && pj.publish(this._joinInfo.sid, { eventElapse: zG.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: false, ec: xD.TIMEOUT, audio: s3, video: a3, p2pid: t3.p2p_id, publishRequestid: this.store.pubId, screenshare: c3, audioName: s3 ? null === (i3 = e4.find((e5) => {
                      let { stream_type: t4 } = e5;
                      return t4 === qk.Audio;
                    })) || void 0 === i3 || null === (r3 = i3.ssrcs[0]) || void 0 === r3 ? void 0 : r3.ssrcId.toString() : void 0, videoName: a3 ? null === (n3 = e4.find((e5) => {
                      let { stream_type: t4 } = e5;
                      return t4 !== qk.Audio;
                    })) || void 0 === n3 || null === (o3 = n3.ssrcs[0]) || void 0 === o3 ? void 0 : o3.ssrcId.toString() : void 0 });
                  }
                  break;
                }
                case mk.SUBSCRIBE:
                  (t3 = t3) && pj.subscribe(this._joinInfo.sid, { succ: false, ec: xD.TIMEOUT, audio: t3.stream_type === AB.AUDIO, video: t3.stream_type === AB.VIDEO, peerid: t3.stream_id, subscribeRequestid: t3.ssrcId, p2pid: this.store.p2pId, eventElapse: zG.measureFromSubscribeStart(this.store.clientId, t3.ssrcId) });
              }
          }), this._gateway.signal.on(_k.ON_P2P_OK, (e3) => {
            this.uid, this._uid;
          }), this._gateway.signal.on(_k.ON_PUBLISHED_USER_LIST, (e3) => {
            if (null == e3 || !e3.users)
              return;
            const t3 = [], i3 = [];
            for (const r3 of e3.users) {
              let e4 = this._users.find((e5) => e5.uid === r3.stream_id);
              e4 ? e4._trust_in_room_ = true : (e4 = new lz(r3.stream_id, r3.stream_id), this._users.push(e4), 0 === this.getListeners(pk.PUBLISHED_USER_LIST).length && (JD.debug("[".concat(this._clientId, "] user online"), r3.stream_id), lP("info", this, "user-joined", { uid: r3.stream_id }), this.emit(pk.USER_JOINED, e4)));
              const n3 = zk.Audio & r3.stream_type, o3 = (zk.Video | zk.LwoVideo) & r3.stream_type, s3 = n3 && e4.hasAudio, a3 = o3 && e4.hasVideo;
              o3 && (e4._trust_video_stream_added_state_ = true, e4._video_added_ = true, e4._videoSSRC = r3.video_ssrc), n3 && (e4._trust_audio_stream_added_state_ = true, e4._audio_added_ = true, e4._audioSSRC = r3.audio_ssrc), n3 && !s3 && 0 === this.getListeners(pk.PUBLISHED_USER_LIST).length && (JD.info("[".concat(this._clientId, "] remote user ").concat(e4.uid, " published audio")), hP("info", this, "remote user ".concat(e4.uid, " published audio")), this.emit(pk.USER_PUBLISHED, e4, "audio")), o3 && !a3 && 0 === this.getListeners(pk.PUBLISHED_USER_LIST).length && (JD.info("[".concat(this._clientId, "] remote user ").concat(e4.uid, " published video")), hP("info", this, "remote user ".concat(e4.uid, " published video")), this.emit(pk.USER_PUBLISHED, e4, "video")), (n3 && !s3 || o3 && !a3) && t3.push(e4), o3 && this._p2pChannel.hasPendingRemoteMedia(e4, "video") && i3.push({ user: e4, mediaType: "video" }), n3 && this._p2pChannel.hasPendingRemoteMedia(e4, "audio") && i3.push({ user: e4, mediaType: "audio" });
            }
            i3.length > 0 && (JD.debug("[".concat(this._clientId, "] RE massSubscribe after reconnect ").concat(i3.map((e4) => "user: ".concat(e4.user.uid, ", mediaType: ").concat(e4.mediaType)).join("; "), " ")), this.massSubscribe(i3).catch((e4) => {
              JD.error("[".concat(this._clientId, "] mass resubscribe error"), e4.toString());
            })), this.getListeners(pk.PUBLISHED_USER_LIST).length > 0 ? (JD.info("[".concat(this._clientId, "] client emit user-list event, users: ").concat(t3.map((e4) => e4.uid).join(", "))), this.emit(pk.PUBLISHED_USER_LIST, t3)) : JD.info("[".concat(this._clientId, "] client not emit user-list event case there is no user-list listener, users: ").concat(t3.map((e4) => e4.uid).join(", ")));
          });
        }
        _handleP2PChannelEvents() {
          this._p2pChannel.on(gB.RequestMuteLocal, async (e3, t3, i3) => {
            if (this._joinInfo)
              try {
                await this._gateway.muteLocal(e3, this._joinInfo.stringUid || this._joinInfo.uid), t3();
              } catch (e4) {
                e4.code === xD.DISCONNECT_P2P ? t3() : i3(e4);
              }
            else
              t3();
          }), this._p2pChannel.on(gB.RequestUnmuteLocal, async (e3, t3, i3) => {
            if (this._joinInfo)
              try {
                await this._gateway.unmuteLocal(e3, this._joinInfo.stringUid || this._joinInfo.uid), t3();
              } catch (e4) {
                e4.code === xD.DISCONNECT_P2P ? t3() : i3(e4);
              }
            else
              t3();
          }), this._p2pChannel.on(gB.RequestRePublish, (e3, t3, i3) => {
            this.publish(e3, false).then(t3).catch(i3);
          }), this._p2pChannel.on(gB.RequestReSubscribe, async (e3, t3, i3) => {
            try {
              for (const { user: t4, kind: i4 } of e3)
                i4 === AB.VIDEO ? await this.subscribe(t4, "video") : await this.subscribe(t4, "audio");
              t3();
            } catch (e4) {
              i3(e4);
            }
          }), this._p2pChannel.on(gB.RequestUploadStats, (e3, t3) => {
            this._gateway.uploadStats(e3, t3);
          }), this._p2pChannel.on(gB.MediaReconnectStart, (e3) => {
            this.emit(pk.MEDIA_RECONNECT_START, e3);
          }), this._p2pChannel.on(gB.MediaReconnectEnd, (e3) => {
            this.emit(pk.MEDIA_RECONNECT_END, e3);
          }), this._p2pChannel.on(gB.NeedSignalRTT, (e3) => {
            e3(this._gateway.getSignalRTT());
          }), this._p2pChannel.on(gB.RequestRestartICE, async () => {
            const e3 = await this._p2pChannel.restartICE(), t3 = await e3.next();
            if (t3.done)
              return;
            const i3 = t3.value;
            let r3;
            try {
              r3 = await this._gateway.restartICE({ iceParameters: i3 });
            } catch (t4) {
              return void e3.throw(t4);
            }
            const { iceParameters: n3 } = function(e4) {
              const t4 = e4.iceParameters;
              return { iceParameters: { iceUfrag: t4.iceUfrag, icePwd: t4.icePwd } };
            }(r3);
            await e3.next({ remoteIceParameters: n3 });
          }), this._p2pChannel.on(gB.RequestReconnect, async () => {
            this._gateway.reconnect();
          }), this._p2pChannel.on(gB.RequestReconnectPC, async () => {
            var e3;
            const { iceParameters: t3, dtlsParameters: i3, rtpCapabilities: r3 } = await this._p2pChannel.startP2PConnection({ turnServer: null === (e3 = this._joinInfo) || void 0 === e3 ? void 0 : e3.turnServer }), { gatewayEstablishParams: n3, gatewayAddress: o3 } = await this._gateway.reconnectPC({ iceParameters: t3, dtlsParameters: i3, rtpCapabilities: r3 }), { dtlsParameters: s3, iceParameters: a3, candidates: c3, rtpCapabilities: d3, setup: u3, cname: h3 } = X$(n3, o3);
            await this._p2pChannel.connect(a3, s3, c3, d3, u3, h3), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe();
          }), this._p2pChannel.on(gB.RequestUnpublishForReconnectPC, async (e3, t3, i3) => {
            this._joinInfo && void 0 !== this._uid ? (await this._gateway.unpublish(e3, this._uid), t3()) : i3();
          }), this._p2pChannel.on(gB.P2PLost, () => {
            this.emit(pk.P2P_LOST, this.store.uid);
          }), this._p2pChannel.on(gB.UpdateVideoEncoder, (e3) => {
            e3._encoderConfig && this._gateway.setVideoProfile(e3._encoderConfig);
          }), this._p2pChannel.on(gB.ConnectionTypeChange, (e3) => {
            this.emit(pk.IS_USING_CLOUD_PROXY, e3);
          }), this._p2pChannel.on(gB.RequestLowStreamParameter, (e3) => {
            e3(this._lowStreamParameter || { width: 160, height: 120, framerate: 15, bitrate: 50 });
          }), this._p2pChannel.on(gB.QueryClientConnectionState, (e3) => {
            e3(this.connectionState);
          });
        }
        getKeyMetrics() {
          return this.store.keyMetrics;
        }
        async enableContentInspect(e3) {
          if ("CONNECTED" !== this.connectionState || !this._joinInfo)
            throw new QD(xD.INVALID_OPERATION, "[".concat(this._clientId, "] Client did not join channel"));
          if (this._inspect)
            throw new QD(xD.INVALID_OPERATION, "[".concat(this._clientId, "] Inspect content service already in connecting/connected state"));
          if (!e3)
            throw new QD(xD.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig is necessary"));
          if (!e3.inspectType || !Array.isArray(e3.inspectType))
            throw new QD(xD.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.inspectType is necessary and is an instance of Array."));
          {
            const t3 = [...new Set(e3.inspectType)];
            t3.forEach((e4) => {
              if (!["supervise", "moderation"].includes(e4))
                throw new QD(xD.INVALID_PARAMS, "[".concat(this._clientId, "] ").concat(e4, " is not a valid inspect type."));
            }), e3.inspectType = t3;
          }
          if (e3 && e3.extraInfo && e3.extraInfo.length > 1024)
            throw new QD(xD.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.extraInfo length cannot exceed 1024 bytes"));
          try {
            const t3 = new I2(e3);
            this._inspect = t3, this.handleVideoInspectEvents(this._inspect), await t3.init({ appId: this._joinInfo.appId, areaCode: "", cname: this._joinInfo.cname, sid: this._joinInfo.sid, token: this._joinInfo.token, uid: this._joinInfo.uid, cid: this._joinInfo.cid, vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0 }, FD);
          } catch (e4) {
            throw Array.isArray(e4) ? e4[0] : e4;
          }
        }
        async disableContentInspect() {
          if (!this._inspect)
            throw new QD(xD.INVALID_OPERATION, "[".concat(this._clientId, "] inspectVideoContent not started"));
          try {
            this._inspect.close(), this._inspect = void 0;
          } catch (e3) {
            throw Array.isArray(e3) ? e3[0] : e3;
          }
        }
        handleVideoInspectEvents(e3) {
          e3.on(SB.CONNECTION_STATE_CHANGE, (t3, i3) => {
            switch (this.emit(pk.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t3, i3), i3) {
              case _B.CONNECTED:
                if ("CONNECTED" !== this.connectionState)
                  return void this.emit(pk.CONTENT_INSPECT_ERROR, new QD(xD.OPERATION_ABORTED, "Content inspect was cancelled because it left the channel"));
                e3.inspectImage();
            }
          }), e3.on(SB.INSPECT_RESULT, (e4, t3) => {
            var i3;
            if ((null == t3 ? void 0 : t3.code) === xD.INVALID_OPERATION && "DISCONNECTED" === this.connectionState)
              return JD.debug("Stop inspect content because that has left channel"), null == this || null === (i3 = this._inspect) || void 0 === i3 || i3.close(), void (this._inspect = void 0);
            this.emit(pk.CONTENT_INSPECT_RESULT, e4, t3);
          }), e3.on(SB.CLIENT_LOCAL_VIDEO_TRACK, (e4) => {
            e4(this.localTracks.filter((e5) => "video" === e5.trackMediaType)[0]);
          });
        }
        getJoinChannelServiceRecords() {
          return JD.debug("getJoinChannelServiceRecords"), this.store.joinChannelServiceRecords;
        }
        async setPublishAudioFilterEnabled(e3) {
          BL(e3, "enabled"), PP("ENABLE_PUBLISH_AUDIO_FILTER", e3), this._joinInfo && await this._gateway.setPublishAudioFilterEnabled(e3);
        }
        _handleResetAddStream(e3, t3) {
          switch (t3) {
            case "audio":
              e3._audio_added_ = false, e3._trust_audio_stream_added_state_ = true;
              break;
            case "video":
              e3._video_added_ = false, e3._trust_video_stream_added_state_ = true;
          }
        }
      }).prototype, "setProxyServer", [C2], Object.getOwnPropertyDescriptor(L2.prototype, "setProxyServer"), L2.prototype), VV(L2.prototype, "setTurnServer", [S2], Object.getOwnPropertyDescriptor(L2.prototype, "setTurnServer"), L2.prototype), VV(L2.prototype, "setLicense", [v2], Object.getOwnPropertyDescriptor(L2.prototype, "setLicense"), L2.prototype), VV(L2.prototype, "setLocalAccessPointsV2", [T2], Object.getOwnPropertyDescriptor(L2.prototype, "setLocalAccessPointsV2"), L2.prototype), VV(L2.prototype, "setLocalAccessPoints", [R2], Object.getOwnPropertyDescriptor(L2.prototype, "setLocalAccessPoints"), L2.prototype), VV(L2.prototype, "setRemoteDefaultVideoStreamType", [y2], Object.getOwnPropertyDescriptor(L2.prototype, "setRemoteDefaultVideoStreamType"), L2.prototype), VV(L2.prototype, "pickSVCLayer", [w2], Object.getOwnPropertyDescriptor(L2.prototype, "pickSVCLayer"), L2.prototype), VV(L2.prototype, "enableContentInspect", [b2], Object.getOwnPropertyDescriptor(L2.prototype, "enableContentInspect"), L2.prototype), VV(L2.prototype, "disableContentInspect", [N2], Object.getOwnPropertyDescriptor(L2.prototype, "disableContentInspect"), L2.prototype), VV(L2.prototype, "getJoinChannelServiceRecords", [O2], Object.getOwnPropertyDescriptor(L2.prototype, "getJoinChannelServiceRecords"), L2.prototype), VV(L2.prototype, "setPublishAudioFilterEnabled", [D2], Object.getOwnPropertyDescriptor(L2.prototype, "setPublishAudioFilterEnabled"), L2.prototype), P2 = L2)) || P2);
      class U2 extends Lj {
        set currentState(e3) {
          e3 !== this._currentState && (this._currentState = e3, this.emit(Sk.AUDIO_SOURCE_STATE_CHANGE, this._currentState));
        }
        get currentState() {
          return this._currentState;
        }
        constructor(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          super(), MN(this, "audioBuffer", void 0), MN(this, "sourceNode", void 0), MN(this, "startPlayTime", 0), MN(this, "startPlayOffset", 0), MN(this, "pausePlayTime", 0), MN(this, "options", void 0), MN(this, "currentLoopCount", 0), MN(this, "_currentState", "stopped"), this.audioBuffer = e3, this.options = t3, this.startPlayOffset = this.options.startPlayTime || 0;
        }
        createWebAudioDiagram() {
          return this.context.createGain();
        }
        get duration() {
          return this.audioBuffer.duration;
        }
        get currentTime() {
          return "stopped" === this.currentState ? 0 : "paused" === this.currentState ? this.pausePlayTime : (this.context.currentTime - this.startPlayTime + this.startPlayOffset) % this.audioBuffer.duration;
        }
        updateOptions(e3) {
          "stopped" === this.currentState ? (this.options = e3, this.startPlayOffset = this.options.startPlayTime || 0) : JD.warning("can not set audio source options");
        }
        startProcessAudioBuffer() {
          this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = "playing";
        }
        pauseProcessAudioBuffer() {
          this.sourceNode && "playing" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = "paused");
        }
        seekAudioBuffer(e3) {
          this.sourceNode && (this.sourceNode.onended = null, "playing" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), "playing" === this.currentState ? (this.startPlayOffset = e3, this.startSourceNode()) : "paused" === this.currentState && (this.pausePlayTime = e3));
        }
        resumeProcessAudioBuffer() {
          "paused" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = "playing");
        }
        stopProcessAudioBuffer() {
          if (this.sourceNode) {
            this.sourceNode.onended = null;
            try {
              this.sourceNode.stop();
            } catch (e3) {
            }
            this.reset();
          }
        }
        startSourceNode() {
          this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));
        }
        createSourceNode() {
          const e3 = this.context.createBufferSource();
          return e3.buffer = this.audioBuffer, e3.loop = !!this.options.loop, e3.connect(this.outputNode), e3;
        }
        handleSourceNodeEnded() {
          if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount)
            return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();
          this.reset();
        }
        reset() {
          this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = "stopped", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;
        }
      }
      const x2 = /* @__PURE__ */ new Map();
      async function Q2(e3, t3) {
        let i3 = null;
        if ("string" == typeof e3) {
          const t4 = x2.get(e3);
          if (t4)
            return JD.debug("use cached audio resource: ", e3), t4;
          try {
            i3 = (await jD(() => kD.get(e3, { responseType: "arraybuffer" }), void 0, void 0, { maxRetryCount: 3 })).data;
          } catch (e4) {
            throw new QD(xD.FETCH_AUDIO_FILE_FAILED, e4.toString());
          }
        } else {
          const t4 = new l_((t5, i4) => {
            const r4 = new FileReader();
            r4.onload = (e4) => {
              e4.target ? t5(e4.target.result) : i4(new QD(xD.READ_LOCAL_AUDIO_FILE_ERROR));
            }, r4.onerror = () => {
              i4(new QD(xD.READ_LOCAL_AUDIO_FILE_ERROR));
            }, r4.readAsArrayBuffer(e3);
          });
          i3 = await t4;
        }
        const r3 = await function(e4) {
          const t4 = yj();
          return new l_((i4, r4) => {
            t4.decodeAudioData(e4, (e5) => {
              i4(e5);
            }, (e5) => {
              r4(new QD(xD.DECODE_AUDIO_FILE_FAILED, e5.toString()));
            });
          });
        }(i3);
        return "string" == typeof e3 && t3 && x2.set(e3, r3), r3;
      }
      function F2(e3, t3) {
        var i3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), i3.push.apply(i3, r3);
        }
        return i3;
      }
      function V2(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? F2(Object(i3), true).forEach(function(t4) {
            MN(e3, t4, i3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : F2(Object(i3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
          });
        }
        return e3;
      }
      function j2(e3, t3, i3, r3) {
        i3.optimizationMode && (r3 && r3.width && r3.height ? (i3.encoderConfig = V2(V2({}, r3), {}, { bitrateMin: r3.bitrateMin, bitrateMax: r3.bitrateMax }), "motion" !== i3.optimizationMode && "detail" !== i3.optimizationMode || (t3.contentHint = i3.optimizationMode, t3.contentHint === i3.optimizationMode ? (JD.debug("[".concat(e3, "] set content hint to"), i3.optimizationMode), fP("debug", ["AgoraRTC"], "videoTrackOptimizationModeProcess", [e3, i3, r3])) : (JD.debug("[".concat(e3, "] set content hint failed")), fP("warning", ["AgoraRTC"], "videoTrackOptimizationModeProcess", [e3, i3, r3], "failed")))) : (JD.warning("[".concat(e3, "] can not apply optimization mode bitrate config, no encoderConfig")), hP("warning", ["AgoraRTC"], "[".concat(e3, "] can not apply optimization mode bitrate config, no encoderConfig"))));
      }
      const G2 = oN().name;
      function K2(e3, t3, i3, r3) {
        let n3, o3 = 0, s3 = null;
        return new l_((a3, c3) => {
          setTimeout(() => {
            n3 && (n3(), a3(o3));
          }, t3), n3 = Nj(() => {
            !function() {
              o3 > r3 && n3 && (n3(), a3(o3));
              const t4 = i3.getContext("2d");
              if (!t4) {
                const e4 = new QD(xD.UNEXPECTED_ERROR, "can not get canvas 2d context.");
                return JD.error(e4.toString()), void c3(e4);
              }
              t4.drawImage(e3, 0, 0, 160, 120);
              const d3 = t4.getImageData(0, 0, i3.width, i3.height), u3 = Math.floor(d3.data.length / 3);
              if (s3) {
                for (let e4 = 0; e4 < u3; e4 += 3)
                  if (d3.data[e4] !== s3[e4])
                    return o3 += 1, void (s3 = d3.data);
                s3 = d3.data;
              } else
                s3 = d3.data;
            }();
          }, 30);
        });
      }
      class H2 {
        constructor(e3, t3) {
          MN(this, "id", 0), MN(this, "element", void 0), MN(this, "peerPair", void 0), MN(this, "context", void 0), MN(this, "audioPlayerElement", void 0), MN(this, "audioTrack", void 0), H2.count += 1, this.id = H2.count, this.element = e3, this.context = t3;
        }
        initPeers() {
          this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()], this.peerPair[1].ontrack = (e3) => {
            const t3 = document.createElement("audio");
            t3.srcObject = new MediaStream([e3.track]), t3.play(), this.audioPlayerElement = t3;
          };
        }
        async switchSdp() {
          if (!this.peerPair)
            return;
          const e3 = async (e4, t4) => {
            const i3 = "offer" === t4 ? await e4.createOffer() : await e4.createAnswer();
            return await e4.setLocalDescription(i3), "complete" === e4.iceGatheringState ? e4.localDescription : new l_((t5) => {
              e4.onicegatheringstatechange = () => {
                "complete" === e4.iceGatheringState && t5(e4.localDescription);
              };
            });
          }, t3 = async (e4, t4) => await e4.setRemoteDescription(t4);
          try {
            const i3 = await e3(this.peerPair[0], "offer");
            await t3(this.peerPair[1], i3);
            const r3 = await e3(this.peerPair[1], "answer");
            await t3(this.peerPair[0], r3);
          } catch (e4) {
            throw new QD(xD.LOCAL_AEC_ERROR, e4.toString()).print();
          }
        }
        async getTracksFromMediaElement(e3) {
          if (this.audioTrack)
            return this.audioTrack;
          let t3;
          try {
            e3 instanceof HTMLVideoElement && (e3.captureStream ? e3.captureStream() : e3.mozCaptureStream()), t3 = this.context.createMediaStreamDestination();
            this.context.createMediaElementSource(e3).connect(t3);
          } catch (e4) {
            throw new QD(xD.LOCAL_AEC_ERROR, e4.toString()).print();
          }
          if (!t3) {
            throw new QD(xD.LOCAL_AEC_ERROR, "no dest node when local aec").print();
          }
          const i3 = t3.stream.getAudioTracks()[0];
          return this.audioTrack = i3, i3;
        }
        getElement() {
          return this.element;
        }
        async startEchoCancellation() {
          this.context.resume(), this.peerPair && this.close(), this.initPeers();
          const e3 = this.element, t3 = await this.getTracksFromMediaElement(e3);
          this.peerPair && this.peerPair[0].addTrack(t3), await this.switchSdp();
        }
        close() {
          JD.debug("close echo cancellation unit, id is", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach((e3) => {
            e3.close();
          }), this.peerPair = void 0, this.audioPlayerElement = void 0;
        }
      }
      var W2, Y2;
      MN(H2, "count", 0);
      const J2 = window.AudioContext || window.webkitAudioContext;
      const q2 = new (W2 = Aj({ report: pj }), VV((Y2 = class {
        constructor() {
          MN(this, "units", []), MN(this, "context", void 0);
        }
        processExternalMediaAEC(e3) {
          if (!this._doesEnvironmentNeedAEC())
            return JD.debug("the system does not need to process local aec"), -1;
          this.context || (this.context = new J2());
          let t3 = this.units.find((t4) => t4 && t4.getElement() === e3);
          return t3 || (t3 = new H2(e3, this.context), this.units.push(t3)), t3.startEchoCancellation(), JD.debug("start processing local audio echo cancellation, id is", t3.id), t3.id;
        }
        _doesEnvironmentNeedAEC() {
          return oN().name !== tN.SAFARI;
        }
      }).prototype, "processExternalMediaAEC", [W2], Object.getOwnPropertyDescriptor(Y2.prototype, "processExternalMediaAEC"), Y2.prototype), Y2)();
      PP("PROCESS_ID", "process-".concat(mK(8, ""), "-").concat(mK(4, ""), "-").concat(mK(4, ""), "-").concat(mK(4, ""), "-").concat(mK(12, ""))), function() {
        const e3 = oN();
        yB.getDisplayMedia = function(e4) {
          if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia)
            return true;
          return false;
        }(), yB.getStreamFromExtension = e3.name === tN.CHROME && Number(e3.version) > 34, yB.supportUnifiedPlan = function() {
          if (!window.RTCRtpTransceiver)
            return false;
          if (!("currentDirection" in RTCRtpTransceiver.prototype))
            return false;
          const e4 = new RTCPeerConnection();
          let t3 = false;
          try {
            e4.addTransceiver("audio"), t3 = true;
          } catch (e5) {
          }
          return e4.close(), t3;
        }(), yB.supportMinBitrate = e3.name === tN.CHROME || e3.name === tN.EDGE, yB.supportSetRtpSenderParameters = function() {
          const e4 = oN();
          if (!window.RTCRtpSender || !window.RTCRtpSender.prototype.setParameters || !window.RTCRtpSender.prototype.getParameters)
            return false;
          return !!yN() || (!(!pN() && !uN()) || e4.name === tN.FIREFOX && Number(e4.version) >= 64);
        }(), e3.name === tN.SAFARI && (Number(e3.version) >= 14 ? yB.supportDualStream = true : yB.supportDualStream = false), yB.webAudioMediaStreamDest = function() {
          const e4 = oN();
          if (e4.name === tN.SAFARI && Number(e4.version) < 12)
            return false;
          return true;
        }(), yB.supportReplaceTrack = function() {
          if (!window.RTCRtpSender)
            return false;
          if ("function" == typeof RTCRtpSender.prototype.replaceTrack)
            return true;
          return false;
        }(), yB.supportWebGL = "undefined" != typeof WebGLRenderingContext, yB.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, yN() || (yB.webAudioWithAEC = true), yB.supportShareAudio = function() {
          const e4 = oN();
          if ((e4.os === eN.WIN_10 || e4.os === eN.WIN_81 || e4.os === eN.WIN_7 || e4.os === eN.LINUX || e4.os === eN.MAC_OS) && e4.name === tN.CHROME && Number(e4.version) >= 74)
            return true;
          return false;
        }(), yB.supportDualStreamEncoding = function() {
          const e4 = oN();
          return "Safari" === e4.name && Number(e4.version) >= 14 || !!("Chrome" === e4.name && /Windows/i.test(e4.os || "") && Number(e4.version) >= 100 && LP("CHROME_DUAL_STREAM_USE_ENCODING"));
        }(), yB.supportDataChannel = function() {
          if (function(e4) {
            const t3 = oN();
            return !(t3.name !== tN.CHROME || !t3.osVersion) && Number(t3.version) >= e4;
          }(76) || function(e4) {
            const t3 = oN();
            return !(t3.name !== tN.FIREFOX || !t3.osVersion) && Number(t3.version) >= e4;
          }(68) || function(e4) {
            const t3 = oN();
            return !(t3.name !== tN.SAFARI || !t3.osVersion) && Number(t3.version) >= e4;
          }(14))
            return true;
          return false;
        }(), JD.info("browser compatibility", JSON.stringify(yB), JSON.stringify(e3)), gP("info", [], "updateAgoraRTCCompatibility", { browserCompatibility: yB, browserInfo: e3 });
      }(), function() {
        let e3;
        try {
          e3 = window.localStorage.getItem("websdk_ng_global_parameter");
        } catch (e4) {
          return void JD.error("Error loading sdk config", e4.message);
        }
        if (e3)
          try {
            const t3 = JSON.parse(window.atob(e3)), i3 = Date.now();
            JD.debug("Loading global parameters from cache", t3), gP("debug", [], "loadConfigFromLocalStorage", t3), Object.keys(t3).forEach((e4) => {
              if (Object.prototype.hasOwnProperty.call(kP, e4)) {
                const { value: r3, expires: n3 } = t3[e4];
                if (n3 && n3 <= i3)
                  return;
                BP[e4] = r3, kP[e4] = r3;
              }
            });
          } catch (t3) {
            JD.error("Error loading mutableParamsCache: ".concat(e3), t3.message);
          }
      }();
      const X2 = { __CLIENT_LIST__: VP, __TRACK_LIST__: jP, VERSION: CP, BUILD: _P, setParameter: PP, getParameter: LP, getSupportedCodec: async function() {
        let e3 = { audio: [], video: [] };
        try {
          let t3 = new RTCPeerConnection();
          t3.addTransceiver("video", { direction: "recvonly" }), t3.addTransceiver("audio", { direction: "recvonly" });
          const i3 = (await t3.createOffer()).sdp;
          if (!i3)
            return e3;
          t3.close(), t3 = null, e3 = function(e4) {
            const t4 = { video: [], audio: [] };
            return e4.match(/ VP8/i) && t4.video.push("VP8"), e4.match(/ VP9/i) && t4.video.push("VP9"), e4.match(/ AV1/i) && t4.video.push("AV1"), e4.match(/ H264/i) && t4.video.push("H264"), e4.match(/ opus/i) && t4.audio.push("OPUS"), e4.match(/ PCMU/i) && t4.audio.push("PCMU"), e4.match(/ PCMA/i) && t4.audio.push("PCMA"), e4.match(/ G722/i) && t4.audio.push("G722"), t4;
          }(i3);
        } catch (e4) {
          throw new QD(xD.CREATE_OFFER_FAILED, e4.toString && e4.toString()).print();
        }
        return e3;
      }, checkSystemRequirements: function() {
        const e3 = pj.reportApiInvoke(null, { name: rk.CHECK_SYSTEM_REQUIREMENTS, options: [], tag: nk.TRACER });
        let t3 = false;
        try {
          const e4 = window.RTCPeerConnection, i4 = navigator.mediaDevices && navigator.mediaDevices.getUserMedia, r4 = window.WebSocket;
          t3 = !!(e4 && i4 && r4);
        } catch (e4) {
          return JD.error("check system requirement failed: ", e4), false;
        }
        let i3 = false;
        const r3 = oN();
        r3.name === tN.CHROME && Number(r3.version) >= 58 && (!AN() || hN()) && (i3 = true), r3.name === tN.FIREFOX && Number(r3.version) >= 56 && (i3 = true), r3.name === tN.OPERA && Number(r3.version) >= 45 && (i3 = true), r3.name === tN.SAFARI && Number(r3.version) >= 11 && (i3 = true), (TN() || oN().name === tN.QQ) && (i3 = true), JD.debug("checkSystemRequirements, api:", t3, "browser", i3);
        const n3 = t3 && i3;
        return e3.onSuccess(n3), n3;
      }, getDevices: function(e3) {
        return Yj.enumerateDevices(true, true, e3);
      }, getMicrophones: function(e3) {
        return Yj.getRecordingDevices(e3);
      }, getCameras: function(e3) {
        return Yj.getCamerasDevices(e3);
      }, getElectronScreenSources: Uj, getPlaybackDevices: function(e3) {
        return Yj.getSpeakers(e3);
      }, createClient: function() {
        let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { codec: "vp8", audioCodec: "opus", mode: "rtc" };
        const t3 = pj.reportApiInvoke(null, { name: rk.CREATE_CLIENT, options: [e3], tag: nk.TRACER });
        try {
          Tk(e3);
        } catch (e4) {
          throw t3.onError(e4), e4;
        }
        return void 0 === e3.audioCodec && (e3.audioCodec = "opus"), t3.onSuccess(), new M2(B2(B2({ forceWaitGatewayResponse: true }, e3), {}, { role: "rtc" === e3.mode ? "host" : e3.role }));
      }, createCameraVideoTrack: async function() {
        let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { encoderConfig: "480p_1" };
        const t3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.CREATE_CAM_VIDEO_TRACK, options: [V2({}, e3)] }), i3 = DX(e3), r3 = mK(8, "track-cam-");
        let n3 = null;
        JD.info("start create camera video track with config", JSON.stringify(e3), "trackId", r3), fP("info", ["AgoraRTC"], "createCameraVideoTrack", e3);
        try {
          n3 = (await Gj({ video: i3 }, r3)).getVideoTracks()[0] || null;
        } catch (e4) {
          throw t3.onError(e4), e4;
        }
        if (!n3) {
          const e4 = new QD(xD.UNEXPECTED_ERROR, "can not find track in media stream");
          return t3.onError(e4), e4.throw();
        }
        e3.optimizationMode && j2(r3, n3, e3, e3.encoderConfig && wP(e3.encoderConfig));
        const o3 = new Az(n3, e3, i3, e3.scalabiltyMode ? NP(e3.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e3.optimizationMode, r3);
        return t3.onSuccess(o3.getTrackId()), JD.info("create camera video success, trackId:", r3), fP("info", ["AgoraRTC"], "createCameraVideoTrack", void 0, r3), o3;
      }, createCustomVideoTrack: function(e3) {
        const t3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.CREATE_CUSTOM_VIDEO_TRACK, options: [e3] }), i3 = new hz(e3.mediaStreamTrack, { bitrateMax: e3.bitrateMax, bitrateMin: e3.bitrateMin }, e3.scalabiltyMode ? NP(e3.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e3.optimizationMode);
        return t3.onSuccess(i3.getTrackId()), JD.info("create custom video track success with config", e3, "trackId", i3.getTrackId()), fP("info", ["AgoraRTC"], "createCustomVideoTrack", e3, i3.getTrackId()), i3;
      }, createScreenVideoTrack: async function() {
        let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "disable";
        const i3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.CREATE_SCREEN_VIDEO_TRACK, options: [V2({}, e3), t3] });
        e3.encoderConfig ? "string" == typeof e3.encoderConfig || e3.encoderConfig.width && e3.encoderConfig.height || (e3.encoderConfig.width = { max: 1920 }, e3.encoderConfig.height = { max: 1080 }) : e3.encoderConfig = "1080p_2";
        const r3 = PX(e3), n3 = mK(8, "track-scr");
        let o3 = null, s3 = null;
        const a3 = wB();
        if (!a3.supportShareAudio && "enable" === t3) {
          const e4 = new QD(xD.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio");
          return i3.onError(e4), e4.throw();
        }
        JD.info("start create screen video track with config", e3, "withAudio", t3, "trackId", n3), fP("info", ["AgoraRTC"], "createScreenVideoTrack", [e3, t3]);
        try {
          const e4 = await Gj({ screen: r3, screenAudio: "auto" === t3 ? a3.supportShareAudio : "enable" === t3 }, n3);
          o3 = e4.getVideoTracks()[0] || null, s3 = e4.getAudioTracks()[0] || null;
        } catch (e4) {
          throw i3.onError(e4), e4;
        }
        if (!o3) {
          const e4 = new QD(xD.UNEXPECTED_ERROR, "can not find track in media stream");
          return i3.onError(e4), e4.throw();
        }
        if (!s3 && "enable" === t3) {
          o3 && o3.stop();
          const e4 = new QD(xD.SHARE_AUDIO_NOT_ALLOWED);
          return i3.onError(e4), e4.throw();
        }
        e3.optimizationMode || (e3.optimizationMode = "detail"), e3.optimizationMode && (j2(n3, o3, e3, e3.encoderConfig && bP(e3.encoderConfig)), e3.encoderConfig && "string" != typeof e3.encoderConfig && (e3.encoderConfig.bitrateMin = e3.encoderConfig.bitrateMax));
        const c3 = new hz(o3, e3.encoderConfig ? bP(e3.encoderConfig) : {}, e3.scalabiltyMode ? NP(e3.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e3.optimizationMode, n3, [$k.SCREEN_TRACK]);
        if (!s3)
          return i3.onSuccess(c3.getTrackId()), JD.info("create screen video track success", "video:", c3.getTrackId()), fP("info", ["AgoraRTC"], "createScreenVideoTrack", void 0, { videoTrack: c3.getTrackId() }), c3;
        const d3 = new HG(s3);
        return i3.onSuccess([c3.getTrackId(), d3.getTrackId()]), JD.info("create screen video track success", "video:", c3.getTrackId(), "audio:", d3.getTrackId()), fP("info", ["AgoraRTC"], "createScreenVideoTrack", void 0, { videoTrack: c3.getTrackId(), audioTrack: d3.getTrackId() }), [c3, d3];
      }, createMicrophoneAndCameraTracks: async function() {
        let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { encoderConfig: "480p_1" };
        const i3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.CREATE_MIC_AND_CAM_TRACKS, options: [e3, t3] }), r3 = DX(t3), n3 = LX(e3), o3 = mK(8, "track-mic-"), s3 = mK(8, "track-cam-");
        let a3 = null, c3 = null;
        JD.info("start create camera video track(".concat(s3, ") and microphone audio track(").concat(o3, ") with config, audio: ").concat(JSON.stringify(e3), ", video: ").concat(JSON.stringify(t3))), fP("info", ["AgoraRTC"], "createMicrophoneAndCameraTracks", { videoConfig: t3, audioConfig: e3 });
        try {
          const e4 = await Gj({ audio: n3, video: r3 }, "".concat(o3, "-").concat(s3));
          a3 = e4.getAudioTracks()[0], c3 = e4.getVideoTracks()[0];
        } catch (e4) {
          throw i3.onError(e4), e4;
        }
        if (!a3 || !c3) {
          const e4 = new QD(xD.UNEXPECTED_ERROR, "can not find tracks in media stream");
          return i3.onError(e4), e4.throw();
        }
        t3.optimizationMode && j2(s3, c3, t3, t3.encoderConfig && wP(t3.encoderConfig));
        const d3 = new WG(a3, e3, n3, o3), u3 = new Az(c3, t3, r3, t3.scalabiltyMode ? NP(t3.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t3.optimizationMode, s3);
        return i3.onSuccess([d3.getTrackId(), u3.getTrackId()]), JD.info("create camera video track(".concat(s3, ") and microphone audio track(").concat(o3, ") success")), fP("info", ["AgoraRTC"], "createMicrophoneAndCameraTracks", void 0, { videoTrackId: s3, audioTrackId: o3 }), [d3, u3];
      }, createMicrophoneAudioTrack: async function() {
        let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const t3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.CREATE_MIC_AUDIO_TRACK, options: [e3] }), i3 = LX(e3), r3 = mK(8, "track-mic-");
        let n3 = null;
        JD.info("start create microphone audio track with config", JSON.stringify(e3), "trackId", r3), fP("info", ["AgoraRTC"], "createMicrophoneAudioTrack", e3);
        try {
          n3 = (await Gj({ audio: i3 }, r3)).getAudioTracks()[0] || null;
        } catch (e4) {
          throw t3.onError(e4), e4;
        }
        if (!n3) {
          const e4 = new QD(xD.UNEXPECTED_ERROR, "can not find track in media stream");
          return t3.onError(e4), e4.throw();
        }
        const o3 = new WG(n3, e3, i3, r3);
        return t3.onSuccess(o3.getTrackId()), JD.info("create microphone audio track success, trackId:", r3), fP("info", ["AgoraRTC"], "createMicrophoneAudioTrack", e3, r3), o3;
      }, createCustomAudioTrack: function(e3) {
        const t3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.CREATE_CUSTOM_AUDIO_TRACK, options: [e3] }), i3 = new HG(e3.mediaStreamTrack, e3.encoderConfig ? DP(e3.encoderConfig) : {});
        return JD.info("create custom audio track success with config", e3, "trackId", i3.getTrackId()), fP("info", ["AgoraRTC"], "createCustomAudioTrack", e3, i3.getTrackId()), t3.onSuccess(i3.getTrackId()), i3;
      }, createBufferSourceAudioTrack: async function(e3) {
        const t3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.CREATE_BUFFER_AUDIO_TRACK, options: [e3] }), i3 = mK(8, "track-buf-");
        JD.info("start create buffer source audio track with config", JSON.stringify(e3), "trackId", i3), fP("info", [], "createBufferSourceAudioTrack", e3);
        const r3 = e3.source;
        if (!(e3.source instanceof AudioBuffer))
          try {
            e3.source = await Q2(e3.source, e3.cacheOnlineFile);
          } catch (e4) {
            return t3.onError(e4), e4.throw();
          }
        const n3 = new U2(e3.source), o3 = new YG(r3, n3, e3.encoderConfig ? DP(e3.encoderConfig) : {}, i3);
        return JD.info("create buffer source audio track success, trackId:", i3), fP("info", ["AgoraRTC"], "createBufferSourceAudioTrack", void 0, i3), t3.onSuccess(o3.getTrackId()), o3;
      }, setAppType: function(e3) {
        if (JD.debug("setAppType: ".concat(e3)), !(Number.isInteger(e3) && e3 >= 0))
          throw JD.debug("Invalid appType"), new QD(xD.INVALID_PARAMS, "invalid app type", e3);
        PP("APP_TYPE", Math.floor(e3));
      }, setLogLevel: function(e3) {
        LP("USE_NEW_LOG") ? function(e4) {
          e4 = Math.min(Math.max(0, e4), 4), tP = e4;
        }(e3) : JD.setLogLevel(e3);
      }, enableLogUpload: function() {
        LP("USE_NEW_LOG") ? PP("UPLOAD_LOG", true) : JD.enableLogUpload();
      }, disableLogUpload: function() {
        LP("USE_NEW_LOG") ? PP("UPLOAD_LOG", false) : JD.disableLogUpload();
      }, createChannelMediaRelayConfiguration: function() {
        return new Zq();
      }, checkAudioTrackIsActive: async function(e3) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        const i3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.CHECK_AUDIO_TRACK_IS_ACTIVE, options: [t3] });
        if (!(e3 instanceof HG || e3 instanceof z1)) {
          const e4 = new QD(xD.INVALID_TRACK, "the parameter is not a audio track");
          return i3.onError(e4), e4.throw();
        }
        t3 && t3 < 1e3 && (t3 = 1e3);
        const r3 = e3 instanceof HG ? e3.getTrackLabel() : "remote_track", n3 = e3.getVolumeLevel();
        let o3 = n3, s3 = n3;
        const a3 = Date.now();
        return new l_((n4) => {
          const c3 = setInterval(() => {
            const d3 = e3.getVolumeLevel();
            o3 = d3 > o3 ? d3 : o3, s3 = d3 < s3 ? d3 : s3;
            const u3 = o3 - s3 > 1e-4, h3 = Date.now() - a3;
            if (u3 || h3 > t3) {
              clearInterval(c3);
              const t4 = u3, s4 = { duration: h3, deviceLabel: r3, maxVolumeLevel: o3, result: t4 };
              JD.info("[track-".concat(e3.getTrackId(), "] check audio track active completed. ").concat(JSON.stringify(s4))), i3.onSuccess(s4), n4(t4);
            }
          }, 200);
        });
      }, checkVideoTrackIsActive: async function(e3) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        const i3 = pj.reportApiInvoke(null, { tag: nk.TRACER, name: rk.CHECK_VIDEO_TRACK_IS_ACTIVE, options: [t3] });
        if (!(e3 instanceof hz || e3 instanceof X1)) {
          const e4 = new QD(xD.INVALID_TRACK, "the parameter is not a video track");
          return i3.onError(e4), e4.throw();
        }
        const r3 = 4;
        t3 && t3 < 1e3 && (t3 = 1e3);
        const n3 = e3 instanceof hz ? e3.getTrackLabel() : "remote_track", o3 = e3.getMediaStreamTrack(true), s3 = document.createElement("video");
        s3.style.width = "1px", s3.style.height = "1px", s3.setAttribute("muted", ""), s3.muted = true, s3.setAttribute("playsinline", ""), s3.controls = false, (pN() || uN()) && (s3.style.opacity = "0.01", s3.style.position = "fixed", s3.style.left = "0", s3.style.top = "0", document.body.appendChild(s3)), s3.srcObject = new MediaStream([o3]), s3.play();
        const a3 = document.createElement("canvas");
        a3.width = 160, a3.height = 120;
        let c3 = 0, d3 = 0;
        try {
          const e4 = Date.now();
          c3 = await K2(s3, t3, a3, r3), d3 = Date.now() - e4;
        } catch (e4) {
          throw i3.onError(e4), e4;
        }
        G2 === tN.SAFARI && (s3.pause(), s3.remove()), s3.srcObject = null;
        const u3 = c3 > r3, h3 = { duration: d3, changedPicNum: c3, deviceLabel: n3, result: u3 };
        return JD.info("[track-".concat(e3.getTrackId(), "] check video track active completed. ").concat(JSON.stringify(h3))), i3.onSuccess(h3), u3;
      }, setArea: function(e3) {
        const t3 = pj.reportApiInvoke(null, { name: rk.SET_AREA, options: e3, tag: nk.TRACER });
        try {
          let t4 = [];
          if ("string" == typeof e3 && (t4 = [e3]), Array.isArray(e3) && (e3.forEach((e4) => {
            if (!aB.includes(e4))
              throw new QD(xD.INVALID_PARAMS, "invalid area code");
          }), t4 = e3), "[object Object]" === Object.prototype.toString.call(e3)) {
            const { areaCode: i4, excludedArea: r3 } = e3;
            if (!i4)
              throw new QD(xD.INVALID_PARAMS, "area code is needed");
            let n3 = i4;
            "string" == typeof i4 && (n3 = [i4]), t4 = r3 ? Lq(n3, r3) : n3;
          }
          PP("AREAS", t4);
          const i3 = ((e4) => {
            const t5 = { CODE: "", WEBCS_DOMAIN: [], WEBCS_DOMAIN_BACKUP_LIST: [], PROXY_CS: [], CDS_AP: [], ACCOUNT_REGISTER: [], UAP_AP: [], EVENT_REPORT_DOMAIN: [], EVENT_REPORT_BACKUP_DOMAIN: [], LOG_UPLOAD_SERVER: [], PROXY_SERVER_TYPE3: [] };
            return e4.map((e5) => {
              const i4 = dB[e5], r3 = Object.keys(i4);
              r3 && r3.map((e6) => {
                "CODE" !== e6 && (t5[e6] = t5[e6].concat(i4[e6]));
              });
            }), t5;
          })(t4);
          Object.keys(i3).map((e4) => {
            if ("LOG_UPLOAD_SERVER" === e4 || "EVENT_REPORT_DOMAIN" === e4 || "EVENT_REPORT_BACKUP_DOMAIN" === e4 || "PROXY_SERVER_TYPE3" === e4) {
              PP(e4, i3[e4][0]);
            } else
              PP(e4, i3[e4]);
          }), JD.debug("set area success:", t4.join(","));
        } catch (e4) {
          throw t3.onError(e4), e4;
        }
        t3.onSuccess();
      }, audioElementPlayCenter: zj, processExternalMediaAEC: function(e3) {
        q2.processExternalMediaAEC(e3);
      }, registerExtensions: function(e3) {
        e3.forEach((e4) => {
          const t3 = e4;
          t3.__registered__ = true, t3.logger.hookLog = JD.extLog, t3.reporter.hookApiInvoke = pj.extApiInvoke, t3.parameters && Object.keys(t3.parameters).forEach((e5) => {
            t3.parameters[e5] = LP(e5);
          });
        });
      }, ChannelMediaRelayError: Jk, ChannelMediaRelayEvent: Wk, ChannelMediaRelayState: Yk, RemoteStreamFallbackType: tB, RemoteStreamType: eB, ConnectionDisconnectedReason: lk, AudienceLatencyLevelType: Ak, AREAS: nB }, z2 = window || document;
      return Object.defineProperties(X2, { onAudioAutoplayFailed: { get: () => nj.onAudioAutoplayFailed, set: (e3) => {
        nj.onAudioAutoplayFailed = e3;
      } }, onAutoplayFailed: { get: () => nj.onAutoplayFailed, set: (e3) => {
        nj.onAutoplayFailed = e3;
      } }, _onSecurityPolicyViolation: { value: void 0, writable: true }, _cspEventHandlerPointer: { value: void 0, writable: true }, onSecurityPolicyViolation: { get: () => X2._onSecurityPolicyViolation, set(e3) {
        if (X2._onSecurityPolicyViolation = e3, !z2)
          return;
        const t3 = (e4) => {
          if (!(e4 && e4.blockedURI && X2.onSecurityPolicyViolation))
            return;
          const t4 = e4.blockedURI;
          LP("CSP_DETECTED_HOSTNAME_LIST").some((e5) => t4.includes(e5)) && X2.onSecurityPolicyViolation && "function" == typeof X2.onSecurityPolicyViolation && X2.onSecurityPolicyViolation(e4);
        }, i3 = X2._cspEventHandlerPointer;
        i3 && z2.removeEventListener("securitypolicyviolation", i3), e3 && "function" == typeof e3 && z2.addEventListener("securitypolicyviolation", t3), X2._cspEventHandlerPointer = t3;
      } } }), Yj.on(sk.CAMERA_DEVICE_CHANGED, (e3) => {
        JD.info("camera device changed", JSON.stringify(e3)), X2.onCameraChanged && X2.onCameraChanged(e3);
      }), Yj.on(sk.RECORDING_DEVICE_CHANGED, (e3) => {
        JD.info("microphone device changed", JSON.stringify(e3)), X2.onMicrophoneChanged && X2.onMicrophoneChanged(e3);
      }), Yj.on(sk.PLAYOUT_DEVICE_CHANGED, (e3) => {
        JD.debug("playout device changed", JSON.stringify(e3)), X2.onPlaybackDeviceChanged && X2.onPlaybackDeviceChanged(e3);
      }), zj.onAutoplayFailed = () => {
        JD.info("detect audio element autoplay failed"), nj.onAudioAutoplayFailed && nj.onAudioAutoplayFailed();
      }, Tj.on("autoplay-failed", () => {
        JD.info("detect webaudio autoplay failed"), nj.onAudioAutoplayFailed && nj.onAudioAutoplayFailed();
      }), window && (window.__ARTC__ = X2), X2;
    });
  }
});
export default require_AgoraRTC_N_production();
/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
/*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> */
//# sourceMappingURL=agora-rtc-sdk-ng.js.map
